head	5.67;
access;
symbols
	expect_5_45:5.67
	expect_6_branch:5.67.0.2
	expect_5_44_1_15:5.67
	activestate_win32_port_start:5.40
	telco-tec-win32-take2-branch:5.33.0.6
	telco-tec-win32-branch:5.33.0.4
	expect-sf418892-sf439042-branch:5.33.0.2
	tclpro-1-5-0:5.33
	tclpro-1-4-1:5.33
	tclpro-1-4-0:5.33
	expect-5-32-2:5.33
	expect-5-32-0:5.33
	ajuba-ajuba2-2-0:5.30.2.19
	scriptics-sc-2-0-b5:5.30.2.19
	scriptics-sc-2-0-fixed:5.30.2.19
	scriptics-sc-2-0-b2:5.30.2.19
	scriptics-sc-2-0-b1:5.30.2.19
	scriptics-sc-1-1:5.30.2.19
	scriptics-sc-1-1-b1:5.30.2.19
	scriptics-sc-1-1-branch:5.30.2.19.0.4
	scriptics-sc-1-1-base:5.30.2.19
	scriptics-sc-1-0:5.30.2.19
	scriptics-sc-1-0-branch:5.30.2.19.0.2
	scriptics-sc-1-0-base:5.30.2.19
	expect-5-31-3:5.30.2.19
	scriptics-bc-1-0-b1:5.30.2.18
	scriptics-tclpro-1-3-0:5.30.2.18
	scriptics-tclpro-1-3-b4:5.30.2.18
	scriptics-tclpro-1-3-b3:5.30.2.18
	expect-5-31:5.30.2.18
	expect-5-31-branch:5.30.0.2
	expect-5-31-base:5.30
	scriptics-tclpro-1-2:5.29
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.67
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.66;

5.66
date	2010.03.17.23.47.49;	author eee;	state Exp;
branches;
next	5.65;

5.65
date	2010.03.15.23.17.31;	author eee;	state Exp;
branches;
next	5.64;

5.64
date	2010.03.11.21.55.27;	author eee;	state Exp;
branches;
next	5.63;

5.63
date	2009.11.03.23.30.05;	author andreas_kupries;	state Exp;
branches;
next	5.62;

5.62
date	2009.11.03.19.27.58;	author andreas_kupries;	state Exp;
branches;
next	5.61;

5.61
date	2009.06.18.16.07.06;	author andreas_kupries;	state Exp;
branches;
next	5.60;

5.60
date	2008.10.03.17.52.35;	author andreas_kupries;	state Exp;
branches;
next	5.59;

5.59
date	2008.10.03.17.47.37;	author andreas_kupries;	state Exp;
branches;
next	5.58;

5.58
date	2008.10.03.17.05.14;	author andreas_kupries;	state Exp;
branches;
next	5.57;

5.57
date	2008.04.03.19.19.41;	author andreas_kupries;	state Exp;
branches;
next	5.56;

5.56
date	2008.04.03.19.07.14;	author andreas_kupries;	state Exp;
branches;
next	5.55;

5.55
date	2007.12.13.22.31.38;	author hobbs;	state Exp;
branches;
next	5.54;

5.54
date	2007.12.13.22.27.34;	author hobbs;	state Exp;
branches;
next	5.53;

5.53
date	2007.12.13.22.20.28;	author hobbs;	state Exp;
branches;
next	5.52;

5.52
date	2007.07.11.20.51.44;	author andreas_kupries;	state Exp;
branches;
next	5.51;

5.51
date	2007.07.11.20.22.10;	author andreas_kupries;	state Exp;
branches;
next	5.50;

5.50
date	2007.07.11.20.07.22;	author andreas_kupries;	state Exp;
branches;
next	5.49;

5.49
date	2007.07.11.20.00.35;	author andreas_kupries;	state Exp;
branches;
next	5.48;

5.48
date	2007.07.11.19.54.13;	author andreas_kupries;	state Exp;
branches;
next	5.47;

5.47
date	2006.03.01.17.21.45;	author andreas_kupries;	state Exp;
branches;
next	5.46;

5.46
date	2005.06.22.17.03.38;	author andreas_kupries;	state Exp;
branches;
next	5.45;

5.45
date	2005.02.15.18.11.03;	author andreas_kupries;	state Exp;
branches;
next	5.44;

5.44
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.43;

5.43
date	2004.05.19.17.33.36;	author andreas_kupries;	state Exp;
branches;
next	5.42;

5.42
date	2004.02.26.01.02.43;	author andreas_kupries;	state Exp;
branches;
next	5.41;

5.41
date	2003.09.05.19.01.56;	author andreas_kupries;	state Exp;
branches;
next	5.40;

5.40
date	2003.06.16.19.41.53;	author andreas_kupries;	state Exp;
branches;
next	5.39;

5.39
date	2003.02.15.00.02.38;	author andreas_kupries;	state Exp;
branches;
next	5.38;

5.38
date	2002.10.25.20.44.57;	author andreas_kupries;	state Exp;
branches;
next	5.37;

5.37
date	2002.05.14.01.10.11;	author libes;	state Exp;
branches;
next	5.36;

5.36
date	2002.04.16.21.00.28;	author libes;	state Exp;
branches;
next	5.35;

5.35
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.34;

5.34
date	2002.02.07.23.46.49;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2000.02.01.06.50.28;	author libes;	state Exp;
branches
	5.33.2.1
	5.33.4.1
	5.33.6.1;
next	5.32;

5.32
date	2000.01.10.18.30.17;	author libes;	state Exp;
branches;
next	5.31;

5.31
date	2000.01.06.23.22.03;	author wart;	state Exp;
branches;
next	5.30;

5.30
date	99.04.01.16.10.29;	author libes;	state Exp;
branches
	5.30.2.1;
next	5.29;

5.29
date	99.02.12.23.51.46;	author libes;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.21;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.21;	author cvsadmin;	state Exp;
branches;
next	;

5.30.2.1
date	99.06.07.17.49.38;	author libes;	state Exp;
branches;
next	5.30.2.2;

5.30.2.2
date	99.06.10.22.01.41;	author don;	state Exp;
branches;
next	5.30.2.3;

5.30.2.3
date	99.06.11.02.10.18;	author stanton;	state Exp;
branches;
next	5.30.2.4;

5.30.2.4
date	99.06.11.20.11.48;	author don;	state Exp;
branches;
next	5.30.2.5;

5.30.2.5
date	99.06.14.20.36.46;	author don;	state Exp;
branches;
next	5.30.2.6;

5.30.2.6
date	99.06.14.23.54.04;	author don;	state Exp;
branches;
next	5.30.2.7;

5.30.2.7
date	99.06.15.01.32.09;	author don;	state Exp;
branches;
next	5.30.2.8;

5.30.2.8
date	99.06.15.10.02.34;	author don;	state Exp;
branches;
next	5.30.2.9;

5.30.2.9
date	99.06.15.19.11.55;	author don;	state Exp;
branches;
next	5.30.2.10;

5.30.2.10
date	99.06.16.03.02.34;	author don;	state Exp;
branches;
next	5.30.2.11;

5.30.2.11
date	99.06.20.06.32.18;	author libes;	state Exp;
branches;
next	5.30.2.12;

5.30.2.12
date	99.06.22.05.03.29;	author libes;	state Exp;
branches;
next	5.30.2.13;

5.30.2.13
date	99.06.22.19.50.52;	author libes;	state Exp;
branches;
next	5.30.2.14;

5.30.2.14
date	99.06.23.17.25.17;	author libes;	state Exp;
branches;
next	5.30.2.15;

5.30.2.15
date	99.06.28.06.29.24;	author libes;	state Exp;
branches;
next	5.30.2.16;

5.30.2.16
date	99.06.29.02.27.46;	author libes;	state Exp;
branches;
next	5.30.2.17;

5.30.2.17
date	99.06.29.04.35.46;	author libes;	state Exp;
branches;
next	5.30.2.18;

5.30.2.18
date	99.07.03.03.44.14;	author libes;	state Exp;
branches;
next	5.30.2.19;

5.30.2.19
date	99.10.29.18.50.41;	author libes;	state Exp;
branches;
next	;

5.33.2.1
date	2002.02.07.23.46.00;	author andreas_kupries;	state Exp;
branches;
next	;

5.33.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.33.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.67
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@/* exp_command.c - the bulk of the Expect commands

Written by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include "expect_cf.h"

#include <stdio.h>
#include <sys/types.h>
/*#include <sys/time.h> seems to not be present on SVR3 systems */
/* and it's not used anyway as far as I can tell */

/* AIX insists that stropts.h be included before ioctl.h, because both */
/* define _IO but only ioctl.h checks first.  Oddly, they seem to be */
/* defined differently! */
#ifdef HAVE_STROPTS_H
#  include <sys/stropts.h>
#endif
#include <sys/ioctl.h>

#ifdef HAVE_SYS_FCNTL_H
#  include <sys/fcntl.h>
#else
#  include <fcntl.h>
#endif
#include <sys/file.h>

#include <errno.h>
#include <signal.h>

#if defined(SIGCLD) && !defined(SIGCHLD)
#define SIGCHLD SIGCLD
#endif

#ifdef HAVE_PTYTRAP
#include <sys/ptyio.h>
#endif

#ifdef CRAY
# ifndef TCSETCTTY
#  if defined(HAVE_TERMIOS)
#   include <termios.h>
#  else
#   include <termio.h>
#  endif
# endif
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#include <math.h>		/* for log/pow computation in send -h */
#include <ctype.h>		/* all this for ispunct! */

#include "tclInt.h"		/* need OpenFile */
/*#include <varargs.h>		tclInt.h drags in varargs.h.  Since Pyramid */
/*				objects to including varargs.h twice, just */
/*				omit this one. */

#include "tcl.h"
#include "string.h"
#include "expect.h"
#include "expect_tcl.h"
#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"
#include "exp_log.h"
#include "exp_event.h"
#include "exp_pty.h"
#include "exp_tty_in.h"
#ifdef TCL_DEBUGGER
#include "tcldbg.h"
#endif

/*
 * These constants refer to the UTF string that encodes a null character.
 */

#define NULL_STRING "\300\200" /* hex C080 */
#define NULL_LENGTH 2

#define SPAWN_ID_VARNAME "spawn_id"

void exp_ecmd_remove_state_direct_and_indirect(Tcl_Interp *interp, ExpState *esPtr);


int exp_forked = FALSE;		/* whether we are child process */

/* the following are use to create reserved addresses, to be used as ClientData */
/* args to be used to tell commands how they were called. */
/* The actual values won't be used, only the addresses, but I give them */
/* values out of my irrational fear the compiler might collapse them all. */
static int sendCD_error = 2;	/* called as send_error */
static int sendCD_user = 3;	/* called as send_user */
static int sendCD_proc = 4;	/* called as send or send_spawn */
static int sendCD_tty = 6;	/* called as send_tty */

/*
 * expect_key is just a source for generating a unique stamp.  As each
 * expect/interact command begins, it generates a new key and marks all
 * the spawn ids of interest with it.  Then, if someone comes along and
 * marks them with yet a newer key, the old command will recognize this
 * reexamine the state of the spawned process.
 */
int expect_key = 0;

/*
 * exp_configure_count is incremented whenever a spawned process is closed
 * or an indirect list is modified.  This forces any (stack of) expect or
 * interact commands to reexamine the state of the world and adjust
 * accordingly.
 */
int exp_configure_count = 0;

#ifdef HAVE_PTYTRAP
/* slaveNames provides a mapping from the pty slave names to our */
/* spawn id entry.  This is needed only on HPs for stty, sigh. */
static Tcl_HashTable slaveNames;
#endif /* HAVE_PTYTRAP */

typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    ExpState *stdinout;
    ExpState *stderrX;   /* grr....stderr is a macro */
    ExpState *devtty;
    ExpState *any; /* for any_spawn_id */

    Tcl_Channel *diagChannel; /* Unused - exp_log.c has its own. */
    Tcl_DString diagDString;  /* Unused */
    int diagEnabled;          /* Unused */

    /* Table of structures for all Tcl channels used as -open argument
     * in a exp_spawn call. For refCounting of Tcl channels used by
     * more than one Expect channel.
     */

    Tcl_HashTable origins;

} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

#ifdef FULLTRAPS
static void
init_traps(RETSIGTYPE (*traps[])())
{
    int i;

    for (i=1;i<NSIG;i++) {
	traps[i] = SIG_ERR;
    }
}
#endif

/* Do not terminate format strings with \n!!! */
/*VARARGS*/
void
exp_error TCL_VARARGS_DEF(Tcl_Interp *,arg1)
/*exp_error(va_alist)*/
/*va_dcl*/
{
    Tcl_Interp *interp;
    char *fmt;
    va_list args;
    char buffer[2000];

    interp = TCL_VARARGS_START(Tcl_Interp *,arg1,args);
    fmt = va_arg(args,char *);
    vsprintf(buffer,fmt,args);
    Tcl_SetResult(interp,buffer,TCL_VOLATILE);
    va_end(args);
}

/* returns current ExpState or 0.  If 0, may be immediately followed by return TCL_ERROR. */
struct ExpState *
expStateCurrent(
    Tcl_Interp *interp,
    int opened,
    int adjust,
    int any)
{
    static char *user_spawn_id = "exp0";

    char *name = exp_get_var(interp,SPAWN_ID_VARNAME);
    if (!name) name = user_spawn_id;

    return expStateFromChannelName(interp,name,opened,adjust,any,SPAWN_ID_VARNAME);
}

ExpState *
expStateCheck(
    Tcl_Interp *interp,
    ExpState *esPtr,
    int open,
    int adjust,
    char *msg)
{
    if (open && !esPtr->open) {
	exp_error(interp,"%s: spawn id %s not open",msg,esPtr->name);
	return(0);
    }
    if (adjust) expAdjust(esPtr);
    return esPtr;
}

ExpState *
expStateFromChannelName(
    Tcl_Interp *interp,
    char *name,
    int open,
    int adjust,
    int any,
    char *msg)
{
    ExpState *esPtr;
    Tcl_Channel channel;
    CONST char *chanName;

    if (any) {
	if (0 == strcmp(name,EXP_SPAWN_ID_ANY_LIT)) {
	    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
	    return tsdPtr->any;
	}
    }

    channel = Tcl_GetChannel(interp,name,(int *)0);
    if (!channel) return(0);

    chanName = Tcl_GetChannelName(channel);
    if (!isExpChannelName(chanName)) {
	exp_error(interp,"%s: %s is not an expect channel - use spawn -open to convert",msg,chanName);
	return(0);
    }

    esPtr = (ExpState *)Tcl_GetChannelInstanceData(channel);

    return expStateCheck(interp,esPtr,open,adjust,msg);
}

/* zero out the wait status field */
static void
exp_wait_zero(WAIT_STATUS_TYPE *status)
{
    int i;

    for (i=0;i<sizeof(WAIT_STATUS_TYPE);i++) {
	((char *)status)[i] = 0;
    }
}

/* called just before an ExpState entry is about to be invalidated */
void
exp_state_prep_for_invalidation(
    Tcl_Interp *interp,
    ExpState *esPtr)
{
    exp_ecmd_remove_state_direct_and_indirect(interp,esPtr);

    exp_configure_count++;

    if (esPtr->fg_armed) {
	exp_event_disarm_fg(esPtr);
    }
}

/*ARGSUSED*/
void
exp_trap_on(int master)
{
#ifdef HAVE_PTYTRAP
    if (master == -1) return;
    exp_slave_control(master,1);
#endif /* HAVE_PTYTRAP */
}

int
exp_trap_off(char *name)
{
#ifdef HAVE_PTYTRAP
    ExpState *esPtr;
    int enable = 0;

    Tcl_HashEntry *entry = Tcl_FindHashEntry(&slaveNames,name);
    if (!entry) {
	expDiagLog("exp_trap_off: no entry found for %s\n",name);
	return -1;
    }

    esPtr = (ExpState *)Tcl_GetHashValue(entry);

    exp_slave_control(esPtr->fdin,0);

    return esPtr->fdin;
#else
    return name[0];	/* pacify lint, use arg and return something */
#endif
}

static
void
expBusy(ExpState *esPtr)
{
    int x = open("/dev/null",0);
    if (x != esPtr->fdin) {
	fcntl(x,F_DUPFD,esPtr->fdin);
	close(x);
    }
    expCloseOnExec(esPtr->fdin);
    esPtr->fdBusy = TRUE;
}

int
exp_close(
    Tcl_Interp *interp,
    ExpState *esPtr)
{
    if (0 == expStateCheck(interp,esPtr,1,0,"close")) return TCL_ERROR;
    esPtr->open = FALSE;

    /* restore blocking for some shells that would otherwise be */
    /* surprised finding stdio or /dev/tty nonblocking */
    (void) Tcl_SetChannelOption(interp,esPtr->channel,"-blocking","on");

    /* Since we're closing the channel, not Tcl, we need to get Tcl's
       buffers flushed.  Because the channel was nonblocking, EAGAINs
       could leave things buffered.  They need to be synchronously
       written now! */
    Tcl_Flush(esPtr->channel);

    /*
     * Ignore close errors from ptys.  Ptys on some systems return errors for
     * no evident reason.  Anyway, receiving an error upon pty-close doesn't
     * mean anything anyway as far as I know.  
     */

    close(esPtr->fdin);
    if (esPtr->fd_slave != EXP_NOFD) close(esPtr->fd_slave);
    if (esPtr->fdin != esPtr->fdout) close(esPtr->fdout);

    if (esPtr->chan_orig) {
        esPtr->chan_orig->refCount --;
	if (esPtr->chan_orig->refCount <= 0) {
	    /*
	     * Ignore close errors from Tcl channels.  They indicate things
	     * like broken pipelines, etc, which don't affect our
	     * subsequent handling.
	     */

	    ThreadSpecificData* tsdPtr = TCL_TSD_INIT(&dataKey);
	    char*               cName  = Tcl_GetChannelName(esPtr->chan_orig->channel_orig);
	    Tcl_HashEntry*      entry  = Tcl_FindHashEntry(&tsdPtr->origins,cName);
	    ExpOrigin*          orig   = (ExpOrigin*) Tcl_GetHashValue(entry);

	    Tcl_DeleteHashEntry(entry);
	    ckfree ((char*)orig);

	    if (!esPtr->leaveopen) {
		Tcl_VarEval(interp,"close ", cName, (char *)0);
	    }
	}
    }

#ifdef HAVE_PTYTRAP
    if (esPtr->slave_name) {
	Tcl_HashEntry *entry;

	entry = Tcl_FindHashEntry(&slaveNames,esPtr->slave_name);
	Tcl_DeleteHashEntry(entry);

	ckfree(esPtr->slave_name);
	esPtr->slave_name = 0;
    }
#endif

    exp_state_prep_for_invalidation(interp,esPtr);

    if (esPtr->user_waited) {
	if (esPtr->registered) {
	    Tcl_UnregisterChannel(interp,esPtr->channel);
	    /* at this point esPtr may have been freed so don't touch it
               any longer */
	}
    } else {
	expBusy(esPtr);
    }

    return(TCL_OK);
}

/* report whether this ExpState represents special spawn_id_any */
/* we need a separate function because spawn_id_any is thread-specific */
/* and can't be seen outside this file */
int
expStateAnyIs(ExpState *esPtr)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (esPtr == tsdPtr->any);
}

int
expDevttyIs(ExpState *esPtr)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (esPtr == tsdPtr->devtty);
}

int
expStdinoutIs(ExpState *esPtr)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (tsdPtr->stdinout == esPtr);
}

ExpState *
expStdinoutGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return tsdPtr->stdinout;
}

ExpState *
expDevttyGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return tsdPtr->devtty;
}

void
exp_init_spawn_id_vars(Tcl_Interp *interp)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    Tcl_SetVar(interp, "user_spawn_id", tsdPtr->stdinout->name,0);
    Tcl_SetVar(interp,"error_spawn_id",  tsdPtr->stderrX->name,0);
    Tcl_SetVar(interp,  "any_spawn_id",   EXP_SPAWN_ID_ANY_LIT,0);

    /* user_spawn_id is NOT /dev/tty which could (at least in theory
     * anyway) be later re-opened on a different fd, while stdin might
     * have been redirected away from /dev/tty
     */

    if (exp_dev_tty != -1) {
	Tcl_SetVar(interp,"tty_spawn_id",tsdPtr->devtty->name,0);
    }
}

void
exp_init_spawn_ids(Tcl_Interp *interp)
{
    static ExpState any_placeholder;  /* can be shared process-wide */
    
    /* note whether 0,1,2 are connected to a terminal so that if we */
    /* disconnect, we can shut these down.  We would really like to */
    /* test if 0,1,2 are our controlling tty, but I don't know any */
    /* way to do that portably.  Anyway, the likelihood of anyone */
    /* disconnecting after redirecting to a non-controlling tty is */
    /* virtually zero. */

    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->stdinout = expCreateChannel(interp,0,1,isatty(0)?exp_getpid:EXP_NOPID);
    tsdPtr->stdinout->keepForever = 1;
    /* hmm, now here's an example of a output-only descriptor!! */
    tsdPtr->stderrX = expCreateChannel(interp,2,2,isatty(2)?exp_getpid:EXP_NOPID);
    tsdPtr->stderrX->keepForever = 1;

    if (exp_dev_tty != -1) {
	tsdPtr->devtty = expCreateChannel(interp,exp_dev_tty,exp_dev_tty,exp_getpid);
	tsdPtr->devtty->keepForever = 1;
    }

    /* set up a dummy channel to give us something when we need to find out if
       people have passed us "any_spawn_id" */
    tsdPtr->any = &any_placeholder;

    /* Set up the hash table for managing the channels used via
     * -open.
     */

    Tcl_InitHashTable (&tsdPtr->origins, TCL_STRING_KEYS);
}

void
expCloseOnExec(int fd)
{
    (void) fcntl(fd,F_SETFD,1);
}

#define STTY_INIT	"stty_init"

#if 0
/*
 * DEBUGGING UTILITIES - DON'T DELETE */
static void
show_pgrp(
    int fd,
    char *string)
{
    int pgrp;

    fprintf(stderr,"getting pgrp for %s\n",string);
    if (-1 == ioctl(fd,TIOCGETPGRP,&pgrp)) perror("TIOCGETPGRP");
    else fprintf(stderr,"%s pgrp = %d\n",string,pgrp);
    if (-1 == ioctl(fd,TIOCGPGRP,&pgrp)) perror("TIOCGPGRP");
    else fprintf(stderr,"%s pgrp = %d\n",string,pgrp);
    if (-1 == tcgetpgrp(fd,pgrp)) perror("tcgetpgrp");
    else fprintf(stderr,"%s pgrp = %d\n",string,pgrp);
}

static void
set_pgrp(int fd)
{
    int pgrp = getpgrp(0);
    if (-1 == ioctl(fd,TIOCSETPGRP,&pgrp)) perror("TIOCSETPGRP");
    if (-1 == ioctl(fd,TIOCSPGRP,&pgrp)) perror("TIOCSPGRP");
    if (-1 == tcsetpgrp(fd,pgrp)) perror("tcsetpgrp");
}
#endif

static
void
expSetpgrp()
{
#ifdef MIPS_BSD
    /* required on BSD side of MIPS OS <jmsellen@@watdragon.waterloo.edu> */
#   include <sysv/sys.s>
    syscall(SYS_setpgrp);
#endif

#ifdef SETPGRP_VOID
    (void) setpgrp();
#else
    (void) setpgrp(0,0);
#endif
}


/*ARGSUSED*/
static void
set_slave_name(
    ExpState *esPtr,
    char *name)
{
#ifdef HAVE_PTYTRAP
    int newptr;
    Tcl_HashEntry *entry;

    /* save slave name */
    esPtr->slave_name = ckalloc(strlen(exp_pty_slave_name)+1);
    strcpy(esPtr->slave_name,exp_pty_slave_name);

    entry = Tcl_CreateHashEntry(&slaveNames,exp_pty_slave_name,&newptr);
    Tcl_SetHashValue(entry,(ClientData)esPtr);
#endif /* HAVE_PTYTRAP */
}

/* arguments are passed verbatim to execvp() */
/*ARGSUSED*/
static int
Exp_SpawnObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    ExpState *esPtr = 0;
    int slave;
    int pid;
#ifdef TIOCNOTTY
    /* tell Saber to ignore non-use of ttyfd */
    /*SUPPRESS 591*/
    int ttyfd;
#endif /* TIOCNOTTY */
    int errorfd;	/* place to stash fileno(stderr) in child */
			/* while we're setting up new stderr */
    int master, k;
    int write_master;	/* write fd of Tcl-opened files */
    int ttyinit = TRUE;
    int ttycopy = TRUE;
    int echo = TRUE;
    int console = FALSE;
    int pty_only = FALSE;
    char** argv;

#ifdef FULLTRAPS
    /* Allow user to reset signals in child */
    /* The following array contains indicates */
    /* whether sig should be DFL or IGN */
    /* ERR is used to indicate no initialization */
    RETSIGTYPE (*traps[NSIG])();
#endif
    int ignore[NSIG];		/* if true, signal in child is ignored */
				/* if false, signal gets default behavior */
    int i;			/* trusty overused temporary */

    char *argv0 = Tcl_GetString (objv[0]);
    char *chanName = 0;
    int leaveopen = FALSE;
    int rc, wc;
    CONST char *stty_init;
    int slave_write_ioctls = 1;
    /* by default, slave will be write-ioctled this many times */
    int slave_opens = 3;
    /* by default, slave will be opened this many times */
    /* first comes from initial allocation */
    /* second comes from stty */
    /* third is our own signal that stty is done */

    int sync_fds[2];
    int sync2_fds[2];
    int status_pipe[2];
    int child_errno;
    char sync_byte;
    int cmdIndex;
    Tcl_Obj* cmdObj;
    char* command;

    static char* options[] = {
	"-console",
	"-ignore",
	"-leaveopen",
	"-noecho",
	"-nottycopy",
	"-nottyinit",
	"-open",
	"-pty",
#ifdef FULLTRAPS
	"-trap",
#endif
	NULL
    };
    enum options {
	SPAWN_CONSOLE
	,SPAWN_IGNORE
	,SPAWN_LEAVEOPEN
	,SPAWN_NOECHO
	,SPAWN_NOTTYCOPY
	,SPAWN_NOTTYINIT
	,SPAWN_OPEN
	,SPAWN_PTY
#ifdef FULLTRAPS
	,SPAWN_TRAP
#endif
    };

    Tcl_Channel channel;
    Tcl_DString dstring;
    Tcl_DStringInit(&dstring);

#ifdef FULLTRAPS
    init_traps(&traps);
#endif
    /* don't ignore any signals in child by default */
    for (i=1;i<NSIG;i++) {
	ignore[i] = FALSE;
    }

    /* Check and process switches */

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case SPAWN_NOTTYINIT:
		ttyinit = FALSE;
		slave_write_ioctls--;
		slave_opens--;
		break;
	    case SPAWN_NOTTYCOPY:
		ttycopy = FALSE;
		break;
	    case SPAWN_NOECHO:
		echo = FALSE;
		break;
	    case SPAWN_CONSOLE:
		console = TRUE;
		break;
	    case SPAWN_PTY:
		pty_only = TRUE;
		break;
	    case SPAWN_OPEN:
		i ++;
		if (i >= objc) {
		    exp_error(interp,"usage: -open file-identifier");
		    return TCL_ERROR;
		}
		chanName = Tcl_GetString (objv[i]);
		break;
	    case SPAWN_LEAVEOPEN:
		i ++;
		if (i >= objc) {
		    exp_error(interp,"usage: -open file-identifier");
		    return TCL_ERROR;
		}
		chanName = Tcl_GetString (objv[i]);
		leaveopen = TRUE;
		break;
	    case SPAWN_IGNORE: {
		int sig;
		i ++;
		if (i >= objc) {
		    exp_error(interp,"usage: -ignore signal");
		    return TCL_ERROR;
		}
		sig = exp_string_to_signal(interp,Tcl_GetString (objv[i]));
		if (sig == -1) {
		    exp_error(interp,"usage: -ignore %s: unknown signal name",Tcl_GetString (objv[i]));
		    return TCL_ERROR;
		}
		ignore[sig] = TRUE;
	    }
		break;
#ifdef FULLTRAPS
	    case SPAWN_TRAP: {
		/* objv[i+1] is list of signals */
		/* objv[i+2] is action */

		static char* actions [] = {
		    "SIG_DFL", "SIG_IGN", NULL
		};
		enum actions {
		    ACTION_SIGDFL, ACTION_SIGIGN;
		}
		int theaction;

		int j;
		RETSIGTYPE (*sig_handler)();
		int       lc;	/* number of signals in list */
		Tcl_Obj** lv;	/* list of signals */

		if ((objc - i) < 3) {
		    exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		    return TCL_ERROR;
		}

		/* Check and process action */

		if (Tcl_GetIndexFromObj(interp, objv[i+2], actions, "action", 0,
				&theaction) != TCL_OK) {
		    exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		    return TCL_ERROR;
		}
		switch ((enum actions) theaction) {
		    case ACTION_SIGDFL:
			sig_handler = SIG_DFL;
			break;
		    case ACTION_SIGIGN:
			sig_handler = SIG_IGN;
			break;
		}

		/* Check and process list of signals */

		if (TCL_OK != Tcl_ListObjGetElements (inter, objv[i+1], &lc, &lv)) {
		    expErrorLogU(Tcl_GetStringResult(interp));
		    expErrorLogU("\r\n");
		    exp_error(interp,"usage: -trap {siglist} ...");
		    return TCL_ERROR;
		}

		for (j=0;j<lc;j++) {
		    int sig = exp_string_to_signal(interp,Tcl_GetString (lv[j]));
		    if (sig == -1) {
			return TCL_ERROR;
		    }
		    traps[sig] = sig_handler;
		}

		i += 2;
	    }
		break;
#endif
	}
    }

    /* Additional checking of arguments */

    if (chanName && (i < objc)) {
	exp_error(interp,"usage: -[leave]open [fileXX]");
	return TCL_ERROR;
    }

    if (!pty_only && !chanName && (i == objc)) {
	exp_error(interp,"usage: spawn [spawn-args] program [program-args]");
	return(TCL_ERROR);
    }

    cmdIndex = i;
    cmdObj = objv[i];

    stty_init = exp_get_var(interp,STTY_INIT);
    if (stty_init) {
	slave_write_ioctls++;
	slave_opens++;
    }

/* any extraneous ioctl's that occur in slave must be accounted for
   when trapping, see below in child half of fork */
#if defined(TIOCSCTTY) && !defined(CIBAUD) && !defined(sun) && !defined(hp9000s300)
    slave_write_ioctls++;
    slave_opens++;
#endif

    exp_pty_slave_name = 0;

    Tcl_ReapDetachedProcs();

    if (!chanName) {
	if (echo) {
	    int c = 0;
	    expStdoutLogU(argv0,0);
	    for (c = 1; c < objc; c++) {
		expStdoutLogU(" ",0);
		expStdoutLogU(Tcl_GetString (objv[c]),0);
	    }
	    expStdoutLogU("\r\n",0);
	}

	if (0 > (master = exp_getptymaster())) {
	    /*
	     * failed to allocate pty, try and figure out why
	     * so we can suggest to user what to do about it.
	     */

	    int testfd;

	    if (exp_pty_error) {
		exp_error(interp,"%s",exp_pty_error);
		return TCL_ERROR;
	    }

	    if (expChannelCountGet() > 10) {
		exp_error(interp,"The system only has a finite number of ptys and you have many of them in use.  The usual reason for this is that you forgot (or didn't know) to call \"wait\" after closing each of them.");
		return TCL_ERROR;
	    }

	    testfd = open("/",0);
	    close(testfd);

	    if (testfd != -1) {
		exp_error(interp,"The system has no more ptys.  Ask your system administrator to create more.");
	    } else {
		exp_error(interp,"- You have too many files are open.  Close some files or increase your per-process descriptor limit.");
	    }
	    return(TCL_ERROR);
	}

	/* ordinarily channel creation takes care of close-on-exec
	 * but because that will occur *after* fork, force close-on-exec
	 * now in this case.
	 */
	expCloseOnExec(master);

#define SPAWN_OUT "spawn_out"
	Tcl_SetVar2(interp,SPAWN_OUT,"slave,name",exp_pty_slave_name,0);

	if (pty_only) {
	    write_master = master;
	}
    } else {
	/*
	 * process "-open $channel"
	 */
	int mode, rfd, wfd;
	ClientData rfdc, wfdc;

	if (echo) {
	    expStdoutLogU(argv0,0);
	    expStdoutLogU(" [open ...]\r\n",0);
	}
	if (!(channel = Tcl_GetChannel(interp,chanName,&mode))) {
	    return TCL_ERROR;
	}
	if (!mode) {
	    exp_error(interp,"channel is neither readable nor writable");
	    return TCL_ERROR;
	}
	if (mode & TCL_READABLE) {
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_READABLE, &rfdc)) {
		return TCL_ERROR;
	    }
	    rfd = (int)(long) rfdc;
	}
	if (mode & TCL_WRITABLE) {
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_WRITABLE, &wfdc)) {
		return TCL_ERROR;
	    }
	    wfd = (int)(long) wfdc;
	}
	master = ((mode & TCL_READABLE)?rfd:wfd);

	/* make a new copy of file descriptor */
	if (-1 == (write_master = master = dup(master))) {
	    exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
	    return TCL_ERROR;
	}

	/* if writefilePtr is different, dup that too */
	if ((mode & TCL_READABLE) && (mode & TCL_WRITABLE) && (wfd != rfd)) {
	    if (-1 == (write_master = dup(wfd))) {
		exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
		return TCL_ERROR;
	    }
	}

	/*
	 * It would be convenient now to tell Tcl to close its
	 * file descriptor.  Alas, if involved in a pipeline, Tcl
	 * will be unable to complete a wait on the process.
	 * So simply remember that we meant to close it.  We will
	 * do so later in our own close routine.
	 */
    }

    if (chanName || pty_only) {
	esPtr = expCreateChannel(interp,master,write_master,EXP_NOPID);

	if (chanName) {
	    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
	    Tcl_HashEntry *entry = Tcl_FindHashEntry(&tsdPtr->origins,chanName);

	    if (entry) {
	        esPtr->chan_orig = (ExpOrigin*) Tcl_GetHashValue(entry);
		esPtr->chan_orig->refCount ++;

	    } else {
	        int newptr;
		ExpOrigin* orig = (ExpOrigin*) ckalloc (sizeof (ExpOrigin));

		esPtr->chan_orig   = orig;
		orig->channel_orig = channel;
		orig->refCount     = 1;

		entry = Tcl_CreateHashEntry(&tsdPtr->origins,chanName,&newptr);
		Tcl_SetHashValue(entry, (ClientData) orig);
	    }

	    esPtr->leaveopen = leaveopen;
	}

	if (exp_pty_slave_name) set_slave_name(esPtr,exp_pty_slave_name);

	/* make it appear as if process has been waited for */
	esPtr->sys_waited = TRUE;
	exp_wait_zero(&esPtr->wait);

	/* tell user of new spawn id */
	Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);

	if (!chanName) {
	    char value[20];

	    /*
	     * open the slave side in the same process to support
	     * the -pty flag.
	     */

	    if (0 > (esPtr->fd_slave = exp_getptyslave(ttycopy,ttyinit,
				    stty_init))) {
		exp_error(interp,"open(slave pty): %s\r\n",Tcl_PosixError(interp));
		return TCL_ERROR;
	    }

	    exp_slave_control(master,1);

	    sprintf(value,"%d",esPtr->fd_slave);
	    Tcl_SetVar2(interp,SPAWN_OUT,"slave,fd",value,0);
	}
	Tcl_SetObjResult (interp, Tcl_NewIntObj (EXP_NOPID));
	expDiagLog("spawn: returns {%s}\r\n",Tcl_GetStringResult(interp));

	return TCL_OK;
    }

    command = Tcl_TranslateFileName(interp,Tcl_GetString (cmdObj),&dstring);
    if (NULL == command) {
	goto parent_error;
    }

    if (-1 == pipe(sync_fds)) {
	exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
	goto parent_error;
    }

    if (-1 == pipe(sync2_fds)) {
	close(sync_fds[0]);
	close(sync_fds[1]);
	exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
	goto parent_error;
    }

    if (-1 == pipe(status_pipe)) {
	close(sync_fds[0]);
	close(sync_fds[1]);
	close(sync2_fds[0]);
	close(sync2_fds[1]);
	exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
	goto parent_error;
    }

    if ((pid = fork()) == -1) {
	exp_error(interp,"fork: %s",Tcl_PosixError(interp));
	goto parent_error;
    }

    if (pid) { /* parent */
	close(sync_fds[1]);
	close(sync2_fds[0]);
	close(status_pipe[1]);

	esPtr = expCreateChannel(interp,master,master,pid);

	if (exp_pty_slave_name) set_slave_name(esPtr,exp_pty_slave_name);

#ifdef CRAY
	setptypid(pid);
#endif

	/*
	 * wait for slave to initialize pty before allowing
	 * user to send to it
	 */ 

	expDiagLog("parent: waiting for sync byte\r\n");
	while (((rc = read(sync_fds[0],&sync_byte,1)) < 0) && (errno == EINTR)) {
	    /* empty */;
	}
	if (rc == -1) {
	    expErrorLogU("parent: sync byte read: ");
	    expErrorLogU(Tcl_ErrnoMsg(errno));
	    expErrorLogU("\r\n");
	    exit(-1);
	}

	/* turn on detection of eof */
	exp_slave_control(master,1);

	/*
	 * tell slave to go on now, now that we have initialized pty
	 */

	expDiagLog("parent: telling child to go ahead\r\n");
	wc = write(sync2_fds[1]," ",1);
	if (wc == -1) {
	    expErrorLog("parent: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
	    exit(-1);
	}

	expDiagLog("parent: now unsynchronized from child\r\n");
	close(sync_fds[0]);
	close(sync2_fds[1]);

	/* see if child's exec worked */
	retry:
	switch (read(status_pipe[0],&child_errno,sizeof child_errno)) {
	    case -1:
		if (errno == EINTR) goto retry;
		/* well it's not really the child's errno */
		/* but it can be treated that way */
		child_errno = errno;
		break;
	    case 0:
		/* child's exec succeeded */
		child_errno = 0;
		break;
	    default:
		/* child's exec failed; child_errno contains exec's errno */
		close(status_pipe[0]);
		waitpid(pid, NULL, 0);
		/* in order to get Tcl to set errorcode, we must */
		/* hand set errno */
		errno = child_errno;
		exp_error(interp, "couldn't execute \"%s\": %s",
			command,Tcl_PosixError(interp));
		goto parent_error;
	}
	close(status_pipe[0]);

	/* tell user of new spawn id */
	Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);

	Tcl_SetObjResult (interp, Tcl_NewIntObj (pid));
	expDiagLog("spawn: returns {%s}\r\n",Tcl_GetStringResult(interp));

	Tcl_DStringFree(&dstring);
	return(TCL_OK);
    }

    /* child process - do not return from here!  all errors must exit() */

    close(sync_fds[0]);
    close(sync2_fds[1]);
    close(status_pipe[0]);
    expCloseOnExec(status_pipe[1]);

    if (exp_dev_tty != -1) {
	close(exp_dev_tty);
	exp_dev_tty = -1;
    }

#ifdef CRAY
    (void) close(master);
#endif

/* ultrix (at least 4.1-2) fails to obtain controlling tty if setsid */
/* is called.  setpgrp works though.  */
#if defined(POSIX) && !defined(ultrix)
#define DO_SETSID
#endif
#ifdef __convex__
#define DO_SETSID
#endif

#ifdef DO_SETSID
    setsid();
#else
#ifdef SYSV3
#ifndef CRAY
    expSetpgrp();
#endif /* CRAY */
#else /* !SYSV3 */
    expSetpgrp();

/* Pyramid lacks this defn */
#ifdef TIOCNOTTY
    ttyfd = open("/dev/tty", O_RDWR);
    if (ttyfd >= 0) {
	(void) ioctl(ttyfd, TIOCNOTTY, (char *)0);
	(void) close(ttyfd);
    }
#endif /* TIOCNOTTY */

#endif /* SYSV3 */
#endif /* DO_SETSID */

    /* save stderr elsewhere to avoid BSD4.4 bogosity that warns */
    /* if stty finds dev(stderr) != dev(stdout) */

    /* save error fd while we're setting up new one */
    errorfd = fcntl(2,F_DUPFD,3);
    /* and here is the macro to restore it */
#define restore_error_fd {close(2);fcntl(errorfd,F_DUPFD,2);}

    close(0);
    close(1);
    close(2);

    /* since we closed fd 0, open of pty slave must return fd 0 */

    /* since exp_getptyslave may have to run stty, (some of which work on fd */
    /* 0 and some of which work on 1) do the dup's inside exp_getptyslave. */

    if (0 > (slave = exp_getptyslave(ttycopy,ttyinit,stty_init))) {
	restore_error_fd

	    if (exp_pty_error) {
		expErrorLog("open(slave pty): %s\r\n",exp_pty_error);
	    } else {
		expErrorLog("open(slave pty): %s\r\n",Tcl_ErrnoMsg(errno));
	    }
	exit(-1);
    }
    /* sanity check */
    if (slave != 0) {
	restore_error_fd
	    expErrorLog("exp_getptyslave: slave = %d but expected 0\n",slave);
	exit(-1);
    }

/* The test for hpux may have to be more specific.  In particular, the */
/* code should be skipped on the hp9000s300 and hp9000s720 (but there */
/* is no documented define for the 720!) */

/*#if defined(TIOCSCTTY) && !defined(CIBAUD) && !defined(sun) && !defined(hpux)*/
#if defined(TIOCSCTTY) && !defined(sun) && !defined(hpux)
    /* 4.3+BSD way to acquire controlling terminal */
    /* according to Stevens - Adv. Prog..., p 642 */
    /* Oops, it appears that the CIBAUD is on Linux also */
    /* so let's try without... */
#ifdef __QNX__
    if (tcsetct(0, getpid()) == -1) {
	restore_error_fd
	    expErrorLog("failed to get controlling terminal using TIOCSCTTY");
	exit(-1);
    }
#else
    (void) ioctl(0,TIOCSCTTY,(char *)0);
    /* ignore return value - on some systems, it is defined but it
     * fails and it doesn't seem to cause any problems.  Or maybe
     * it works but returns a bogus code.  Noone seems to be able
     * to explain this to me.  The systems are an assortment of
     * different linux systems (and FreeBSD 2.5), RedHat 5.2 and
     * Debian 2.0
     */
#endif
#endif

#ifdef CRAY
    (void) setsid();
    (void) ioctl(0,TCSETCTTY,0);
    (void) close(0);
    if (open("/dev/tty", O_RDWR) < 0) {
	restore_error_fd
	    expErrorLog("open(/dev/tty): %s\r\n",Tcl_ErrnoMsg(errno));
	exit(-1);
    }
    (void) close(1);
    (void) close(2);
    (void) dup(0);
    (void) dup(0);
    setptyutmp();	/* create a utmp entry */

    /* _CRAY2 code from Hal Peterson <hrp@@cray.com>, Cray Research, Inc. */
#ifdef _CRAY2
    /*
     * Interpose a process between expect and the spawned child to
     * keep the slave side of the pty open to allow time for expect
     * to read the last output.  This is a workaround for an apparent
     * bug in the Unicos pty driver on Cray-2's under Unicos 6.0 (at
     * least).
     */
    if ((pid = fork()) == -1) {
	restore_error_fd
	    expErrorLog("second fork: %s\r\n",Tcl_ErrnoMsg(errno));
	exit(-1);
    }

    if (pid) {
	/* Intermediate process. */
	int status;
	int timeout;
	char *t;

	/* How long should we wait? */
	if (t = exp_get_var(interp,"pty_timeout"))
	    timeout = atoi(t);
	else if (t = exp_get_var(interp,"timeout"))
	    timeout = atoi(t)/2;
	else
	    timeout = 5;

	/* Let the spawned process run to completion. */
	while (wait(&status) < 0 && errno == EINTR)
	    /* empty body */;

	/* Wait for the pty to clear. */
	sleep(timeout);

	/* Duplicate the spawned process's status. */
	if (WIFSIGNALED(status))
	    kill(getpid(), WTERMSIG(status));

	/* The kill may not have worked, but this will. */
	exit(WEXITSTATUS(status));
    }
#endif /* _CRAY2 */
#endif /* CRAY */

    if (console) exp_console_set();

#ifdef FULLTRAPS
    for (i=1;i<NSIG;i++) {
	if (traps[i] != SIG_ERR) {
	    signal(i,traps[i]);
	}
    }
#endif /* FULLTRAPS */

    for (i=1;i<NSIG;i++) {
	signal(i,ignore[i]?SIG_IGN:SIG_DFL);
    }

    /*
     * avoid fflush of cmdfile, logfile, & diagfile since this screws up
     * the parents seek ptr.  There is no portable way to fclose a shared
     * read-stream!!!!
     */

    /* (possibly multiple) masters are closed automatically due to */
    /* earlier fcntl(,,CLOSE_ON_EXEC); */

    /* tell parent that we are done setting up pty */
    /* The actual char sent back is irrelevant. */

    /* expDiagLog("child: telling parent that pty is initialized\r\n");*/
    wc = write(sync_fds[1]," ",1);
    if (wc == -1) {
	restore_error_fd
	    expErrorLog("child: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
	exit(-1);
    }
    close(sync_fds[1]);

    /* wait for master to let us go on */
    while (((rc = read(sync2_fds[0],&sync_byte,1)) < 0) && (errno == EINTR)) {
	/* empty */;
    }

    if (rc == -1) {
	restore_error_fd
	    expErrorLog("child: sync byte read: %s\r\n",Tcl_ErrnoMsg(errno));
	exit(-1);
    }
    close(sync2_fds[0]);

    /* expDiagLog("child: now unsynchronized from parent\r\n"); */

    argv = (char**) ckalloc ((objc+1)*sizeof(char*));
    for (k=0, i=cmdIndex;i<objc;k++,i++) {
	argv[k] = ckalloc (1+strlen(Tcl_GetString (objv[i])));
	strcpy (argv[k],Tcl_GetString (objv[i]));
    }
    argv[k] = NULL;

    execvp(command,argv);

    for (k=0,i=cmdIndex;i<objc;k++,i++) {
	ckfree (argv[k]);
    }
    ckfree((char*)argv);

    /* Alas, by now we've closed fd's to stderr, logfile and diagfile.
     * The only reasonable thing to do is to send back the error as part of
     * the program output.  This will be picked up in an expect or interact
     * command.
     */

    /* if exec failed, communicate the reason back to the parent */
    write(status_pipe[1], &errno, sizeof errno);
    exit(-1);
    /*NOTREACHED*/
    parent_error:
    Tcl_DStringFree(&dstring);
    if (esPtr) {
        exp_close(interp,esPtr);
	waitpid(esPtr->pid,(int *)&esPtr->wait,0);
	if (esPtr->registered) {
	    Tcl_UnregisterChannel(interp,esPtr->channel);
	}
    }
    return TCL_ERROR;
}

/*ARGSUSED*/
static int
Exp_ExpPidObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    char *chanName = 0;
    ExpState *esPtr = 0;

    static char* options[] = { "-i", NULL };
    enum options { PID_ID };
    int i;

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    goto usage;
	}
	switch ((enum options) index) {
	    case PID_ID:
		i++;
		if (i >= objc) goto usage;
		chanName = Tcl_GetString (objv[i]);
		break;
	}
    }

    if (chanName) {
	esPtr = expStateFromChannelName(interp,chanName,0,0,0,"exp_pid");
    } else {
	esPtr = expStateCurrent(interp,0,0,0);
    }
    if (!esPtr) return TCL_ERROR;

    Tcl_SetObjResult (interp, Tcl_NewIntObj (esPtr->pid));
    return TCL_OK;
    usage:
    exp_error(interp,"usage: -i spawn_id");
    return TCL_ERROR;
}

/*ARGSUSED*/
static int
Exp_GetpidDeprecatedObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    expDiagLog("getpid is deprecated, use pid\r\n");
    Tcl_SetObjResult (interp, Tcl_NewIntObj (getpid()));
    return(TCL_OK);
}

/*ARGSUSED*/
static int
Exp_SleepObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    double s;

    if (objc != 2) {
	exp_error(interp,"must have one arg: seconds");
	return TCL_ERROR;
    }

    if (TCL_OK != Tcl_GetDoubleFromObj (interp, objv[1], &s)) {
	if (0 == strlen (Tcl_GetString(objv[1]))) {
	    /* Keep undocumented acceptance of "" as 0 = no delay */
	    return TCL_OK;
	}
	return TCL_ERROR;
    }

    return exp_dsleep(interp,s);
}

struct slow_arg {
    int size;
    double time;
};

/* returns 0 for success, -1 for failure */
static int
get_slow_args(
    Tcl_Interp *interp,
    struct slow_arg *x)
{
    int sc;		/* return from scanf */
    CONST char *s = exp_get_var(interp,"send_slow");
    if (!s) {
	exp_error(interp,"send -s: send_slow has no value");
	return(-1);
    }
    if (2 != (sc = sscanf(s,"%d %lf",&x->size,&x->time))) {
	exp_error(interp,"send -s: found %d value(s) in send_slow but need 2",sc);
	return(-1);
    }
    if (x->size <= 0) {
	exp_error(interp,"send -s: size (%d) in send_slow must be positive", x->size);
	return(-1);
    }
    if (x->time <= 0) {
	exp_error(interp,"send -s: time (%f) in send_slow must be larger",x->time);
	return(-1);
    }
    return(0);
}

/* returns 0 for success, -1 for failure, pos. for Tcl return value */
static int
slow_write(
    Tcl_Interp *interp,
    ExpState *esPtr,
    char *buffer,
    int rembytes,
    struct slow_arg *arg)
{
    int rc;

    while (rembytes > 0) {
	int i, bytelen, charlen;
	char *p;

	p = buffer;
	charlen = (arg->size<rembytes?arg->size:rembytes);

	/* count out the right number of UTF8 chars */
	for (i=0;i<charlen;i++) {
	    p = Tcl_UtfNext(p);
	}
	bytelen = p-buffer;

	if (0 > expWriteChars(esPtr,buffer,bytelen)) { return(-1); }
	rembytes -= bytelen;
	buffer += bytelen;

	/* skip sleep after last write */
	if (rembytes > 0) {
	    rc = exp_dsleep(interp,arg->time);
	    if (rc>0) return rc;
	}
    }
    return(0);
}

struct human_arg {
    float alpha;		/* average interarrival time in seconds */
    float alpha_eow;	/* as above but for eow transitions */
    float c;		/* shape */
    float min, max;
};

/* returns -1 if error, 0 if success */
static int
get_human_args(
    Tcl_Interp *interp,
    struct human_arg *x)
{
    int sc;		/* return from scanf */
    CONST char *s = exp_get_var(interp,"send_human");

    if (!s) {
	exp_error(interp,"send -h: send_human has no value");
	return(-1);
    }
    if (5 != (sc = sscanf(s,"%f %f %f %f %f",
			    &x->alpha,&x->alpha_eow,&x->c,&x->min,&x->max))) {
	if (sc == EOF) sc = 0;	/* make up for overloaded return */
	exp_error(interp,"send -h: found %d value(s) in send_human but need 5",sc);
	return(-1);
    }
    if (x->alpha < 0 || x->alpha_eow < 0) {
	exp_error(interp,"send -h: average interarrival times (%f %f) must be non-negative in send_human", x->alpha,x->alpha_eow);
	return(-1);
    }
    if (x->c <= 0) {
	exp_error(interp,"send -h: variability (%f) in send_human must be positive",x->c);
	return(-1);
    }
    x->c = 1/x->c;

    if (x->min < 0) {
	exp_error(interp,"send -h: minimum (%f) in send_human must be non-negative",x->min);
	return(-1);
    }
    if (x->max < 0) {
	exp_error(interp,"send -h: maximum (%f) in send_human must be non-negative",x->max);
	return(-1);
    }
    if (x->max < x->min) {
	exp_error(interp,"send -h: maximum (%f) must be >= minimum (%f) in send_human",x->max,x->min);
	return(-1);
    }
    return(0);
}

/* Compute random numbers from 0 to 1, for expect's send -h */
/* This implementation sacrifices beauty for portability */
static float
unit_random()
{
    /* current implementation is pathetic but works */
    /* 99991 is largest prime in my CRC - can't hurt, eh? */
    return((float)(1+(rand()%99991))/99991.0);
}

void
exp_init_unit_random()
{
    srand(getpid());
}

/* This function is my implementation of the Weibull distribution. */
/* I've added a max time and an "alpha_eow" that captures the slight */
/* but noticable change in human typists when hitting end-of-word */
/* transitions. */
/* returns 0 for success, -1 for failure, pos. for Tcl return value */
static int
human_write(
    Tcl_Interp *interp,
    ExpState *esPtr,
    char *buffer,
    struct human_arg *arg)
{
    char *sp;
    int size;
    float t;
    float alpha;
    int wc;
    int in_word = TRUE;
    Tcl_UniChar ch;

    expDiagLog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
	    arg->alpha,arg->alpha_eow,arg->c,arg->min,arg->max);

    for (sp = buffer;*sp;sp += size) {
	size = Tcl_UtfToUniChar(sp, &ch);
	/* use the end-of-word alpha at eow transitions */
	if (in_word && (Tcl_UniCharIsPunct(ch) || Tcl_UniCharIsSpace(ch)))
	    alpha = arg->alpha_eow;
	else alpha = arg->alpha;
	in_word = !(Tcl_UniCharIsPunct(ch) || Tcl_UniCharIsSpace(ch));

	t = alpha * pow(-log((double)unit_random()),arg->c);

	/* enforce min and max times */
	if (t<arg->min) t = arg->min;
	else if (t>arg->max) t = arg->max;

	/* skip sleep before writing first character */
	if (sp != buffer) {
	    wc = exp_dsleep(interp,(double)t);
	    if (wc > 0) return wc;
	}

	wc = expWriteChars(esPtr, sp, size);
	if (0 > wc) return(wc);
    }
    return(0);
}

struct exp_i *exp_i_pool = 0;
struct exp_state_list *exp_state_list_pool = 0;

#define EXP_I_INIT_COUNT	10
#define EXP_FD_INIT_COUNT	10

struct exp_i *
exp_new_i()
{
    int n;
    struct exp_i *i;

    if (!exp_i_pool) {
	/* none avail, generate some new ones */
	exp_i_pool = i = (struct exp_i *)ckalloc(
	    EXP_I_INIT_COUNT * sizeof(struct exp_i));
	for (n=0;n<EXP_I_INIT_COUNT-1;n++,i++) {
	    i->next = i+1;
	}
	i->next = 0;
    }

    /* now that we've made some, unlink one and give to user */

    i = exp_i_pool;
    exp_i_pool = exp_i_pool->next;
    i->value = 0;
    i->variable = 0;
    i->state_list = 0;
    i->ecount = 0;
    i->next = 0;
    return i;
}

struct exp_state_list *
exp_new_state(ExpState *esPtr)
{
    int n;
    struct exp_state_list *fd;

    if (!exp_state_list_pool) {
	/* none avail, generate some new ones */
	exp_state_list_pool = fd = (struct exp_state_list *)ckalloc(
	    EXP_FD_INIT_COUNT * sizeof(struct exp_state_list));
	for (n=0;n<EXP_FD_INIT_COUNT-1;n++,fd++) {
	    fd->next = fd+1;
	}
	fd->next = 0;
    }

    /* now that we've made some, unlink one and give to user */

    fd = exp_state_list_pool;
    exp_state_list_pool = exp_state_list_pool->next;
    fd->esPtr = esPtr;
    /* fd->next is assumed to be changed by caller */
    return fd;
}

void
exp_free_state(struct exp_state_list *fd_first)
{
    struct exp_state_list *fd, *penultimate;

    if (!fd_first) return;

    /* link entire chain back in at once by first finding last pointer */
    /* making that point back to pool, and then resetting pool to this */

    /* run to end */
    for (fd = fd_first;fd;fd=fd->next) {
	penultimate = fd;
    }
    penultimate->next = exp_state_list_pool;
    exp_state_list_pool = fd_first;
}

/* free a single fd */
void
exp_free_state_single(struct exp_state_list *fd)
{
    fd->next = exp_state_list_pool;
    exp_state_list_pool = fd;
}

void
exp_free_i(
    Tcl_Interp *interp,
    struct exp_i *i,
    Tcl_VarTraceProc *updateproc)/* proc to invoke if indirect is written */
{
    if (i->next) exp_free_i(interp,i->next,updateproc);

    exp_free_state(i->state_list);

    if (i->direct == EXP_INDIRECT) {
	Tcl_UntraceVar(interp,i->variable, TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
		updateproc, (ClientData)i);
    }

    /* here's the long form
       if duration & direct	free(var)  free(val)
       PERM	  DIR	    		1
       PERM	  INDIR	    1		1
       TMP	  DIR
       TMP	  INDIR			1
       Also if i->variable was a bogus variable name, i->value might not be
       set, so test i->value to protect this
       TMP in this case does NOT mean from the "expect" command.  Rather
       it means "an implicit spawn id from any expect or expect_XXX
       command".  In other words, there was no variable name provided.
    */
    if (i->value
	    && (((i->direct == EXP_DIRECT) && (i->duration == EXP_PERMANENT))
		    || ((i->direct == EXP_INDIRECT) && (i->duration == EXP_TEMPORARY)))) {
	ckfree(i->value);
    } else if (i->duration == EXP_PERMANENT) {
	if (i->value) ckfree(i->value);
	if (i->variable) ckfree(i->variable);
    }

    i->next = exp_i_pool;
    exp_i_pool = i;
}

/* generate a descriptor for a "-i" flag */
/* can only fail on bad direct descriptors */
/* indirect descriptors always succeed */
struct exp_i *
exp_new_i_complex(
    Tcl_Interp *interp,
    char *arg,		/* spawn id list or a variable containing a list */
    int duration,		/* if we have to copy the args */
    /* should only need do this in expect_before/after */
    Tcl_VarTraceProc *updateproc)	/* proc to invoke if indirect is written */
{
    struct exp_i *i;
    char **stringp;

    i = exp_new_i();

    i->direct = (isExpChannelName(arg) || (0 == strcmp(arg, EXP_SPAWN_ID_ANY_LIT))?EXP_DIRECT:EXP_INDIRECT);
#if OBSOLETE
    i->direct = (isdigit(arg[0]) || (arg[0] == '-'))?EXP_DIRECT:EXP_INDIRECT;
#endif
    if (i->direct == EXP_DIRECT) {
	stringp = &i->value;
    } else {
	stringp = &i->variable;
    }

    i->duration = duration;
    if (duration == EXP_PERMANENT) {
	*stringp = ckalloc(strlen(arg)+1);
	strcpy(*stringp,arg);
    } else {
	*stringp = arg;
    }

    i->state_list = 0;
    if (TCL_ERROR == exp_i_update(interp,i)) {
	exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
	return 0;
    }

    /* if indirect, ask Tcl to tell us when variable is modified */

    if (i->direct == EXP_INDIRECT) {
	Tcl_TraceVar(interp, i->variable,
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
		updateproc, (ClientData) i);
    }

    return i;
}

void
exp_i_add_state(
    struct exp_i *i,
    ExpState *esPtr)
{
    struct exp_state_list *new_state;

    new_state = exp_new_state(esPtr);
    new_state->next = i->state_list;
    i->state_list = new_state;
}

/* this routine assumes i->esPtr is meaningful */
/* returns TCL_ERROR only on direct */
/* indirects always succeed */
static int
exp_i_parse_states(
    Tcl_Interp *interp,
    struct exp_i *i)
{
    struct ExpState *esPtr;
    char *p = i->value;
    int argc;
    char **argv;
    int j;

    if (Tcl_SplitList(NULL, p, &argc, &argv) != TCL_OK) goto error;

    for (j = 0; j < argc; j++) {
        esPtr = expStateFromChannelName(interp,argv[j],1,0,1,"");
	if (!esPtr) goto error;
	exp_i_add_state(i,esPtr);
    }
    ckfree((char*)argv);
    return TCL_OK;
    error:
    expDiagLogU("exp_i_parse_states: ");
    expDiagLogU(Tcl_GetStringResult(interp));
    return TCL_ERROR;
}

/* updates a single exp_i struct */
/* return TCL_ERROR only on direct variables */
/* indirect variables always succeed */
int
exp_i_update(
    Tcl_Interp *interp,
    struct exp_i *i)
{
    char *p;	/* string representation of list of spawn ids */

    if (i->direct == EXP_INDIRECT) {
	p = Tcl_GetVar(interp,i->variable,TCL_GLOBAL_ONLY);
	if (!p) {
	    p = "";
	    /* *really* big variable names could blow up expDiagLog! */
	    expDiagLog("warning: indirect variable %s undefined",i->variable);
	}

	if (i->value) {
	    if (streq(p,i->value)) return TCL_OK;

	    /* replace new value with old */
	    ckfree(i->value);
	}
	i->value = ckalloc(strlen(p)+1);
	strcpy(i->value,p);

	exp_free_state(i->state_list);
	i->state_list = 0;
    } else {
	/* no free, because this should only be called on */
	/* "direct" i's once */
	i->state_list = 0;
    }
    return exp_i_parse_states(interp, i);
}

struct exp_i *
exp_new_i_simple(
    ExpState *esPtr,
    int duration)		/* if we have to copy the args */
    /* should only need do this in expect_before/after */
{
    struct exp_i *i;

    i = exp_new_i();

    i->direct = EXP_DIRECT;
    i->duration = duration;

    exp_i_add_state(i,esPtr);

    return i;
}

/*ARGSUSED*/
static int
Exp_SendLogObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    static char* options[] = { "--", NULL };
    enum options { LOG_QUOTE };
    int i;

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    goto usage;
	}
	if (((enum options) index) == LOG_QUOTE) {
	    i++;
	    break;
	}
    }

    if (i != (objc-1)) goto usage;

    expLogDiagU(Tcl_GetString (objv[i]));
    return(TCL_OK);

    usage:
    exp_error(interp,"usage: send [args] string");
    return TCL_ERROR;
}


/* I've rewritten this to be unbuffered.  I did this so you could shove */
/* large files through "send".  If you are concerned about efficiency */
/* you should quote all your send args to make them one single argument. */
/*ARGSUSED*/
static int
Exp_SendObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr = 0;
    int rc; 	/* final result of this procedure */
    struct human_arg human_args;
    struct slow_arg slow_args;
#define SEND_STYLE_STRING_MASK	0x07	/* mask to detect a real string arg */
#define SEND_STYLE_PLAIN	0x01
#define SEND_STYLE_HUMAN	0x02
#define SEND_STYLE_SLOW		0x04
#define SEND_STYLE_ZERO		0x10
#define SEND_STYLE_BREAK	0x20
    int send_style = SEND_STYLE_PLAIN;
    int want_cooked = TRUE;
    char *string;		/* string to send */
    int len = -1;		/* length of string to send */
    int zeros;		/* count of how many ascii zeros to send */

    char *chanName = 0;
    struct exp_state_list *state_list;
    struct exp_i *i;
    int j;

    static char *options[] = {
	"-i", "-h", "-s", "-null", "-0", "-raw", "-break", "--", (char *)0
    };
    enum options {
	SEND_SPAWNID, SEND_HUMAN, SEND_SLOW, SEND_NULL, SEND_ZERO,
	SEND_RAW, SEND_BREAK, SEND_LAST
    };

    for (j = 1; j < objc; j++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[j]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[j], options, "flag", 0,
			&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case SEND_SPAWNID:
		j++;
		chanName = Tcl_GetString(objv[j]);
		break;

	    case SEND_LAST:
		j++;
		goto getString;

	    case SEND_HUMAN:
		if (-1 == get_human_args(interp,&human_args))
		    return(TCL_ERROR);
		send_style = SEND_STYLE_HUMAN;
		break;

	    case SEND_SLOW:
		if (-1 == get_slow_args(interp,&slow_args))
		    return(TCL_ERROR);
		send_style = SEND_STYLE_SLOW;
		break;

	    case SEND_NULL:
	    case SEND_ZERO:
		j++;
		if (j >= objc) {
		    zeros = 1;
		} else if (Tcl_GetIntFromObj(interp, objv[j], &zeros)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		if (zeros < 1) return TCL_OK;
		send_style = SEND_STYLE_ZERO;
		string = "<zero(s)>";
		break;

	    case SEND_RAW:
		want_cooked = FALSE;
		break;

	    case SEND_BREAK:
		send_style = SEND_STYLE_BREAK;
		string = "<break>";
		break;
	}
    }

    if (send_style & SEND_STYLE_STRING_MASK) {
	getString:
	if (j != objc-1) {
	    exp_error(interp,"usage: send [args] string");
	    return TCL_ERROR;
	}
	string = Tcl_GetStringFromObj(objv[j], &len);
    } else {
	len = strlen(string);
    }

    if (clientData == &sendCD_user) esPtr = tsdPtr->stdinout;
    else if (clientData == &sendCD_error) esPtr = tsdPtr->stderrX;
    else if (clientData == &sendCD_tty) {
	esPtr = tsdPtr->devtty;
	if (!esPtr) {
	    exp_error(interp,"send_tty: cannot send to controlling terminal in an environment when there is no controlling terminal to send to!");
	    return TCL_ERROR;
	}
    } else if (!chanName) {
	/* we want to check if it is open */
	/* but since stdin could be closed, we have to first */
	/* get the fd and then convert it from 0 to 1 if necessary */
	if (!(esPtr = expStateCurrent(interp,0,0,0))) return(TCL_ERROR);
    }

    if (esPtr) {
	i = exp_new_i_simple(esPtr,EXP_TEMPORARY);
    } else {
	i = exp_new_i_complex(interp,chanName,FALSE,(Tcl_VarTraceProc *)0);
	if (!i) return TCL_ERROR;
    }

#define send_to_stderr	(clientData == &sendCD_error)
#define send_to_proc	(clientData == &sendCD_proc)
#define send_to_user	((clientData == &sendCD_user) ||	\
	    (clientData == &sendCD_tty))

    if (send_to_proc) {
	want_cooked = FALSE;
	expDiagLogU("send: sending \"");
	expDiagLogU(expPrintify(string));
	expDiagLogU("\" to {");
	/* if closing brace doesn't appear, that's because an error */
	/* was encountered before we could send it */
    } else {
	expLogDiagU(string);
    }

    for (state_list=i->state_list;state_list;state_list=state_list->next) {
	esPtr = state_list->esPtr;

	if (send_to_proc) {
	    expDiagLog(" %s ",esPtr->name);
	}

	/* check validity of each - i.e., are they open */
	if (0 == expStateCheck(interp,esPtr,1,0,"send")) {
	    rc = TCL_ERROR;
	    goto finish;
	}
	if (want_cooked) string = exp_cook(string,&len);

	switch (send_style) {
	    case SEND_STYLE_PLAIN:
		rc = expWriteChars(esPtr,string,len);
		break;
	    case SEND_STYLE_SLOW:
		rc = slow_write(interp,esPtr,string,len,&slow_args);
		break;
	    case SEND_STYLE_HUMAN:
		rc = human_write(interp,esPtr,string,&human_args);
		break;
	    case SEND_STYLE_ZERO:
		for (;zeros>0;zeros--) {
		    rc = expWriteChars(esPtr,NULL_STRING,NULL_LENGTH);
		}
		/* catching error on last write is sufficient */
		break;
	    case SEND_STYLE_BREAK:
		exp_tty_break(interp,esPtr->fdout);
		rc = 0;
		break;
	}

	if (rc != 0) {
	    if (rc == -1) {
		exp_error(interp,"write(spawn_id=%d): %s",esPtr->fdout,Tcl_PosixError(interp));
		rc = TCL_ERROR;
	    }
	    goto finish;
	}
    }
    if (send_to_proc) expDiagLogU("}\r\n");

    rc = TCL_OK;
    finish:
    exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
    return rc;
}

/*ARGSUSED*/
static int
Exp_LogFileObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    static char resultbuf[1000];
    char *chanName = 0;
    int leaveOpen = FALSE;
    int logAll = FALSE;
    int append = TRUE;
    char *filename = 0;
    int i;

    static char* options[] = {
	"-a",
	"-info",
	"-leaveopen",
	"-noappend",
	"-open",
	NULL
    };
    enum options {
	LOGFILE_A,
	LOGFILE_INFO,
	LOGFILE_LEAVEOPEN,
	LOGFILE_NOAPPEND,
	LOGFILE_OPEN
    };

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case LOGFILE_A:
		logAll = TRUE;
		break;
	    case LOGFILE_INFO:
		resultbuf[0] = '\0';
		if (expLogChannelGet()) {
		    /* FUTURE: Use List-ops to construct a proper Tcl_Obj */
		    if (expLogAllGet()) strcat(resultbuf,"-a ");
		    if (!expLogAppendGet()) strcat(resultbuf,"-noappend ");
		    if (expLogFilenameGet()) {
			strcat(resultbuf,expLogFilenameGet());
		    } else {
			if (expLogLeaveOpenGet()) {
			    strcat(resultbuf,"-leaveopen ");
			}
			strcat(resultbuf,Tcl_GetChannelName(expLogChannelGet()));
		    }
		    Tcl_SetResult(interp,resultbuf,TCL_STATIC);
		}
		return TCL_OK;
	    case LOGFILE_LEAVEOPEN:
		i ++;
		if (i >= objc) goto usage_error;
		chanName = Tcl_GetString (objv[i]);
		leaveOpen = TRUE;
		break;
	    case LOGFILE_NOAPPEND:
		append = FALSE;
		break;
	    case LOGFILE_OPEN:
		i++;
		if (i >= objc) goto usage_error;
		chanName = Tcl_GetString (objv[i]);
		break;
	}
    }
    
    if (i == (objc - 1)) {
	filename = Tcl_GetString (objv[i]);
    } else if (objc > i) {
	/* too many arguments */
	goto usage_error;
    } 
    
    if (chanName && filename) {
	goto usage_error;
    }

    /* check if user merely wants to change logAll (-a) */
    if (expLogChannelGet() && (chanName || filename)) {
	if (filename && (0 == strcmp(filename,expLogFilenameGet()))) {
	    expLogAllSet(logAll);
	    return TCL_OK;
	} else if (chanName &&
		(0 == strcmp(chanName,Tcl_GetChannelName(expLogChannelGet())))) {
	    expLogAllSet(logAll);
	    return TCL_OK;
	} else {
	    exp_error(interp,"cannot start logging without first stopping logging");
	    return TCL_ERROR;
	}
    }

    if (filename) {
	if (TCL_ERROR == expLogChannelOpen(interp,filename,append)) {
	    return TCL_ERROR;
	}
    } else if (chanName) {
	if (TCL_ERROR == expLogChannelSet(interp,chanName)) {
	    return TCL_ERROR;
	}
    } else {
	expLogChannelClose(interp);
	if (logAll) {
	    exp_error(interp,"cannot use -a without a file or channel");
	    return TCL_ERROR;
	}
    }
    expLogAllSet(logAll);
    expLogLeaveOpenSet(leaveOpen);

    return TCL_OK;

    usage_error:
    exp_error(interp,"usage: log_file [-info] [-noappend] [[-a] file] [-[leave]open [open ...]]");
    return TCL_ERROR;
}

/*ARGSUSED*/
static int
Exp_LogUserObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int old_loguser = expLogUserGet();

    if (objc == 0 || (objc == 2 && streq(Tcl_GetString (objv[1]),"-info"))) {
	/* do nothing */
    } else if (objc == 2) {
	int flag;
	if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[1], &flag)) {
	    if (0 == strlen (Tcl_GetString(objv[1]))) {
		/* Keep undocumented acceptance of "" as 0. */
		flag = 0;
	    } else {
		return TCL_ERROR;
	    }
	}
	expLogUserSet(flag);
    } else {
	exp_error(interp,"usage: [-info|1|0]");
    }

    Tcl_SetObjResult (interp, Tcl_NewIntObj (old_loguser));
    return(TCL_OK);
}

#ifdef TCL_DEBUGGER
/*ARGSUSED*/
static int
Exp_DebugObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int now = FALSE;	/* soon if FALSE, now if TRUE */
    int exp_tcl_debugger_was_available = exp_tcl_debugger_available;

    static char* options[] = { "-now", NULL };
    enum options { DEBUG_NOW };
    int i;

    if (objc > 3) goto usage;

    if (objc == 1) {
	Tcl_SetObjResult (interp, Tcl_NewIntObj (exp_tcl_debugger_available));
	return TCL_OK;
    }

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    goto usage;
	}
	switch ((enum options) index) {
	    case DEBUG_NOW:
		now = TRUE;
		break;
	}
    }

    if (i == objc) {
	if (now) {
	    Dbg_On(interp,1);
	    exp_tcl_debugger_available = 1;
	} else {
	    goto usage;
	}
    } else {
	int flag;
	if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[i], &flag)) {
	    goto usage;
	}
	if (!flag) {
	    Dbg_Off(interp);
	    exp_tcl_debugger_available = 0;
	} else {
	    Dbg_On(interp,now);
	    exp_tcl_debugger_available = 1;
	}
    }
    Tcl_SetObjResult (interp, Tcl_NewBooleanObj (exp_tcl_debugger_was_available));
    return(TCL_OK);
    usage:
    exp_error(interp,"usage: [[-now] 1|0]");
    return TCL_ERROR;
}
#endif


/*ARGSUSED*/
static int
Exp_ExpInternalObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int newChannel = FALSE;
    Tcl_Channel oldChannel;
    static char resultbuf[1000];
    int flag, i;

    static char* options[] = {
	"-f",
	"-info",
	NULL
    };
    enum options {
	INTERNAL_F,
	INTERNAL_INFO
    };

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    goto usage;
	}
	switch ((enum options) index) {
	    case INTERNAL_INFO:
		/* FUTURE: Construct a proper list Tcl_Obj here */
		/* Should check that there are no arguments coming after -info */

		resultbuf[0] = '\0';
		oldChannel = expDiagChannelGet();
		if (oldChannel) {
		    sprintf(resultbuf,"-f %s ",expDiagFilename());
		}
		strcat(resultbuf,expDiagToStderrGet()?"1":"0");
		Tcl_SetResult(interp,resultbuf,TCL_STATIC);
		return TCL_OK;
	    case INTERNAL_F:
		i ++;
		if (i >= objc) goto usage;
		expDiagChannelClose(interp);
		if (TCL_OK != expDiagChannelOpen(interp,Tcl_GetString (objv[i]))) {
		    return TCL_ERROR;
		}
		newChannel = TRUE;
		break;
	}
    }

    if (i >= objc) goto usage;

    if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[i], &flag)) {
	goto usage;
    }
    
    /* if no -f given, close file */
    if (!newChannel) {
	expDiagChannelClose(interp);
    }

    expDiagToStderrSet(flag);
    return(TCL_OK);
    usage:
    exp_error(interp,"usage: [-f file] 0|1");
    return TCL_ERROR;
}

char *exp_onexit_action = 0;

/*ARGSUSED*/
static int
Exp_ExitObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int value = 0;

    objc--;
    objv++;

    if (objc) {
	if (exp_flageq(Tcl_GetString (objv[0]),"-onexit",3)) {
	    objc--;
	    objv++;
	    if (objc) {
		int len;
		char* act = Tcl_GetStringFromObj (objv[0], &len);

		if (exp_onexit_action)
		    ckfree(exp_onexit_action);

		exp_onexit_action = ckalloc(len + 1);
		strcpy(exp_onexit_action,act);

	    } else if (exp_onexit_action) {
		Tcl_AppendResult(interp,exp_onexit_action,(char *)0);
	    }
	    return TCL_OK;
	} else if (exp_flageq(Tcl_GetString (objv[0]),"-noexit",3)) {
	    objc--;
	    objv++;
	    exp_exit_handlers((ClientData)interp);
	    return TCL_OK;
	}
    }

    if (objc) {
	if (Tcl_GetIntFromObj(interp, objv[0], &value) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    /*
     * Restore previous definition of close.  Needed when expect is
     * dynamically loaded after close has been redefined
     * e.g.  the virtual file system in tclkit
     */
    Tcl_Eval(interp, "rename _close.pre_expect close");
    Tcl_Exit(value);
    /*NOTREACHED*/
    return TCL_ERROR;
}

/*ARGSUSED*/
static int
Exp_ConfigureObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    /* Magic configuration stuff. */
    int i, opt, val;

    static CONST84 char* options [] = {
	"-strictwrite", NULL
    };
    enum options {
	EXP_STRICTWRITE
    };

    if ((objc < 3) || (objc % 2 == 0)) {
	Tcl_WrongNumArgs (interp, 1, objv, "-strictwrite value");
	return TCL_ERROR;
    }

    for (i=1; i < objc; i+=2) {
	if (Tcl_GetIndexFromObj (interp, objv [i], options, "option",
			0, &opt) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch (opt) {
	    case EXP_STRICTWRITE:
		if (Tcl_GetBooleanFromObj (interp, objv [i+1], &val) != TCL_OK) {
		    return TCL_ERROR;
		}
		exp_strict_write = val;
		break;
	}
    }

    return TCL_OK;
}

/*ARGSUSED*/
static int
Exp_CloseObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[]) 	/* Argument objects. */
{
    int onexec_flag = FALSE;	/* true if -onexec seen */
    int close_onexec;
    int slave_flag = FALSE;
    ExpState *esPtr = 0;
    char *chanName = 0;
    int i;

    static char* options[] = {
	"-i",
	"-onexec",
	"-slave",
	NULL
    };
    enum options {
	CLOSE_ID,
	CLOSE_ONEXEC,
	CLOSE_SLAVE
    };

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case CLOSE_ID:
		i++;
		if (i == objc) {
		    exp_error(interp,"usage: -i spawn_id");
		    return(TCL_ERROR);
		}
		chanName = Tcl_GetString(objv[i]);
		break;
	    case CLOSE_ONEXEC:
		i++;
		if (i == objc) {
		    on_exec_usage:
		    exp_error(interp,"usage: -onexec 0|1");
		    return(TCL_ERROR);
		}
		onexec_flag = TRUE;
		if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[i], &close_onexec)) {
		    goto on_exec_usage;
		}
		break;
	    case CLOSE_SLAVE:
		slave_flag = TRUE;
		break;
	}
    }

    if (i < objc) {
	/* doesn't look like our format, it must be a Tcl-style file */
	/* handle.  Lucky that formats are easily distinguishable. */
	/* Historical note: we used "close"  long before there was a */
	/* Tcl builtin by the same name. */

        Tcl_CmdInfo* close_info;

	Tcl_ResetResult(interp);

	close_info = (Tcl_CmdInfo*) Tcl_GetAssocData (interp, EXP_CMDINFO_CLOSE, NULL);
	return(close_info->objProc(close_info->objClientData,interp,objc,objv));
    }

    if (chanName) {
	esPtr = expStateFromChannelName(interp,chanName,1,0,0,"close");
    } else {
	esPtr = expStateCurrent(interp,1,0,0);
    }
    if (!esPtr) return TCL_ERROR;

    if (slave_flag) {
	if (esPtr->fd_slave != EXP_NOFD) {
	    close(esPtr->fd_slave);
	    esPtr->fd_slave = EXP_NOFD;

	    exp_slave_control(esPtr->fdin,1);

	    return TCL_OK;
	} else {
	    exp_error(interp,"no such slave");
	    return TCL_ERROR;
	}
    }

    if (onexec_flag) {
	/* heck, don't even bother to check if fd is open or a real */
	/* spawn id, nothing else depends on it */
	fcntl(esPtr->fdin,F_SETFD,close_onexec);
	return TCL_OK;
    }

    return(exp_close(interp,esPtr));
}

/*ARGSUSED*/
static int
tcl_tracer(
    ClientData clientData,
    Tcl_Interp *interp,
    int level,
    CONST char *command,
    Tcl_Command cmdInfo,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int i;

    /* come out on stderr, by using expErrorLog */
    expErrorLog("%2d",level);
    for (i = 0;i<level;i++) expErrorLogU("  ");
    expErrorLogU((char*)command);
    expErrorLogU("\r\n");
    return TCL_OK;
}

static void
tcl_tracer_del(ClientData clientData)
{
    /* Nothing */
}

/*ARGSUSED*/
static int
Exp_StraceObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    static int trace_level = 0;
    static Tcl_Trace trace_handle;

    if (objc > 1 && streq(Tcl_GetString (objv[1]),"-info")) {
	Tcl_SetObjResult (interp, Tcl_NewIntObj (trace_level));
	return TCL_OK;
    }

    if (objc != 2) {
	exp_error(interp,"usage: trace level");
	return(TCL_ERROR);
    }
    /* tracing already in effect, undo it */
    if (trace_level > 0) Tcl_DeleteTrace(interp,trace_handle);

    /* get and save new trace level */

    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[1], &trace_level)) {
	return TCL_ERROR;
    }

    if (trace_level > 0)
	trace_handle = Tcl_CreateObjTrace(interp, trace_level,0,
		tcl_tracer,(ClientData)0,
		tcl_tracer_del);
    return(TCL_OK);
}

/* following defn's are stolen from tclUnix.h */

/*
 * The type of the status returned by wait varies from UNIX system
 * to UNIX system.  The macro below defines it:
 */

#if 0
#ifndef NO_UNION_WAIT
#   define WAIT_STATUS_TYPE union wait
#else
#   define WAIT_STATUS_TYPE int
#endif
#endif /* 0 */

/*
 * following definitions stolen from tclUnix.h
 * (should have been made public!)

 * Supply definitions for macros to query wait status, if not already
 * defined in header files above.
 */

#if 0
#ifndef WIFEXITED
#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xff) == 0)
#endif

#ifndef WEXITSTATUS
#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#ifndef WIFSIGNALED
#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
#endif

#ifndef WTERMSIG
#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
#endif

#ifndef WIFSTOPPED
#   define WIFSTOPPED(stat)  (((*((int *) &(stat))) & 0xff) == 0177)
#endif

#ifndef WSTOPSIG
#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
#endif
#endif /* 0 */

/* end of stolen definitions */

/* Describe the processes created with Expect's fork.
   This allows us to wait on them later.

   This is maintained as a linked list.  As additional procs are forked,
   new links are added.  As procs disappear, links are marked so that we
   can reuse them later.
*/

struct forked_proc {
    int pid;
    WAIT_STATUS_TYPE wait_status;
    enum {not_in_use, wait_done, wait_not_done} link_status;
    struct forked_proc *next;
} *forked_proc_base = 0;

void
fork_clear_all()
{
    struct forked_proc *f;

    for (f=forked_proc_base;f;f=f->next) {
	f->link_status = not_in_use;
    }
}

void
fork_init(
    struct forked_proc *f,
    int pid)
{
    f->pid = pid;
    f->link_status = wait_not_done;
}

/* make an entry for a new proc */
void
fork_add(int pid)
{
    struct forked_proc *f;

    for (f=forked_proc_base;f;f=f->next) {
	if (f->link_status == not_in_use) break;
    }

    /* add new entry to the front of the list */
    if (!f) {
	f = (struct forked_proc *)ckalloc(sizeof(struct forked_proc));
	f->next = forked_proc_base;
	forked_proc_base = f;
    }
    fork_init(f,pid);
}

/* Provide a last-chance guess for this if not defined already */
#ifndef WNOHANG
#define WNOHANG WNOHANG_BACKUP_VALUE
#endif

/* wait returns are a hodgepodge of things
   If wait fails, something seriously has gone wrong, for example:
   bogus arguments (i.e., incorrect, bogus spawn id)
   no children to wait on
   async event failed
   If wait succeeeds, something happened on a particular pid
   3rd arg is 0 if successfully reaped (if signal, additional fields supplied)
   3rd arg is -1 if unsuccessfully reaped (additional fields supplied)
*/
/*ARGSUSED*/
static int
Exp_WaitObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    char *chanName = 0;
    struct ExpState *esPtr;
    struct forked_proc *fp = 0;	/* handle to a pure forked proc */
    struct ExpState esTmp;	/* temporary memory for either f or fp */
    char spawn_id[20];

    int nowait = FALSE;
    int result = 0;		/* 0 means child was successfully waited on */
				/* -1 means an error occurred */
				/* -2 means no eligible children to wait on */

    static char* options[] = {
	"-i",
	"-nowait",
	NULL
    };
    enum options {
	WAIT_ID,
	WAIT_NOWAIT
    };
    int i;

#define NO_CHILD (-2)

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    goto usage;
	}
	switch ((enum options) index) {
	    case WAIT_ID:
		i++;
		if (i >= objc) goto usage;
		chanName = Tcl_GetString (objv[i]);
		break;
	    case WAIT_NOWAIT:
		nowait = TRUE;
		break;
	}
    }

    if (!chanName) {
	esPtr = expStateCurrent(interp,0,0,1);
    } else {
	esPtr = expStateFromChannelName(interp,chanName,0,0,1,"wait");
    }
    if (!esPtr) return TCL_ERROR;

    if (!expStateAnyIs(esPtr)) {
	/* check if waited on already */
	/* things opened by "open" or set with -nowait */
	/* are marked sys_waited already */
	if (!esPtr->sys_waited) {
	    if (nowait) {
		Tcl_Pid pid = (Tcl_Pid)(long)esPtr->pid;
		/* should probably generate an error */
		/* if SIGCHLD is trapped. */

		/* pass to Tcl, so it can do wait */
		/* in background */
		Tcl_DetachPids(1,&pid);
		exp_wait_zero(&esPtr->wait);
	    } else {
		while (1) {
		    if (Tcl_AsyncReady()) {
			int rc = Tcl_AsyncInvoke(interp,TCL_OK);
			if (rc != TCL_OK) return(rc);
		    }

		    result = waitpid(esPtr->pid,(int *)&esPtr->wait,0);
		    if (result == esPtr->pid) break;
		    if (result == -1) {
			if (errno == EINTR) continue;
			else break;
		    }
		}
	    }
	}

	/*
	 * Now have Tcl reap anything we just detached. 
	 * This also allows procs user has created with "exec &"
	 * and and associated with an "exec &" process to be reaped.
	 */
	
	Tcl_ReapDetachedProcs();
	exp_rearm_sigchld(interp); /* new */

	strcpy(spawn_id,esPtr->name);
    } else {
	/* wait for any of our own spawned processes */
	/* we call waitpid rather than wait to avoid running into */
	/* someone else's processes.  Yes, according to Ousterhout */
	/* this is the best way to do it. */

	int waited_on_forked_process = 0;

	esPtr = expWaitOnAny();
	if (!esPtr) {
	    /* if it's not a spawned process, maybe its a forked process */
	    for (fp=forked_proc_base;fp;fp=fp->next) {
		if (fp->link_status == not_in_use) continue;
		restart:
		result = waitpid(fp->pid,(int *)&fp->wait_status,WNOHANG);
		if (result == fp->pid) {
		    waited_on_forked_process = 1;
		    break;
		}
		if (result == 0) continue;	/* busy, try next */
		if (result == -1) {
		    if (errno == EINTR) goto restart;
		    else break;
		}
	    }

	    if (waited_on_forked_process) {
		/*
		 * The literal spawn id in the return value from wait appears
		 * as a -1 to indicate a forked process was waited on.  
		 */
		strcpy(spawn_id,"-1");
	    } else {
		result = NO_CHILD;	/* no children */
		Tcl_ReapDetachedProcs();
	    }
	    exp_rearm_sigchld(interp);
	}
    }

    /*  sigh, wedge forked_proc into an ExpState structure so we don't
     *  have to rewrite remaining code (too much)
     */
    if (fp) {
	esPtr = &esTmp;
	esPtr->pid = fp->pid;
	esPtr->wait = fp->wait_status;
    }

    /* non-portable assumption that pid_t can be printed with %d */

    if (result == -1) {
	Tcl_Obj* d = Tcl_NewListObj (0,NULL);

	Tcl_ListObjAppendElement (interp, d, Tcl_NewIntObj    (esPtr->pid));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (spawn_id, -1));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewIntObj    (-1));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewIntObj    (errno));
	Tcl_ListObjAppendElement (interp, d, LITERAL ("POSIX"));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (Tcl_ErrnoId(),-1));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (Tcl_ErrnoMsg(errno),-1));

	Tcl_SetObjResult (interp, d);
	result = TCL_OK;
    } else if (result == NO_CHILD) {
	exp_error(interp,"no children");
	return TCL_ERROR;
    } else {
	Tcl_Obj* d = Tcl_NewListObj (0,NULL);
	Tcl_ListObjAppendElement (interp, d, Tcl_NewIntObj    (esPtr->pid));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (spawn_id,-1));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewIntObj    (0));
	Tcl_ListObjAppendElement (interp, d, Tcl_NewIntObj    (WEXITSTATUS(esPtr->wait)));

	if (WIFSIGNALED(esPtr->wait)) {
	    Tcl_ListObjAppendElement (interp, d, LITERAL ("CHILDKILLED"));
	    Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (Tcl_SignalId ((int) (WTERMSIG(esPtr->wait))),-1));
	    Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (Tcl_SignalMsg((int) (WTERMSIG(esPtr->wait))),-1));
	} else if (WIFSTOPPED(esPtr->wait)) {
	    Tcl_ListObjAppendElement (interp, d, LITERAL ("CHILDSUSP"));
	    Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (Tcl_SignalId ((int) (WSTOPSIG(esPtr->wait))),-1));
	    Tcl_ListObjAppendElement (interp, d, Tcl_NewStringObj (Tcl_SignalMsg((int) (WSTOPSIG(esPtr->wait))),-1));
	}

	Tcl_SetObjResult (interp, d);
    }
			
    if (fp) {
	fp->link_status = not_in_use;
	return ((result == -1)?TCL_ERROR:TCL_OK);		
    }

    esPtr->sys_waited = TRUE;
    esPtr->user_waited = TRUE;

    /* if user has already called close, forget about this entry entirely */
    if (!esPtr->open) {
	if (esPtr->registered) {
	    Tcl_UnregisterChannel(interp,esPtr->channel);
	}
    }

    return ((result == -1)?TCL_ERROR:TCL_OK);

    usage:
    exp_error(interp,"usage: -i spawn_id");
    return(TCL_ERROR);
}

/*ARGSUSED*/
static int
Exp_ForkObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int rc;
    if (objc > 1) {
	exp_error(interp,"usage: fork");
	return(TCL_ERROR);
    }

    rc = fork();
    if (rc == -1) {
	exp_error(interp,"fork: %s",Tcl_PosixError(interp));
	return TCL_ERROR;
    } else if (rc == 0) {
	/* child */
	exp_forked = TRUE;
	exp_getpid = getpid();
	fork_clear_all();
    } else {
	/* parent */
	fork_add(rc);
    }

    /* both child and parent follow remainder of code */
    Tcl_SetObjResult (interp, Tcl_NewIntObj (rc));
    expDiagLog("fork: returns {%s}\r\n",Tcl_GetStringResult(interp));
    return(TCL_OK);
}

/*ARGSUSED*/
static int
Exp_DisconnectObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    
#ifdef TIOCNOTTY
    /* tell CenterLine to ignore non-use of ttyfd */
    /*SUPPRESS 591*/
    int ttyfd;
#endif /* TIOCNOTTY */

    if (objc > 1) {
	exp_error(interp,"usage: disconnect");
	return(TCL_ERROR);
    }

    if (exp_disconnected) {
	exp_error(interp,"already disconnected");
	return(TCL_ERROR);
    }
    if (!exp_forked) {
	exp_error(interp,"can only disconnect child process");
	return(TCL_ERROR);
    }
    exp_disconnected = TRUE;

    /* ignore hangup signals generated by testing ptys in getptymaster */
    /* and other places */
    signal(SIGHUP,SIG_IGN);

    /* reopen prevents confusion between send/expect_user */
    /* accidentally mapping to a real spawned process after a disconnect */

    /* if we're in a child that's about to be disconnected from the
       controlling tty, close and reopen 0, 1, and 2 but associated
       with /dev/null.  This prevents send and expect_user doing
       special things if newly spawned processes accidentally
       get allocated 0, 1, and 2.
    */
	   
    if (isatty(0)) {
	ExpState *stdinout = tsdPtr->stdinout;
	if (stdinout->valid) {
	    exp_close(interp,stdinout);
	    if (stdinout->registered) {
		Tcl_UnregisterChannel(interp,stdinout->channel);
	    }
	}
	open("/dev/null",0);
	open("/dev/null",1);
	/* tsdPtr->stdinout = expCreateChannel(interp,0,1,EXP_NOPID);*/
	/* tsdPtr->stdinout->keepForever = 1;*/
    }
    if (isatty(2)) {
	ExpState *devtty = tsdPtr->devtty;
	
	/* reopen stderr saves error checking in error/log routines. */
	if (devtty->valid) {
	    exp_close(interp,devtty);
	    if (devtty->registered) {
		Tcl_UnregisterChannel(interp,devtty->channel);
	    }
	}
	open("/dev/null",1);
	/* tsdPtr->devtty = expCreateChannel(interp,2,2,EXP_NOPID);*/
	/* tsdPtr->devtty->keepForever = 1;*/
    }

    Tcl_UnsetVar(interp,"tty_spawn_id",TCL_GLOBAL_ONLY);

#ifdef DO_SETSID
    setsid();
#else
#ifdef SYSV3
    /* put process in our own pgrp, and lose controlling terminal */
#ifdef sysV88
    /* With setpgrp first, child ends up with closed stdio */
    /* according to Dave Schmitt <daves@@techmpc.csg.gss.mot.com> */
    if (fork()) exit(0);
    expSetpgrp();
#else
    expSetpgrp();
    /*signal(SIGHUP,SIG_IGN); moved out to above */
    if (fork()) exit(0);	/* first child exits (as per Stevens, */
    /* UNIX Network Programming, p. 79-80) */
    /* second child process continues as daemon */
#endif
#else /* !SYSV3 */
    expSetpgrp();

/* Pyramid lacks this defn */
#ifdef TIOCNOTTY
    ttyfd = open("/dev/tty", O_RDWR);
    if (ttyfd >= 0) {
	/* zap controlling terminal if we had one */
	(void) ioctl(ttyfd, TIOCNOTTY, (char *)0);
	(void) close(ttyfd);
    }
#endif /* TIOCNOTTY */

#endif /* SYSV3 */
#endif /* DO_SETSID */
    return(TCL_OK);
}

/*ARGSUSED*/
static int
Exp_OverlayObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int newfd, oldfd;
    int dash_name = 0;
    char *command;
    int k, j;
    char **argv;

    int i;

    for (i=1;i<objc;i++) {
	char *name;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	} else if (streq (name,"-")) {	/* - by itself */
	    dash_name = 1;
	    continue;
	}

	if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &newfd)) {
	    return TCL_ERROR;
	}
	newfd = - newfd; /* Negation rids us of the effect the '-' prefix had. */

	i ++;
	if (i >= objc) {
	    exp_error(interp,"overlay -# requires additional argument");
	    return(TCL_ERROR);
	}
	if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &oldfd)) {
	    return TCL_ERROR;
	}

	expDiagLog("overlay: mapping fd %d to %d\r\n",oldfd,newfd);
	if (oldfd != newfd) (void) dup2(oldfd,newfd);
	else expDiagLog("warning: overlay: old fd == new fd (%d)\r\n",oldfd);
    }

    if (i >= objc) {
	exp_error(interp,"need program name");
	return(TCL_ERROR);
    }

    /* convert to string array for execvp.
     * Take only the arguments after the command name (i+1 ...). The arguments
     * before are arguments of overlay, not of the invoked command. The
     * command name is at index.
     */

    argv = (char**) ckalloc ((objc+1)*sizeof(char*));

    for (k=i+1,j=1;k<objc;k++,j++) {
	argv[j] = ckalloc (1+strlen(Tcl_GetString (objv[k])));
	strcpy (argv[j],Tcl_GetString (objv[k]));
    }
    argv[j] = NULL;

    /* command, handle '-' */
    command = Tcl_GetString (objv[i]);
    argv[0] = ckalloc (2+strlen(command));
    if (dash_name) {
	argv [0][0] = '-';
	strcpy (argv[0]+1,command);
    } else {
	strcpy (argv[0],command);
    }

    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);

    (void) execvp(command,argv);

    for (k=0;k<objc;k++) {
	ckfree (argv[k]);
    }
    ckfree ((char*)argv);

    exp_error(interp,"execvp(%s): %s\r\n",
	    Tcl_GetString(objv[0]),
	    Tcl_PosixError(interp));
    return(TCL_ERROR);
}

/*ARGSUSED*/
int
Exp_InterpreterObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    Tcl_Obj *eofObj = 0;
    int i;
    int index;
    int rc;

    static char *options[] = {
	"-eof", (char *)0
    };
    enum options {
	FLAG_EOF
    };

    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case FLAG_EOF:
		i++;
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-eof cmd");
		    return TCL_ERROR;
		}
		eofObj = objv[i];
		Tcl_IncrRefCount(eofObj);
		break;
	}
    }

    /* errors and ok, are caught by exp_interpreter() and discarded */
    /* to return TCL_OK, type "return" */
    rc = exp_interpreter(interp,eofObj);
    if (eofObj) {
	Tcl_DecrRefCount(eofObj);
    }
    return rc;
}

/* this command supercede's Tcl's builtin CONTINUE command */
/*ARGSUSED*/
int
Exp_ExpContinueObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    if (objc == 1) {
	return EXP_CONTINUE;
    } else if ((objc == 2) &&
	    (0 == strcmp(Tcl_GetString (objv[1]),"-continue_timer"))) {
	return EXP_CONTINUE_TIMER;
    }

    exp_error(interp,"usage: exp_continue [-continue_timer]\n");
    return(TCL_ERROR);
}

/* most of this is directly from Tcl's definition for return */
/*ARGSUSED*/
int
Exp_InterReturnObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])
{
    /* let Tcl's return command worry about args */
    /* if successful (i.e., TCL_RETURN is returned) */
    /* modify the result, so that we will handle it specially */

    Tcl_CmdInfo* return_info = (Tcl_CmdInfo*)
	Tcl_GetAssocData (interp, EXP_CMDINFO_RETURN, NULL);

    int result = return_info->objProc(return_info->objClientData,interp,objc,objv);
    if (result == TCL_RETURN)
        result = EXP_TCL_RETURN;
    return result;
}

/*ARGSUSED*/
int
Exp_OpenObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    ExpState *esPtr;
    char *chanName = 0;
    int newfd;
    int leaveopen = FALSE;
    Tcl_Channel channel;

    static char* options[] = {
	"-i",
	"-leaveopen",
	NULL
    };
    enum options {
	OPEN_ID,
	OPEN_LEAVEOPEN
    };
    int i;

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			&index) != TCL_OK) {
	    goto usage;
	}
	switch ((enum options) index) {
	    case OPEN_ID:
		i++;
		if (i >= objc) goto usage;
		chanName = Tcl_GetString (objv[i]);
		break;
	    case OPEN_LEAVEOPEN:
		leaveopen = TRUE;
		break;
	}
    }

    if (!chanName) {
	esPtr = expStateCurrent(interp,1,0,0);
    } else {
	esPtr = expStateFromChannelName(interp,chanName,1,0,0,"exp_open");
    }
    if (!esPtr) return TCL_ERROR;

    /* make a new copy of file descriptor */
    if (-1 == (newfd = dup(esPtr->fdin))) {
	exp_error(interp,"dup: %s",Tcl_PosixError(interp));
	return TCL_ERROR;
    }

    if (!leaveopen) {
	/* remove from Expect's memory in anticipation of passing to Tcl */
	if (esPtr->pid != EXP_NOPID) {
	    Tcl_Pid pid = (Tcl_Pid)(long)esPtr->pid;
	    Tcl_DetachPids(1,&pid);
	    esPtr->pid = EXP_NOPID;
	    esPtr->sys_waited = esPtr->user_waited = TRUE;
	}
	exp_close(interp,esPtr);
    }

    /*
     * Tcl's MakeFileChannel only allows us to pass a single file descriptor
     * but that shouldn't be a problem in practice since all of the channels
     * that Expect generates only have one fd.  Of course, this code won't
     * work if someone creates a pipeline, then passes it to spawn, and then
     * again to exp_open.  For that to work, Tcl would need a new API.
     * Oh, and we're also being rather cavalier with the permissions here,
     * but they're likely to be right for the same reasons.
     */
    channel = Tcl_MakeFileChannel((ClientData)(long)newfd,TCL_READABLE|TCL_WRITABLE);
    Tcl_RegisterChannel(interp, channel);
    Tcl_AppendResult(interp, Tcl_GetChannelName(channel), (char *) NULL);
    return TCL_OK;

    usage:
    exp_error(interp,"usage: -i spawn_id");
    return TCL_ERROR;
}

/* return 1 if a string is substring of a flag */
/* this version is the code used by the macro that everyone calls */
int
exp_flageq_code(
    char *flag,
    char *string,
    int minlen)		/* at least this many chars must match */
{
    for (;*flag;flag++,string++,minlen--) {
	if (*string == '\0') break;
	if (*string != *flag) return 0;
    }
    if (*string == '\0' && minlen <= 0) return 1;
    return 0;
}

void
exp_create_commands(interp,c)
    Tcl_Interp *interp;
    struct exp_cmd_data *c;
{
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
    Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
    char cmdnamebuf[80];

    for (;c->name;c++) {
	/* if already defined, don't redefine */
	if ((c->flags & EXP_REDEFINE) ||
		!(Tcl_FindHashEntry(&globalNsPtr->cmdTable,c->name) ||
			Tcl_FindHashEntry(&currNsPtr->cmdTable,c->name))) {
	    if (c->objproc)
		Tcl_CreateObjCommand(interp,c->name,
			c->objproc,c->data,exp_deleteObjProc);
	    else
		Tcl_CreateCommand(interp,c->name,c->proc,
			c->data,exp_deleteProc);
	}
	if (!(c->name[0] == 'e' &&
			c->name[1] == 'x' &&
			c->name[2] == 'p')
		&& !(c->flags & EXP_NOPREFIX)) {
	    sprintf(cmdnamebuf,"exp_%s",c->name);
	    if (c->objproc)
		Tcl_CreateObjCommand(interp,cmdnamebuf,c->objproc,c->data,
			exp_deleteObjProc);
	    else
		Tcl_CreateCommand(interp,cmdnamebuf,c->proc,
			c->data,exp_deleteProc);
	}
    }
}

static struct exp_cmd_data cmd_data[]  = {
    {"close",	     Exp_CloseObjCmd,	0,	(ClientData)0,	EXP_REDEFINE},
#ifdef TCL_DEBUGGER
    {"debug",	     Exp_DebugObjCmd,       0,	(ClientData)0,	0},
#endif
    {"exp_internal", Exp_ExpInternalObjCmd, 0,	(ClientData)0,	0},
    {"disconnect",   Exp_DisconnectObjCmd,  0,	(ClientData)0,	0},
    {"exit",	     Exp_ExitObjCmd,        0,	(ClientData)0,	EXP_REDEFINE},
    {"exp_continue", Exp_ExpContinueObjCmd, 0,	(ClientData)0,	0},
    {"fork",	     Exp_ForkObjCmd,        0,	(ClientData)0,	0},
    {"exp_pid",	     Exp_ExpPidObjCmd,      0,	(ClientData)0,	0},
    {"getpid",	     Exp_GetpidDeprecatedObjCmd, 0,	(ClientData)0,	0},
    {"interpreter",  Exp_InterpreterObjCmd, 0,	(ClientData)0,	0},
    {"log_file",     Exp_LogFileObjCmd,     0,	(ClientData)0,	0},
    {"log_user",     Exp_LogUserObjCmd,     0,	(ClientData)0,	0},
    {"exp_open",     Exp_OpenObjCmd,        0,	(ClientData)0,	0},
    {"overlay",	     Exp_OverlayObjCmd,     0,	(ClientData)0,	0},
    {"inter_return", Exp_InterReturnObjCmd, 0,	(ClientData)0,	0},
    {"send",	     Exp_SendObjCmd,	    0,	(ClientData)&sendCD_proc,0},
    {"send_error",   Exp_SendObjCmd,	    0,	(ClientData)&sendCD_error,0},
    {"send_log",     Exp_SendLogObjCmd,     0,	(ClientData)0,	0},
    {"send_tty",     Exp_SendObjCmd,	    0,	(ClientData)&sendCD_tty,0},
    {"send_user",    Exp_SendObjCmd,	    0,	(ClientData)&sendCD_user,0},
    {"sleep",	     Exp_SleepObjCmd,       0,	(ClientData)0,	0},
    {"spawn",	     Exp_SpawnObjCmd,       0,	(ClientData)0,	0},
    {"strace",	     Exp_StraceObjCmd,      0,	(ClientData)0,	0},
    {"wait",	     Exp_WaitObjCmd,        0,	(ClientData)0,	0},
    {"exp_configure",Exp_ConfigureObjCmd,   0,	(ClientData)0,	0},
    {0}};

void
exp_init_most_cmds(Tcl_Interp *interp)
{
    exp_create_commands(interp,cmd_data);

#ifdef HAVE_PTYTRAP
    Tcl_InitHashTable(&slaveNames,TCL_STRING_KEYS);
#endif /* HAVE_PTYTRAP */
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.66
log
@ANSIfication changes
@
text
@d62 3
a64 2

#include <varargs.h>
d309 2
a310 1
static void
d428 1
a428 1
expStdinoutGet(void)
d436 1
a436 1
expDevttyGet(void)
d535 3
a537 2
static void
expSetpgrp(void)
d1588 1
a1588 1
exp_init_unit_random(void)
d1649 1
a1649 1
exp_new_i(void)
d2809 1
a2809 1
fork_clear_all(void)
d2868 1
a2868 1
    char *chanName = NULL;
d2870 2
a2871 2
    struct forked_proc *fp = NULL;	/* handle to a pure forked proc */
    struct ExpState esTmp;		/* temporary memory for either f or fp */
d3506 3
a3508 1
exp_create_commands(Tcl_Interp *interp, struct exp_cmd_data *c)
d3580 1
a3580 1

@


5.65
log
@ANSIfication changes.
@
text
@d62 2
a63 3
/*#include <varargs.h>		tclInt.h drags in varargs.h.  Since Pyramid */
/*				objects to including varargs.h twice, just */
/*				omit this one. */
@


5.64
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d309 1
a309 2
static
void
d427 1
a427 1
expStdinoutGet()
d435 1
a435 1
expDevttyGet()
d534 2
a535 3
static
void
expSetpgrp()
d1586 1
a1586 1
exp_init_unit_random()
d1647 1
a1647 1
exp_new_i()
d2807 1
a2807 1
fork_clear_all()
d2866 1
a2866 1
    char *chanName = 0;
d2868 2
a2869 2
    struct forked_proc *fp = 0;	/* handle to a pure forked proc */
    struct ExpState esTmp;	/* temporary memory for either f or fp */
d3504 1
a3504 3
exp_create_commands(interp,c)
    Tcl_Interp *interp;
    struct exp_cmd_data *c;
@


5.63
log
@
 See last ChangeLog entry: Ditto for the same
 type of bug when emitting error 'usage: -ignore unknown signal
 name'. The remainder of the exp_error calls are ok however.
@
text
@d3580 1
a3580 1

@


5.62
log
@
	* exp_command.c (Exp_SpawnObjCmd): [Expect SF Bug 2891422]. Fixed
	  error message when the command to spawn could not be executed.
	  Tried to use a Tcl_Obj* as argument for a %s. Replaced with the
	  correct char* variable. Thanks to Elchonon Edelson
	  <eee@@users.sourceforge.net> for the report.

	* configure.in: Bumped version to 5.44.1.15.
	* configure: Regen'd, autoconf 2.59.
@
text
@d731 1
a731 1
		    exp_error(interp,"usage: -ignore %s: unknown signal name",objv[i]);
@


5.61
log
@
	* exp_command.c (Exp_LogFileObjCmd): Fix argument parsing logic
	  error in the log_file command breaking the use of options -open
	  and -leaveopen. Applied patch supplied by Andy Belsey
	  <Andrew.Belsey@@Sun.COM>. With thanks for both the analysis of
	  the problem and the patch.

	* configure.in: Bumped version to 5.44.1.14.
	* configure: Regen'd, autoconf 2.59.
@
text
@d1098 1
a1098 1
			objv[0],Tcl_PosixError(interp));
@


5.60
log
@More fixes in that area. Use second index for destination array, avoid complex index calculations to derive from index in objv.
@
text
@d2240 1
a2240 1
    } else if (objc > 1) {
@


5.59
log
@Fixed indexing error left over from command correction. Was still using
overlay arguments for the execvp'd command.
@
text
@d3228 1
a3228 1
    int k;
d3276 3
a3278 3
    for (k=i+1;k<objc;k++) {
	argv[k] = ckalloc (1+strlen(Tcl_GetString (objv[k])));
	strcpy (argv[k],Tcl_GetString (objv[k]));
d3280 1
a3280 1
    argv[objc] = NULL;
@


5.58
log
@
	* configure.in: Bumped version to 5.44.1.11.
	* configure: Regen'd, autoconf 2.59.

	* exp_command.c (Exp_OverlayObjCmd): Fixed [Expect SF Bug 2127456]
	  reported by <eee@@users.sourceforge.net>, with thanks. Changed
	  retrieval of command from objv[0] (== 'overlay' itself), to
	  objv[i] containing the actual user command.

	* expect.c (string_case_first, string_first, eval_case_string):
	  Applied patch supplied by Andy Belsey <Andrew.Belsey@@Sun.COM>
	  fixing the seg.fault in 'expect -exact'. With thanks for both
	  the analysis of the problem and the patch. See also [Expect SF
	  Bug 2114547].
@
text
@d3268 5
a3272 1
    /* convert to string array for execvp */
d3276 1
a3276 1
    for (k=1;k<objc;k++) {
@


5.57
log
@
	* configure.in: Bumped version to 5.44.1.7.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* exp_command.c: Fixed more compiler warnings, and started
	* exp_command.h: to ansify the code base, beginning with
	* exp_inter.c: the introduction of proper function prototypes.
	* exp_main_exp.c:
	* exp_pty.h:
	* exp_tty.c:
	* exp_tty.h:
	* exp_win.c:
	* expect.c:
	* pty_termios.c:
	* retoglob.c:
@
text
@d3279 2
a3280 1
    argv[0] = ckalloc (2+strlen(Tcl_GetString (objv[0])));
d3283 1
a3283 1
	strcpy (argv[0]+1,Tcl_GetString (objv[0]));
d3285 1
a3285 1
	strcpy (argv[0],Tcl_GetString (objv[0]));
a3286 1
    command = Tcl_GetString (objv[0]);
@


5.56
log
@
	* configure.in: Bumped version to 5.44.1.6.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* configure.in: Fixed checking of stty on linux, do not restrict
	  to specific cpu's. Further try with stdin, and stdin redirected
	  to /dev/tty when determining if stdout is read.

	* testsuite/configure.in: Brought up to TEA 3.5.
	* testsuite/aclocal.m4: New file, to import the TEA definitions.

	* Dbg.c: Added missed CONST in declaration and definition of
	  'debugger_trap'.

	* exp_command.c: Fixed pointer aliasing trouble with
	  'Tcl_DetachPids', and added the missing initialization of the
	  command string in the 'overlay' command.

	* expect.c: Fixed missing initialization of 'simple_start' element
	  of 'ecase'.

	* exp_inter.c: Fixed bogus use of 'slen' in 'intMatch'. The
	  relevant string is Tcl_Unichar, not Utf.

	* Makefile.in: Replaced bogus INSTALL_ROOT with DESTDIR, and added
	  missing DESTDIR references to the target for the installation of
	  the manpages.
@
text
@a31 1
#include "exp_tty.h"
d68 1
d76 1
d90 2
a91 2
int exp_getptymaster();
int exp_getptyslave();
d155 1
a155 2
init_traps(traps)
    RETSIGTYPE (*traps[])();
d186 5
a190 5
expStateCurrent(interp,opened,adjust,any)
    Tcl_Interp *interp;
    int opened;
    int adjust;
    int any;
d201 6
a206 6
expStateCheck(interp,esPtr,open,adjust,msg)
    Tcl_Interp *interp;
    ExpState *esPtr;
    int open;
    int adjust;
    char *msg;
d217 7
a223 6
expStateFromChannelName(interp,name,open,adjust,any,msg)
    Tcl_Interp *interp;
    char *name;
    int open;
    int adjust;
    char *msg;
d252 1
a252 2
exp_wait_zero(status)
WAIT_STATUS_TYPE *status;
d263 3
a265 3
exp_state_prep_for_invalidation(interp,esPtr)
Tcl_Interp *interp;
ExpState *esPtr;
d278 1
a278 2
exp_trap_on(master)
int master;
d287 1
a287 2
exp_trap_off(name)
char *name;
d311 1
a311 2
expBusy(esPtr)
     ExpState *esPtr;
d323 3
a325 3
exp_close(interp,esPtr)
    Tcl_Interp *interp;
    ExpState *esPtr;
d404 1
a404 2
expStateAnyIs(esPtr)
    ExpState *esPtr;
d412 1
a412 2
expDevttyIs(esPtr)
    ExpState *esPtr;
d420 1
a420 2
expStdinoutIs(esPtr)
    ExpState *esPtr;
d444 1
a444 2
exp_init_spawn_id_vars(interp)
    Tcl_Interp *interp;
d463 1
a463 2
exp_init_spawn_ids(interp)
    Tcl_Interp *interp;
d499 1
a499 2
expCloseOnExec(fd)
    int fd;
d510 3
a512 3
show_pgrp(fd,string)
    int fd;
    char *string;
d526 1
a526 2
set_pgrp(fd)
    int fd;
d555 3
a557 3
set_slave_name(esPtr,name)
    ExpState *esPtr;
    char *name;
d575 5
a579 5
Exp_SpawnObjCmd(clientData,interp,objc,objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d903 1
a903 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_READABLE, (ClientData *) &rfdc)) {
d906 1
a906 1
	    rfd = (int) rfdc;
d909 1
a909 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_WRITABLE, (ClientData *) &wfdc)) {
d912 1
a912 1
	    wfd = (int) wfdc;
d1339 1
a1339 1
    (void) execvp(command,argv);
d1370 5
a1374 5
Exp_ExpPidObjCmd(clientData,interp,objc,objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d1420 5
a1424 5
Exp_GetpidDeprecatedObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d1433 5
a1437 5
Exp_SleepObjCmd(clientData,interp,objc,objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d1464 3
a1466 3
get_slow_args(interp,x)
    Tcl_Interp *interp;
    struct slow_arg *x;
d1491 6
a1496 6
slow_write(interp,esPtr,buffer,rembytes,arg) /* INTL */
    Tcl_Interp *interp;
    ExpState *esPtr;
    char *buffer;
    int rembytes;
    struct slow_arg *arg;
d1535 3
a1537 3
get_human_args(interp,x)
    Tcl_Interp *interp;
    struct human_arg *x;
d1599 5
a1603 5
human_write(interp,esPtr,buffer,arg) /* INTL */
    Tcl_Interp *interp;
    ExpState *esPtr;
    char *buffer;
    struct human_arg *arg;
d1677 1
a1677 2
exp_new_state(esPtr)
    ExpState *esPtr;
d1702 1
a1702 2
exp_free_state(fd_first)
    struct exp_state_list *fd_first;
d1721 1
a1721 2
exp_free_state_single(fd)
    struct exp_state_list *fd;
d1728 4
a1731 4
exp_free_i(interp,i,updateproc)
    Tcl_Interp *interp;
    struct exp_i *i;
    Tcl_VarTraceProc *updateproc; /* proc to invoke if indirect is written */
d1771 4
a1774 4
exp_new_i_complex(interp,arg,duration,updateproc)
    Tcl_Interp *interp;
    char *arg;		/* spawn id list or a variable containing a list */
    int duration;		/* if we have to copy the args */
d1776 1
a1776 1
    Tcl_VarTraceProc *updateproc;	/* proc to invoke if indirect is written */
d1819 3
a1821 3
exp_i_add_state(i,esPtr)
    struct exp_i *i;
    ExpState *esPtr;
d1834 3
a1836 3
exp_i_parse_states(interp,i) /* INTL */
    Tcl_Interp *interp;
    struct exp_i *i;
d1863 3
a1865 3
exp_i_update(interp,i)
    Tcl_Interp *interp;
    struct exp_i *i;
d1897 3
a1899 3
exp_new_i_simple(esPtr,duration)
    ExpState *esPtr;
    int duration;		/* if we have to copy the args */
d1916 5
a1920 5
Exp_SendLogObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d1960 5
a1964 5
Exp_SendObjCmd(clientData, interp, objc, objv) /* INTL */
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];
d2158 5
a2162 5
Exp_LogFileObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2291 5
a2295 5
Exp_LogUserObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2323 5
a2327 5
Exp_DebugObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2393 5
a2397 5
Exp_ExpInternalObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2473 5
a2477 5
Exp_ExitObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2524 1
d2529 5
a2533 5
Exp_ConfigureObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d2538 1
a2538 1
    static CONST char* options [] = {
d2570 5
a2574 5
Exp_CloseObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d2681 8
a2688 8
tcl_tracer(clientData,interp,level,command,cmdInfo,objc,objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int level;
    CONST char *command;
    Tcl_Command cmdInfo;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2701 1
a2701 2
tcl_tracer_del(clientData)
    ClientData clientData;
d2708 5
a2712 5
Exp_StraceObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2819 3
a2821 3
fork_init(f,pid)
    struct forked_proc *f;
    int pid;
d2829 1
a2829 2
fork_add(pid)
    int pid;
d2862 5
a2866 5
Exp_WaitObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2929 1
a2929 1
		Tcl_Pid pid = (Tcl_Pid)esPtr->pid;
d3075 5
a3079 5
Exp_ForkObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d3109 5
a3113 5
Exp_DisconnectObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d3219 5
a3223 5
Exp_OverlayObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d3306 5
a3310 5
Exp_InterpreterObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d3354 5
a3358 5
Exp_ExpContinueObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d3374 5
a3378 5
Exp_InterReturnObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];
d3395 5
a3399 5
Exp_OpenObjCmd(clientData, interp, objc, objv)
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d3458 1
a3458 1
	    Tcl_Pid pid = (Tcl_Pid)esPtr->pid;
d3475 1
a3475 1
    channel = Tcl_MakeFileChannel((ClientData)newfd,TCL_READABLE|TCL_WRITABLE);
d3488 4
a3491 4
exp_flageq_code(flag,string,minlen)
    char *flag;
    char *string;
    int minlen;		/* at least this many chars must match */
d3568 1
a3568 2
exp_init_most_cmds(interp)
    Tcl_Interp *interp;
@


5.55
log
@(Exp_SendObjCmd): fix -- handling to expect last argument
@
text
@d2943 1
d2949 1
a2949 1
		Tcl_DetachPids(1,(Tcl_Pid *)&esPtr->pid);
d3300 1
d3472 2
a3473 1
	    Tcl_DetachPids(1,(Tcl_Pid *)&esPtr->pid);
@


5.54
log
@whitespace police
@
text
@d2069 1
a2073 1
	getString:
@


5.53
log
@(Exp_SendLogObjCmd): fix -- handling
@
text
@d155 1
a155 1
RETSIGTYPE (*traps[])();
d157 1
a157 1
	int i;
d159 3
a161 3
	for (i=1;i<NSIG;i++) {
		traps[i] = SIG_ERR;
	}
d172 10
a181 10
	Tcl_Interp *interp;
	char *fmt;
	va_list args;
	char buffer[2000];

	interp = TCL_VARARGS_START(Tcl_Interp *,arg1,args);
	fmt = va_arg(args,char *);
	vsprintf(buffer,fmt,args);
	Tcl_SetResult(interp,buffer,TCL_VOLATILE);
	va_end(args);
d187 4
a190 4
Tcl_Interp *interp;
int opened;
int adjust;
int any;
d254 1
a254 1
	int i;
d256 3
a258 3
	for (i=0;i<sizeof(WAIT_STATUS_TYPE);i++) {
		((char *)status)[i] = 0;
	}
d282 2
a283 2
	if (master == -1) return;
	exp_slave_control(master,1);
d302 1
a302 1
    
d315 8
a322 8
{     
  int x = open("/dev/null",0);
  if (x != esPtr->fdin) {
    fcntl(x,F_DUPFD,esPtr->fdin);
    close(x);
  }
  expCloseOnExec(esPtr->fdin);
  esPtr->fdBusy = TRUE;
d327 2
a328 2
Tcl_Interp *interp;
ExpState *esPtr;
d371 1
a371 1
	      Tcl_VarEval(interp,"close ", cName, (char *)0);
d379 1
a379 1
	
d397 1
a397 1
      expBusy(esPtr);
d426 1
a426 1
ExpState *esPtr;
d451 1
a451 1
Tcl_Interp *interp;
d508 1
a508 1
int fd;
d510 1
a510 1
     (void) fcntl(fd,F_SETFD,1);
d520 2
a521 2
int fd;
char *string;
d523 1
a523 1
	int pgrp;
d525 7
a531 7
	fprintf(stderr,"getting pgrp for %s\n",string);
	if (-1 == ioctl(fd,TIOCGETPGRP,&pgrp)) perror("TIOCGETPGRP");
	else fprintf(stderr,"%s pgrp = %d\n",string,pgrp);
	if (-1 == ioctl(fd,TIOCGPGRP,&pgrp)) perror("TIOCGPGRP");
	else fprintf(stderr,"%s pgrp = %d\n",string,pgrp);
	if (-1 == tcgetpgrp(fd,pgrp)) perror("tcgetpgrp");
	else fprintf(stderr,"%s pgrp = %d\n",string,pgrp);
d536 1
a536 1
int fd;
d538 4
a541 4
	int pgrp = getpgrp(0);
	if (-1 == ioctl(fd,TIOCSETPGRP,&pgrp)) perror("TIOCSETPGRP");
	if (-1 == ioctl(fd,TIOCSPGRP,&pgrp)) perror("TIOCSPGRP");
	if (-1 == tcsetpgrp(fd,pgrp)) perror("tcsetpgrp");
d566 2
a567 2
ExpState *esPtr;
char *name;
d570 2
a571 2
	int newptr;
	Tcl_HashEntry *entry;
d573 3
a575 3
	/* save slave name */
	esPtr->slave_name = ckalloc(strlen(exp_pty_slave_name)+1);
	strcpy(esPtr->slave_name,exp_pty_slave_name);
d577 2
a578 2
	entry = Tcl_CreateHashEntry(&slaveNames,exp_pty_slave_name,&newptr);
	Tcl_SetHashValue(entry,(ClientData)esPtr);
d586 4
a589 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d611 4
a614 4
				/* Allow user to reset signals in child */
				/* The following array contains indicates */
				/* whether sig should be DFL or IGN */
				/* ERR is used to indicate no initialization */
d627 1
a627 1
		/* by default, slave will be write-ioctled this many times */
d629 4
a632 4
		/* by default, slave will be opened this many times */
		/* first comes from initial allocation */
		/* second comes from stty */
		/* third is our own signal that stty is done */
d694 1
a694 1
				&index) != TCL_OK) {
d698 47
a744 22
	case SPAWN_NOTTYINIT:
	    ttyinit = FALSE;
	    slave_write_ioctls--;
	    slave_opens--;
	    break;
	case SPAWN_NOTTYCOPY:
	    ttycopy = FALSE;
	    break;
	case SPAWN_NOECHO:
	    echo = FALSE;
	    break;
	case SPAWN_CONSOLE:
	    console = TRUE;
	    break;
	case SPAWN_PTY:
	    pty_only = TRUE;
	    break;
	case SPAWN_OPEN:
	    i ++;
	    if (i >= objc) {
		exp_error(interp,"usage: -open file-identifier");
		return TCL_ERROR;
d746 1
a746 26
	    chanName = Tcl_GetString (objv[i]);
	    break;
	case SPAWN_LEAVEOPEN:
	    i ++;
	    if (i >= objc) {
		exp_error(interp,"usage: -open file-identifier");
		return TCL_ERROR;
	    }
	    chanName = Tcl_GetString (objv[i]);
	    leaveopen = TRUE;
	    break;
	case SPAWN_IGNORE: {
	    int sig;
	    i ++;
	    if (i >= objc) {
		exp_error(interp,"usage: -ignore signal");
		return TCL_ERROR;
	    }
	    sig = exp_string_to_signal(interp,Tcl_GetString (objv[i]));
	    if (sig == -1) {
		exp_error(interp,"usage: -ignore %s: unknown signal name",objv[i]);
		return TCL_ERROR;
	    }
	    ignore[sig] = TRUE;
	}
	    break;
d748 16
a763 21
	case SPAWN_TRAP: {
	    /* objv[i+1] is list of signals */
	    /* objv[i+2] is action */

	    static char* actions [] = {
		"SIG_DFL", "SIG_IGN", NULL
	    };
	    enum actions {
		ACTION_SIGDFL, ACTION_SIGIGN;
	    }
	    int theaction;

	    int j;
	    RETSIGTYPE (*sig_handler)();
	    int       lc;	/* number of signals in list */
	    Tcl_Obj** lv;	/* list of signals */
	    
	    if ((objc - i) < 3) {
		exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		return TCL_ERROR;
	    }
d765 4
a768 1
	    /* Check and process action */
d770 1
a770 13
	    if (Tcl_GetIndexFromObj(interp, objv[i+2], actions, "action", 0,
				    &theaction) != TCL_OK) {
		exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		return TCL_ERROR;
	    }
	    switch ((enum actions) theaction) {
	    case ACTION_SIGDFL:
		sig_handler = SIG_DFL;
		break;
	    case ACTION_SIGIGN:
		sig_handler = SIG_IGN;
		break;
	    }
d772 13
a784 1
	    /* Check and process list of signals */
d786 1
a786 6
	    if (TCL_OK != Tcl_ListObjGetElements (inter, objv[i+1], &lc, &lv)) {
		expErrorLogU(Tcl_GetStringResult(interp));
		expErrorLogU("\r\n");
		exp_error(interp,"usage: -trap {siglist} ...");
		return TCL_ERROR;
	    }
d788 4
a791 3
	    for (j=0;j<lc;j++) {
		int sig = exp_string_to_signal(interp,Tcl_GetString (lv[j]));
		if (sig == -1) {
d794 10
a803 1
		traps[sig] = sig_handler;
d805 1
a805 4

	    i += 2;
    }
	    break;
d832 1
a832 1
when trapping, see below in child half of fork */
d839 1
a839 1
    
d860 1
a860 1
		
d892 1
a892 1
	  write_master = master;
d898 1
a898 2
	int mode;
	int rfd, wfd;
d900 1
a900 1
	
d948 1
a948 1
	
d951 1
a951 1
	    
d993 1
a993 1
		    stty_init))) {
d999 1
a999 1
	    
d1041 3
a1043 3
	    close(sync_fds[1]);
	    close(sync2_fds[0]);
	    close(status_pipe[1]);
d1045 1
a1045 1
	    esPtr = expCreateChannel(interp,master,master,pid);
d1047 1
a1047 1
	    if (exp_pty_slave_name) set_slave_name(esPtr,exp_pty_slave_name);
d1050 1
a1050 1
	    setptypid(pid);
d1053 15
a1067 15
	    /*
	     * wait for slave to initialize pty before allowing
	     * user to send to it
	     */ 

	    expDiagLog("parent: waiting for sync byte\r\n");
	    while (((rc = read(sync_fds[0],&sync_byte,1)) < 0) && (errno == EINTR)) {
		/* empty */;
	    }
	    if (rc == -1) {
		expErrorLogU("parent: sync byte read: ");
		expErrorLogU(Tcl_ErrnoMsg(errno));
		expErrorLogU("\r\n");
		exit(-1);
	    }
d1069 2
a1070 2
	    /* turn on detection of eof */
	    exp_slave_control(master,1);
d1072 1
a1072 1
	    /*
d1074 1
a1074 1
	     */
d1076 6
a1081 6
	    expDiagLog("parent: telling child to go ahead\r\n");
	    wc = write(sync2_fds[1]," ",1);
	    if (wc == -1) {
		expErrorLog("parent: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
		exit(-1);
	    }
d1083 3
a1085 3
	    expDiagLog("parent: now unsynchronized from child\r\n");
	    close(sync_fds[0]);
	    close(sync2_fds[1]);
d1087 1
a1087 1
	    /* see if child's exec worked */
d1089 23
a1111 23
	    switch (read(status_pipe[0],&child_errno,sizeof child_errno)) {
		case -1:
		    if (errno == EINTR) goto retry;
		    /* well it's not really the child's errno */
		    /* but it can be treated that way */
		    child_errno = errno;
		    break;
		case 0:
		    /* child's exec succeeded */
		    child_errno = 0;
		    break;
		default:
	      /* child's exec failed; child_errno contains exec's errno */
	      close(status_pipe[0]);
		    waitpid(pid, NULL, 0);
		    /* in order to get Tcl to set errorcode, we must */
		    /* hand set errno */
		    errno = child_errno;
		    exp_error(interp, "couldn't execute \"%s\": %s",
		      objv[0],Tcl_PosixError(interp));
		    goto parent_error;
	    }
	    close(status_pipe[0]);
d1113 2
a1114 2
	    /* tell user of new spawn id */
	    Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);
d1119 3
a1121 3
	    Tcl_DStringFree(&dstring);
	    return(TCL_OK);
	}
d1123 1
a1123 1
	/* child process - do not return from here!  all errors must exit() */
d1125 4
a1128 4
	close(sync_fds[0]);
	close(sync2_fds[1]);
	close(status_pipe[0]);
	expCloseOnExec(status_pipe[1]);
d1130 4
a1133 4
	if (exp_dev_tty != -1) {
		close(exp_dev_tty);
		exp_dev_tty = -1;
	}
d1136 1
a1136 1
	(void) close(master);
d1149 1
a1149 1
	setsid();
d1153 1
a1153 1
	expSetpgrp();
d1156 1
a1156 1
	expSetpgrp();
d1160 5
a1164 5
	ttyfd = open("/dev/tty", O_RDWR);
	if (ttyfd >= 0) {
		(void) ioctl(ttyfd, TIOCNOTTY, (char *)0);
		(void) close(ttyfd);
	}
d1170 2
a1171 2
	/* save stderr elsewhere to avoid BSD4.4 bogosity that warns */
	/* if stty finds dev(stderr) != dev(stdout) */
d1173 3
a1175 3
	/* save error fd while we're setting up new one */
	errorfd = fcntl(2,F_DUPFD,3);
	/* and here is the macro to restore it */
d1178 25
a1202 25
	close(0);
	close(1);
	close(2);

	/* since we closed fd 0, open of pty slave must return fd 0 */

	/* since exp_getptyslave may have to run stty, (some of which work on fd */
	/* 0 and some of which work on 1) do the dup's inside exp_getptyslave. */

	if (0 > (slave = exp_getptyslave(ttycopy,ttyinit,stty_init))) {
		restore_error_fd

		if (exp_pty_error) {
			expErrorLog("open(slave pty): %s\r\n",exp_pty_error);
		} else {
			expErrorLog("open(slave pty): %s\r\n",Tcl_ErrnoMsg(errno));
		}
		exit(-1);
	}
	/* sanity check */
	if (slave != 0) {
		restore_error_fd
		expErrorLog("exp_getptyslave: slave = %d but expected 0\n",slave);
		exit(-1);
	}
d1210 4
a1213 4
	/* 4.3+BSD way to acquire controlling terminal */
	/* according to Stevens - Adv. Prog..., p 642 */
	/* Oops, it appears that the CIBAUD is on Linux also */
	/* so let's try without... */
d1215 5
a1219 5
	if (tcsetct(0, getpid()) == -1) {
	  restore_error_fd
	  expErrorLog("failed to get controlling terminal using TIOCSCTTY");
	  exit(-1);
	}
d1221 8
a1228 8
	(void) ioctl(0,TIOCSCTTY,(char *)0);
	/* ignore return value - on some systems, it is defined but it
	 * fails and it doesn't seem to cause any problems.  Or maybe
	 * it works but returns a bogus code.  Noone seems to be able
	 * to explain this to me.  The systems are an assortment of
	 * different linux systems (and FreeBSD 2.5), RedHat 5.2 and
	 * Debian 2.0
	 */
d1233 13
a1245 13
 	(void) setsid();
 	(void) ioctl(0,TCSETCTTY,0);
 	(void) close(0);
 	if (open("/dev/tty", O_RDWR) < 0) {
		restore_error_fd
 		expErrorLog("open(/dev/tty): %s\r\n",Tcl_ErrnoMsg(errno));
 		exit(-1);
 	}
 	(void) close(1);
 	(void) close(2);
 	(void) dup(0);
 	(void) dup(0);
	setptyutmp();	/* create a utmp entry */
d1247 1
a1247 1
	/* _CRAY2 code from Hal Peterson <hrp@@cray.com>, Cray Research, Inc. */
d1249 37
a1285 37
	/*
	 * Interpose a process between expect and the spawned child to
	 * keep the slave side of the pty open to allow time for expect
	 * to read the last output.  This is a workaround for an apparent
	 * bug in the Unicos pty driver on Cray-2's under Unicos 6.0 (at
	 * least).
	 */
	if ((pid = fork()) == -1) {
		restore_error_fd
		expErrorLog("second fork: %s\r\n",Tcl_ErrnoMsg(errno));
		exit(-1);
	}

	if (pid) {
 		/* Intermediate process. */
		int status;
		int timeout;
		char *t;

		/* How long should we wait? */
		if (t = exp_get_var(interp,"pty_timeout"))
			timeout = atoi(t);
		else if (t = exp_get_var(interp,"timeout"))
			timeout = atoi(t)/2;
		else
			timeout = 5;

		/* Let the spawned process run to completion. */
 		while (wait(&status) < 0 && errno == EINTR)
			/* empty body */;

		/* Wait for the pty to clear. */
		sleep(timeout);

		/* Duplicate the spawned process's status. */
		if (WIFSIGNALED(status))
			kill(getpid(), WTERMSIG(status));
d1287 3
a1289 3
		/* The kill may not have worked, but this will. */
 		exit(WEXITSTATUS(status));
	}
d1293 1
a1293 1
	if (console) exp_console_set();
d1296 3
a1298 4
	for (i=1;i<NSIG;i++) {
		if (traps[i] != SIG_ERR) {
			signal(i,traps[i]);
		}
d1300 1
d1303 3
a1305 3
	for (i=1;i<NSIG;i++) {
		signal(i,ignore[i]?SIG_IGN:SIG_DFL);
	}
d1307 5
a1311 5
	/*
	 * avoid fflush of cmdfile, logfile, & diagfile since this screws up
	 * the parents seek ptr.  There is no portable way to fclose a shared
	 * read-stream!!!!
	 */
d1313 2
a1314 2
	/* (possibly multiple) masters are closed automatically due to */
	/* earlier fcntl(,,CLOSE_ON_EXEC); */
d1316 2
a1317 2
	/* tell parent that we are done setting up pty */
	/* The actual char sent back is irrelevant. */
d1319 8
a1326 8
	/* expDiagLog("child: telling parent that pty is initialized\r\n");*/
	wc = write(sync_fds[1]," ",1);
	if (wc == -1) {
		restore_error_fd
		expErrorLog("child: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
		exit(-1);
	}
	close(sync_fds[1]);
d1328 4
a1331 4
	/* wait for master to let us go on */
	while (((rc = read(sync2_fds[0],&sync_byte,1)) < 0) && (errno == EINTR)) {
		/* empty */;
	}
d1333 6
a1338 6
	if (rc == -1) {
		restore_error_fd
		expErrorLog("child: sync byte read: %s\r\n",Tcl_ErrnoMsg(errno));
		exit(-1);
	}
	close(sync2_fds[0]);
d1340 1
a1340 1
	/* expDiagLog("child: now unsynchronized from parent\r\n"); */
d1356 5
a1360 5
	/* Alas, by now we've closed fd's to stderr, logfile and diagfile.
	 * The only reasonable thing to do is to send back the error as part of
	 * the program output.  This will be picked up in an expect or interact
	 * command.
	 */
d1362 5
a1366 5
	/* if exec failed, communicate the reason back to the parent */
	write(status_pipe[1], &errno, sizeof errno);
	exit(-1);
	/*NOTREACHED*/
parent_error:
d1381 4
a1384 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d1402 1
a1402 1
				&index) != TCL_OK) {
d1406 5
a1410 5
	case PID_ID:
	    i++;
	    if (i >= objc) goto usage;
	    chanName = Tcl_GetString (objv[i]);
	    break;
d1420 1
a1420 1
    
d1423 1
a1423 1
  usage:
d1431 4
a1434 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d1436 1
a1436 1
	expDiagLog("getpid is deprecated, use pid\r\n");
d1438 1
a1438 1
	return(TCL_OK);
d1444 4
a1447 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d1452 3
a1454 3
		exp_error(interp,"must have one arg: seconds");
		return TCL_ERROR;
	}
d1475 2
a1476 2
Tcl_Interp *interp;
struct slow_arg *x;
d1478 19
a1496 19
	int sc;		/* return from scanf */
	CONST char *s = exp_get_var(interp,"send_slow");
	if (!s) {
		exp_error(interp,"send -s: send_slow has no value");
		return(-1);
	}
	if (2 != (sc = sscanf(s,"%d %lf",&x->size,&x->time))) {
		exp_error(interp,"send -s: found %d value(s) in send_slow but need 2",sc);
		return(-1);
	}
	if (x->size <= 0) {
		exp_error(interp,"send -s: size (%d) in send_slow must be positive", x->size);
		return(-1);
	}
	if (x->time <= 0) {
		exp_error(interp,"send -s: time (%f) in send_slow must be larger",x->time);
		return(-1);
	}
	return(0);
d1502 29
a1530 32
Tcl_Interp *interp;
ExpState *esPtr;
char *buffer;
int rembytes;
struct slow_arg *arg;
{
	int rc;

	while (rembytes > 0) {
		int bytelen;
		int charlen;
		char *p;
		int i;
		
		p = buffer;
		charlen = (arg->size<rembytes?arg->size:rembytes);

		/* count out the right number of UTF8 chars */
		for (i=0;i<charlen;i++) {
		  p = Tcl_UtfNext(p);
		}
		bytelen = p-buffer;

		if (0 > expWriteChars(esPtr,buffer,bytelen)) return(-1);
		rembytes -= bytelen;
		buffer += bytelen;

		/* skip sleep after last write */
		if (rembytes > 0) {
			rc = exp_dsleep(interp,arg->time);
			if (rc>0) return rc;
		}
d1532 2
a1533 1
	return(0);
d1537 4
a1540 4
	float alpha;		/* average interarrival time in seconds */
	float alpha_eow;	/* as above but for eow transitions */
	float c;		/* shape */
	float min, max;
d1546 2
a1547 2
Tcl_Interp *interp;
struct human_arg *x;
d1549 2
a1550 2
	int sc;		/* return from scanf */
	CONST char *s = exp_get_var(interp,"send_human");
d1552 33
a1584 33
	if (!s) {
		exp_error(interp,"send -h: send_human has no value");
		return(-1);
	}
	if (5 != (sc = sscanf(s,"%f %f %f %f %f",
			&x->alpha,&x->alpha_eow,&x->c,&x->min,&x->max))) {
		if (sc == EOF) sc = 0;	/* make up for overloaded return */
		exp_error(interp,"send -h: found %d value(s) in send_human but need 5",sc);
		return(-1);
	}
	if (x->alpha < 0 || x->alpha_eow < 0) {
		exp_error(interp,"send -h: average interarrival times (%f %f) must be non-negative in send_human", x->alpha,x->alpha_eow);
		return(-1);
	}
	if (x->c <= 0) {
		exp_error(interp,"send -h: variability (%f) in send_human must be positive",x->c);
		return(-1);
	}
	x->c = 1/x->c;

	if (x->min < 0) {
		exp_error(interp,"send -h: minimum (%f) in send_human must be non-negative",x->min);
		return(-1);
	}
	if (x->max < 0) {
		exp_error(interp,"send -h: maximum (%f) in send_human must be non-negative",x->max);
		return(-1);
	}
	if (x->max < x->min) {
		exp_error(interp,"send -h: maximum (%f) must be >= minimum (%f) in send_human",x->max,x->min);
		return(-1);
	}
	return(0);
d1592 3
a1594 3
	/* current implementation is pathetic but works */
	/* 99991 is largest prime in my CRC - can't hurt, eh? */
	return((float)(1+(rand()%99991))/99991.0);
d1600 1
a1600 1
	srand(getpid());
d1610 4
a1613 4
Tcl_Interp *interp;
ExpState *esPtr;
char *buffer;
struct human_arg *arg;
d1640 1
a1640 1
		/* skip sleep before writing first character */
d1661 2
a1662 2
	int n;
	struct exp_i *i;
d1664 6
a1669 8
	if (!exp_i_pool) {
		/* none avail, generate some new ones */
		exp_i_pool = i = (struct exp_i *)ckalloc(
			EXP_I_INIT_COUNT * sizeof(struct exp_i));
		for (n=0;n<EXP_I_INIT_COUNT-1;n++,i++) {
			i->next = i+1;
		}
		i->next = 0;
d1671 2
d1674 1
a1674 1
	/* now that we've made some, unlink one and give to user */
d1676 8
a1683 8
	i = exp_i_pool;
	exp_i_pool = exp_i_pool->next;
	i->value = 0;
	i->variable = 0;
	i->state_list = 0;
	i->ecount = 0;
	i->next = 0;
	return i;
d1688 1
a1688 1
ExpState *esPtr;
d1714 1
a1714 1
struct exp_state_list *fd_first;
d1716 1
a1716 1
	struct exp_state_list *fd, *penultimate;
d1718 1
a1718 1
	if (!fd_first) return;
d1720 2
a1721 2
	/* link entire chain back in at once by first finding last pointer */
	/* making that point back to pool, and then resetting pool to this */
d1723 6
a1728 6
	/* run to end */
	for (fd = fd_first;fd;fd=fd->next) {
		penultimate = fd;
	}
	penultimate->next = exp_state_list_pool;
	exp_state_list_pool = fd_first;
d1734 1
a1734 1
struct exp_state_list *fd;
d1736 2
a1737 2
	fd->next = exp_state_list_pool;
	exp_state_list_pool = fd;
d1742 3
a1744 3
Tcl_Interp *interp;
struct exp_i *i;
Tcl_VarTraceProc *updateproc;	/* proc to invoke if indirect is written */
d1746 1
a1746 1
	if (i->next) exp_free_i(interp,i->next,updateproc);
d1748 1
a1748 1
	exp_free_state(i->state_list);
d1750 25
a1774 26
	if (i->direct == EXP_INDIRECT) {
		Tcl_UntraceVar(interp,i->variable,
			TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
			updateproc,(ClientData)i);
	}

	/* here's the long form
	   if duration & direct	free(var)  free(val)
		PERM	  DIR	    		1
		PERM	  INDIR	    1		1
		TMP	  DIR
		TMP	  INDIR			1
	   Also if i->variable was a bogus variable name, i->value might not be
	   set, so test i->value to protect this
	   TMP in this case does NOT mean from the "expect" command.  Rather
	   it means "an implicit spawn id from any expect or expect_XXX
	   command".  In other words, there was no variable name provided.
	*/
	if (i->value
	   && (((i->direct == EXP_DIRECT) && (i->duration == EXP_PERMANENT))
		|| ((i->direct == EXP_INDIRECT) && (i->duration == EXP_TEMPORARY)))) {
		ckfree(i->value);
	} else if (i->duration == EXP_PERMANENT) {
		if (i->value) ckfree(i->value);
		if (i->variable) ckfree(i->variable);
	}
d1776 2
a1777 2
	i->next = exp_i_pool;
	exp_i_pool = i;
d1785 5
a1789 5
Tcl_Interp *interp;
char *arg;		/* spawn id list or a variable containing a list */
int duration;		/* if we have to copy the args */
			/* should only need do this in expect_before/after */
Tcl_VarTraceProc *updateproc;	/* proc to invoke if indirect is written */
d1791 2
a1792 2
	struct exp_i *i;
	char **stringp;
d1794 1
a1794 1
	i = exp_new_i();
d1796 1
a1796 1
	i->direct = (isExpChannelName(arg) || (0 == strcmp(arg, EXP_SPAWN_ID_ANY_LIT))?EXP_DIRECT:EXP_INDIRECT);
d1798 1
a1798 1
	i->direct = (isdigit(arg[0]) || (arg[0] == '-'))?EXP_DIRECT:EXP_INDIRECT;
d1800 5
a1804 5
	if (i->direct == EXP_DIRECT) {
		stringp = &i->value;
	} else {
		stringp = &i->variable;
	}
d1806 7
a1812 7
	i->duration = duration;
	if (duration == EXP_PERMANENT) {
		*stringp = ckalloc(strlen(arg)+1);
		strcpy(*stringp,arg);
	} else {
		*stringp = arg;
	}
d1814 5
a1818 5
	i->state_list = 0;
	if (TCL_ERROR == exp_i_update(interp,i)) {
	  exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
	  return 0;
	}
d1820 1
a1820 1
	/* if indirect, ask Tcl to tell us when variable is modified */
d1822 5
a1826 5
	if (i->direct == EXP_INDIRECT) {
		Tcl_TraceVar(interp, i->variable,
			TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
			updateproc, (ClientData) i);
	}
d1828 1
a1828 1
	return i;
d1833 2
a1834 2
struct exp_i *i;
ExpState *esPtr;
d1836 1
a1836 1
	struct exp_state_list *new_state;
d1838 3
a1840 3
	new_state = exp_new_state(esPtr);
	new_state->next = i->state_list;
	i->state_list = new_state;
d1848 2
a1849 2
Tcl_Interp *interp;
struct exp_i *i;
d1866 1
a1866 1
error:
d1871 1
a1871 1
	
d1877 2
a1878 2
Tcl_Interp *interp;
struct exp_i *i;
d1880 12
a1891 1
  char *p;	/* string representation of list of spawn ids */
d1893 12
a1904 13
  if (i->direct == EXP_INDIRECT) {
    p = Tcl_GetVar(interp,i->variable,TCL_GLOBAL_ONLY);
    if (!p) {
      p = "";
      /* *really* big variable names could blow up expDiagLog! */
      expDiagLog("warning: indirect variable %s undefined",i->variable);
    }
    
    if (i->value) {
      if (streq(p,i->value)) return TCL_OK;
      
      /* replace new value with old */
      ckfree(i->value);
d1906 1
a1906 11
    i->value = ckalloc(strlen(p)+1);
    strcpy(i->value,p);

    exp_free_state(i->state_list);
    i->state_list = 0;
  } else {
    /* no free, because this should only be called on */
    /* "direct" i's once */
    i->state_list = 0;
  }
  return exp_i_parse_states(interp, i);
d1911 3
a1913 3
ExpState *esPtr;
int duration;		/* if we have to copy the args */
			/* should only need do this in expect_before/after */
d1915 1
a1915 1
	struct exp_i *i;
d1917 1
a1917 1
	i = exp_new_i();
d1919 2
a1920 2
	i->direct = EXP_DIRECT;
	i->duration = duration;
d1922 1
a1922 1
	exp_i_add_state(i,esPtr);
d1924 1
a1924 1
	return i;
d1930 4
a1933 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d1962 1
a1962 1
 usage:
d1974 4
a1977 4
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];
d2018 1
a2018 1
		&index) != TCL_OK) {
d2073 1
a2073 1
getString:
d2082 5
a2086 5
      esPtr = tsdPtr->devtty;
      if (!esPtr) {
	exp_error(interp,"send_tty: cannot send to controlling terminal in an environment when there is no controlling terminal to send to!");
	return TCL_ERROR;
      }
d2103 2
a2104 2
#define send_to_user	((clientData == &sendCD_user) || \
			 (clientData == &sendCD_tty))
d2143 1
a2143 1
		  rc = expWriteChars(esPtr,NULL_STRING,NULL_LENGTH);
d2164 1
a2164 1
 finish:
d2174 2
a2175 2
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2210 1
a2210 1
				&index) != TCL_OK) {
d2214 16
a2229 14
	case LOGFILE_A:
	    logAll = TRUE;
	    break;
	case LOGFILE_INFO:
	    resultbuf[0] = '\0';
	    if (expLogChannelGet()) {
		/* FUTURE: Use List-ops to construct a proper Tcl_Obj */
		if (expLogAllGet()) strcat(resultbuf,"-a ");
		if (!expLogAppendGet()) strcat(resultbuf,"-noappend ");
		if (expLogFilenameGet()) {
		    strcat(resultbuf,expLogFilenameGet());
		} else {
		    if (expLogLeaveOpenGet()) {
			strcat(resultbuf,"-leaveopen ");
d2231 1
a2231 1
		    strcat(resultbuf,Tcl_GetChannelName(expLogChannelGet()));
d2233 15
a2247 17
		Tcl_SetResult(interp,resultbuf,TCL_STATIC);
	    }
	    return TCL_OK;
	case LOGFILE_LEAVEOPEN:
	    i ++;
	    if (i >= objc) goto usage_error;
	    chanName = Tcl_GetString (objv[i]);
	    leaveOpen = TRUE;
	    break;
	case LOGFILE_NOAPPEND:
	    append = FALSE;
	    break;
	case LOGFILE_OPEN:
	    i++;
	    if (i >= objc) goto usage_error;
	    chanName = Tcl_GetString (objv[i]);
	    break;
d2268 1
a2268 1
		   (0 == strcmp(chanName,Tcl_GetChannelName(expLogChannelGet())))) {
d2297 1
a2297 1
 usage_error:
d2305 4
a2308 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2337 4
a2340 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2365 1
a2365 1
				&index) != TCL_OK) {
d2369 3
a2371 3
	case DEBUG_NOW:
	    now = TRUE;
	    break;
d2388 6
a2393 6
	Dbg_Off(interp);
	exp_tcl_debugger_available = 0;
    } else {
	Dbg_On(interp,now);
	exp_tcl_debugger_available = 1;
    }
d2397 1
a2397 1
 usage:
d2407 4
a2410 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2436 1
a2436 1
				&index) != TCL_OK) {
d2440 21
a2460 18
	case INTERNAL_INFO:
	    /* FUTURE: Construct a proper list Tcl_Obj here */
	    /* Should check that there are no arguments coming after -info */

	resultbuf[0] = '\0';
	oldChannel = expDiagChannelGet();
	if (oldChannel) {
	    sprintf(resultbuf,"-f %s ",expDiagFilename());
	}
	strcat(resultbuf,expDiagToStderrGet()?"1":"0");
	Tcl_SetResult(interp,resultbuf,TCL_STATIC);
	return TCL_OK;
	case INTERNAL_F:
	    i ++;
	    if (i >= objc) goto usage;
	expDiagChannelClose(interp);
	    if (TCL_OK != expDiagChannelOpen(interp,Tcl_GetString (objv[i]))) {
	    return TCL_ERROR;
a2461 3
	newChannel = TRUE;
	    break;
    }
d2477 1
a2477 1
 usage:
d2487 4
a2490 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2492 1
a2492 1
	int value = 0;
d2505 2
a2506 2
				if (exp_onexit_action)
					ckfree(exp_onexit_action);
d2508 1
a2508 1
				exp_onexit_action = ckalloc(len + 1);
d2511 4
a2514 4
			} else if (exp_onexit_action) {
				Tcl_AppendResult(interp,exp_onexit_action,(char *)0);
			}
			return TCL_OK;
d2518 2
a2519 3
			exp_exit_handlers((ClientData)interp);
			return TCL_OK;
		}
d2521 1
d2525 1
a2525 2
			return TCL_ERROR;
		}
d2527 1
d2529 8
a2536 8
	/*
	 * Restore previous definition of close.  Needed when expect is
	 * dynamically loaded after close has been redefined
	 * e.g.  the virtual file system in tclkit
	 */
	Tcl_Eval(interp, "rename _close.pre_expect close");
	Tcl_Exit(value);
	/*NOTREACHED*/
d2542 4
a2545 4
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];	/* Argument objects. */
d2547 2
a2548 2
  /* Magic configuration stuff. */
  int i, opt, val;
d2550 6
a2555 6
  static CONST char* options [] = {
    "-strictwrite", NULL
  };
  enum options {
    EXP_STRICTWRITE
  };
d2557 4
a2560 4
  if ((objc < 3) || (objc % 2 == 0)) {
    Tcl_WrongNumArgs (interp, 1, objv, "-strictwrite value");
    return TCL_ERROR;
  }
d2562 13
a2574 12
  for (i=1; i < objc; i+=2) {
    if (Tcl_GetIndexFromObj (interp, objv [i], options, "option",
			     0, &opt) != TCL_OK) {
      return TCL_ERROR;
    }
    switch (opt) {
    case EXP_STRICTWRITE:
      if (Tcl_GetBooleanFromObj (interp, objv [i+1], &val) != TCL_OK) {
	return TCL_ERROR;
      }
      exp_strict_write = val;
      break;
a2575 1
  }
d2577 1
a2577 1
  return TCL_OK;
d2583 4
a2586 4
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];	/* Argument objects. */
d2616 1
a2616 1
				&index) != TCL_OK) {
d2620 23
a2642 23
	case CLOSE_ID:
	    i++;
	    if (i == objc) {
		exp_error(interp,"usage: -i spawn_id");
		return(TCL_ERROR);
	    }
	    chanName = Tcl_GetString(objv[i]);
	    break;
	case CLOSE_ONEXEC:
	    i++;
	    if (i == objc) {
	    on_exec_usage:
		exp_error(interp,"usage: -onexec 0|1");
		return(TCL_ERROR);
	    }
	    onexec_flag = TRUE;
	    if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[i], &close_onexec)) {
		goto on_exec_usage;
	    }
	    break;
	case CLOSE_SLAVE:
	    slave_flag = TRUE;
	    break;
d2694 13
a2706 13
ClientData clientData;
Tcl_Interp *interp;
int level;
     CONST char *command;
     Tcl_Command cmdInfo;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
	int i;

	/* come out on stderr, by using expErrorLog */
	expErrorLog("%2d",level);
	for (i = 0;i<level;i++) expErrorLogU("  ");
d2708 1
a2708 1
	expErrorLogU("\r\n");
d2714 1
a2714 1
     ClientData clientData;
d2722 4
a2725 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2727 2
a2728 2
	static int trace_level = 0;
	static Tcl_Trace trace_handle;
d2732 2
a2733 2
		return TCL_OK;
	}
d2736 5
a2740 5
		exp_error(interp,"usage: trace level");
		return(TCL_ERROR);
	}
	/* tracing already in effect, undo it */
	if (trace_level > 0) Tcl_DeleteTrace(interp,trace_handle);
d2742 1
a2742 1
	/* get and save new trace level */
d2748 1
a2748 1
	if (trace_level > 0)
d2750 3
a2752 3
					  tcl_tracer,(ClientData)0,
					  tcl_tracer_del);
	return(TCL_OK);
d2807 1
a2807 1
This allows us to wait on them later.
d2809 3
a2811 3
This is maintained as a linked list.  As additional procs are forked,
new links are added.  As procs disappear, links are marked so that we
can reuse them later.
d2815 4
a2818 4
	int pid;
	WAIT_STATUS_TYPE wait_status;
	enum {not_in_use, wait_done, wait_not_done} link_status;
	struct forked_proc *next;
d2824 1
a2824 1
	struct forked_proc *f;
d2826 3
a2828 3
	for (f=forked_proc_base;f;f=f->next) {
		f->link_status = not_in_use;
	}
d2833 2
a2834 2
struct forked_proc *f;
int pid;
d2836 2
a2837 2
	f->pid = pid;
	f->link_status = wait_not_done;
d2843 1
a2843 1
int pid;
d2845 1
a2845 1
	struct forked_proc *f;
d2847 3
a2849 3
	for (f=forked_proc_base;f;f=f->next) {
		if (f->link_status == not_in_use) break;
	}
d2851 7
a2857 7
	/* add new entry to the front of the list */
	if (!f) {
		f = (struct forked_proc *)ckalloc(sizeof(struct forked_proc));
		f->next = forked_proc_base;
		forked_proc_base = f;
	}
	fork_init(f,pid);
d2866 1
a2866 1
 If wait fails, something seriously has gone wrong, for example:
d2870 1
a2870 1
 If wait succeeeds, something happened on a particular pid
d2877 4
a2880 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2913 1
a2913 1
	    }
d2915 1
a2915 1
				&index) != TCL_OK) {
d2919 8
a2926 8
	case WAIT_ID:
	    i++;
	    if (i >= objc) goto usage;
	    chanName = Tcl_GetString (objv[i]);
	    break;
	case WAIT_NOWAIT:
	    nowait = TRUE;
	    break;
d2990 1
a2990 1
	restart:
d3074 3
a3076 3
      if (esPtr->registered) {
	Tcl_UnregisterChannel(interp,esPtr->channel);
      }
d3081 1
a3081 1
 usage:
d3089 4
a3092 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3094 1
a3094 1
	int rc;
d3096 3
a3098 3
		exp_error(interp,"usage: fork");
		return(TCL_ERROR);
	}
d3100 13
a3112 13
	rc = fork();
	if (rc == -1) {
		exp_error(interp,"fork: %s",Tcl_PosixError(interp));
		return TCL_ERROR;
	} else if (rc == 0) {
		/* child */
		exp_forked = TRUE;
		exp_getpid = getpid();
		fork_clear_all();
	} else {
		/* parent */
		fork_add(rc);
	}
d3114 1
a3114 1
	/* both child and parent follow remainder of code */
d3117 1
a3117 1
	return(TCL_OK);
d3123 4
a3126 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3177 1
a3177 1
	}
d3233 4
a3236 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3238 3
a3240 3
	int newfd, oldfd;
	int dash_name = 0;
	char *command;
d3253 3
a3255 3
			dash_name = 1;
			continue;
		}
d3264 3
a3266 3
			exp_error(interp,"overlay -# requires additional argument");
			return(TCL_ERROR);
		}
d3271 4
a3274 4
		expDiagLog("overlay: mapping fd %d to %d\r\n",oldfd,newfd);
		if (oldfd != newfd) (void) dup2(oldfd,newfd);
		else expDiagLog("warning: overlay: old fd == new fd (%d)\r\n",oldfd);
	}
d3277 3
a3279 3
		exp_error(interp,"need program name");
		return(TCL_ERROR);
	}
d3293 1
a3293 1
	if (dash_name) {
d3298 1
a3298 1
	}
d3300 2
a3301 2
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
d3303 1
a3303 1
        (void) execvp(command,argv);
d3311 3
a3313 3
	      Tcl_GetString(objv[0]),
	      Tcl_PosixError(interp));
	return(TCL_ERROR);
d3319 4
a3322 4
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d3338 1
a3338 1
				&index) != TCL_OK) {
d3342 9
a3350 9
	case FLAG_EOF:
	    i++;
	    if (i >= objc) {
		Tcl_WrongNumArgs(interp, 1, objv,"-eof cmd");
		return TCL_ERROR;
	    }
	    eofObj = objv[i];
	    Tcl_IncrRefCount(eofObj);
	    break;
d3367 4
a3370 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3375 1
a3375 1
	       (0 == strcmp(Tcl_GetString (objv[1]),"-continue_timer"))) {
d3387 4
a3390 4
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];
d3396 2
a3397 1
    Tcl_CmdInfo* return_info = (Tcl_CmdInfo*) Tcl_GetAssocData (interp, EXP_CMDINFO_RETURN, NULL);
d3408 4
a3411 4
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3439 1
a3439 1
				&index) != TCL_OK) {
d3441 1
a3441 1
	    }
d3443 8
a3450 8
	case OPEN_ID:
	    i++;
	    if (i >= objc) goto usage;
	    chanName = Tcl_GetString (objv[i]);
	    break;
	case OPEN_LEAVEOPEN:
	    leaveopen = TRUE;
	    break;
d3491 1
a3491 1
 usage:
d3500 10
a3509 10
char *flag;
char *string;
int minlen;		/* at least this many chars must match */
{
	for (;*flag;flag++,string++,minlen--) {
		if (*string == '\0') break;
		if (*string != *flag) return 0;
	}
	if (*string == '\0' && minlen <= 0) return 1;
	return 0;
d3514 2
a3515 2
Tcl_Interp *interp;
struct exp_cmd_data *c;
d3517 27
a3543 28
	Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
	Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
	char cmdnamebuf[80];

	for (;c->name;c++) {
		/* if already defined, don't redefine */
		if ((c->flags & EXP_REDEFINE) ||
		    !(Tcl_FindHashEntry(&globalNsPtr->cmdTable,c->name) ||
		      Tcl_FindHashEntry(&currNsPtr->cmdTable,c->name))) {
			if (c->objproc)
				Tcl_CreateObjCommand(interp,c->name,
						     c->objproc,c->data,exp_deleteObjProc);
			else
				Tcl_CreateCommand(interp,c->name,c->proc,
						  c->data,exp_deleteProc);
		}
		if (!(c->name[0] == 'e' &&
		      c->name[1] == 'x' &&
		      c->name[2] == 'p')
		    && !(c->flags & EXP_NOPREFIX)) {
			sprintf(cmdnamebuf,"exp_%s",c->name);
			if (c->objproc)
				Tcl_CreateObjCommand(interp,cmdnamebuf,c->objproc,c->data,
						     exp_deleteObjProc);
			else
				Tcl_CreateCommand(interp,cmdnamebuf,c->proc,
						  c->data,exp_deleteProc);
		}
d3545 1
d3566 2
a3567 2
{"send",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_proc,0},
{"send_error",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_error,0},
d3569 2
a3570 2
{"send_tty",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_tty,0},
{"send_user",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_user,0},
d3576 1
a3576 1
{0}};
d3580 1
a3580 1
Tcl_Interp *interp;
@


5.52
log
@
	* Dbg.c: Converted the lot of argc,argv based command
	* exp_command.c: implementations over to objc,objv.
	* expect.c:
	* exp_main_sub.c:
@
text
@d1950 1
a1950 1
		}
d1952 1
a1952 1
				&index) != TCL_OK) {
d1955 1
a1955 2
	switch ((enum options) index) {
	case LOG_QUOTE:
d1959 1
a1959 1
	}
d1961 1
a1961 1
    if (i >= objc) goto usage;
d1964 1
a1964 1
	return(TCL_OK);
@


5.51
log
@
	* Dbg.c: Cleaned up the direct access to interp->result,
	* exp_command.c: replaced with the proper functions and
	* expect.c: Tcl_Obj's.
	* exp_main_exp.c:
	* exp_main_sub.c:
	* exp_main_tk.c:
	* exp_prog.h:
	* exp_trap.c:
	* exp_tty.c:
	* exp_win.c:
	* exp_win.h:
@
text
@d585 1
a585 1
Exp_SpawnCmd(clientData,interp,argc,argv)
d588 2
a589 2
int argc;
char **argv;
d594 1
a594 1
    char **a;
d597 2
d601 1
a601 2
    int ttyfd;
    int master;
d608 1
d621 1
a621 1
    char *argv0 = argv[0];
d639 31
d683 1
a683 1
    argc--; argv++;
d685 14
a698 2
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-nottyinit")) {
d702 2
a703 1
	} else if (streq(*argv,"-nottycopy")) {
d705 2
a706 1
	} else if (streq(*argv,"-noecho")) {
d708 2
a709 1
	} else if (streq(*argv,"-console")) {
d711 2
a712 1
	} else if (streq(*argv,"-pty")) {
d714 4
a717 2
	} else if (streq(*argv,"-open")) {
	    if (argc < 2) {
d721 5
a725 4
	    chanName = argv[1];
	    argc--; argv++;
	} else if (streq(*argv,"-leaveopen")) {
	    if (argc < 2) {
d729 1
a729 1
	    chanName = argv[1];
d731 2
a732 2
	    argc--; argv++;
	} else if (streq(*argv,"-ignore")) {
d734 2
a735 2

	    if (argc < 2) {
d739 1
a739 1
	    sig = exp_string_to_signal(interp,argv[1]);
d741 1
a741 1
		exp_error(interp,"usage: -ignore %s: unknown signal name",argv[1]);
d745 2
a746 1
	    argc--; argv++;
d748 11
a758 3
	} else if (streq(*argv,"-trap")) {
	    /* argv[1] is action */
	    /* argv[2] is list of signals */
d760 1
d762 2
a763 2
	    int n;		/* number of signals in list */
	    char **list;	/* list of signals */
d765 1
a765 1
	    if (argc < 3) {
d770 9
a778 1
	    if (0 == strcmp(argv[2],"SIG_DFL")) {
d780 2
a781 1
	    } else if (0 == strcmp(argv[2],"SIG_IGN")) {
d783 1
a783 3
	    } else {
		exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		return TCL_ERROR;
d786 4
a789 2
	    if (TCL_OK != Tcl_SplitList(interp,argv[1],&n,&list)) {
		expErrorLogU(interp->result);
d794 3
a796 2
	    for (i=0;i<n;i++) {
		int sig = exp_string_to_signal(interp,list[i]);
a797 1
		    ckfree((char *)&list);
a801 1
	    ckfree((char *)&list);
d803 5
a807 4
	    argc--; argv++;
	    argc--; argv++;
#endif /*FULLTRAPS*/
	} else break;
d810 3
a812 1
    if (chanName && (argc != 0)) {
d817 1
a817 1
    if (!pty_only && !chanName && (argc == 0)) {
d822 3
d844 1
d846 1
a846 1
	    for (a = argv;*a;a++) {
d848 1
a848 1
		expStdoutLogU(*a,0);
d1004 2
a1005 2
	sprintf(interp->result,"%d",EXP_NOPID);
	expDiagLog("spawn: returns {%s}\r\n",interp->result);
d1010 2
a1011 1
    if (NULL == (argv[0] = Tcl_TranslateFileName(interp,argv[0],&dstring))) {
d1109 1
a1109 1
			    argv[0],Tcl_PosixError(interp));
d1343 13
a1355 1
        (void) execvp(argv[0],argv);
d1381 1
a1381 1
Exp_ExpPidCmd(clientData,interp,argc,argv)
d1384 2
a1385 2
int argc;
char **argv;
d1390 3
a1392 1
    argc--; argv++;
d1394 19
a1412 6
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) goto usage;
	    chanName = *argv;
	} else goto usage;
d1416 1
a1416 1
	if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"exp_pid"))) return TCL_ERROR;
d1418 1
a1418 1
	if (!(esPtr = expStateCurrent(interp,0,0,0))) return TCL_ERROR;
d1420 1
d1422 1
a1422 1
    sprintf(interp->result,"%d",esPtr->pid);
d1431 1
a1431 1
Exp_GetpidDeprecatedCmd(clientData, interp, argc, argv)
d1434 2
a1435 2
int argc;
char **argv;
d1438 1
a1438 1
	sprintf(interp->result,"%d",getpid());
d1444 1
a1444 1
Exp_SleepCmd(clientData,interp,argc,argv)
d1447 2
a1448 2
int argc;
char **argv;
d1450 1
a1450 1
	argc--; argv++;
d1452 1
a1452 1
	if (argc != 1) {
d1457 9
a1465 1
	return(exp_dsleep(interp,(double)atof(*argv)));
d1933 1
a1933 1
Exp_SendLogCmd(clientData, interp, argc, argv)
d1936 2
a1937 2
int argc;
char **argv;
d1939 11
a1949 5
	argv++;
	argc--;
	if (argc) {
		if (streq(*argv,"--")) {
			argc--; argv++;
d1951 9
d1962 1
a1962 4
	if (argc != 1) {
		exp_error(interp,"usage: send [args] string");
		return TCL_ERROR;
	}
d1964 1
a1964 1
	expLogDiagU(*argv);
d1966 4
d2176 1
a2176 1
Exp_LogFileCmd(clientData, interp, argc, argv)
d2179 2
a2180 2
    int argc;
    char **argv;
d2188 17
d2206 14
a2219 13
    argv++;
    argc--;
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-open")) {
	    if (!argv[1]) goto usage_error;
	    chanName = argv[1];
	    argc--; argv++;
	} else if (streq(*argv,"-leaveopen")) {
	    if (!argv[1]) goto usage_error;
	    chanName = argv[1];
	    leaveOpen = TRUE;
	    argc--; argv++;
	} else if (streq(*argv,"-a")) {
d2221 2
a2222 1
	} else if (streq(*argv,"-info")) {
d2225 1
d2239 7
a2245 1
	} else if (streq(*argv,"-noappend")) {
d2247 7
a2253 1
	} else break;
d2256 3
a2258 3
    if (argc == 1) {
	filename = argv[0];
    } else if (argc > 1) {
d2309 1
a2309 1
Exp_LogUserCmd(clientData, interp, argc, argv)
d2312 2
a2313 2
int argc;
char **argv;
d2317 1
a2317 1
    if (argc == 0 || (argc == 2 && streq(argv[1],"-info"))) {
d2319 11
a2329 2
    } else if (argc == 2) {
	expLogUserSet(atoi(argv[1]));
d2334 1
a2334 2
    sprintf(interp->result,"%d",old_loguser);

d2341 1
a2341 1
Exp_DebugCmd(clientData, interp, argc, argv)
d2344 2
a2345 2
int argc;
char **argv;
d2350 3
a2352 1
    if (argc > 3) goto usage;
d2354 4
a2357 2
    if (argc == 1) {
	sprintf(interp->result,"%d",exp_tcl_debugger_available);
d2361 3
a2363 1
    argv++;
d2365 10
a2374 2
    while (*argv) {
	if (streq(*argv,"-now")) {
d2376 1
a2376 1
	    argv++;
a2377 1
	else break;
d2380 1
a2380 1
    if (!*argv) {
d2387 6
a2392 1
    } else if (streq(*argv,"0")) {
d2399 2
a2400 1
    sprintf(interp->result,"%d",exp_tcl_debugger_was_available);
d2411 1
a2411 1
Exp_ExpInternalCmd(clientData, interp, argc, argv)
d2414 2
a2415 2
int argc;
char **argv;
d2420 28
a2448 1
    if ((argc > 1) && streq(argv[1],"-info")) {
d2457 3
a2459 9
    }

    argv++;
    argc--;

    while (argc) {
	if (!streq(*argv,"-f")) break;
	argc--;argv++;
	if (argc < 1) goto usage;
d2461 1
a2461 1
	if (TCL_OK != expDiagChannelOpen(interp,argv[0])) {
d2465 2
a2466 1
	argc--;argv++;
d2469 5
a2473 1
    if (argc != 1) goto usage;
d2479 2
a2480 1
    expDiagToStderrSet(atoi(*argv));
d2491 1
a2491 1
Exp_ExitCmd(clientData, interp, argc, argv)
d2494 2
a2495 2
int argc;
char **argv;
d2499 10
a2508 1
	argv++;
a2509 5
	if (*argv) {
		if (exp_flageq(*argv,"-onexit",3)) {
			argv++;
			if (*argv) {
				int len = strlen(*argv);
d2512 1
d2514 2
a2515 1
				strcpy(exp_onexit_action,*argv);
d2520 3
a2522 2
		} else if (exp_flageq(*argv,"-noexit",3)) {
			argv++;
d2528 2
a2529 2
	if (*argv) {
		if (Tcl_GetInt(interp, *argv, &value) != TCL_OK) {
d2598 1
d2600 11
a2610 2
    int objc_orig = objc;
    Tcl_Obj *CONST *objv_orig = objv;
d2612 3
a2614 1
    objc--; objv++;
d2616 12
a2627 4
    for (;objc>0;objc--,objv++) {
	if (streq("-i",Tcl_GetString(*objv))) {
	    objc--; objv++;
	    if (objc == 0) {
d2631 6
a2636 6
	    chanName = Tcl_GetString(*objv);
	} else if (streq(Tcl_GetString(*objv),"-slave")) {
	    slave_flag = TRUE;
	} else if (streq(Tcl_GetString(*objv),"-onexec")) {
	    objc--; objv++;
	    if (objc == 0) {
d2641 8
a2648 2
	    close_onexec = atoi(Tcl_GetString(*objv));
	} else break;
d2651 1
a2651 1
    if (objc) {
d2662 1
a2662 1
	return(close_info->objProc(close_info->objClientData,interp,objc_orig,objv_orig));
d2666 1
a2666 1
	if (!(esPtr = expStateFromChannelName(interp,chanName,1,0,0,"close"))) return TCL_ERROR;
d2668 1
a2668 1
	if (!(esPtr = expStateCurrent(interp,1,0,0))) return TCL_ERROR;
d2670 1
d2697 2
a2698 2
static void
tcl_tracer(clientData,interp,level,command,cmdProc,cmdClientData,argc,argv)
d2702 4
a2705 5
char *command;
int (*cmdProc)();
ClientData cmdClientData;
int argc;
char *argv[];
d2712 1
a2712 1
	expErrorLogU(command);
d2714 8
d2726 1
a2726 1
Exp_StraceCmd(clientData, interp, argc, argv)
d2729 2
a2730 2
int argc;
char **argv;
d2735 2
a2736 2
	if (argc > 1 && streq(argv[1],"-info")) {
		sprintf(interp->result,"%d",trace_level);
d2740 1
a2740 1
	if (argc != 2) {
d2748 5
a2752 1
	trace_level = atoi(argv[1]);
d2754 3
a2756 2
		trace_handle = Tcl_CreateTrace(interp,
				trace_level,tcl_tracer,(ClientData)0);
d2881 1
a2881 1
Exp_WaitCmd(clientData, interp, argc, argv)
d2884 2
a2885 2
int argc;
char **argv;
a2896 1
#define NO_CHILD -2
d2898 20
a2917 8
    argv++;
    argc--;
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (argc==0) {
		exp_error(interp,"usage: -i spawn_id");
		return(TCL_ERROR);
d2919 11
a2929 2
	    chanName = *argv;
	} else if (streq(*argv,"-nowait")) {
d2931 1
d2936 1
a2936 1
	if (!(esPtr = expStateCurrent(interp,0,0,1))) return TCL_ERROR;
d2938 1
a2938 2
	if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,1,"wait")))
	    return TCL_ERROR;
d2940 1
d3085 4
d3093 1
a3093 1
Exp_ForkCmd(clientData, interp, argc, argv)
d3096 2
a3097 2
int argc;
char **argv;
d3100 1
a3100 1
	if (argc > 1) {
d3120 2
a3121 2
	sprintf(interp->result,"%d",rc);
	expDiagLog("fork: returns {%s}\r\n",interp->result);
d3127 1
a3127 1
Exp_DisconnectCmd(clientData, interp, argc, argv)
d3130 2
a3131 2
int argc;
char **argv;
d3135 1
a3135 1

d3139 1
d3141 1
a3141 1
    if (argc > 1) {
d3237 1
a3237 1
Exp_OverlayCmd(clientData, interp, argc, argv)
d3240 2
a3241 2
int argc;
char **argv;
d3246 4
d3251 7
a3257 5
	argc--; argv++;
	while (argc) {
		if (*argv[0] != '-') break;	/* not a flag */
		if (streq(*argv,"-")) {		/* - by itself */
			argc--; argv++;
d3261 8
a3268 3
		newfd = atoi(argv[0]+1);
		argc--; argv++;
		if (argc == 0) {
d3272 4
a3275 2
		oldfd = atoi(argv[0]);
		argc--; argv++;
d3280 2
a3281 1
	if (argc == 0) {
d3285 13
a3297 1
	command = argv[0];
d3299 4
a3302 2
		argv[0] = ckalloc(1+strlen(command));
		sprintf(argv[0],"-%s",command);
d3307 1
d3309 9
a3317 1
	exp_error(interp,"execvp(%s): %s\r\n",argv[0],Tcl_PosixError(interp));
d3362 3
a3364 1
    if (eofObj) Tcl_DecrRefCount(eofObj);
d3371 1
a3371 1
Exp_ExpContinueCmd(clientData, interp, argc, argv)
d3374 2
a3375 2
int argc;
char **argv;
d3377 1
a3377 1
    if (argc == 1) {
d3379 2
a3380 1
    } else if ((argc == 2) && (0 == strcmp(argv[1],"-continue_timer"))) {
d3411 1
a3411 1
Exp_OpenCmd(clientData, interp, argc, argv)
d3414 2
a3415 2
int argc;
char **argv;
d3423 10
a3432 1
    argc--; argv++;
d3434 11
a3444 6
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) {
		exp_error(interp,"usage: -i spawn_id");
		return TCL_ERROR;
d3446 7
a3452 2
	    chanName = *argv;
	} else if (streq(*argv,"-leaveopen")) {
d3454 2
a3455 2
	    argc--; argv++;
	} else break;
d3459 1
a3459 1
	if (!(esPtr = expStateCurrent(interp,1,0,0))) return TCL_ERROR;
d3461 1
a3461 2
	if (!(esPtr = expStateFromChannelName(interp,chanName,1,0,0,"exp_open")))
return TCL_ERROR;
d3463 1
d3494 4
d3553 1
a3553 1
{"close",	Exp_CloseObjCmd,	0,	0,	EXP_REDEFINE},
d3555 1
a3555 1
{"debug",	exp_proc(Exp_DebugCmd),	0,	0},
d3557 13
a3569 13
{"exp_internal",exp_proc(Exp_ExpInternalCmd),	0,	0},
{"disconnect",	exp_proc(Exp_DisconnectCmd),	0,	0},
{"exit",	exp_proc(Exp_ExitCmd),	0,	EXP_REDEFINE},
{"exp_continue",exp_proc(Exp_ExpContinueCmd),0,	0},
{"fork",	exp_proc(Exp_ForkCmd),	0,	0},
{"exp_pid",	exp_proc(Exp_ExpPidCmd),	0,	0},
{"getpid",	exp_proc(Exp_GetpidDeprecatedCmd),0,	0},
{"interpreter",	Exp_InterpreterObjCmd,	0,	0,	0},
{"log_file",	exp_proc(Exp_LogFileCmd),	0,	0},
{"log_user",	exp_proc(Exp_LogUserCmd),	0,	0},
{"exp_open",	exp_proc(Exp_OpenCmd),	0,	0},
{"overlay",	exp_proc(Exp_OverlayCmd),	0,	0},
{"inter_return",Exp_InterReturnObjCmd,	0,	0,	0},
d3572 1
a3572 1
{"send_log",	exp_proc(Exp_SendLogCmd),	0,	0},
d3575 5
a3579 5
{"sleep",	exp_proc(Exp_SleepCmd),	0,	0},
{"spawn",	exp_proc(Exp_SpawnCmd),	0,	0},
{"strace",	exp_proc(Exp_StraceCmd),	0,	0},
{"wait",	exp_proc(Exp_WaitCmd),	0,	0},
{"exp_configure",Exp_ConfigureObjCmd, 0, 0, 0},
d3592 8
@


5.50
log
@
	* exp_command.c: Reformatted overlong lines, whitespace,
	* expect.c: comments. Added braces to some if-constructs.
	* exp_inter.c: Reworked if-constructs interleaved with
	* exp_tty.c: #if for better formatting in emacs.
@
text
@d1039 2
a1040 2
	    sprintf(interp->result,"%d",pid);
	    expDiagLog("spawn: returns {%s}\r\n",interp->result);
d2751 11
a2761 2
	sprintf(interp->result,"%d %s -1 %d POSIX %s %s",
		esPtr->pid,spawn_id,errno,Tcl_ErrnoId(),Tcl_ErrnoMsg(errno));
d2767 6
a2772 2
	sprintf(interp->result,"%d %s 0 %d",
		esPtr->pid,spawn_id,WEXITSTATUS(esPtr->wait));
d2774 3
a2776 3
	    Tcl_AppendElement(interp,"CHILDKILLED");
	    Tcl_AppendElement(interp,Tcl_SignalId((int)(WTERMSIG(esPtr->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WTERMSIG(esPtr->wait))));
d2778 3
a2780 3
	    Tcl_AppendElement(interp,"CHILDSUSP");
	    Tcl_AppendElement(interp,Tcl_SignalId((int) (WSTOPSIG(esPtr->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WSTOPSIG(esPtr->wait))));
d2782 2
@


5.49
log
@
	* Dbg.c: Added note about unhandled cases in a switch.
	* exp_chan.c: Added code to suppress unhandled warning for
	  unreachable code.
	* exp_command.c: Removed unused variable.
	* expect.c: Removed unused static function, added code to suppress
	  unhandled warning for unreachable code.
@
text
@d2110 2
a2111 1
	} else if (chanName && (0 == strcmp(chanName,Tcl_GetChannelName(expLogChannelGet())))) {
a2316 1

@


5.48
log
@
	* exp_command.c: Fixed typo in comment.
@
text
@a1396 1
	char *p = buffer;
@


5.47
log
@
	* exp_main_sub.c: Added command 'exp_configure' for magic configuration.
	* exp_command.c:  Accepts option -strictwrite. Default is 0, ignoring
	* exp_chan.c:     write errors (compatible to 5.41). Setting to 1 re-
	* expect_tcl.h:   activates 5.42 behaviour.
@
text
@d996 1
a996 1
	     * tell slave to go on now now that we have initialized pty
@


5.46
log
@
	* exp_chan.c:    Fixed bug causing crash of expect on exit when a
	* exp_command.c: Tcl channel is used with -(leave)open more than
	* exp_command.h: once. It tried to close such channels multiple
	  times, going through already freed memory. Added data structures
	  to track and refcount all such channels, to close them only when
	  the last user goes away.
@
text
@d2324 41
d3214 1
@


5.45
log
@
	* Merged changes from the official versions 5.42.1 and 5.43.0 of
	  expect into the SF sources. See the details below.

	  --------------------
	  Martin Forssen <maf@@tkrat.xorg> fixed bug in ExpOutputProc
	  that caused misbehavior during partial writes.

	  Someone noted that gets stdin behaves differently (returns -1
	  immediately) from tclsh because with 5.42, stdin is unblocked by
	  defaults.

	  Robroy Gregg <robroy@@armory.xcom> noted that expect_background
	  ignores timeouts.  Added to documentation.

	  Jens Peterson <peterson@@redhat.xcom> provided patch for
	  "mkpasswd -vo".

	  Gary Bliesener <gary.bliesener@@nextel.xcom> noted that
	  multixterm failed on his system which had an old Tk that didn't
	  support the Tk package.

	  Removed beta designation.

	  Daniel A. Steffen <steffen@@ics.mq.edu.xau> provided patch for
	  MacOS to avoid panic-redefinition.
	  --------------------
@
text
@d137 11
a147 3
    Tcl_Channel *diagChannel;
    Tcl_DString diagDString;
    int diagEnabled;
d353 21
a373 8
    if (esPtr->channel_orig && !esPtr->leaveopen) {
	/*
	 * Ignore close errors from Tcl channels.  They indicate things
	 * like broken pipelines, etc, which don't affect our
	 * subsequent handling.
	 */
	Tcl_VarEval(interp,"close ",Tcl_GetChannelName(esPtr->channel_orig),
		(char *)0);
d406 1
d415 1
d498 6
d877 19
a895 1
	    esPtr->channel_orig = channel;
@


5.44
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@d329 6
d1234 1
a1234 1
	waitpid(esPtr->pid,&esPtr->wait,0);
d2592 1
a2592 1
		    result = waitpid(esPtr->pid,&esPtr->wait,0);
d2626 1
a2626 1
		result = waitpid(fp->pid,&fp->wait_status,WNOHANG);
@


5.43
log
@
	* Merged changes from the official version 5.41 of expect into the
	  SF sources. See details below.

	  --------------------
	  Simon Taylor <simon@@unisolve.com.xau> provided fix for interact
	  -o which was completely broken by 5.40.1.

	  Added scroll support to official tkterm.  Copied all fixes
	  from/to term_expect to/from tkterm.

	  Kiran Madabhushi <maskiran@@hotmail.xcom> encountered interact
	  diagnostics incorrectly pointing to expect_background.  Also,
	  found multiple -o flags behaving unexpectedly.  Added diag.

	  Kristoffer Eriksson <ske@@pkmab.xse> noted typo in SIMPLE code in
	  exp_inter.c.  However, this is extremely unlikely to affect any
	  machines.

	  Reinhard Max <max@@suse.xcom> noted that "make test" failed when
	  run in the background.  The log testcase was testing the
	  send_tty command.  Added code in both Expect and in the test to
	  handle this.
	  --------------------
@
text
@d325 4
a1300 12
/* if this works, exact_write should disappear and function should
   call Tcl_WriteChars directly */
static int
exact_write(esPtr,buffer,rembytes) /* INTL */
ExpState *esPtr;
char *buffer;
int rembytes;
{
    Tcl_WriteChars(esPtr->channel,buffer,rembytes);
    return(0);
}

d1360 1
a1360 1
		if (0 > exact_write(esPtr,buffer,bytelen)) return(-1);
d1483 1
a1483 1
	wc = Tcl_WriteChars(esPtr->channel, sp, size);
d1956 1
a1956 1
		rc = exact_write(esPtr,string,len);
d1966 1
a1966 2
		    rc = Tcl_WriteChars(esPtr->channel,
			    NULL_STRING, NULL_LENGTH);
a1968 1
		rc = ((rc==1) ? 0 : -1);   /* normal is 1 not 0 */
@


5.42
log
@
	* Merged changes from the official version 5.40 of expect into the
	  SF sources. See details below. Partially already done (Rich
	  Kennedy's patch).

	  --------------------
	  Eric Raymond <esr@@snark.thyrsus.xcom> provided troff-related
	  fixes for the expect, lib, and dislocate man pages.

	  Rich Kennedy <rickenne@@cisco.xcom> noted a bug having to do
	  with our caching of whether we have registered a filehandler.
	  This broke when Tcl was setting a handler on the same file.

	  Ken Pizzini <ken.pizzini@@explicate.xorg> provided patch for
	  leak in spawn error handling.

	  Pete Lancashire <plancashire@@columbia.xcom> noted autopasswd
	  example broke on Solaris which capitalized prompts.
	  --------------------
@
text
@d1912 7
a1918 2
    else if (clientData == &sendCD_tty) esPtr = tsdPtr->devtty;
    else if (!chanName) {
@


5.41
log
@
	* Merged changes from the official version 5.39 of expect into the
	  SF sources. See details below. Partially already done.

	  --------------------
	  Poorva Gupta <poorva@@cup.hp.xcom> noted that grantpt/unlockpt
	  order was backward.  Strange that this was never a prob before!

	  Eric Raymond <esr@@snark.thyrsus.xcom> provided a troff-related
	  fix for the multixterm man page.

	  Nicolas Roeser <n-roeser@@gmx.xnet> noted confusion with md5 so I
	  made the Expect page more explicit about which file that hash
	  was based on.

	  Josh Purinton noted that earlier fix wasn't quite right.  Exit
	  on INT/TERM should cause Expect to exit with signal embedded in
	  status.  He also requested I obfuscate email addresses in this
	  file.

	  Guido Ostkamp <Guido.Ostkamp@@t-online.xde> and Igor Sobrado
	  <sobrado@@string1.ciencias.uniovi.xes> noted that fixline1
	  rewrote scripts to be expect scripts even if they were expectk
	  scripts.

	  Dirk Petera <dirkpetera@@yahoo.xcom> noted that any_spawn_id used
	  to work but did no longer.  Looks like a bug left over from the
	  the I18L conversion.  Fixed.

	  Steve Szabo noted exp_log_file -open channel failed.  Fixed.

	  Fixed bug from 5.31 that prevent stty from returning messages
	  from underlying program.

	  Thomas Dickey <dickey@@herndon4.his.xcom> noted that ncurses
	  ignores 2-char term names because of, well, poor assumptions and
	  coding.  Changed tkterm to use longer names.

	  Heath Moore <hmoore@@systran.xcom> noted that exp_clib could lock
	  up if remtime happened to be precisely 0.  Recoded to avoid.

	  At request of Per Otterholm <otterholm@@telia.xcom>, wrote script
	  to read from stdin and echo passwords (exercise 9 in Tk chapter
	  of Expect book).  Added to example directory as passwdprompt.

	  Josh Purinton <josh@@purinton.xorg> pointed out that by default,
	  SIGINT/TERM should cause expect's return status to be 1, not 0.

	  Paul Reithmuller <paul.reithmuller@@eng.sun.xcom> noted that
	  unbuffer shouldn't postprocess its output.  Added stty_init.

	  Mordechai T. Abzug <morty@@sanctuary.arbutus.md.xus> noted that
	  log_file wasn't recording -append status.

	  James Kelly <macubergeek@@comcast.xnet> noted weather example
	  needed new source.

	  Dimitar Haralanov <mitko@@tahoenetworks.xcom> noted that interact
	  dumped core with interact { timeout 1 }
	  --------------------
@
text
@d897 2
d967 2
a968 1
		    /* child's exec failed; err contains exec's errno  */
@


5.40
log
@
	* exp_command.c: Applied patch provided on c.l.t., by Don Libes
	  <libes@@nist.gov> in response to a bug report by Dirk Petera
	  <dirkpetera@@yahoo.com> in same place. See thread reference
	  below:

	  http://groups.google.ca/groups?threadm=4791f5a6.0305250619.1a660299%40posting.google.com
@
text
@a792 1

d798 1
a798 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_READABLE, (ClientData*) &rfdc)) {
d804 1
a804 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_WRITABLE, (ClientData*) &wfdc)) {
d2060 1
a2060 1
	} else if (chanName && (0 == strcmp(filename,Tcl_GetChannelName(expLogChannelGet())))) {
@


5.39
log
@
	* configure.in:   Made expect aware of tcl stubs. Derived from the
	* exp_command.h:  patches to expect done by Steve Landers
	* exp_command.c:  <stevel@@digital-smarties.com>. Modifications:
	* exp_main_sub.c  No global cmdinfo structures for 'close' and
	* exp_main_exp.c: 'return'. Made this per-interpreter information
	* exp_main_tk.c:  as it should be. Using interp assoc data for this.

	NOTE: stubs is not default, but has to be activated via '--enable-stubs'.

	* configure:      Regenerated.
@
text
@d1640 1
a1640 1
	i->direct = (isExpChannelName(arg)?EXP_DIRECT:EXP_INDIRECT);
d1704 1
a1704 1
        esPtr = expStateFromChannelName(interp,argv[j],1,0,0,"");
@


5.38
log
@
	* exp_command.c (Exp_SpawnCmd): Tcl_GetChannelHandle expected a
	  ClientData*, but got an int*. sizeof(int) != sizeof(ClientData)
	  on 64bit platforms. Crashed the command on a PA-RISC 2.0 machine
	  with --enable-64bit set. Fix: Use temp. variables of type
	  ClientData to retrieve the fd's, and copy this into the actual
	  variables, with a cast to int.
@
text
@d2261 7
d2318 2
a2319 1
	Tcl_CmdInfo info;
d2321 3
a2323 4
	if (0 == Tcl_GetCommandInfo(interp,"close",&info)) {
	    info.clientData = 0;
	}
	return(Tcl_CloseObjCmd(info.clientData,interp,objc_orig,objv_orig));
d2968 3
a2970 1
    int result = Tcl_ReturnObjCmd(clientData,interp,objc,objv);
@


5.37
log
@Fixed bad interaction involving multibyte UTF8 characters between send -s
and Tcl.
@
text
@d784 1
d793 1
d799 1
a799 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_READABLE, (ClientData) &rfd)) {
d802 1
d805 1
a805 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_WRITABLE, (ClientData) &wfd)) {
d807 2
a808 1
	    }    
@


5.36
log
@misc updates
@
text
@d1346 1
d1348 4
a1351 1
		int len;
d1353 12
a1364 4
		len = (arg->size<rembytes?arg->size:rembytes);
		if (0 > exact_write(esPtr,buffer,len)) return(-1);
		rembytes -= arg->size;
		buffer += arg->size;
@


5.35
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d186 1
a186 1
    CONST char *name = exp_get_var(interp,SPAWN_ID_VARNAME);
d211 1
a211 1
    CONST char *name;
d1708 1
a1708 1
  CONST char *p;	/* string representation of list of spawn ids */
@


5.34
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@d186 1
a186 1
    char *name = exp_get_var(interp,SPAWN_ID_VARNAME);
d211 1
a211 1
    char *name;
d218 1
a218 1
    char *chanName;
d584 1
a584 1
    char *stty_init;
d1315 1
a1315 1
	char *s = exp_get_var(interp,"send_slow");
d1377 1
a1377 1
	char *s = exp_get_var(interp,"send_human");
d1708 1
a1708 1
  char *p;	/* string representation of list of spawn ids */
@


5.33
log
@Made exp_wait with no spawned processes behave like in 5.29 - see HISTORY.
@
text
@d1609 2
a1610 1
/* cannot fail */
d1643 4
a1646 1
	exp_i_update(interp,i);
d1672 3
a1674 1
static void
d1693 1
a1693 1
    return;
d1697 1
a1697 1
    return;
d1701 3
a1703 1
void
d1719 1
a1719 1
      if (streq(p,i->value)) return;
d1734 1
a1734 2
  exp_i_parse_states(interp, i);
  return;
d1906 1
@


5.33.2.1
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@d1609 1
a1609 2
/* can only fail on bad direct descriptors */
/* indirect descriptors always succeed */
d1642 1
a1642 4
	if (TCL_ERROR == exp_i_update(interp,i)) {
	  exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
	  return 0;
	}
d1668 1
a1668 3
/* returns TCL_ERROR only on direct */
/* indirects always succeed */
static int
d1687 1
a1687 1
    return TCL_OK;
d1691 1
a1691 1
    return TCL_ERROR;
d1695 1
a1695 3
/* return TCL_ERROR only on direct variables */
/* indirect variables always succeed */
int
d1711 1
a1711 1
      if (streq(p,i->value)) return TCL_OK;
d1726 2
a1727 1
  return exp_i_parse_states(interp, i);
a1898 1
	if (!i) return TCL_ERROR;
@


5.33.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.33.4.1
log
@Top-level source files removed.
@
text
@@


5.32
log
@uninit'd var in Exp_OpenCmd made exp_open (no args) fail sometimes.
@
text
@d2658 3
a2660 7
    /* If user hasn't already called close, do so on their behalf.
     * Check before calling exp_close since it will write over the
     * result that we've already written! */

    if (esPtr->open) exp_close(interp,esPtr);

    if (esPtr->registered) {
d2662 1
@


5.31
log
@Merge of expect5-31-branch to mainline
@
text
@d2955 1
a2955 1
    char *chanName;
@


5.30
log
@Martin Forssen <maf@@crt.se> provided fix to allow configure
to start with LDFLAGS from environment.

Paul Tazzyman <Paul.Tazzyman@@one.at> noted that log_file didn't
check for logging twice without turning off logging first.

Ben <spy@@calvin.iconoclasm.org> provided updated host for
weather example.

Jonathon Kamens noted that Expect didn't build properly if
Tcl and/or Tk used build/install directories out of the usual
hierarchy.  At the same time, I fixed a number of other related
problems in Makefile/configure.

Pierre Pomes <ppomes@@it.marseille-innov.assoc.fr> provided fix
to ftp-inband.  It blew up from an unprotected send that
was handed a uuencoded line that started with a -.

Autoexpect was thrown off by simple-minded [file executable]
test picking up expect directory while searching for
executable.
@
text
@a33 11
#ifdef HAVE_SYS_WAIT_H
  /* ISC doesn't def WNOHANG unless _POSIX_SOURCE is def'ed */
# ifdef WNOHANG_REQUIRES_POSIX_SOURCE
#  define _POSIX_SOURCE
# endif
# include <sys/wait.h>
# ifdef WNOHANG_REQUIRES_POSIX_SOURCE
#  undef _POSIX_SOURCE
# endif
#endif

d80 7
d89 2
a90 2
int getptymaster();
int getptyslave();
d94 1
a94 1
/* the following are just reserved addresses, to be used as ClientData */
a102 3
struct exp_f *exp_fs = 0;		/* process array (indexed by spawn_id's) */
int exp_fd_max = -1;		/* highest fd */

a119 6
/* this message is required because fopen sometimes fails to set errno */
/* Apparently, it "does the user a favor" and doesn't even call open */
/* if the file name is bizarre enough.  This means we can't handle fopen */
/* with the obvious trivial logic. */
static char *open_failed = "could not open - odd file name?";

d126 18
d167 1
a169 2
	/*va_start(args);*/
	/*interp = va_arg(args,Tcl_Interp *);*/
d171 2
a172 1
	vsprintf(interp->result,fmt,args);
d176 3
a178 3
/* returns handle if fd is usable, 0 if not */
struct exp_f *
exp_fd2f(interp,fd,opened,adjust,msg)
d180 8
a187 15
int fd;
int opened;		/* check not closed */
int adjust;		/* adjust buffer sizes */
char *msg;
{
	if (fd >= 0 && fd <= exp_fd_max && (exp_fs[fd].valid)) {
		struct exp_f *f = exp_fs + fd;

		/* following is a little tricky, do not be tempted do the */
		/* 'usual' boolean simplification */
		if ((!opened) || !f->user_closed) {
			if (adjust) exp_adjust(f);
			return f;
		}
	}
d189 1
a189 2
	exp_error(interp,"%s: invalid spawn id (%d)",msg,fd);
	return(0);
d192 7
a198 6
#if 0
/* following routine is not current used, but might be later */
/* returns fd or -1 if no such entry */
static int
pid_to_fd(pid)
int pid;
d200 7
a206 1
	int fd;
d208 16
a223 2
	for (fd=0;fd<=exp_fd_max;fd++) {
		if (exp_fs[fd].pid == pid) return(fd);
d225 14
a238 1
	return 0;
a239 4
#endif

/* Tcl needs commands in writable space */
static char close_cmd[] = "close";
d253 1
a253 14
/* prevent an fd from being allocated */
void
exp_busy(fd)
int fd;
{
	int x = open("/dev/null",0);
	if (x != fd) {
		fcntl(x,F_DUPFD,fd);
		close(x);
	}
	exp_close_on_exec(fd);
}

/* called just before an exp_f entry is about to be invalidated */
d255 1
a255 1
exp_f_prep_for_invalidation(interp,f)
d257 1
a257 1
struct exp_f *f;
d259 1
a259 1
	int fd = f - exp_fs;
d261 1
a261 1
	exp_ecmd_remove_fd_direct_and_indirect(interp,fd);
d263 3
a265 16
	exp_configure_count++;

	if (f->buffer) {
		ckfree(f->buffer);
		f->buffer = 0;
		f->msize = 0;
		f->size = 0;
		f->printed = 0;
		f->echoed = 0;
		if (f->fg_armed) {
			exp_event_disarm(f-exp_fs);
			f->fg_armed = FALSE;
		}
		ckfree(f->lower);
	}
	f->fg_armed = FALSE;
d284 2
a285 3
	int master;
	struct exp_f *f;
	int enable = 0;
d287 5
a291 8
	Tcl_HashEntry *entry = Tcl_FindHashEntry(&slaveNames,name);
	if (!entry) {
		debuglog("exp_trap_off: no entry found for %s\n",name);
		return -1;
	}

	f = (struct exp_f *)Tcl_GetHashValue(entry);
	master = f - exp_fs;
d293 3
a295 1
	exp_slave_control(master,0);
d297 1
a297 1
	return master;
d299 1
a299 1
	return name[0];	/* pacify lint, use arg and return something */
d303 1
a303 1
/*ARGSUSED*/
d305 10
a314 22
sys_close(fd,f)
int fd;
struct exp_f *f;
{
	/* Ignore close errors.  Some systems are really odd and */
	/* return errors for no evident reason.  Anyway, receiving */
	/* an error upon pty-close doesn't mean anything anyway as */
	/* far as I know. */
	close(fd);
	f->sys_closed = TRUE;

#ifdef HAVE_PTYTRAP
	if (f->slave_name) {
		Tcl_HashEntry *entry;

		entry = Tcl_FindHashEntry(&slaveNames,f->slave_name);
		Tcl_DeleteHashEntry(entry);

		ckfree(f->slave_name);
		f->slave_name = 0;
	}
#endif
d317 2
a318 3
/* given a Tcl file identifier, close it */
static void
close_tcl_file(interp,file_id)
d320 1
a320 1
char *file_id;
d322 2
a323 1
    Tcl_VarEval(interp,"close ",file_id,(char *)0);
d325 5
a329 3
#if 0  /* old Tcl 7.6 code */
    char *argv[3];
    Tcl_CmdInfo info;
d331 3
a333 3
    argv[0] = close_cmd;
    argv[1] = file_id;
    argv[2] = 0;
d335 8
a342 4
    Tcl_ResetResult(interp);
    Tcl_GetCommandInfo(interp,"close",&info);
    if (0 == Tcl_GetCommandInfo(interp,"close",&info)) {
        info.clientData = 0;
a343 3
    (void) Tcl_CloseCmd(info.clientData,interp,2,argv);
#endif
}			
d345 6
d352 4
a355 6
/* close all connections
The kernel would actually do this by default, however Tcl is going to
come along later and try to reap its exec'd processes.  If we have
inherited any via spawn -open, Tcl can hang if we don't close the
connections first.
*/
d357 1
a357 5
void
exp_close_all(interp)
Tcl_Interp *interp;
{
	int fd;
d359 5
a363 4
	for (fd=0;fd<=exp_fd_max;fd++) {
		if (exp_fs[fd].valid) {
			exp_close(interp,fd);
		}
d365 5
d372 5
a376 4
int
exp_close(interp,fd)
Tcl_Interp *interp;
int fd;
d378 1
a378 2
	struct exp_f *f = exp_fd2f(interp,fd,1,0,"close");
	if (!f) return(TCL_ERROR);
d380 2
a381 1
	f->user_closed = TRUE;
d383 4
a386 8
	if (f->slave_fd != EXP_NOFD) close(f->slave_fd);
#if 0
	if (f->tcl_handle) {
		ckfree(f->tcl_handle);
		if ((f - exp_fs) != f->tcl_output) close(f->tcl_output);
	}
#endif
	sys_close(fd,f);
d388 2
a389 2
	if (f->tcl_handle) {
		if ((f - exp_fs) != f->tcl_output) close(f->tcl_output);
d391 5
a395 6
		if (!f->leaveopen) {
			/*
			 * Ignore errors from close; they report things like
			 * broken pipeline, etc, which don't affect our
			 * subsequent handling.
			 */
d397 2
a398 1
			close_tcl_file(interp,f->tcl_handle);
d400 4
a403 4
			ckfree(f->tcl_handle);
			f->tcl_handle = 0;
		}
	}
d405 1
a405 10
	exp_f_prep_for_invalidation(interp,f);

	if (f->user_waited) {
		f->valid = FALSE;
	} else {
		exp_busy(fd);
		f->sys_closed = FALSE;
	}

	return(TCL_OK);
d408 2
a409 4
static struct exp_f *
fd_new(fd,pid)
int fd;
int pid;
d411 1
a411 67
	int i, low;
	struct exp_f *newfs;	/* temporary, so we don't lose old exp_fs */

	/* resize table if nec */
	if (fd > exp_fd_max) {
		if (!exp_fs) {	/* no fd's yet allocated */
			newfs = (struct exp_f *)ckalloc(sizeof(struct exp_f)*(fd+1));
			low = 0;
		} else {		/* enlarge fd table */
			newfs = (struct exp_f *)ckrealloc((char *)exp_fs,sizeof(struct exp_f)*(fd+1));
			low = exp_fd_max+1;
		}
		exp_fs = newfs;
		exp_fd_max = fd;
		for (i = low; i <= exp_fd_max; i++) { /* init new fd entries */
			exp_fs[i].valid = FALSE;
			exp_fs[i].fd_ptr = (int *)ckalloc(sizeof(int));
			*exp_fs[i].fd_ptr = i;

/*			exp_fs[i].ptr = (struct exp_f **)ckalloc(sizeof(struct exp_fs *));*/

		}

#if 0
		for (i = 0; i <= exp_fd_max; i++) { /* update all indirect ptrs */
			*exp_fs[i].ptr = exp_fs + i;
		}
#endif
	}

	/* this could happen if user does "spawn -open stdin" I suppose */
	if (exp_fs[fd].valid) return exp_fs+fd;

	/* close down old table entry if nec */
	exp_fs[fd].pid = pid;
	exp_fs[fd].size = 0;
	exp_fs[fd].msize = 0;
	exp_fs[fd].buffer = 0;
	exp_fs[fd].printed = 0;
	exp_fs[fd].echoed = 0;
	exp_fs[fd].rm_nulls = exp_default_rm_nulls;
	exp_fs[fd].parity = exp_default_parity;
	exp_fs[fd].key = expect_key++;
	exp_fs[fd].force_read = FALSE;
	exp_fs[fd].fg_armed = FALSE;
#if TCL_MAJOR_VERSION < 8
	/* Master must be inited each time because Tcl could have alloc'd */
	/* this fd and shut it down (deallocating the FileHandle) behind */
	/* our backs */
	exp_fs[fd].Master = Tcl_GetFile((ClientData)fd,TCL_UNIX_FD);
	exp_fs[fd].MasterOutput = 0;
	exp_fs[fd].Slave = 0;
#endif /* TCL_MAJOR_VERSION < 8 */
	exp_fs[fd].tcl_handle = 0;
	exp_fs[fd].slave_fd = EXP_NOFD;
#ifdef HAVE_PTYTRAP
	exp_fs[fd].slave_name = 0;
#endif /* HAVE_PTYTRAP */
	exp_fs[fd].umsize = exp_default_match_max;
	exp_fs[fd].valid = TRUE;
	exp_fs[fd].user_closed = FALSE;
	exp_fs[fd].sys_closed = FALSE;
	exp_fs[fd].user_waited = FALSE;
	exp_fs[fd].sys_waited = FALSE;
	exp_fs[fd].bg_interp = 0;
	exp_fs[fd].bg_status = unarmed;
	exp_fs[fd].bg_ecount = 0;
d413 1
a413 1
	return exp_fs+fd;
a415 15
#if 0
void
exp_global_init(eg,duration,location)
struct expect_global *eg;
int duration;
int location;
{
	eg->ecases = 0;
	eg->ecount = 0;
	eg->i_list = 0;
	eg->duration = duration;
	eg->location = location;
}
#endif

d420 1
a420 2
	Tcl_SetVar(interp,"user_spawn_id",EXP_SPAWN_ID_USER_LIT,0);
	Tcl_SetVar(interp,"error_spawn_id",EXP_SPAWN_ID_ERROR_LIT,0);
d422 8
a429 3
	/* note that the user_spawn_id is NOT /dev/tty which could */
	/* (at least in theory anyway) be later re-opened on a different */
	/* fd, while stdin might have been redirected away from /dev/tty */
d431 3
a433 5
	if (exp_dev_tty != -1) {
		char dev_tty_str[10];
		sprintf(dev_tty_str,"%d",exp_dev_tty);
		Tcl_SetVar(interp,"tty_spawn_id",dev_tty_str,0);
	}
d437 2
a438 1
exp_init_spawn_ids()
d440 21
a460 14
	/* note whether 0,1,2 are connected to a terminal so that if we */
	/* disconnect, we can shut these down.  We would really like to */
	/* test if 0,1,2 are our controlling tty, but I don't know any */
	/* way to do that portably.  Anyway, the likelihood of anyone */
	/* disconnecting after redirecting to a non-controlling tty is */
	/* virtually zero. */

	fd_new(0,isatty(0)?exp_getpid:EXP_NOPID);
	fd_new(1,isatty(1)?exp_getpid:EXP_NOPID);
	fd_new(2,isatty(2)?exp_getpid:EXP_NOPID);

	if (exp_dev_tty != -1) {
		fd_new(exp_dev_tty,exp_getpid);
	}
d462 3
a464 2
	/* really should be in interpreter() but silly to do on every call */
	exp_adjust(&exp_fs[0]);
d468 1
a468 1
exp_close_on_exec(fd)
d471 1
a471 1
	(void) fcntl(fd,F_SETFD,1);
d477 2
d506 18
d526 2
a527 2
set_slave_name(f,name)
struct exp_f *f;
d535 2
a536 2
	f->slave_name = ckalloc(strlen(exp_pty_slave_name)+1);
	strcpy(f->slave_name,exp_pty_slave_name);
d539 1
a539 1
	Tcl_SetHashValue(entry,(ClientData)f);
d552 7
a558 6
	int slave;
	int pid;
	char **a;
	/* tell Saber to ignore non-use of ttyfd */
	/*SUPPRESS 591*/
	int errorfd;	/* place to stash fileno(stderr) in child */
d560 8
a567 8
	int ttyfd;
	int master;
	int write_master;	/* write fd of Tcl-opened files */
	int ttyinit = TRUE;
	int ttycopy = TRUE;
	int echo = TRUE;
	int console = FALSE;
	int pty_only = FALSE;
d574 1
a574 1
	RETSIGTYPE (*traps[NSIG])();
d576 1
a576 1
	int ignore[NSIG];	/* if true, signal in child is ignored */
d578 1
a578 1
	int i;			/* trusty overused temporary */
d580 6
a585 8
	char *argv0 = argv[0];
	char *openarg = 0;
	int leaveopen = FALSE;
	FILE *readfilePtr;
	FILE *writefilePtr;
	int rc, wc;
	char *stty_init;
	int slave_write_ioctls = 1;
d587 1
a587 1
	int slave_opens = 3;
d593 9
a601 10
	int sync_fds[2];
	int sync2_fds[2];
	int status_pipe[2];
	int child_errno;
	char sync_byte;

	char buf[4];		/* enough space for a string literal */
				/* representing a file descriptor */
	Tcl_DString dstring;
	Tcl_DStringInit(&dstring);
d604 1
a604 1
	init_traps(&traps);
d606 4
a609 4
	/* don't ignore any signals in child by default */
	for (i=1;i<NSIG;i++) {
		ignore[i] = FALSE;
	}
d611 1
a611 1
	argc--; argv++;
d613 30
a642 30
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-nottyinit")) {
			ttyinit = FALSE;
			slave_write_ioctls--;
			slave_opens--;
		} else if (streq(*argv,"-nottycopy")) {
			ttycopy = FALSE;
		} else if (streq(*argv,"-noecho")) {
			echo = FALSE;
		} else if (streq(*argv,"-console")) {
			console = TRUE;
		} else if (streq(*argv,"-pty")) {
			pty_only = TRUE;
		} else if (streq(*argv,"-open")) {
			if (argc < 2) {
				exp_error(interp,"usage: -open file-identifier");
				return TCL_ERROR;
			}
			openarg = argv[1];
			argc--; argv++;
		} else if (streq(*argv,"-leaveopen")) {
			if (argc < 2) {
				exp_error(interp,"usage: -open file-identifier");
				return TCL_ERROR;
			}
			openarg = argv[1];
			leaveopen = TRUE;
			argc--; argv++;
		} else if (streq(*argv,"-ignore")) {
			int sig;
d644 11
a654 11
			if (argc < 2) {
				exp_error(interp,"usage: -ignore signal");
				return TCL_ERROR;
			}
			sig = exp_string_to_signal(interp,argv[1]);
			if (sig == -1) {
				exp_error(interp,"usage: -ignore %s: unknown signal name",argv[1]);
				return TCL_ERROR;
			}
			ignore[sig] = TRUE;
			argc--; argv++;
d656 12
a667 12
		} else if (streq(*argv,"-trap")) {
			/* argv[1] is action */
			/* argv[2] is list of signals */

			RETSIGTYPE (*sig_handler)();
			int n;		/* number of signals in list */
			char **list;	/* list of signals */

			if (argc < 3) {
				exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
				return TCL_ERROR;
			}
d669 8
a676 8
			if (0 == strcmp(argv[2],"SIG_DFL")) {
				sig_handler = SIG_DFL;
			} else if (0 == strcmp(argv[2],"SIG_IGN")) {
				sig_handler = SIG_IGN;
			} else {
				exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
				return TCL_ERROR;
			}
d678 15
a692 14
			if (TCL_OK != Tcl_SplitList(interp,argv[1],&n,&list)) {
				errorlog("%s\r\n",interp->result);
				exp_error(interp,"usage: -trap {siglist} ...");
				return TCL_ERROR;
			}
			for (i=0;i<n;i++) {
				int sig = exp_string_to_signal(interp,list[i]);
				if (sig == -1) {
					ckfree((char *)&list);
					return TCL_ERROR;
				}
				traps[sig] = sig_handler;
			}
			ckfree((char *)&list);
d694 2
a695 2
			argc--; argv++;
			argc--; argv++;
d697 2
a698 2
		} else break;
	}
d700 4
a703 4
	if (openarg && (argc != 0)) {
		exp_error(interp,"usage: -[leave]open [fileXX]");
		return TCL_ERROR;
	}
d705 4
a708 4
	if (!pty_only && !openarg && (argc == 0)) {
		exp_error(interp,"usage: spawn [spawn-args] program [program-args]");
		return(TCL_ERROR);
	}
d710 5
a714 5
	stty_init = exp_get_var(interp,STTY_INIT);
	if (stty_init) {
		slave_write_ioctls++;
		slave_opens++;
	}
d719 2
a720 2
	slave_write_ioctls++;
	slave_opens++;
d723 26
a748 1
	exp_pty_slave_name = 0;
d750 4
a753 1
	Tcl_ReapDetachedProcs();
d755 2
a756 8
	if (!openarg) {
		if (echo) {
			exp_log(0,"%s ",argv0);
			for (a = argv;*a;a++) {
				exp_log(0,"%s ",*a);
			}
			exp_nflog("\r\n",0);
		}
d758 13
a770 36
		if (0 > (master = getptymaster())) {
			/*
			 * failed to allocate pty, try and figure out why
			 * so we can suggest to user what to do about it.
			 */

			int count;
			int testfd;

			if (exp_pty_error) {
				exp_error(interp,"%s",exp_pty_error);
				return TCL_ERROR;
			}

			count = 0;
			for (i=3;i<=exp_fd_max;i++) {
				count += exp_fs[i].valid;
			}
			if (count > 10) {
				exp_error(interp,"The system only has a finite number of ptys and you have many of them in use.  The usual reason for this is that you forgot (or didn't know) to call \"wait\" after closing each of them.");
				return TCL_ERROR;
			}

			testfd = open("/",0);
			close(testfd);

			if (testfd != -1) {
				exp_error(interp,"The system has no more ptys.  Ask your system administrator to create more.");
			} else {
				exp_error(interp,"- You have too many files are open.  Close some files or increase your per-process descriptor limit.");
			}
			return(TCL_ERROR);
		}
#ifdef PTYTRAP_DIES
		if (!pty_only) exp_slave_control(master,1);
#endif /* PTYTRAP_DIES */
d773 1
a773 19
		Tcl_SetVar2(interp,SPAWN_OUT,"slave,name",exp_pty_slave_name,0);
	} else {
		Tcl_Channel chan;
		int mode;
#if TCL_MAJOR_VERSION < 8
		Tcl_File tclReadFile, tclWriteFile;
#endif /* TCL_MAJOR_VERSION < 8 */
		int rfd, wfd;

		if (echo) exp_log(0,"%s [open ...]\r\n",argv0);

#if TCL7_4
		rc = Tcl_GetOpenFile(interp,openarg,0,1,&readfilePtr);
		wc = Tcl_GetOpenFile(interp,openarg,1,1,&writefilePtr);

		/* fail only if both descriptors are bad */
		if (rc == TCL_ERROR && wc == TCL_ERROR) {
			return TCL_ERROR;		
		}
d775 20
a794 70
		master = fileno((rc == TCL_OK)?readfilePtr:writefilePtr);

		/* make a new copy of file descriptor */
		if (-1 == (write_master = master = dup(master))) {
			exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
			return TCL_ERROR;
		}

		/* if writefilePtr is different, dup that too */
		if ((rc == TCL_OK) && (wc == TCL_OK) && (fileno(writefilePtr) != fileno(readfilePtr))) {
			if (-1 == (write_master = dup(fileno(writefilePtr)))) {
				exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
				return TCL_ERROR;
			}
			exp_close_on_exec(write_master);
		}

#endif
		if (!(chan = Tcl_GetChannel(interp,openarg,&mode))) {
			return TCL_ERROR;
		}
		if (!mode) {
			exp_error(interp,"channel is neither readable nor writable");
			return TCL_ERROR;
		}
		if (mode & TCL_READABLE) {
#if TCL_MAJOR_VERSION < 8
			tclReadFile = Tcl_GetChannelFile(chan, TCL_READABLE);
			rfd = (int)Tcl_GetFileInfo(tclReadFile, (int *)0);
#else
			if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_READABLE, (ClientData) &rfd)) {
				return TCL_ERROR;
			}
#endif
		}
		if (mode & TCL_WRITABLE) {
#if TCL_MAJOR_VERSION < 8
			tclWriteFile = Tcl_GetChannelFile(chan, TCL_WRITABLE);
			wfd = (int)Tcl_GetFileInfo(tclWriteFile, (int *)0);
#else
			if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_WRITABLE, (ClientData) &wfd)) {
				return TCL_ERROR;
			}
#endif
		}

		master = ((mode & TCL_READABLE)?rfd:wfd);

		/* make a new copy of file descriptor */
		if (-1 == (write_master = master = dup(master))) {
			exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
			return TCL_ERROR;
		}

		/* if writefilePtr is different, dup that too */
		if ((mode & TCL_READABLE) && (mode & TCL_WRITABLE) && (wfd != rfd)) {
			if (-1 == (write_master = dup(wfd))) {
				exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
				return TCL_ERROR;
			}
			exp_close_on_exec(write_master);
		}

		/*
		 * It would be convenient now to tell Tcl to close its
		 * file descriptor.  Alas, if involved in a pipeline, Tcl
		 * will be unable to complete a wait on the process.
		 * So simply remember that we meant to close it.  We will
		 * do so later in our own close routine.
		 */
d796 4
a799 85

	/* much easier to set this, than remember all masters */
	exp_close_on_exec(master);

	if (openarg || pty_only) {
		struct exp_f *f;

		f = fd_new(master,EXP_NOPID);

		if (openarg) {
			/* save file# handle */
			f->tcl_handle = ckalloc(strlen(openarg)+1);
			strcpy(f->tcl_handle,openarg);

			f->tcl_output = write_master;
#if 0
			/* save fd handle for output */
			if (wc == TCL_OK) {
/*				f->tcl_output = fileno(writefilePtr);*/
				f->tcl_output = write_master;
			} else {
				/* if we actually try to write to it at some */
				/* time in the future, then this will cause */
				/* an error */
				f->tcl_output = master;
			}
#endif

			f->leaveopen = leaveopen;
		}

		if (exp_pty_slave_name) set_slave_name(f,exp_pty_slave_name);

		/* make it appear as if process has been waited for */
		f->sys_waited = TRUE;
		exp_wait_zero(&f->wait);

		/* tell user id of new process */
		sprintf(buf,"%d",master);
		Tcl_SetVar(interp,SPAWN_ID_VARNAME,buf,0);

		if (!openarg) {
			char value[20];
			int dummyfd1, dummyfd2;

			/*
			 * open the slave side in the same process to support
			 * the -pty flag.
			 */

			/* Start by working around a bug in Tcl's exec.
			   It closes all the file descriptors from 3 to it's
			   own fd_max which inappropriately closes our slave
			   fd.  To avoid this, open several dummy fds.  Then
			   exec's fds will fall below ours.
			   Note that if you do something like pre-allocating
			   a bunch before using them or generating a pipeline,
			   then this code won't help.
			   Instead you'll need to add the right number of
			   explicit Tcl open's of /dev/null.
			   The right solution is fix Tcl's exec so it is not
			   so cavalier.
			 */

			dummyfd1 = open("/dev/null",0);
			dummyfd2 = open("/dev/null",0);

			if (0 > (f->slave_fd = getptyslave(ttycopy,ttyinit,
					stty_init))) {
				exp_error(interp,"open(slave pty): %s\r\n",Tcl_PosixError(interp));
				return TCL_ERROR;
			}

			close(dummyfd1);
			close(dummyfd2);

			exp_slave_control(master,1);

			sprintf(value,"%d",f->slave_fd);
			Tcl_SetVar2(interp,SPAWN_OUT,"slave,fd",value,0);
		}
		sprintf(interp->result,"%d",EXP_NOPID);
		debuglog("spawn: returns {%s}\r\n",interp->result);

		return TCL_OK;
d801 4
a804 3

	if (NULL == (argv[0] = Tcl_TildeSubst(interp,argv[0],&dstring))) {
		goto parent_error;
d806 1
d808 4
a811 3
	if (-1 == pipe(sync_fds)) {
		exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
		goto parent_error;
d814 6
a819 5
	if (-1 == pipe(sync2_fds)) {
		close(sync_fds[0]);
		close(sync_fds[1]);
		exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
		goto parent_error;
d822 39
a860 6
	if (-1 == pipe(status_pipe)) {
		close(sync_fds[0]);
		close(sync_fds[1]);
		close(sync2_fds[0]);
		close(sync2_fds[1]);
	}
d862 4
a865 3
	if ((pid = fork()) == -1) {
		exp_error(interp,"fork: %s",Tcl_PosixError(interp));
		goto parent_error;
d867 2
d870 2
a871 2
	if (pid) { /* parent */
		struct exp_f *f;
d873 3
a875 3
		close(sync_fds[1]);
		close(sync2_fds[0]);
		close(status_pipe[1]);
d877 4
a880 1
		f = fd_new(master,pid);
d882 6
a887 1
		if (exp_pty_slave_name) set_slave_name(f,exp_pty_slave_name);
d889 6
a894 3
#ifdef CRAY
		setptypid(pid);
#endif
d896 4
d901 4
a904 2
#if PTYTRAP_DIES
#ifdef HAVE_PTYTRAP
d906 1
a906 12
		while (slave_opens) {
			int cc;
			cc = exp_wait_for_slave_open(master);
#if defined(TIOCSCTTY) && !defined(CIBAUD) && !defined(sun) && !defined(hp9000s300)
			if (cc == TIOCSCTTY) slave_opens = 0;
#endif
			if (cc == TIOCOPEN) slave_opens--;
			if (cc == -1) {
				exp_error(interp,"failed to trap slave pty");
				goto parent_error;
			}
		}
d908 1
a908 9
#if 0
		/* trap initial ioctls in a feeble attempt to not block */
		/* the initially.  If the process itself ioctls */
		/* /dev/tty, such blocks will be trapped later */
		/* during normal event processing */

		/* initial slave ioctl */
		while (slave_write_ioctls) {
			int cc;
d910 2
a911 3
			cc = exp_wait_for_slave_open(master);
#if defined(TIOCSCTTY) && !defined(CIBAUD) && !defined(sun) && !defined(hp9000s300)
			if (cc == TIOCSCTTY) slave_write_ioctls = 0;
a912 7
			if (cc & IOC_IN) slave_write_ioctls--;
			else if (cc == -1) {
				exp_error(interp,"failed to trap slave pty");
				goto parent_error;
			}
		}
#endif /*0*/
d914 4
a917 2
#endif /* HAVE_PTYTRAP */
#endif /* PTYTRAP_DIES */
d919 10
a928 13
		/*
		 * wait for slave to initialize pty before allowing
		 * user to send to it
		 */ 

		debuglog("parent: waiting for sync byte\r\n");
		while (((rc = read(sync_fds[0],&sync_byte,1)) < 0) && (errno == EINTR)) {
			/* empty */;
		}
		if (rc == -1) {
			errorlog("parent: sync byte read: %s\r\n",Tcl_ErrnoMsg(errno));
			exit(-1);
		}
d930 2
a931 2
		/* turn on detection of eof */
		exp_slave_control(master,1);
d933 10
a942 10
		/*
		 * tell slave to go on now now that we have initialized pty
		 */

		debuglog("parent: telling child to go ahead\r\n");
		wc = write(sync2_fds[1]," ",1);
		if (wc == -1) {
			errorlog("parent: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
			exit(-1);
		}
d944 3
a946 3
		debuglog("parent: now unsynchronized from child\r\n");
		close(sync_fds[0]);
		close(sync2_fds[1]);
d948 1
a948 1
		/* see if child's exec worked */
d950 1
a950 1
		switch (read(status_pipe[0],&child_errno,sizeof child_errno)) {
d952 5
a956 5
			if (errno == EINTR) goto retry;
			/* well it's not really the child's errno */
			/* but it can be treated that way */
			child_errno = errno;
			break;
d958 3
a960 3
			/* child's exec succeeded */
			child_errno = 0;
			break;
d962 10
a971 11
			/* child's exec failed; err contains exec's errno  */
			waitpid(pid, NULL, 0);
			/* in order to get Tcl to set errorcode, we must */
			/* hand set errno */
			errno = child_errno;
			exp_error(interp, "couldn't execute \"%s\": %s",
				argv[0],Tcl_PosixError(interp));
			goto parent_error;
		}
		close(status_pipe[0]);

d973 2
a974 3
		/* tell user id of new process */
		sprintf(buf,"%d",master);
		Tcl_SetVar(interp,SPAWN_ID_VARNAME,buf,0);
d976 2
a977 2
		sprintf(interp->result,"%d",pid);
		debuglog("spawn: returns {%s}\r\n",interp->result);
d979 2
a980 5
		Tcl_DStringFree(&dstring);
		return(TCL_OK);
parent_error:
		Tcl_DStringFree(&dstring);
		return TCL_ERROR;
d988 1
a988 1
	exp_close_on_exec(status_pipe[1]);
d1013 1
a1013 1
	setpgrp();
d1016 1
a1016 7
#ifdef MIPS_BSD
	/* required on BSD side of MIPS OS <jmsellen@@watdragon.waterloo.edu> */
#	include <sysv/sys.s>
	syscall(SYS_setpgrp);
#endif
	setpgrp(0,0);
/*	setpgrp(0,getpid());*/	/* make a new pgrp leader */
d1044 2
a1045 2
	/* since getptyslave may have to run stty, (some of which work on fd */
	/* 0 and some of which work on 1) do the dup's inside getptyslave. */
d1047 1
a1047 1
	if (0 > (slave = getptyslave(ttycopy,ttyinit,stty_init))) {
d1051 1
a1051 1
			errorlog("open(slave pty): %s\r\n",exp_pty_error);
d1053 1
a1053 1
			errorlog("open(slave pty): %s\r\n",Tcl_ErrnoMsg(errno));
d1060 1
a1060 1
		errorlog("getptyslave: slave = %d but expected 0\n",slave);
d1076 4
d1081 8
a1088 1
	if (ioctl(0,TIOCSCTTY,(char *)0) < 0) {
a1089 4
		restore_error_fd
		errorlog("failed to get controlling terminal using TIOCSCTTY");
		exit(-1);
	}
d1098 1
a1098 1
 		errorlog("open(/dev/tty): %s\r\n",Tcl_ErrnoMsg(errno));
d1118 1
a1118 1
		errorlog("second fork: %s\r\n",Tcl_ErrnoMsg(errno));
d1167 6
a1172 8
#if 0
	/* avoid fflush of cmdfile since this screws up the parents seek ptr */
	/* There is no portable way to fclose a shared read-stream!!!! */
	if (exp_cmdfile && (exp_cmdfile != stdin))
		(void) close(fileno(exp_cmdfile));
	if (logfile) (void) fclose(logfile);
	if (debugfile) (void) fclose(debugfile);
#endif
d1179 1
a1179 1
	/* debuglog("child: telling parent that pty is initialized\r\n");*/
d1183 1
a1183 1
		errorlog("child: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
a1188 4
	/* debuglog("child: waiting for go ahead from parent\r\n"); */

/*	close(master);	/* force master-side close so we can read */

d1195 1
a1195 1
		errorlog("child: sync byte read: %s\r\n",Tcl_ErrnoMsg(errno));
d1200 1
a1200 1
	/* debuglog("child: now unsynchronized from parent\r\n"); */
d1202 7
a1208 3
	/* So much for close-on-exec.  Tcl doesn't mark its files that way */
	/* everything has to be closed explicitly. */
	if (exp_close_in_child) (*exp_close_in_child)();
a1209 10
        (void) execvp(argv[0],argv);
#if 0
	/* Unfortunately, by now we've closed fd's to stderr, logfile and
		debugfile.
	   The only reasonable thing to do is to send back the error as
	   part of the program output.  This will be picked up in an
	   expect or interact command.
	*/
	errorlog("%s: %s\r\n",argv[0],Tcl_ErrnoMsg(errno));
#endif
d1214 10
d1234 2
a1235 2
	struct exp_f *f;
	int m = -1;
d1237 1
a1237 1
	argc--; argv++;
d1239 7
a1245 7
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-i")) {
			argc--; argv++;
			if (!*argv) goto usage;
			m = atoi(*argv);
		} else goto usage;
	}
d1247 11
a1257 11
	if (m == -1) {
		if (exp_update_master(interp,&m,0,0) == 0) return TCL_ERROR;
	}

	if (0 == (f = exp_fd2f(interp,m,1,0,"exp_pid"))) return TCL_ERROR;

	sprintf(interp->result,"%d",f->pid);
	return TCL_OK;
 usage:
	exp_error(interp,"usage: -i spawn_id");
	return TCL_ERROR;
d1268 1
a1268 1
	debuglog("getpid is deprecated, use pid\r\n");
a1272 15
/* returns current master (via out-parameter) */
/* returns f or 0, but note that since exp_fd2f calls tcl_error, this */
/* may be immediately followed by a "return(TCL_ERROR)"!!! */
struct exp_f *
exp_update_master(interp,m,opened,adjust)
Tcl_Interp *interp;
int *m;
int opened;
int adjust;
{
	char *s = exp_get_var(interp,SPAWN_ID_VARNAME);
	*m = (s?atoi(s):EXP_SPAWN_ID_USER);
	return(exp_fd2f(interp,*m,opened,adjust,(s?s:EXP_SPAWN_ID_USER_LIT)));
}

d1291 2
a1292 2
/* write exactly this many bytes, i.e. retry partial writes */
/* returns 0 for success, -1 for failure */
d1294 2
a1295 2
exact_write(fd,buffer,rembytes)
int fd;
d1299 2
a1300 18
	int cc;

	while (rembytes) {
		if (-1 == (cc = write(fd,buffer,rembytes))) return(-1);
		if (0 == cc) {
			/* This shouldn't happen but I'm told that it does */
			/* nonetheless (at least on SunOS 4.1.3).  Since */
			/* this is not a documented return value, the most */
			/* reasonable thing is to complain here and retry */
			/* in the hopes that is some transient condition. */
			sleep(1);
			exp_debuglog("write() failed to write anything but returned - sleeping and retrying...\n");
		}

		buffer += cc;
		rembytes -= cc;
	}
	return(0);
d1304 2
a1305 2
	int size;
	double time;
d1337 1
a1337 1
slow_write(interp,fd,buffer,rembytes,arg)
d1339 1
a1339 1
int fd;
d1348 1
a1348 1

d1350 1
a1350 1
		if (0 > exact_write(fd,buffer,len)) return(-1);
d1436 1
a1436 1
human_write(interp,fd,buffer,arg)
d1438 1
a1438 1
int fd;
d1442 24
a1465 21
	char *sp;
	float t;
	float alpha;
	int wc;
	int in_word = TRUE;

	debuglog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
		arg->alpha,arg->alpha_eow,arg->c,arg->min,arg->max);

	for (sp = buffer;*sp;sp++) {
		/* use the end-of-word alpha at eow transitions */
		if (in_word && (ispunct(*sp) || isspace(*sp)))
			alpha = arg->alpha_eow;
		else alpha = arg->alpha;
		in_word = !(ispunct(*sp) || isspace(*sp));

		t = alpha * pow(-log((double)unit_random()),arg->c);

		/* enforce min and max times */
		if (t<arg->min) t = arg->min;
		else if (t>arg->max) t = arg->max;
a1466 1
/*fprintf(stderr,"\nwriting <%c> but first sleep %f seconds\n",*sp,t);*/
d1468 4
a1471 4
		if (sp != buffer) {
			wc = exp_dsleep(interp,(double)t);
			if (wc > 0) return wc;
		}
d1473 4
a1476 4
		wc = write(fd,sp,1);
		if (0 > wc) return(wc);
	}
	return(0);
d1480 1
a1480 1
struct exp_fd_list *exp_fd_list_pool = 0;
d1507 1
a1507 1
	i->fd_list = 0;
d1513 13
a1525 15
struct exp_fd_list *
exp_new_fd(val)
int val;
{
	int n;
	struct exp_fd_list *fd;

	if (!exp_fd_list_pool) {
		/* none avail, generate some new ones */
		exp_fd_list_pool = fd = (struct exp_fd_list *)ckalloc(
			EXP_FD_INIT_COUNT * sizeof(struct exp_fd_list));
		for (n=0;n<EXP_FD_INIT_COUNT-1;n++,fd++) {
			fd->next = fd+1;
		}
		fd->next = 0;
d1527 2
d1530 1
a1530 1
	/* now that we've made some, unlink one and give to user */
d1532 5
a1536 5
	fd = exp_fd_list_pool;
	exp_fd_list_pool = exp_fd_list_pool->next;
	fd->fd = val;
	/* fd->next is assumed to be changed by caller */
	return fd;
d1540 2
a1541 2
exp_free_fd(fd_first)
struct exp_fd_list *fd_first;
d1543 1
a1543 1
	struct exp_fd_list *fd, *penultimate;
d1554 2
a1555 2
	penultimate->next = exp_fd_list_pool;
	exp_fd_list_pool = fd_first;
d1560 2
a1561 2
exp_free_fd_single(fd)
struct exp_fd_list *fd;
d1563 2
a1564 2
	fd->next = exp_fd_list_pool;
	exp_fd_list_pool = fd;
d1575 1
a1575 1
	exp_free_fd(i->fd_list);
d1623 2
d1626 1
d1641 1
a1641 1
	i->fd_list = 0;
d1656 1
a1656 1
exp_i_add_fd(i,fd)
d1658 1
a1658 1
int fd;
d1660 1
a1660 1
	struct exp_fd_list *new_fd;
d1662 3
a1664 3
	new_fd = exp_new_fd(fd);
	new_fd->next = i->fd_list;
	i->fd_list = new_fd;
d1667 4
a1670 3
/* this routine assumes i->fd is meaningful */
void
exp_i_parse_fds(i)
d1673 19
a1691 27
	char *p = i->value;

	/* reparse it */
	while (1) {
		int m;
		int negative = 0;
		int valid_spawn_id = 0;

		m = 0;
		while (isspace(*p)) p++;
		for (;;p++) {
			if (*p == '-') negative = 1;
			else if (isdigit(*p)) {
				m = m*10 + (*p-'0');
				valid_spawn_id = 1;
			} else if (*p == '\0' || isspace(*p)) break;
		}

		/* we either have a spawn_id or whitespace at end of string */

		/* skip whitespace end-of-string */
		if (!valid_spawn_id) break;

		if (negative) m = -m;

		exp_i_add_fd(i,m);
	}
d1700 1
a1700 1
	char *p;	/* string representation of list of spawn ids */
d1702 16
a1717 9
	if (i->direct == EXP_INDIRECT) {
		p = Tcl_GetVar(interp,i->variable,TCL_GLOBAL_ONLY);
		if (!p) {
			p = "";
			exp_debuglog("warning: indirect variable %s undefined",i->variable);
		}

		if (i->value) {
			if (streq(p,i->value)) return;
d1719 9
a1727 14
			/* replace new value with old */
			ckfree(i->value);
		}
		i->value = ckalloc(strlen(p)+1);
		strcpy(i->value,p);

		exp_free_fd(i->fd_list);
		i->fd_list = 0;
	} else {
		/* no free, because this should only be called on */
		/* "direct" i's once */
		i->fd_list = 0;
	}
	exp_i_parse_fds(i);
d1731 2
a1732 2
exp_new_i_simple(fd,duration)
int fd;
d1743 1
a1743 1
	exp_i_add_fd(i,fd);
a1755 3
	char *string;
	int len;

a1757 1

d1769 1
a1769 7
	string = *argv;

	len = strlen(string);

	if (debugfile) fwrite(string,1,len,debugfile);
	if (logfile) fwrite(string,1,len,logfile);

d1779 1
a1779 1
Exp_SendCmd(clientData, interp, argc, argv)
d1782 2
a1783 2
int argc;
char **argv;
d1785 5
a1789 4
	int m = -1;	/* spawn id (master) */
	int rc; 	/* final result of this procedure */
	struct human_arg human_args;
	struct slow_arg slow_args;
d1796 66
a1861 5
	int send_style = SEND_STYLE_PLAIN;
	int want_cooked = TRUE;
	char *string;		/* string to send */
	int len;		/* length of string to send */
	int zeros;		/* count of how many ascii zeros to send */
d1863 3
a1865 4
	char *i_masters = 0;
	struct exp_fd_list *fd;
	struct exp_i *i;
	char *arg;
d1867 4
a1870 54
	argv++;
	argc--;
	while (argc) {
		arg = *argv;
		if (arg[0] != '-') break;
		arg++;
		if (exp_flageq1('-',arg)) {			/* "--" */
			argc--; argv++;
			break;
		} else if (exp_flageq1('i',arg)) {		/* "-i" */
			argc--; argv++;
			if (argc==0) {
				exp_error(interp,"usage: -i spawn_id");
				return(TCL_ERROR);
			}
			i_masters = *argv;
			argc--; argv++;
			continue;
		} else if (exp_flageq1('h',arg)) {		/* "-h" */
			argc--; argv++;
			if (-1 == get_human_args(interp,&human_args))
				return(TCL_ERROR);
			send_style = SEND_STYLE_HUMAN;
			continue;
		} else if (exp_flageq1('s',arg)) {		/* "-s" */
			argc--; argv++;
			if (-1 == get_slow_args(interp,&slow_args))
				return(TCL_ERROR);
			send_style = SEND_STYLE_SLOW;
			continue;
		} else if (exp_flageq("null",arg,1) || exp_flageq1('0',arg)) {
			argc--; argv++;				/* "-null" */
			if (!*argv) zeros = 1;
			else {
				zeros = atoi(*argv);
				argc--; argv++;
				if (zeros < 1) return TCL_OK;
			}
			send_style = SEND_STYLE_ZERO;
			string = "<zero(s)>";
			continue;
		} else if (exp_flageq("raw",arg,1)) {		/* "-raw" */
			argc--; argv++;
			want_cooked = FALSE;
			continue;
		} else if (exp_flageq("break",arg,1)) {		/* "-break" */
			argc--; argv++;
			send_style = SEND_STYLE_BREAK;
			string = "<break>";
			continue;
		} else {
			exp_error(interp,"usage: unrecognized flag <-%.80s>",arg);
			return TCL_ERROR;
		}
d1872 1
d1874 8
a1881 7
	if (send_style & SEND_STYLE_STRING_MASK) {
		if (argc != 1) {
			exp_error(interp,"usage: send [args] string");
			return TCL_ERROR;
		}
		string = *argv;
	}
d1883 1
d1885 9
a1893 10
	if (clientData == &sendCD_user) m = 1;
	else if (clientData == &sendCD_error) m = 2;
	else if (clientData == &sendCD_tty) m = exp_dev_tty;
	else if (!i_masters) {
		/* we really do want to check if it is open */
		/* but since stdin could be closed, we have to first */
		/* get the fd and then convert it from 0 to 1 if necessary */
		if (0 == exp_update_master(interp,&m,0,0))
			return(TCL_ERROR);
	}
d1895 5
a1899 8
	/* if master != -1, then it holds desired master */
	/* else i_masters does */

	if (m != -1) {
		i = exp_new_i_simple(m,EXP_TEMPORARY);
	} else {
		i = exp_new_i_complex(interp,i_masters,FALSE,(Tcl_VarTraceProc *)0);
	}
d1906 14
d1921 1
a1921 9
		want_cooked = FALSE;
		debuglog("send: sending \"%s\" to {",dprintify(string));
		/* if closing brace doesn't appear, that's because an error */
		/* was encountered before we could send it */
	} else {
		if (debugfile)
			fwrite(string,1,len,debugfile);
		if ((send_to_user && logfile_all) || logfile)
			fwrite(string,1,len,logfile);
d1924 37
a1960 50
	for (fd=i->fd_list;fd;fd=fd->next) {
		m = fd->fd;

		if (send_to_proc) {
			debuglog(" %d ",m);
		}

		/* true if called as Send with user_spawn_id */
		if (exp_is_stdinfd(m)) m = 1;

		/* check validity of each - i.e., are they open */
		if (0 == exp_fd2f(interp,m,1,0,"send")) {
			rc = TCL_ERROR;
			goto finish;
		}
		/* Check if Tcl is using a different fd for output */
		if (exp_fs[m].tcl_handle) {
			m = exp_fs[m].tcl_output;
		}

		if (want_cooked) string = exp_cook(string,&len);

		switch (send_style) {
		case SEND_STYLE_PLAIN:
			rc = exact_write(m,string,len);
			break;
		case SEND_STYLE_SLOW:
			rc = slow_write(interp,m,string,len,&slow_args);
			break;
		case SEND_STYLE_HUMAN:
			rc = human_write(interp,m,string,&human_args);
			break;
		case SEND_STYLE_ZERO:
			for (;zeros>0;zeros--) rc = write(m,"",1);
			/* catching error on last write is sufficient */
			rc = ((rc==1) ? 0 : -1);   /* normal is 1 not 0 */
			break;
		case SEND_STYLE_BREAK:
			exp_tty_break(interp,m);
			rc = 0;
			break;
		}

		if (rc != 0) {
			if (rc == -1) {
				exp_error(interp,"write(spawn_id=%d): %s",m,Tcl_PosixError(interp));
				rc = TCL_ERROR;
			}
			goto finish;
		}
d1962 2
a1963 1
	if (send_to_proc) debuglog("}\r\n");
d1965 1
a1965 1
	rc = TCL_OK;
d1967 2
a1968 2
	exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
	return rc;
d1971 60
a2030 188
/*ARGSUSED*/
static int
Exp_LogFileCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	static Tcl_DString dstring;
	static int first_time = TRUE;
	static int current_append;	/* true if currently appending */
	static char *openarg = 0;	/* Tcl file identifier from -open */
	static int leaveopen = FALSE;	/* true if -leaveopen was used */

	int old_logfile_all = logfile_all;
	FILE *old_logfile = logfile;
	char *old_openarg = openarg;
	int old_leaveopen = leaveopen;

	int aflag = FALSE;
	int append = TRUE;
	char *filename = 0;
	char *type;
	FILE *writefilePtr;
	int usage_error_occurred = FALSE;

	openarg = 0;
	leaveopen = FALSE;

	if (first_time) {
		Tcl_DStringInit(&dstring);
		first_time = FALSE;
	}


#define usage_error	if (0) ; else {\
				 usage_error_occurred = TRUE;\
				 goto error;\
			}

	/* when this function returns, we guarantee that if logfile_all */
	/* is TRUE, then logfile is non-zero */

	argv++;
	argc--;
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-open")) {
			if (!argv[1]) usage_error;
			openarg = ckalloc(strlen(argv[1])+1);
			strcpy(openarg,argv[1]);
			argc--; argv++;
		} else if (streq(*argv,"-leaveopen")) {
			if (!argv[1]) usage_error;
			openarg = ckalloc(strlen(argv[1])+1);
			strcpy(openarg,argv[1]);
			leaveopen = TRUE;
			argc--; argv++;
		} else if (streq(*argv,"-a")) {
			aflag = TRUE;
		} else if (streq(*argv,"-info")) {
			if (logfile) {
				if (logfile_all) strcat(interp->result,"-a ");
				if (!current_append) strcat(interp->result,"-noappend ");
				strcat(interp->result,Tcl_DStringValue(&dstring));
			}
			return TCL_OK;
		} else if (streq(*argv,"-noappend")) {
			append = FALSE;
		} else break;
	}

	if (argc == 1) {
		filename = argv[0];
	} else if (argc > 1) {
		/* too many arguments */
		usage_error
	} 

	if (openarg && filename) {
		usage_error
	}
	if (aflag && !(openarg || filename)) {
		usage_error
	}
	if (current_append && (openarg || filename)) {
		exp_error(interp,"cannot start logging without first stopping logging");
		return TCL_ERROR;
	}

	logfile = 0;
	logfile_all = aflag;

	current_append = append;

	type = (append?"a":"w");

	if (filename) {
		filename = Tcl_TildeSubst(interp,filename,&dstring);
		if (filename == NULL) {
			goto error;
		} else {
			/* Tcl_TildeSubst doesn't store into dstring */
			/* if no ~, so force string into dstring */
			/* this is only needed so that next time around */
			/* we can get dstring for -info if necessary */
			if (Tcl_DStringValue(&dstring)[0] == '\0') {
				Tcl_DStringAppend(&dstring,filename,-1);
			}
		}

		errno = 0;
		if (NULL == (logfile = fopen(filename,type))) {
			char *msg;

			if (errno == 0) {
				msg = open_failed;
			} else {
				msg = Tcl_PosixError(interp);
			}
			exp_error(interp,"%s: %s",filename,msg);
			Tcl_DStringFree(&dstring);
			goto error;
		}
	} else if (openarg) {
		int cc;
		int fd;
		Tcl_Channel chan;
		int mode;
#if TCL_MAJOR_VERSION < 8
		Tcl_File tclWriteFile;
#endif /* TCL_MAJOR_VERSION < 8 */

		Tcl_DStringTrunc(&dstring,0);

#if TCL7_4
		cc = Tcl_GetOpenFile(interp,openarg,1,1,&writefilePtr);
		if (cc == TCL_ERROR) goto error;

		if (-1 == (fd = dup(fileno(writefilePtr)))) {
			exp_error(interp,"dup: %s",Tcl_PosixError(interp));
			goto error;
		}
#endif
		if (!(chan = Tcl_GetChannel(interp,openarg,&mode))) {
			return TCL_ERROR;
		}
		if (!(mode & TCL_WRITABLE)) {
			exp_error(interp,"channel is not writable");
		}
#if TCL_MAJOR_VERSION < 8
		tclWriteFile = Tcl_GetChannelFile(chan, TCL_WRITABLE);
		fd = dup((int)Tcl_GetFileInfo(tclWriteFile, (int *)0));
#else
		if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_WRITABLE, (ClientData) &fd)) {
			goto error;
		}
		fd = dup(fd);
#endif
	
		if (!(logfile = fdopen(fd,type))) {
			exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
			close(fd);
			goto error;
		}

		if (leaveopen) {
			Tcl_DStringAppend(&dstring,"-leaveopen ",-1);
		} else {
			Tcl_DStringAppend(&dstring,"-open ",-1);
		}
		Tcl_DStringAppend(&dstring,openarg,-1);

		/*
		 * It would be convenient now to tell Tcl to close its
		 * file descriptor.  Alas, if involved in a pipeline, Tcl
		 * will be unable to complete a wait on the process.
		 * So simply remember that we meant to close it.  We will
		 * do so later in our own close routine.
		 */
	}
	if (logfile) {
		setbuf(logfile,(char *)0);
		exp_close_on_exec(fileno(logfile));
	}

	if (old_logfile) {
		fclose(old_logfile);
	}
d2032 11
a2042 5
	if (old_openarg) {
		if (!old_leaveopen) {
			close_tcl_file(interp,old_openarg);
		}
		ckfree((char *)old_openarg);
d2044 1
d2046 13
a2058 6
	return TCL_OK;

 error:
	if (old_logfile) {
		logfile = old_logfile;
		logfile_all = old_logfile_all;
d2060 3
d2064 1
a2064 7
	if (openarg) ckfree(openarg);
	openarg = old_openarg;
	leaveopen = old_leaveopen;

	if (usage_error_occurred) {
		exp_error(interp,"usage: log_file [-info] [-noappend] [[-a] file] [-[leave]open [open ...]]");
	}
d2066 3
a2068 1
	return TCL_ERROR;
d2079 1
a2079 1
	int old_loguser = loguser;
d2081 7
a2087 8
	if (argc == 0 || (argc == 2 && streq(argv[1],"-info"))) {
		/* do nothing */
	} else if (argc == 2) {
		if (0 == atoi(argv[1])) loguser = FALSE;
		else loguser = TRUE;
	} else {
		exp_error(interp,"usage: [-info|1|0]");
	}
d2089 1
a2089 1
	sprintf(interp->result,"%d",old_loguser);
d2091 1
a2091 1
	return(TCL_OK);
d2103 2
a2104 2
	int now = FALSE;	/* soon if FALSE, now if TRUE */
	int exp_tcl_debugger_was_available = exp_tcl_debugger_available;
d2106 1
a2106 1
	if (argc > 3) goto usage;
d2108 4
a2111 4
	if (argc == 1) {
		sprintf(interp->result,"%d",exp_tcl_debugger_available);
		return TCL_OK;
	}
d2113 1
a2113 1
	argv++;
d2115 4
a2118 6
	while (*argv) {
		if (streq(*argv,"-now")) {
			now = TRUE;
			argv++;
		}
		else break;
d2120 2
d2123 4
a2126 10
	if (!*argv) {
		if (now) {
			Dbg_On(interp,1);
			exp_tcl_debugger_available = 1;
		} else {
			goto usage;
		}
	} else if (streq(*argv,"0")) {
		Dbg_Off(interp);
		exp_tcl_debugger_available = 0;
d2128 1
a2128 2
		Dbg_On(interp,now);
		exp_tcl_debugger_available = 1;
d2130 9
a2138 2
	sprintf(interp->result,"%d",exp_tcl_debugger_was_available);
	return(TCL_OK);
d2140 2
a2141 2
	exp_error(interp,"usage: [[-now] 1|0]");
	return TCL_ERROR;
d2145 1
d2154 9
a2162 7
	static Tcl_DString dstring;
	static int first_time = TRUE;
	int fopened = FALSE;

	if (first_time) {
		Tcl_DStringInit(&dstring);
		first_time = FALSE;
d2164 4
d2169 2
a2170 37
	if (argc > 1 && streq(argv[1],"-info")) {
		if (debugfile) {
			sprintf(interp->result,"-f %s ",
				Tcl_DStringValue(&dstring));
		}
		strcat(interp->result,((exp_is_debugging==0)?"0":"1"));
		return TCL_OK;
	}

	argv++;
	argc--;
	while (argc) {
		if (!streq(*argv,"-f")) break;
		argc--;argv++;
		if (argc < 1) goto usage;
		if (debugfile) fclose(debugfile);
		argv[0] = Tcl_TildeSubst(interp, argv[0],&dstring);
		if (argv[0] == NULL) goto error;
		else {
			/* Tcl_TildeSubst doesn't store into dstring */
			/* if no ~, so force string into dstring */
			/* this is only needed so that next time around */
			/* we can get dstring for -info if necessary */
			if (Tcl_DStringValue(&dstring)[0] == '\0') {
				Tcl_DStringAppend(&dstring,argv[0],-1);
			}
		}

		errno = 0;
		if (NULL == (debugfile = fopen(*argv,"a"))) {
			char *msg;

			if (errno == 0) {
				msg = open_failed;
			} else {
				msg = Tcl_PosixError(interp);
			}
d2172 7
a2178 7
			exp_error(interp,"%s: %s",*argv,msg);
			goto error;
		}
		setbuf(debugfile,(char *)0);
		exp_close_on_exec(fileno(debugfile));
		fopened = TRUE;
		argc--;argv++;
d2180 3
d2184 8
a2191 11
	if (argc != 1) goto usage;

	/* if no -f given, close file */
	if (fopened == FALSE && debugfile) {
		fclose(debugfile);
		debugfile = 0;
		Tcl_DStringFree(&dstring);
	}

	exp_is_debugging = atoi(*argv);
	return(TCL_OK);
d2193 2
a2194 4
	exp_error(interp,"usage: [-f file] expr");
 error:
	Tcl_DStringFree(&dstring);
	return TCL_ERROR;
d2237 1
a2237 1
	exp_exit(interp,value);
a2240 3
/* so cmd table later is more intuitive */
#define Exp_CloseObjCmd Exp_CloseCmd

d2243 1
a2243 1
Exp_CloseCmd(clientData, interp, argc, argv)
d2246 2
a2247 6
int argc;
#if TCL_MAJOR_VERSION < 8
char **argv;
#else
Tcl_Obj *CONST argv[];	/* Argument objects. */
#endif
d2249 31
a2279 19
	int onexec_flag = FALSE;	/* true if -onexec seen */
	int close_onexec;
	int slave_flag = FALSE;
	int m = -1;

	int argc_orig = argc;
#if TCL_MAJOR_VERSION < 8
	char **argv_orig = argv;
#else
	Tcl_Obj *CONST *argv_orig = argv;
#endif

	argc--; argv++;

#if TCL_MAJOR_VERSION < 8
#define STARARGV *argv
#else
#define STARARGV Tcl_GetStringFromObj(*argv,(int *)0)
#endif
d2281 10
a2290 19
	for (;argc>0;argc--,argv++) {
		if (streq("-i",STARARGV)) {
			argc--; argv++;
			if (argc == 0) {
				exp_error(interp,"usage: -i spawn_id");
				return(TCL_ERROR);
			}
			m = atoi(STARARGV);
		} else if (streq(STARARGV,"-slave")) {
			slave_flag = TRUE;
		} else if (streq(STARARGV,"-onexec")) {
			argc--; argv++;
			if (argc == 0) {
				exp_error(interp,"usage: -onexec 0|1");
				return(TCL_ERROR);
			}
			onexec_flag = TRUE;
			close_onexec = atoi(STARARGV);
		} else break;
d2292 2
d2295 5
a2299 21
	if (argc) {
		/* doesn't look like our format, it must be a Tcl-style file */
		/* handle.  Lucky that formats are easily distinguishable. */
		/* Historical note: we used "close"  long before there was a */
		/* Tcl builtin by the same name. */

		Tcl_CmdInfo info;
		Tcl_ResetResult(interp);
		if (0 == Tcl_GetCommandInfo(interp,"close",&info)) {
			info.clientData = 0;
		}
#if TCL_MAJOR_VERSION < 8
		return(Tcl_CloseCmd(info.clientData,interp,argc_orig,argv_orig));
#else
		return(Tcl_CloseObjCmd(info.clientData,interp,argc_orig,argv_orig));
#endif
	}

	if (m == -1) {
		if (exp_update_master(interp,&m,1,0) == 0) return(TCL_ERROR);
	}
d2301 4
a2304 3
	if (slave_flag) {
		struct exp_f *f = exp_fd2f(interp,m,1,0,"-slave");
		if (!f) return TCL_ERROR;
d2306 1
a2306 3
		if (f->slave_fd) {
			close(f->slave_fd);
			f->slave_fd = EXP_NOFD;
d2308 4
a2311 7
			exp_slave_control(m,1);

			return TCL_OK;
		} else {
			exp_error(interp,"no such slave");
			return TCL_ERROR;
		}
d2313 1
d2315 6
a2320 6
	if (onexec_flag) {
		/* heck, don't even bother to check if fd is open or a real */
		/* spawn id, nothing else depends on it */
		fcntl(m,F_SETFD,close_onexec);
		return TCL_OK;
	}
d2322 1
a2322 1
	return(exp_close(interp,m));
d2339 5
a2343 4
	/* come out on stderr, by using errorlog */
	errorlog("%2d",level);
	for (i = 0;i<level;i++) exp_nferrorlog("  ",0/*ignored - satisfy lint*/);
	errorlog("%s\r\n",command);
d2504 5
a2508 4
	int master_supplied = FALSE;
	int m;			/* master waited for */
	struct exp_f *f;	/* ditto */
	struct forked_proc *fp = 0;	/* handle to a pure forked proc */
d2510 2
a2511 4
	struct exp_f ftmp;	/* temporary memory for either f or fp */

	int nowait = FALSE;
	int result = 0;		/* 0 means child was successfully waited on */
d2516 12
a2527 14
	argv++;
	argc--;
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-i")) {
			argc--; argv++;
			if (argc==0) {
				exp_error(interp,"usage: -i spawn_id");
				return(TCL_ERROR);
			}
			master_supplied = TRUE;
			m = atoi(*argv);
		} else if (streq(*argv,"-nowait")) {
			nowait = TRUE;
		}
d2529 1
d2531 6
a2536 4
	if (!master_supplied) {
		if (0 == exp_update_master(interp,&m,0,0))
			return TCL_ERROR;
	}
d2538 26
a2563 3
	if (m != EXP_SPAWN_ID_ANY) {
		if (0 == exp_fd2f(interp,m,0,0,"wait")) {
			return TCL_ERROR;
d2565 2
d2568 8
a2575 1
		f = exp_fs + m;
d2577 24
a2600 31
		/* check if waited on already */
		/* things opened by "open" or set with -nowait */
		/* are marked sys_waited already */
		if (!f->sys_waited) {
			if (nowait) {
				/* should probably generate an error */
				/* if SIGCHLD is trapped. */

				/* pass to Tcl, so it can do wait */
				/* in background */
#if TCL_MAJOR_VERSION < 8
				Tcl_DetachPids(1,&f->pid);
#else
				Tcl_DetachPids(1,(Tcl_Pid *)&f->pid);
#endif
				exp_wait_zero(&f->wait);
			} else {
				while (1) {
					if (Tcl_AsyncReady()) {
						int rc = Tcl_AsyncInvoke(interp,TCL_OK);
						if (rc != TCL_OK) return(rc);
					}

					result = waitpid(f->pid,&f->wait,0);
					if (result == f->pid) break;
					if (result == -1) {
						if (errno == EINTR) continue;
						else break;
					}
				}
			}
d2602 1
d2604 1
d2606 2
a2607 3
		 * Now have Tcl reap anything we just detached. 
		 * This also allows procs user has created with "exec &"
		 * and and associated with an "exec &" process to be reaped.
d2609 8
d2618 8
a2625 23
		Tcl_ReapDetachedProcs();
		exp_rearm_sigchld(interp); /* new */
	} else {
		/* wait for any of our own spawned processes */
		/* we call waitpid rather than wait to avoid running into */
		/* someone else's processes.  Yes, according to Ousterhout */
		/* this is the best way to do it. */

		for (m=0;m<=exp_fd_max;m++) {
			f = exp_fs + m;
			if (!f->valid) continue;
			if (f->pid == exp_getpid) continue; /* skip ourself */
			if (f->user_waited) continue;	/* one wait only! */
			if (f->sys_waited) break;
		   restart:
			result = waitpid(f->pid,&f->wait,WNOHANG);
			if (result == f->pid) break;
			if (result == 0) continue;	/* busy, try next */
			if (result == -1) {
				if (errno == EINTR) goto restart;
				else break;
			}
		}
d2627 1
a2627 15
		/* if it's not a spawned process, maybe its a forked process */
		for (fp=forked_proc_base;fp;fp=fp->next) {
			if (fp->link_status == not_in_use) continue;
		restart2:
			result = waitpid(fp->pid,&fp->wait_status,WNOHANG);
			if (result == fp->pid) {
				m = -1; /* DOCUMENT THIS! */
				break;
			}
			if (result == 0) continue;	/* busy, try next */
			if (result == -1) {
				if (errno == EINTR) goto restart2;
				else break;
			}
		}
d2629 18
a2646 5
		if (m > exp_fd_max) {
			result = NO_CHILD;	/* no children */
			Tcl_ReapDetachedProcs();
		}
		exp_rearm_sigchld(interp);
d2648 13
d2662 1
a2662 8
	/*  sigh, wedge forked_proc into an exp_f structure so we don't
	 *  have to rewrite remaining code (too much)
	 */
	if (fp) {
		f = &ftmp;
		f->pid = fp->pid;
		f->wait = fp->wait_status;
	}
d2664 3
a2666 27
	/* non-portable assumption that pid_t can be printed with %d */

	if (result == -1) {
		sprintf(interp->result,"%d %d -1 %d POSIX %s %s",
			f->pid,m,errno,Tcl_ErrnoId(),Tcl_ErrnoMsg(errno));
		result = TCL_OK;
	} else if (result == NO_CHILD) {
		interp->result = "no children";
		return TCL_ERROR;
	} else {
		sprintf(interp->result,"%d %d 0 %d",
					f->pid,m,WEXITSTATUS(f->wait));
		if (WIFSIGNALED(f->wait)) {
			Tcl_AppendElement(interp,"CHILDKILLED");
			Tcl_AppendElement(interp,Tcl_SignalId((int)(WTERMSIG(f->wait))));
			Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WTERMSIG(f->wait))));
		} else if (WIFSTOPPED(f->wait)) {
			Tcl_AppendElement(interp,"CHILDSUSP");
			Tcl_AppendElement(interp,Tcl_SignalId((int) (WSTOPSIG(f->wait))));
			Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WSTOPSIG(f->wait))));
		}
	}
			
	if (fp) {
		fp->link_status = not_in_use;
		return ((result == -1)?TCL_ERROR:TCL_OK);		
	}
d2668 1
a2668 12
	f->sys_waited = TRUE;
	f->user_waited = TRUE;

	/* if user has already called close, make sure fd really is closed */
	/* and forget about this entry entirely */
	if (f->user_closed) {
		if (!f->sys_closed) {
			sys_close(m,f);
		}
		f->valid = FALSE;
	}
	return ((result == -1)?TCL_ERROR:TCL_OK);
d2701 1
a2701 1
	debuglog("fork: returns {%s}\r\n",interp->result);
d2713 6
a2718 3
	/* tell Saber to ignore non-use of ttyfd */
	/*SUPPRESS 591*/
	int ttyfd;
d2720 4
a2723 4
	if (argc > 1) {
		exp_error(interp,"usage: disconnect");
		return(TCL_ERROR);
	}
d2725 9
a2733 9
	if (exp_disconnected) {
		exp_error(interp,"already disconnected");
		return(TCL_ERROR);
	}
	if (!exp_forked) {
		exp_error(interp,"can only disconnect child process");
		return(TCL_ERROR);
	}
	exp_disconnected = TRUE;
d2735 26
a2760 21
	/* ignore hangup signals generated by testing ptys in getptymaster */
	/* and other places */
	signal(SIGHUP,SIG_IGN);

	/* reopen prevents confusion between send/expect_user */
	/* accidentally mapping to a real spawned process after a disconnect */
	if (exp_fs[0].pid != EXP_NOPID) {
		exp_close(interp,0);
		open("/dev/null",0);
		fd_new(0, EXP_NOPID);
	}
	if (exp_fs[1].pid != EXP_NOPID) {
		exp_close(interp,1);
		open("/dev/null",1);
		fd_new(1, EXP_NOPID);
	}
	if (exp_fs[2].pid != EXP_NOPID) {
		/* reopen stderr saves error checking in error/log routines. */
		exp_close(interp,2);
		open("/dev/null",1);
		fd_new(2, EXP_NOPID);
d2762 14
d2777 1
a2777 1
	Tcl_UnsetVar(interp,"tty_spawn_id",TCL_GLOBAL_ONLY);
d2780 1
a2780 1
	setsid();
d2783 1
a2783 1
	/* put process in our own pgrp, and lose controlling terminal */
d2785 10
a2794 10
	/* With setpgrp first, child ends up with closed stdio */
	/* according to Dave Schmitt <daves@@techmpc.csg.gss.mot.com> */
	if (fork()) exit(0);
	setpgrp();
#else
	setpgrp();
	/*signal(SIGHUP,SIG_IGN); moved out to above */
	if (fork()) exit(0);	/* first child exits (as per Stevens, */
	/* UNIX Network Programming, p. 79-80) */
	/* second child process continues as daemon */
d2797 1
a2797 7
#ifdef MIPS_BSD
	/* required on BSD side of MIPS OS <jmsellen@@watdragon.waterloo.edu> */
#	include <sysv/sys.s>
	syscall(SYS_setpgrp);
#endif
	setpgrp(0,0);
/*	setpgrp(0,getpid());*/	/* put process in our own pgrp */
d2801 6
a2806 6
	ttyfd = open("/dev/tty", O_RDWR);
	if (ttyfd >= 0) {
		/* zap controlling terminal if we had one */
		(void) ioctl(ttyfd, TIOCNOTTY, (char *)0);
		(void) close(ttyfd);
	}
d2811 1
a2811 1
	return(TCL_OK);
d2842 1
a2842 1
		debuglog("overlay: mapping fd %d to %d\r\n",oldfd,newfd);
d2844 1
a2844 1
		else debuglog("warning: overlay: old fd == new fd (%d)\r\n",oldfd);
a2862 1
#if 0
d2865 1
a2865 1
cmdReady(clientData, interp, argc, argv)
d2868 2
a2869 2
int argc;
char **argv;
d2871 27
a2897 49
	char num[4];	/* can hold up to "999 " */
	char buf[1024];	/* can easily hold 256 spawn_ids! */
	int i, j;
	int *masters, *masters2;
	int timeout = get_timeout();

	if (argc < 2) {
		exp_error(interp,"usage: ready spawn_id1 [spawn_id2 ...]");
		return(TCL_ERROR);
	}

	masters = (int *)ckalloc((argc-1)*sizeof(int));
	masters2 = (int *)ckalloc((argc-1)*sizeof(int));

	for (i=1;i<argc;i++) {
		j = atoi(argv[i]);
		if (!exp_fd2f(interp,j,1,"ready")) {
			ckfree(masters);
			return(TCL_ERROR);
		}
		masters[i-1] = j;
	}
	j = i-1;
	if (TCL_ERROR == ready(masters,i-1,masters2,&j,&timeout))
		return(TCL_ERROR);

	/* pack result back into out-array */
	buf[0] = '\0';
	for (i=0;i<j;i++) {
		sprintf(num,"%d ",masters2[i]); /* note extra blank */
		strcat(buf,num);
	}
	ckfree(masters); ckfree(masters2);
	Tcl_Return(interp,buf,TCL_VOLATILE);
	return(TCL_OK);
}
#endif

/*ARGSUSED*/
int
Exp_InterpreterCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	if (argc != 1) {
		exp_error(interp,"no arguments allowed");
		return(TCL_ERROR);
d2899 1
d2901 5
a2905 3
	return(exp_interpreter(interp));
	/* errors and ok, are caught by exp_interpreter() and discarded */
	/* to return TCL_OK, type "return" */
d2917 5
a2921 5
	if (argc == 1) {
		return EXP_CONTINUE;
	} else if ((argc == 2) && (0 == strcmp(argv[1],"-continue_timer"))) {
		return EXP_CONTINUE_TIMER;
	}
d2923 2
a2924 2
	exp_error(interp,"usage: exp_continue [-continue_timer]\n");
	return(TCL_ERROR);
a2926 20
#if TCL_MAJOR_VERSION < 8
/* most of this is directly from Tcl's definition for return */
/*ARGSUSED*/
int
Exp_InterReturnCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	/* let Tcl's return command worry about args */
	/* if successful (i.e., TCL_RETURN is returned) */
	/* modify the result, so that we will handle it specially */

	int result = Tcl_ReturnCmd(clientData,interp,argc,argv);
	if (result == TCL_RETURN)
		result = EXP_TCL_RETURN;
	return result;
}
#else
a2944 1
#endif
d2954 21
a2974 5
	struct exp_f *f;
	int m = -1;
	int m2;
	int leaveopen = FALSE;
	Tcl_Channel chan;
d2976 6
a2981 1
	argc--; argv++;
d2983 5
a2987 13
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-i")) {
			argc--; argv++;
			if (!*argv) {
				exp_error(interp,"usage: -i spawn_id");
				return TCL_ERROR;
			}
			m = atoi(*argv);
		} else if (streq(*argv,"-leaveopen")) {
			leaveopen = TRUE;
			argc--; argv++;
		} else break;
	}
d2989 6
a2994 24
	if (m == -1) {
		if (exp_update_master(interp,&m,0,0) == 0) return TCL_ERROR;
	}

	if (0 == (f = exp_fd2f(interp,m,1,0,"exp_open"))) return TCL_ERROR;

	/* make a new copy of file descriptor */
	if (-1 == (m2 = dup(m))) {
		exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
		return TCL_ERROR;
	}

	if (!leaveopen) {
		/* remove from Expect's memory in anticipation of passing to Tcl */
		if (f->pid != EXP_NOPID) {
#if TCL_MAJOR_VERSION < 8
			Tcl_DetachPids(1,&f->pid);
#else
			Tcl_DetachPids(1,(Tcl_Pid *)&f->pid);
#endif
			f->pid = EXP_NOPID;
			f->sys_waited = f->user_waited = TRUE;
		}
		exp_close(interp,m);
d2996 2
d2999 13
a3011 9
	chan = Tcl_MakeFileChannel(
#if TCL_MAJOR_VERSION < 8
			    (ClientData)m2,
#endif
			    (ClientData)m2,
			    TCL_READABLE|TCL_WRITABLE);
	Tcl_RegisterChannel(interp, chan);
	Tcl_AppendResult(interp, Tcl_GetChannelName(chan), (char *) NULL);
	return TCL_OK;
a3034 3
#if TCL_MAJOR_VERSION < 8
	Interp *iPtr = (Interp *) interp;
#else
a3036 1
#endif
a3039 12
#if TCL_MAJOR_VERSION < 8
		int create = FALSE;
		/* if already defined, don't redefine */
		if (c->flags & EXP_REDEFINE) create = TRUE;
		else if (!Tcl_FindHashEntry(&iPtr->commandTable,c->name)) {
			create = TRUE;
		}
		if (create) {
			Tcl_CreateCommand(interp,c->name,c->proc,
				c->data,exp_deleteProc);
		}
#else
a3050 1
#endif
a3055 4
#if TCL_MAJOR_VERSION < 8
			Tcl_CreateCommand(interp,cmdnamebuf,c->proc,
				c->data,exp_deleteProc);
#else
a3061 1
#endif
a3066 3
#if TCL_MAJOR_VERSION < 8
{"close",	Exp_CloseCmd,	0,	EXP_REDEFINE},
#else
a3067 1
#endif
d3078 1
a3078 1
{"interpreter",	exp_proc(Exp_InterpreterCmd),	0,	0},
a3082 3
#if TCL_MAJOR_VERSION < 8
{"inter_return",Exp_InterReturnCmd,	0,	0},
#else
d3084 2
a3085 3
#endif
{"send",	exp_proc(Exp_SendCmd),	(ClientData)&sendCD_proc,	0},
{"send_error",	exp_proc(Exp_SendCmd),	(ClientData)&sendCD_error,	0},
d3087 2
a3088 2
{"send_tty",	exp_proc(Exp_SendCmd),	(ClientData)&sendCD_tty,	0},
{"send_user",	exp_proc(Exp_SendCmd),	(ClientData)&sendCD_user,	0},
d3099 1
a3099 1
	exp_create_commands(interp,cmd_data);
d3102 1
a3102 1
	Tcl_InitHashTable(&slaveNames,TCL_STRING_KEYS);
a3103 2

	exp_close_in_child = exp_close_tcl_files;
@


5.30.2.1
log
@Initial 8.1 changes.
@
text
@a161 1
	char buffer[2000];
d164 2
d167 1
a167 2
	vsprintf(buffer,fmt,args);
	Tcl_SetResult(interp,buffer,TCL_VOLATILE);
d474 8
d847 3
d853 28
d889 4
d896 1
d899 4
d906 1
d2332 3
d2338 9
d2353 4
d2361 2
d2629 3
d2633 1
d2641 3
d2645 1
d2649 3
d2653 1
d2687 3
d2691 1
d2954 3
d2958 1
d3341 20
d3379 1
d3426 3
d3430 1
d3438 3
d3469 3
d3474 1
d3478 12
d3501 1
d3507 4
d3517 1
d3523 3
d3527 1
d3543 3
d3547 1
@


5.30.2.2
log
@Added Exp channel driver and modified rest to support it.
@
text
@d107 3
a138 15
typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    ExpState *stdinout;
    ExpState *stderr;
    ExpState *devtty;
    ExpState *any; /* for any_spawn_id */
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
ExpState any_placeholder;

d171 3
a173 4
/* returns ExpState if channel is usable, 0 if not */
/* this replaces exp_fd2f */
ExpState *
expGetState(interp,chan,opened,adjust,msg)
d175 1
a175 1
Tcl_Channel chan;
d180 10
a189 1
    ExpState *esPtr = Tcl_GetChannelInstanceData(chan);
d191 2
a192 8
    /* following is a little tricky, do not be tempted do the */
    /* 'usual' boolean simplification */
    if ((!opened) || !esPtr->user_closed) {
	if (adjust) exp_adjust(esPtr);
	return esPtr;
    }
    exp_error(interp,"%s: invalid spawn id (%d)",msg,esPtr->name);
    return(0);
d195 13
a207 10
ExpState *
expCheckState(interp,esPtr,opened,adjust,msg)
    /* following is a little tricky, do not be tempted do the */
    /* 'usual' boolean simplification */
    if ((!opened) || !esPtr->user_closed) {
	if (adjust) exp_adjust(esPtr);
	return esPtr;
    }
    exp_error(interp,"%s: invalid spawn id (%d)",msg,esPtr->name);
    return(0);
d209 1
a225 2
/* I believe this busy nonsense can disappear but haven't thought about it
   enough to be positive */
d241 1
a241 1
exp_state_prep_for_invalidation(interp,esPtr)
d243 1
a243 1
ExpState *esPtr;
d245 3
a247 1
	exp_ecmd_remove_state_direct_and_indirect(interp,esPtr);
d251 10
a260 6
	
	if (esPtr->buffer) {
		Tcl_DecrRefCount(esPtr->buffer);
		if (esPtr->fg_armed) {
			exp_event_disarm(esPtr);
			esPtr->fg_armed = FALSE;
d262 1
d264 1
a264 1
	esPtr->fg_armed = FALSE;
d284 1
a284 1
	ExpState *esPtr;
d293 2
a294 1
	esPtr = (ExpState *)Tcl_GetHashValue(entry);
d296 1
a296 1
	exp_slave_control(master->fdin,0);
d298 1
a298 1
	return master->fdin;
d306 3
a308 2
expSysClose(esPtr)
ExpState *esPtr;
d314 2
a315 2
	close(esPtr->fd);
	esPtr->sys_closed = TRUE;
d318 1
a318 1
	if (esPtr->slave_name) {
d321 1
a321 1
		entry = Tcl_FindHashEntry(&slaveNames,esPtr->slave_name);
d324 2
a325 2
		ckfree(esPtr->slave_name);
		esPtr->slave_name = 0;
d337 16
d356 20
d377 1
a377 1
exp_close(interp,esPtr);
d379 1
a379 1
ExpState *esPtr;
d381 2
a382 1
    if (0 == expCheckState(interp,esPtr,1,0,"close")) return TCL_ERROR;
d384 1
a384 1
    esPtr->user_closed = TRUE;
d386 8
a393 2
    if (esPtr->fd_slave != EXP_NOFD) close(esPtr->fd_slave);
    expSysClose(esPtr);
d395 2
a396 2
    if (esPtr->channel_orig) {
	if (esPtr->fdin == esPtr->fdout) close(esPtr->fdout);
d398 6
a403 6
	if (!esPtr->leaveopen) {
	    /*
	     * Ignore errors from close; they report things like
	     * broken pipeline, etc, which don't affect our
	     * subsequent handling.
	     */
d405 1
a405 1
	    close_tcl_file(interp,esPtr->channel_orig);
d407 3
a409 2
	    ckfree(esPtr->channel_orig);
	    esPtr->channel_orig = 0;
a410 1
    }
d412 1
a412 1
    exp_state_prep_for_invalidation(interp,esPtr);
d414 6
a419 6
    if (esPtr->user_waited) {
	Tcl_UnregisterChannel(interp,channel);
    } else {
	exp_busy(esPtr->fdin);
	esPtr->sys_closed = FALSE;
    }
d421 1
a421 1
    return(TCL_OK);
d424 4
a427 2
void
exp_init_send(interp)
d429 2
a430 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d432 19
a450 4
    /* for efficiency, create a null for exp_send -null command */
    tsdPtr->null = ckalloc(TCL_UTF_MAX);
    Tcl_UniCharToUtf((Tcl_UniChar)0,tsdPtr->null);
}
d452 6
a457 3
expIsStdinout(esPtr)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d459 2
a460 2
    return (tsdPtr->stdinout == esPtr);
}
d462 26
a487 3
expStdinout()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d489 1
a489 1
    return tsdPtr->stdinout;
d492 12
a503 5
expDevtty()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return tsdPtr->devtty;
d505 1
d511 2
a512 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d514 9
a522 14
    Tcl_SetVar(interp,"user_spawn_id", tsdPtr->stdinout->name,0);
    Tcl_SetVar(interp,"spawn_id",      tsdPtr->stdinout->name,0);
    Tcl_SetVar(interp,"error_spawn_id",tsdPtr->stderr->name,0);
    Tcl_SetVar(interp,"any_spawn_id",  "-1",0);

    /* note that the user_spawn_id is NOT /dev/tty which could */
    /* (at least in theory anyway) be later re-opened on a different */
    /* fd, while stdin might have been redirected away from /dev/tty */

    if (exp_dev_tty != -1) {
	char dev_tty_str[10];
	sprintf(dev_tty_str,"%d",exp_dev_tty);
	Tcl_SetVar(interp,"tty_spawn_id",tsdPtr->devtty->name,0);
    }
d528 10
a537 12
    /* note whether 0,1,2 are connected to a terminal so that if we */
    /* disconnect, we can shut these down.  We would really like to */
    /* test if 0,1,2 are our controlling tty, but I don't know any */
    /* way to do that portably.  Anyway, the likelihood of anyone */
    /* disconnecting after redirecting to a non-controlling tty is */
    /* virtually zero. */

    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey)

    tsdPtr->stdinout = expCreateChannel(0,1,isatty(0)?exp_getpid:EXP_NOPID);
    /* really should be in interpreter() but silly to do on every call */
    exp_adjust(tsdPtr->stdinout);
d539 3
a541 52
    /* hmm, now here's an example of a output-only descriptor!! */
    tsdPtr->stderr = expCreateChannel(2,2,isatty(2)?exp_getpid:EXP_NOPID);

    if (exp_dev_tty != -1) {
	tsdPtr->devtty = expCreateChannel(exp_dev_tty,exp_dev_tty,exp_getpid);
    }

    /* set up a dummy channel to give us something when we need to find out if
       people have passed us "any_spawn_id" */
    tsdPtr->any = &any_placeholder;
}

/* version of Tcl_GetChannel that handles any_spawn_id */
ExpState *
expGetChannel(interp,name)
    Tcl_Interp *interp;
    char *name;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (0 == strcmp(name,EXP_SPAWN_ID_ANY_LIT)) {
	return tsdPtr->any;
    }
    return(Tcl_GetChannel(interp,name,(char *)0));
}

/* report whether this ExpState represents special spawn_id_any */
/* we need a separate function because spawn_id_any is thread-specific */
/* and can't be seen outside this file */
expIsStateAny(esPtr)
    ExpState *esPtr;
{
    Tcl_ChannelType *channelTypePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (esPtr == tsdPtr->any);
}

expIsStateStdinout(esPtr)
    ExpState *esPtr;
{
    Tcl_ChannelType *channelTypePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (esPtr == tsdPtr->stdinout);
}

expIsStateDevtty(esPtr)
    ExpState *esPtr;
{
    Tcl_ChannelType *channelTypePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d543 2
a544 1
    return (esPtr == tsdPtr->devtty);
a556 2
/*
 * DEBUGGING UTILITIES - DON'T DELETE */
d586 2
a587 2
set_slave_name(esPtr,name)
ExpState *esPtr;
d595 2
a596 2
	esPtr->slave_name = ckalloc(strlen(exp_pty_slave_name)+1);
	strcpy(esPtr->slave_name,exp_pty_slave_name);
d599 1
a599 1
	Tcl_SetHashValue(entry,(ClientData)esPtr);
a659 1
	Tcl_Channel chan;
d803 1
d811 5
a815 1
			if (exp_ChannelCount > 10) {
d830 3
d850 3
a852 3
		    if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_READABLE, (ClientData) &rfd)) {
			return TCL_ERROR;
		    }
d855 3
a857 3
		    if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_WRITABLE, (ClientData) &wfd)) {
			return TCL_ERROR;
		    }    
d859 1
d864 2
a865 2
		    exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
		    return TCL_ERROR;
d870 5
a874 5
		    if (-1 == (write_master = dup(wfd))) {
			exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
			return TCL_ERROR;
		    }
		    exp_close_on_exec(write_master);
d885 4
a888 1
	
d890 22
a911 2
	    Tcl_Channel channel;
	    ExpState *esPtr;
d913 2
a914 7
	    channel = Exp_CreateChannel(master,write_master,EXP_NOPID);
	    esPtr = Tcl_GetChannelInstanceData(channel);
	    
	    if (openarg) {
		esPtr->channel_orig = channel; 
		esPtr->leaveopen = leaveopen;
	    }
d919 2
a920 2
		esPtr->sys_waited = TRUE;
		exp_wait_zero(&esPtr->wait);
d928 1
d935 18
a952 1
			if (0 > (esPtr->fd_slave = getptyslave(ttycopy,ttyinit,
d958 3
d963 1
a963 1
			sprintf(value,"%d",esPtr->fd_slave);
d972 2
a973 3
	if (NULL == (argv[0] = Tcl_TranslateFileName(interp, argv[0],
		&dstring))) {
	    goto parent_error;
d1001 1
a1001 2
	    Tcl_Channel channel;
	    ExpState *esPtr;
d1007 1
a1007 2
		channel = Exp_CreateChannel(master,master,pid);
		esPtr = Tcl_GetChannelInstanceData(channel);
d1009 1
a1009 1
		if (exp_pty_slave_name) set_slave_name(esPtr,exp_pty_slave_name);
d1015 42
d1381 18
a1398 13
    struct exp_f *f;
    char *chanName = 0;
    ExpState *esPtr = 0;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) goto usage;
	    chanName = argv;
	} else goto usage;
    }
d1400 5
a1404 11
    if (chanName) {
	if (!(esPtr = expGetState(interp,chan,1,0,"exp_pid"))) return TCL_ERROR;
    } else {
	if (!(esPtr = expGetCurrentState(interp,0,0))) return TCL_ERROR;
    }
    
    sprintf(interp->result,"%d",esPtr->pid);
    return TCL_OK;
    usage:
    exp_error(interp,"usage: -i spawn_id");
    return TCL_ERROR;
d1421 4
a1424 3
/* returns f or 0.  If 0, may be immediately followed by return TCL_ERROR. */
struct ExpState *
expGetCurrentState(interp,opened,adjust)
d1426 1
d1430 3
a1432 7
    char *s = exp_get_var(interp,SPAWN_ID_VARNAME);
    if (!s) return 0;

    chan = Tcl_GetChannel(interp,s,(int *)0);
    if (!chan) return 0;

    return(expGetState(interp,chan,opened,adjust,SPAWN_ID_VARNAME));
d1456 2
a1457 2
exact_write(esPtr,buffer,rembytes)
ExpState *esPtr;
a1462 1
/*SCOTT*/
d1464 1
a1464 1
		if (-1 == (cc = Tcl_Write(esPtr->channel,buffer,rembytes))) return(-1);
d1515 1
a1515 1
slow_write(interp,esPtr,buffer,rembytes,arg)
d1517 1
a1517 1
ExpState *esPtr;
a1526 2
/*SCOTT?*/

d1528 1
a1528 1
		if (0 > exact_write(esPtr,buffer,len)) return(-1);
d1614 1
a1614 1
human_write(interp,esPtr,buffer,arg)
d1616 1
a1616 1
ExpState *esPtr;
d1620 21
a1640 21
    char *sp;
    float t;
    float alpha;
    int wc;
    int in_word = TRUE;

    debuglog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
	    arg->alpha,arg->alpha_eow,arg->c,arg->min,arg->max);

    for (sp = buffer;*sp;sp++) {
	/* use the end-of-word alpha at eow transitions */
	if (in_word && (ispunct(*sp) || isspace(*sp)))
	    alpha = arg->alpha_eow;
	else alpha = arg->alpha;
	in_word = !(ispunct(*sp) || isspace(*sp));

	t = alpha * pow(-log((double)unit_random()),arg->c);

	/* enforce min and max times */
	if (t<arg->min) t = arg->min;
	else if (t>arg->max) t = arg->max;
d1642 1
d1644 7
a1650 3
	if (sp != buffer) {
	    wc = exp_dsleep(interp,(double)t);
	    if (wc > 0) return wc;
d1652 1
a1652 6

/*SCOTT?*/
	wc = write(fd,sp,1);
	if (0 > wc) return(wc);
    }
    return(0);
d1656 1
a1656 1
struct exp_state_list *exp_state_list_pool = 0;
d1683 1
a1683 1
	i->state_list = 0;
d1689 2
a1690 2
struct exp_state_list *
exp_new_state(val)
d1694 1
a1694 1
	struct exp_state_list *fd;
d1696 1
a1696 1
	if (!exp_state_list_pool) {
d1698 2
a1699 2
		exp_state_list_pool = fd = (struct exp_state_list *)ckalloc(
			EXP_FD_INIT_COUNT * sizeof(struct exp_state_list));
d1708 3
a1710 3
	fd = exp_state_list_pool;
	exp_state_list_pool = exp_state_list_pool->next;
	fd->esPtr = val;
d1716 2
a1717 2
exp_free_state(fd_first)
struct exp_state_list *fd_first;
d1719 1
a1719 1
	struct exp_state_list *fd, *penultimate;
d1730 2
a1731 2
	penultimate->next = exp_state_list_pool;
	exp_state_list_pool = fd_first;
d1736 2
a1737 2
exp_free_state_single(fd)
struct exp_state_list *fd;
d1739 2
a1740 2
	fd->next = exp_state_list_pool;
	exp_state_list_pool = fd;
d1751 1
a1751 1
	exp_free_fd(i->state_list);
d1814 1
a1814 1
	i->state_list = 0;
d1829 1
a1829 1
exp_i_add_state(i,esPtr)
d1831 1
a1831 1
ExpState *esPtr;
d1833 1
a1833 1
	struct exp_state_list *new_state;
d1835 3
a1837 3
	new_state = exp_new_state(esPtr);
	new_state->next = i->state_list;
	i->state_list = new_state;
d1840 1
a1840 1
/* this routine assumes i->esPtr is meaningful */
d1842 1
a1842 1
exp_i_parse_states(i)
d1845 1
a1845 1
    char *p = i->value;
d1847 5
a1851 6
/*SCOTT*/
    /* reparse it */
    while (1) {
	int m;
	int negative = 0;
	int valid_spawn_id = 0;
d1853 9
a1861 9
	m = 0;
	while (isspace(*p)) p++;
	for (;;p++) {
	    if (*p == '-') negative = 1;
	    else if (isdigit(*p)) {
		m = m*10 + (*p-'0');
		valid_spawn_id = 1;
	    } else if (*p == '\0' || isspace(*p)) break;
	}
d1863 1
a1863 1
	/* we either have a spawn_id or whitespace at end of string */
d1865 2
a1866 2
	/* skip whitespace end-of-string */
	if (!valid_spawn_id) break;
d1868 1
a1868 1
	if (negative) m = -m;
d1870 2
a1871 2
	exp_i_add_state(i,m);
    }
d1898 2
a1899 2
		exp_free_fd(i->state_list);
		i->state_list = 0;
d1903 1
a1903 1
		i->state_list = 0;
d1905 1
a1905 1
	exp_i_parse_states(i);
d1909 2
a1910 2
exp_new_i_simple(esPtr,duration)
ExpState *esPtr;
d1921 1
a1921 1
	exp_i_add_state(i,esPtr);
d1967 1
a1967 1
Exp_SendObjCmd(clientData, interp, objc, objv)
d1970 2
a1971 2
int objc;
Tcl_Obj *CONST objv[];
d1973 4
a1976 5
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr = 0;
    int rc; 	/* final result of this procedure */
    struct human_arg human_args;
    struct slow_arg slow_args;
d1983 5
a1987 71
    int send_style = SEND_STYLE_PLAIN;
    int want_cooked = TRUE;
    char *string;		/* string to send */
    int len = -1;		/* length of string to send */
    int zeros;		/* count of how many ascii zeros to send */

    char *i_masters = 0;
    struct exp_state_list *state_list;
    struct exp_i *i;
    int j;
    char *arg;

    static char *options[] = {
	"-i", "-h",	"-s", "-null", "-0", "-raw", "-break", "--", (char *) NULL
    };
    enum options {
	SEND_SPAWNID, SEND_HUMAN, SEND_SLOW, SEND_NULL, SEND_ZERO,
	SEND_RAW, SEND_BREAK, SEND_LAST
    };

    for (j = 1; j < objc; j++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[j]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[j], options, "flag", 0,
		&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case SEND_SPAWNID:
		j++;
		if (j >= objc) {
		    exp_error(interp,"usage: -i spawn_id");
		    return TCL_ERROR;
		}
		i_masters = Tcl_GetString(objv[j]);
		break;

	    case SEND_LAST:
		j++;
		break;

	    case SEND_HUMAN:
		if (-1 == get_human_args(interp,&human_args))
		    return(TCL_ERROR);
		send_style = SEND_STYLE_HUMAN;
		break;

	    case SEND_SLOW:
		if (-1 == get_slow_args(interp,&slow_args))
		    return(TCL_ERROR);
		send_style = SEND_STYLE_SLOW;
		break;

	    case SEND_NULL:
	    case SEND_ZERO:
		j++;
		if (j >= objc) {
		    zeros = 1;
		} else if (Tcl_GetIntFromObj(interp, objv[j], &zeros)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		if (zeros < 1) return TCL_OK;
		send_style = SEND_STYLE_ZERO;
		string = "<zero(s)>";
		break;
d1989 4
a1992 3
	    case SEND_RAW:
		want_cooked = FALSE;
		break;
d1994 54
a2047 4
	    case SEND_BREAK:
		send_style = SEND_STYLE_BREAK;
		string = "<break>";
		break;
a2048 1
    }
d2050 6
a2055 4
    if (send_style & SEND_STYLE_STRING_MASK) {
	if (j != objc-1) {
	    exp_error(interp,"usage: send [args] string");
	    return TCL_ERROR;
a2056 2
	string = Tcl_GetStringFromObj(objv[j], &len);
    } else {
a2057 1
    }
d2059 13
a2071 9
    if (clientData == &sendCD_user) esPtr = tsdPtr->stdinout;
    else if (clientData == &sendCD_error) esPtr = tsdPtr->stderr;
    else if (clientData == &sendCD_tty) esPtr = tsdPtr->devtty;
    else if (!i_masters) {
	/* we want to check if it is open */
	/* but since stdin could be closed, we have to first */
	/* get the fd and then convert it from 0 to 1 if necessary */
	if (!(esPtr = expGetCurrentState(interp,0,0))) return(TCL_ERROR);
    }
d2073 5
a2077 5
    if (esPtr) {
	i = exp_new_i_simple(esPtr,EXP_TEMPORARY);
    } else {
	i = exp_new_i_complex(interp,i_masters,FALSE,(Tcl_VarTraceProc *)0);
    }
d2084 31
a2114 12
    if (send_to_proc) {
	want_cooked = FALSE;
	debuglog("send: sending \"%s\" to {",dprintify(string));
	/* if closing brace doesn't appear, that's because an error */
	/* was encountered before we could send it */
    } else {
/*SCOTT*/
	if (debugfile)
	    fwrite(string,1,len,debugfile);
	if ((send_to_user && logfile_all) || logfile)
	    fwrite(string,1,len,logfile);
    }
d2116 1
a2116 2
    for (state_list=i->state_list;state_list;state_list=state_list->next) {
	esPtr = state_list->esPtr;
d2118 20
a2137 3
	if (send_to_proc) {
	    debuglog(" %s ",esPtr->name);
	}
d2139 7
a2145 36
	/* check validity of each - i.e., are they open */
	if (0 == expCheckState(interp,esPtr,1,0,"send")) {
	    rc = TCL_ERROR;
	    goto finish;
	}
	if (want_cooked) string = exp_cook(string,&len);

	switch (send_style) {
	    case SEND_STYLE_PLAIN:
		rc = exact_write(esPtr,string,len);
		break;
	    case SEND_STYLE_SLOW:
		rc = slow_write(interp,esPtr,string,len,&slow_args);
		break;
	    case SEND_STYLE_HUMAN:
		rc = human_write(interp,esPtr,string,&human_args);
		break;
	    case SEND_STYLE_ZERO:
		for (;zeros>0;zeros--) {
		    rc = Tcl_WriteChar(esPtr->channel,tsdPtr->null);
		}
		/* catching error on last write is sufficient */
		rc = ((rc==1) ? 0 : -1);   /* normal is 1 not 0 */
		break;
	    case SEND_STYLE_BREAK:
		exp_tty_break(interp,esPtr->fdout);
		rc = 0;
		break;
	}

	if (rc != 0) {
	    if (rc == -1) {
		exp_error(interp,"write(spawn_id=%d): %s",esPtr->fdout,Tcl_PosixError(interp));
		rc = TCL_ERROR;
	    }
	    goto finish;
d2147 1
a2147 2
    }
    if (send_to_proc) debuglog("}\r\n");
d2149 1
a2149 1
    rc = TCL_OK;
d2151 2
a2152 2
    exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
    return rc;
d2553 3
d2558 1
a2558 1
Exp_CloseObjCmd(clientData, interp, objc, objv)
d2561 2
a2562 2
int objc;
Tcl_Obj *CONST objv[];	/* Argument objects. */
d2564 7
a2570 4
    int onexec_flag = FALSE;	/* true if -onexec seen */
    int close_onexec;
    int slave_flag = FALSE;
    ExpState *esPtr = 0;
d2572 1
a2572 2
    int objc_orig = objc;
    Tcl_Obj *CONST *objv_orig = objv;
a2573 1
    objc--; objv++;
d2576 34
a2609 20
    for (;objc>0;objc--,argv++) {
	if (streq("-i",STARARGV)) {
	    objc--; argv++;
	    if (objc == 0) {
		exp_error(interp,"usage: -i spawn_id");
		return(TCL_ERROR);
	    }
	    chanName = STARARGV;
	} else if (streq(STARARGV,"-slave")) {
	    slave_flag = TRUE;
	} else if (streq(STARARGV,"-onexec")) {
	    objc--; argv++;
	    if (objc == 0) {
		exp_error(interp,"usage: -onexec 0|1");
		return(TCL_ERROR);
	    }
	    onexec_flag = TRUE;
	    close_onexec = atoi(STARARGV);
	} else break;
    }
d2611 2
a2612 10
    if (objc) {
	/* doesn't look like our format, it must be a Tcl-style file */
	/* handle.  Lucky that formats are easily distinguishable. */
	/* Historical note: we used "close"  long before there was a */
	/* Tcl builtin by the same name. */

	Tcl_CmdInfo info;
	Tcl_ResetResult(interp);
	if (0 == Tcl_GetCommandInfo(interp,"close",&info)) {
	    info.clientData = 0;
a2613 2
	return(Tcl_CloseObjCmd(info.clientData,interp,objc_orig,argv_orig));
    }
d2615 3
a2617 6
    if (chanName) {
	if (!(chan = Tcl_GetChannel(interp,chanName,(char *)0))) return TCL_ERROR;
	if (!(esPtr = expGetState(interp,chan,1,0,"close"))) return TCL_ERROR;
    } else {
	if (!(esPtr = expGetCurrentState(interp,1,0))) return TCL_ERROR;
    }
d2619 3
a2621 4
    if (slave_flag) {
	if (esPtr->fd_slave != EXP_NOFD) {
	    close(esPtr->fd_slave);
	    esPtr->fd_slave = EXP_NOFD;
d2623 1
a2623 1
	    exp_slave_control(esPtr->fdin,1);
d2625 5
a2629 4
	    return TCL_OK;
	} else {
	    exp_error(interp,"no such slave");
	    return TCL_ERROR;
a2630 1
    }
d2632 6
a2637 6
    if (onexec_flag) {
	/* heck, don't even bother to check if fd is open or a real */
	/* spawn id, nothing else depends on it */
	fcntl(esPtr->fdin,F_SETFD,close_onexec);
	return TCL_OK;
    }
d2639 1
a2639 1
    return(exp_close(interp,esPtr));
d2820 6
a2825 5
    char *chanName = 0;
    struct ExpState *esPtr;
    struct forked_proc *fp = 0;	/* handle to a pure forked proc */
    struct ExpState esTmp;	/* temporary memory for either f or fp */
    char spawn_id[20];
d2827 2
a2828 2
    int nowait = FALSE;
    int result = 0;		/* 0 means child was successfully waited on */
d2833 14
a2846 12
    argv++;
    argc--;
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (argc==0) {
		exp_error(interp,"usage: -i spawn_id");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else if (streq(*argv,"-nowait")) {
	    nowait = TRUE;
a2847 1
    }
d2849 4
a2852 5
    if (!chanName) {
	if (!(esPtr = expGetCurrentState(interp,0,0))) return TCL_ERROR;
    } else {
	if (!(esPtr = expGetChannel(interp,chanName))) return TCL_ERROR;
    }
d2854 3
a2856 28
    if (!expIsStateAny(esPtr)) {
	if (0 == expCheckState(interp,esPtr,0,0,"wait")) return TCL_ERROR;

	/* check if waited on already */
	/* things opened by "open" or set with -nowait */
	/* are marked sys_waited already */
	if (!esPtr->sys_waited) {
	    if (nowait) {
		/* should probably generate an error */
		/* if SIGCHLD is trapped. */

		/* pass to Tcl, so it can do wait */
		/* in background */
		Tcl_DetachPids(1,(Tcl_Pid *)&esPtr->pid);
		exp_wait_zero(&esPtr->wait);
	    } else {
		while (1) {
		    if (Tcl_AsyncReady()) {
			int rc = Tcl_AsyncInvoke(interp,TCL_OK);
			if (rc != TCL_OK) return(rc);
		    }

		    result = waitpid(esPtr->pid,&esPtr->wait,0);
		    if (result == esPtr->pid) break;
		    if (result == -1) {
			if (errno == EINTR) continue;
			else break;
		    }
a2857 2
	    }
	}
d2859 1
a2859 8
	/*
	 * Now have Tcl reap anything we just detached. 
	 * This also allows procs user has created with "exec &"
	 * and and associated with an "exec &" process to be reaped.
	 */
	
	Tcl_ReapDetachedProcs();
	exp_rearm_sigchld(interp); /* new */
d2861 27
a2887 24
	strcpy(spawn_id,esPtr->name);
    } else {
	/* wait for any of our own spawned processes */
	/* we call waitpid rather than wait to avoid running into */
	/* someone else's processes.  Yes, according to Ousterhout */
	/* this is the best way to do it. */

	int waited_on_forked_process = 0;

	esPtr = expWaitOnAny(interp);
	if (!esPtr) {
	    /* if it's not a spawned process, maybe its a forked process */
	    for (fp=forked_proc_base;fp;fp=fp->next) {
		if (fp->link_status == not_in_use) continue;
	restart:
		result = waitpid(fp->pid,&fp->wait_status,WNOHANG);
		if (result == fp->pid) {
		    waited_on_forked_process = 1;
		    break;
		}
		if (result == 0) continue;	/* busy, try next */
		if (result == -1) {
		    if (errno == EINTR) goto restart;
		    else break;
a2888 1
	    }
a2889 1
	    if (waited_on_forked_process) {
d2891 3
a2893 2
		 * The literal spawn id in the return value from wait appears
		 * as a -1 to indicate a forked process was waited on.  
d2895 1
a2895 3
		strcpy(spawn_id,"-1");
	    } else {
		result = NO_CHILD;	/* no children */
d2897 44
a2940 2
	    }
	    exp_rearm_sigchld(interp);
a2941 1
    }
d2943 8
a2950 8
    /*  sigh, wedge forked_proc into an exp_f structure so we don't
     *  have to rewrite remaining code (too much)
     */
    if (fp) {
	esPtr = &esTmp;
	esPtr->pid = fp->pid;
	esPtr->wait = fp->wait_status;
    }
d2952 21
a2972 20
    /* non-portable assumption that pid_t can be printed with %d */

    if (result == -1) {
	sprintf(interp->result,"%d %s -1 %d POSIX %s %s",
		esPtr->pid,spawn_id,errno,Tcl_ErrnoId(),Tcl_ErrnoMsg(errno));
	result = TCL_OK;
    } else if (result == NO_CHILD) {
	exp_error(interp,"no children");
	return TCL_ERROR;
    } else {
	sprintf(interp->result,"%d %s 0 %d",
		esPtr->pid,spawn_id,WEXITSTATUS(esPtr->wait));
	if (WIFSIGNALED(esPtr->wait)) {
	    Tcl_AppendElement(interp,"CHILDKILLED");
	    Tcl_AppendElement(interp,Tcl_SignalId((int)(WTERMSIG(esPtr->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WTERMSIG(esPtr->wait))));
	} else if (WIFSTOPPED(esPtr->wait)) {
	    Tcl_AppendElement(interp,"CHILDSUSP");
	    Tcl_AppendElement(interp,Tcl_SignalId((int) (WSTOPSIG(esPtr->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WSTOPSIG(esPtr->wait))));
a2973 1
    }
d2975 4
a2978 4
    if (fp) {
	fp->link_status = not_in_use;
	return ((result == -1)?TCL_ERROR:TCL_OK);		
    }
d2980 2
a2981 2
    esPtr->sys_waited = TRUE;
    esPtr->user_waited = TRUE;
d2983 7
a2989 5
    /* if user has already called close, make sure fd really is closed */
    /* and forget about this entry entirely */
    if (esPtr->user_closed) {
	if (!esPtr->sys_closed) {
	    expSysClose(esPtr);
d2991 1
a2991 3
	Tcl_UnregisterChannel(interp,esPtr->channel);
    }
    return ((result == -1)?TCL_ERROR:TCL_OK);
d3061 1
a3061 9

	/* if we're in a child that's about to be disconnected from the
	   controlling tty, close and reopen 0, 1, and 2 but associated
	   with /dev/null.  This prevents send and expect_user doing
	   special things if newly spawned processes accidentally
	   get allocated 0, 1, and 2.
	*/
	   
	if (isatty(0)) {
d3064 1
a3064 1
		Exp_CreateChannel(0,1,EXP_NOPID);
d3066 6
a3071 1
	if (isatty(2)) {
d3075 1
a3075 1
		Exp_CreateChannel(2,2,EXP_NOPID);
d3170 47
d3281 21
a3301 2
    ExpState *esPtr;
    char *chanName;
d3303 3
a3305 19
    int newfd;
    int leaveopen = FALSE;
    Tcl_Channel chan;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) {
		exp_error(interp,"usage: -i spawn_id");
		return TCL_ERROR;
	    }
	    chanName = *argv;
	} else if (streq(*argv,"-leaveopen")) {
	    leaveopen = TRUE;
	    argc--; argv++;
	} else break;
    }
d3307 1
a3307 8
    if (!chanName) {
	if (!(esPtr = expGetCurrentState(interp,0,0))) return TCL_ERROR;
    } else {
	if (!(chan = Tcl_GetChannel(interp,chanName,(char *)0))) return
								     TCL_ERROR;
	if (!(esPtr = expGetState(interp,chan,0,0,"exp_open"))) return
								    TCL_ERROR;
    }
d3309 5
a3313 5
    /* make a new copy of file descriptor */
    if (-1 == (newfd = dup(esPtr->fdin))) {
	exp_error(interp,"dup: %s",Tcl_PosixError(interp));
	return TCL_ERROR;
    }
d3315 8
a3322 6
    if (!leaveopen) {
	/* remove from Expect's memory in anticipation of passing to Tcl */
	if (esPtr->pid != EXP_NOPID) {
	    Tcl_DetachPids(1,(Tcl_Pid *)&esPtr->pid);
	    esPtr->pid = EXP_NOPID;
	    esPtr->sys_waited = esPtr->user_waited = TRUE;
a3323 2
	exp_close(interp,esPtr);
    }
d3325 3
a3327 10
    /*
     * Tcl's MakeFileChannel only allows us to pass a single file descriptor
     * but that shouldn't be a problem in practice since all of the channels
     * that Expect generates only have one fd.  Of course, this code won't
     * work if someone creates a pipeline, then passes it to spawn, and then
     * again to exp_open.  For that to work, Tcl would need a new API.
     * Oh, and we're also being rather cavalier with the permissions here,
     * but they're likely to be right for the same reasons.
     */
    chan = Tcl_MakeFileChannel((ClientData)newfd,TCL_READABLE|TCL_WRITABLE);
d3403 2
a3404 2
{"send",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_proc,0},
{"send_error",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_error,0},
d3406 2
a3407 2
{"send_tty",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_tty,0},
{"send_user",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_user,0},
@


5.30.2.3
log
@modified expect command to use new regexp interfaces, made various
I18N changes
@
text
@a90 7
/*
 * These constants refer to the UTF string that encodes a null character.
 */

#define NULL_STRING "\xC0\x80"
#define NULL_LENGTH 2

d380 10
d1333 1
a1333 1
exact_write(esPtr,buffer,rembytes) /* INTL */
d1339 2
d1342 1
a1342 1
		if (-1 == (cc = Tcl_WriteChars(esPtr->channel,buffer,rembytes))) return(-1);
d1393 1
a1393 1
slow_write(interp,esPtr,buffer,rembytes,arg) /* INTL */
d1404 3
a1406 1
		
d1494 1
a1494 1
human_write(interp,esPtr,buffer,arg) /* INTL */
a1500 1
    int size;
a1504 1
    Tcl_UniChar ch;
d1509 1
a1509 2
    for (sp = buffer;*sp;sp += size) {
	size = Tcl_UtfToUniChar(sp, &ch);
d1511 1
a1511 1
	if (in_word && (Tcl_UniCharIsPunct(ch) || Tcl_UniCharIsSpace(ch)))
d1514 1
a1514 1
	in_word = !(Tcl_UniCharIsPunct(ch) || Tcl_UniCharIsSpace(ch));
d1528 2
a1529 1
	wc = Tcl_WriteChars(esPtr->channel, sp, size);
d1722 1
a1722 1
exp_i_parse_states(i) /* INTL */
a1725 2
    int argc;
    char **argv;
d1727 23
a1749 3
    if (Tcl_SplitList(NULL, p, &argc, &argv) != TCL_OK) {
	return;
    }
d1751 1
a1751 2
    for (i = 0; i < argc; i++) {
	exp_i_add_state(i,argv[i]);
a1752 1
    ckfree((char*)argv);
d1786 1
a1786 1
	exp_i_parse_states(interp, i);
d1848 1
a1848 1
Exp_SendObjCmd(clientData, interp, objc, objv) /* INTL */
d1985 1
d1987 1
a1987 1
	    Tcl_WriteChars(debugfile, string, len);
d1989 1
a1989 1
	    Tcl_WriteChars(logfile, string, len);
d2018 1
a2018 2
		    rc = Tcl_WriteChars(esPtr->channel,
			    NULL_STRING, NULL_LENGTH);
@


5.30.2.4
log
@got rid of remaining references to exp_fs and friends and exp_update_masters
@
text
@d190 4
a193 4
/* returns current master (via out-parameter) */
/* returns f or 0.  If 0, may be immediately followed by return TCL_ERROR. */
struct ExpState *
expGetCurrentState(interp,opened,adjust)
d195 4
a198 16
int opened;
int adjust;
{
    char *name = exp_get_var(interp,SPAWN_ID_VARNAME);
    if (!name) return 0;

    return expGetStateFromChannelName(interp,name,opened,adjust,SPAWN_ID_VARNAME);
}

ExpState *
expGetStateFromChannelName(interp,name,opened,adjust,msg)
    Tcl_Interp *interp,
    char *name;
    int opened;
    int adjust;
    char *msg;
a201 3
    Tcl_Channel channel = Tcl_GetChannel(interp,name,(int *)0);
    if (!channel) return(0);

d239 16
a254 1
/* called just before an ExpState entry is about to be invalidated */
d291 9
a299 3
    int master;
    ExpState *esPtr;
    int enable = 0;
d301 1
a301 5
    Tcl_HashEntry *entry = Tcl_FindHashEntry(&slaveNames,name);
    if (!entry) {
	debuglog("exp_trap_off: no entry found for %s\n",name);
	return -1;
    }
d303 1
a303 3
    esPtr = (ExpState *)Tcl_GetHashValue(entry);
    
    exp_slave_control(master->fdin,0);
d305 1
a305 1
    return master->fdin;
d307 1
a307 1
    return name[0];	/* pacify lint, use arg and return something */
d316 6
a321 6
    /* Ignore close errors.  Some systems are really odd and */
    /* return errors for no evident reason.  Anyway, receiving */
    /* an error upon pty-close doesn't mean anything anyway as */
    /* far as I know. */
    close(esPtr->fdin);
    esPtr->sys_closed = TRUE;
d324 5
a328 5
    if (esPtr->slave_name) {
	Tcl_HashEntry *entry;
	
	entry = Tcl_FindHashEntry(&slaveNames,esPtr->slave_name);
	Tcl_DeleteHashEntry(entry);
d330 3
a332 3
	ckfree(esPtr->slave_name);
	esPtr->slave_name = 0;
    }
d379 3
d1252 1
d1267 1
a1267 1
	if (!(esPtr = expGetStateFromChannelName(interp,chanName,1,0,"exp_pid"))) return TCL_ERROR;
d1274 1
a1274 1
  usage:
d1292 17
d2477 2
a2478 1
	if (!(esPtr = expGetStateFromChannelName(interp,chanName,1,0,"close"))) return TCL_ERROR;
d2800 1
a2800 1
    /*  sigh, wedge forked_proc into an ExpState structure so we don't
d2893 3
a2895 2
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    
d2897 4
a2900 3
    /* tell CenterLine to ignore non-use of ttyfd */
    /*SUPPRESS 591*/
    int ttyfd;
d2902 9
a2910 4
    if (argc > 1) {
	exp_error(interp,"usage: disconnect");
	return(TCL_ERROR);
    }
d2912 13
a2924 23
    if (exp_disconnected) {
	exp_error(interp,"already disconnected");
	return(TCL_ERROR);
    }
    if (!exp_forked) {
	exp_error(interp,"can only disconnect child process");
	return(TCL_ERROR);
    }
    exp_disconnected = TRUE;

    /* ignore hangup signals generated by testing ptys in getptymaster */
    /* and other places */
    signal(SIGHUP,SIG_IGN);

    /* reopen prevents confusion between send/expect_user */
    /* accidentally mapping to a real spawned process after a disconnect */

    /* if we're in a child that's about to be disconnected from the
       controlling tty, close and reopen 0, 1, and 2 but associated
       with /dev/null.  This prevents send and expect_user doing
       special things if newly spawned processes accidentally
       get allocated 0, 1, and 2.
    */
d2926 11
a2936 12
    if (isatty(0)) {
	exp_close(interp,tsdPtr->stdinout);
	open("/dev/null",0);
	open("/dev/null",1);
	tsdPtr->stdinout = expCreateChannel(0,1,EXP_NOPID);
	}
    if (isatty(2)) {
	/* reopen stderr saves error checking in error/log routines. */
	exp_close(interp,ExpDevtty());
	open("/dev/null",1);
	tsdPtr->devtty = expCreateChannel(2,2,EXP_NOPID);
    }
d2938 1
a2938 1
    Tcl_UnsetVar(interp,"tty_spawn_id",TCL_GLOBAL_ONLY);
d2941 1
a2941 1
    setsid();
d2944 1
a2944 1
    /* put process in our own pgrp, and lose controlling terminal */
d2946 4
a2949 4
    /* With setpgrp first, child ends up with closed stdio */
    /* according to Dave Schmitt <daves@@techmpc.csg.gss.mot.com> */
    if (fork()) exit(0);
    setpgrp();
d2951 5
a2955 5
    setpgrp();
    /*signal(SIGHUP,SIG_IGN); moved out to above */
    if (fork()) exit(0);	/* first child exits (as per Stevens, */
    /* UNIX Network Programming, p. 79-80) */
    /* second child process continues as daemon */
d2959 1
a2959 1
    /* required on BSD side of MIPS OS <jmsellen@@watdragon.waterloo.edu> */
d2961 1
a2961 1
    syscall(SYS_setpgrp);
d2963 2
a2964 2
    setpgrp(0,0);
/*  setpgrp(0,getpid());*/	/* put process in our own pgrp */
d2968 6
a2973 6
    ttyfd = open("/dev/tty", O_RDWR);
    if (ttyfd >= 0) {
	/* zap controlling terminal if we had one */
	(void) ioctl(ttyfd, TIOCNOTTY, (char *)0);
	(void) close(ttyfd);
    }
d2978 1
a2978 1
    return(TCL_OK);
d3057 5
a3061 5
    if (argc == 1) {
	return EXP_CONTINUE;
    } else if ((argc == 2) && (0 == strcmp(argv[1],"-continue_timer"))) {
	return EXP_CONTINUE_TIMER;
    }
d3063 2
a3064 2
    exp_error(interp,"usage: exp_continue [-continue_timer]\n");
    return(TCL_ERROR);
d3096 1
d3099 1
d3120 4
a3123 2
	if (!(esPtr = expGetStateFromChannelName(interp,chanName,0,0,"exp_open")))
return TCL_ERROR;
@


5.30.2.5
log
@fixed Log/Diag and ExpectCmd
@
text
@a86 1
#include "expTcl.h"
d105 1
a105 1
/* the following are use to create reserved addresses, to be used as ClientData */
d131 6
a152 4

    Tcl_Channel *diagChannel;
    Tcl_DString diagDString;
    int diagEnabled;
d156 1
d190 2
a191 1
/* returns current ExpState or 0.  If 0, may be immediately followed by return TCL_ERROR. */
d193 1
a193 1
expStateCurrent(interp,opened,adjust,any)
a196 1
int any;
d201 1
a201 1
    return expStateFromChannelName(interp,name,opened,adjust,any,SPAWN_ID_VARNAME);
d205 1
a205 1
expStateFromChannelName(interp,name,open,adjust,any,msg)
d212 1
a212 9
    ExpState *esPtr;
    Tcl_Channel channel;

    if (any) {
	if (0 == strcmp(name,EXP_SPAWN_ID_ANY_LIT)) {
	    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
	    return tsdPtr->any;
	}
    }
d214 1
a214 2
    channel = Tcl_GetChannel(interp,name,(int *)0);
    esPtr = Tcl_GetChannelInstanceData(channel);
d217 4
a220 4
    /* following is a little tricky */
    if ((!open) || esPtr->open) {   /* if open == 1, then check if actually
				       open */
	if (adjust) expAdjust(esPtr);
d228 1
a228 1
expStateCheck(interp,esPtr,opened,adjust,msg)
d232 1
a232 1
	if (adjust) expAdjust(esPtr);
d235 1
a235 1
    exp_error(interp,"%s: invalid spawn id (%s)",msg,esPtr->name);
d291 1
d297 1
a297 1
	expDiagLog("exp_trap_off: no entry found for %s\n",name);
d303 1
a303 1
    exp_slave_control(esPtr->fdin,0);
d305 1
a305 1
    return esPtr->fdin;
d311 3
a313 3
int
exp_close(interp,esPtr);
Tcl_Interp *interp;
d316 4
a319 9
    if (0 == expStateCheck(interp,esPtr,1,0,"close")) return TCL_ERROR;
    esPtr->open = FALSE;

    /*
     * Ignore close errors from ptys.  Ptys on some systems return errors for
     * no evident reason.  Anyway, receiving an error upon pty-close doesn't
     * mean anything anyway as far as I know.  
     */

d321 1
a321 11
    if (esPtr->fd_slave != EXP_NOFD) close(esPtr->fd_slave);
    if (esPtr->fdin != esPtr->fdout) close(esPtr->fdout);

    if (esPtr->channel_orig && !esPtr->leaveopen) {
	/*
	 * Ignore close errors from Tcl channels.  They indicate things
	 * like broken pipelines, etc, which don't affect our
	 * subsequent handling.
	 */
	Tcl_VarEval(interp,"close ",file_id,(char *)0);
    }
d334 40
d378 1
a378 4
	if (esPtr->registered) {
	    Tcl_UnregisterChannel(interp,channel);
	    esPtr->registered = 0;
	}
d384 1
a384 1
expStdinoutIs(esPtr)
d391 1
a391 1
expStdinoutGet()
d398 1
a398 1
expDevttyGet()
a429 2
    static ExpState any_placeholder;  /* can be shared process-wide */
    
d440 3
d455 14
d472 1
a472 1
expStateAnyIs(esPtr)
d481 1
a481 1
expStdinoutIs(esPtr)
d490 1
a490 1
expDevttyIs(esPtr)
d696 1
a696 2
				expErrorLogU(interp->result);
				expErrorLogU("\r\n",interp->result);
d745 5
a749 4
		    expStdoutLogU(argv0,0);
		    expStdoutLogU(" ",0);
		    for (a = argv;*a;a++) {
			expStdoutLogU(*a,0);
d788 1
a788 4
		if (echo) {
		    expStdoutLogU(argv0,0);
		    expStdoutLogU(" [open ...]\r\n",0);
		}
d836 1
a836 1
	    channel = expCreateChannel(master,write_master,EXP_NOPID);
d850 3
a852 2
		/* tell user of new spawn id */
		Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);
d874 1
a874 1
		expDiagLog("spawn: returns {%s}\r\n",interp->result);
d916 1
a916 1
		channel = expCreateChannel(master,master,pid);
d930 1
a930 1
		expDiagLog("parent: waiting for sync byte\r\n");
d935 1
a935 3
			expErrorLogU("parent: sync byte read: ");
			expErrorLogU(Tcl_ErrnoMsg(errno));
			expErrorLogU("\r\n");
d946 1
a946 1
		expDiagLog("parent: telling child to go ahead\r\n");
d949 1
a949 1
			expErrorLog("parent: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
d953 1
a953 1
		expDiagLog("parent: now unsynchronized from child\r\n");
d983 3
a985 2
		/* tell user of new spawn id */
		Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);
d988 1
a988 1
		expDiagLog("spawn: returns {%s}\r\n",interp->result);
d1071 1
a1071 1
			expErrorLog("open(slave pty): %s\r\n",exp_pty_error);
d1073 1
a1073 1
			expErrorLog("open(slave pty): %s\r\n",Tcl_ErrnoMsg(errno));
d1080 1
a1080 1
		expErrorLog("getptyslave: slave = %d but expected 0\n",slave);
d1100 1
a1100 1
		expErrorLog("failed to get controlling terminal using TIOCSCTTY");
d1111 1
a1111 1
 		expErrorLog("open(/dev/tty): %s\r\n",Tcl_ErrnoMsg(errno));
d1131 1
a1131 1
		expErrorLog("second fork: %s\r\n",Tcl_ErrnoMsg(errno));
d1180 8
a1187 6
	/*
	 * avoid fflush of cmdfile, logfile, & diagfile since this screws up
	 * the parents seek ptr.  There is no portable way to fclose a shared
	 * read-stream!!!!
	 */

d1194 1
a1194 1
	/* expDiagLog("child: telling parent that pty is initialized\r\n");*/
d1198 1
a1198 1
		expErrorLog("child: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
d1204 1
a1204 1
	/* expDiagLog("child: waiting for go ahead from parent\r\n"); */
d1206 1
a1206 1
	/* close(master);	/* force master-side close so we can read */
d1214 1
a1214 1
		expErrorLog("child: sync byte read: %s\r\n",Tcl_ErrnoMsg(errno));
d1219 1
a1219 1
	/* expDiagLog("child: now unsynchronized from parent\r\n"); */
d1226 9
a1234 7

	/* Alas, by now we've closed fd's to stderr, logfile and diagfile.
	 * The only reasonable thing to do is to send back the error as part of
	 * the program output.  This will be picked up in an expect or interact
	 * command.
	 */

d1263 1
a1263 1
	if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"exp_pid"))) return TCL_ERROR;
d1265 1
a1265 1
	if (!(esPtr = expStateCurrent(interp,0,0,0))) return TCL_ERROR;
d1283 1
a1283 1
	expDiagLog("getpid is deprecated, use pid\r\n");
d1314 15
a1328 11
    int cc;
    while (rembytes) {
	if (-1 == (cc = Tcl_WriteChars(esPtr->channel,buffer,rembytes))) return(-1);
	if (0 == cc) {
	    /* This shouldn't happen but I'm told that it does */
	    /* nonetheless (at least on SunOS 4.1.3).  Since */
	    /* this is not a documented return value, the most */
	    /* reasonable thing is to complain here and retry */
	    /* in the hopes that is some transient condition. */
	    sleep(1);
	    expDiagLog("write() failed to write anything but returned - sleeping and retrying...\n");
d1330 1
a1330 5

	buffer += cc;
	rembytes -= cc;
    }
    return(0);
d1334 2
a1335 2
    int size;
    double time;
d1480 1
a1480 1
    expDiagLog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
d1725 1
a1725 2
			/* *really* big variable names could blow up expDiagLog! */
			expDiagLog("warning: indirect variable %s undefined",i->variable);
d1773 3
d1778 1
d1790 7
a1796 1
	expLogDiagU(*argv);
d1829 1
a1829 1
    char *chanName = 0;
d1862 1
a1862 1
		chanName = Tcl_GetString(objv[j]);
d1919 1
a1919 1
    else if (!chanName) {
d1923 1
a1923 1
	if (!(esPtr = expStateCurrent(interp,0,0,0))) return(TCL_ERROR);
d1929 1
a1929 1
	i = exp_new_i_complex(interp,chanName,FALSE,(Tcl_VarTraceProc *)0);
d1939 1
a1939 3
	expDiagLogU("send: sending \"");
	expDiagLogU(expPrintify(string));
	expDiagLogU("\" to {");
d1943 4
a1946 1
	expLogDiagU(string);
d1953 1
a1953 1
	    expDiagLog(" %s ",esPtr->name);
d1957 1
a1957 1
	if (0 == expStateCheck(interp,esPtr,1,0,"send")) {
d1995 1
a1995 1
    if (send_to_proc) expDiagLogU("}\r\n");
d2006 4
a2009 4
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
d2011 138
a2148 6
    static char resultbuf[1000];
    char *chanName = 0;
    int leaveOpen = FALSE;
    int logAll = FALSE;
    int append = TRUE;
    char *filename = 0;
d2150 2
a2151 21
    argv++;
    argc--;
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-open")) {
	    if (!argv[1]) goto usage_error;
	    chanName = argv[1];
	    argc--; argv++;
	} else if (streq(*argv,"-leaveopen")) {
	    if (!argv[1]) goto usage_error;
	    chanName = argv[1];
	    leaveOpen = TRUE;
	    argc--; argv++;
	} else if (streq(*argv,"-a")) {
	    logAll = TRUE;
	} else if (streq(*argv,"-info")) {
	    resultbuf[0] = '\0';
	    if (expLogChannelGet()) {
		if (expLogAllGet()) strcat(resultbuf,"-a ");
		if (!expLogAppendGet()) strcat(resultbuf,"-noappend ");
		if (expLogFilename()) {
		    strcat(resultbuf,expLogFilenameGet());
d2153 1
a2153 4
		    if (expLogLeaveOpen()) {
			strcat(resultbuf,"-leaveopen ");
		    }
		    strcat(resultbuf,Tcl_GetChannelName(expLogChannelGet()));
d2155 1
a2155 18
		Tcl_SetResult(interp,resultbuf,TCL_STATIC);
	    }
	    return TCL_OK;
	} else if (streq(*argv,"-noappend")) {
	    append = FALSE;
	} else break;
    }
    
    if (argc == 1) {
	filename = argv[0];
    } else if (argc > 1) {
	/* too many arguments */
	goto usage_error;
    } 
    
    if (chanName && filename) {
	goto usage_error;
    }
d2157 11
a2167 11
    /* check if user merely wants to change logAll (-a) */
    if (expLogChannelGet() && (chanName || filename)) {
	if (filename && (0 == strcmp(filename,expLogFilenameGet()))) {
	    expLogAllSet(logAll);
	    return TCL_OK;
	} else if (chanName && (0 == strcmp(filename,Tcl_GetChannelName(expLogChannelGet())))) {
	    expLogAllSet(logAll);
	    return TCL_OK;
	} else {
	    exp_error(interp,"cannot start logging without first stopping logging");
	    return TCL_ERROR;
a2168 1
    }
d2170 2
a2171 3
    if (filename) {
	if (TCL_ERROR == expLogChannelOpen(interp,filename,append)) {
	    return TCL_ERROR;
d2173 6
a2178 3
    } else if (chanName) {
	if (TCL_ERROR == expLogChannelSet(interp,openarg)) {
	    return TCL_ERROR;
d2180 7
a2186 5
    } else {
	expLogCloseChannel();
	if (logAll) {
	    exp_error(interp,"cannot use -a without a file or channel");
	    return TCL_ERROR;
a2187 2
    }
    expLogAllSet(logAll);
d2189 7
a2195 1
    return TCL_OK;
d2197 1
a2197 3
 usage_error:
    exp_error(interp,"usage: log_file [-info] [-noappend] [[-a] file] [-[leave]open [open ...]]");
    return TCL_ERROR;
d2208 1
a2208 1
    int old_loguser = expLogUserGet();
d2210 8
a2217 7
    if (argc == 0 || (argc == 2 && streq(argv[1],"-info"))) {
	/* do nothing */
    } else if (argc == 2) {
	expLogUserSet(atoi(argv[1]);
    } else {
	exp_error(interp,"usage: [-info|1|0]");
    }
d2219 1
a2219 1
    sprintf(interp->result,"%d",old_loguser);
d2221 1
a2221 1
    return(TCL_OK);
d2233 2
a2234 2
    int now = FALSE;	/* soon if FALSE, now if TRUE */
    int exp_tcl_debugger_was_available = exp_tcl_debugger_available;
d2236 1
a2236 1
    if (argc > 3) goto usage;
d2238 4
a2241 4
    if (argc == 1) {
	sprintf(interp->result,"%d",exp_tcl_debugger_available);
	return TCL_OK;
    }
d2243 1
a2243 1
    argv++;
d2245 7
a2251 7
    while (*argv) {
	if (streq(*argv,"-now")) {
	    now = TRUE;
	    argv++;
	}
	else break;
    }
d2253 10
a2262 4
    if (!*argv) {
	if (now) {
	    Dbg_On(interp,1);
	    exp_tcl_debugger_available = 1;
d2264 2
a2265 1
	    goto usage;
d2267 2
a2268 9
    } else if (streq(*argv,"0")) {
	Dbg_Off(interp);
	exp_tcl_debugger_available = 0;
    } else {
	Dbg_On(interp,now);
	exp_tcl_debugger_available = 1;
    }
    sprintf(interp->result,"%d",exp_tcl_debugger_was_available);
    return(TCL_OK);
d2270 2
a2271 2
    exp_error(interp,"usage: [[-now] 1|0]");
    return TCL_ERROR;
a2274 1

d2283 54
a2336 9
    int newChannel = FALSE;
    Tcl_Channel oldChannel;
    static char resultbuf[1000];

    if ((argc > 1) && streq(Tcl_GetString(argv[1]),"-info")) {
	resultbuf[0] = '\0';
	oldChannel = expDiagChannel();
	if (oldChannel) {
	    sprintf(resultbuf,"-f %s ",expDiagFilename());
a2337 4
	strcat(resultbuf,expDiagToStderrGet()?"1":"0");
	Tcl_SetResult(interp,resultbuf,TCL_STATIC);
	return TCL_OK;
    }
d2339 1
a2339 2
    argv++;
    argc--;
d2341 5
a2345 7
    while (argc) {
	if (!streq(*argv,"-f")) break;
	argc--;argv++;
	if (argc < 1) goto usage;
	expDiagChannelClose();
	if (TCL_OK != expDiagChannelOpen(interp,argv[0])) {
	    return TCL_ERROR;
a2346 3
	newChannel = TRUE;
	argc--;argv++;
    }
d2348 2
a2349 8
    if (argc != 1) goto usage;
    
    /* if no -f given, close file */
    if (!newChannel) {
	expDiagChannelClose();
    }
    expDiagToStderrSet(atoi(*argv));
    return(TCL_OK);
d2351 4
a2354 2
    exp_error(interp,"usage: [-f file] 0|1");
    return TCL_ERROR;
d2418 1
d2420 3
a2422 3
    for (;objc>0;objc--,objv++) {
	if (streq("-i",Tcl_GetString(*objv))) {
	    objc--; objv++;
d2427 2
a2428 2
	    chanName = Tcl_GetString(*objv);
	} else if (streq(Tcl_GetString(*objv),"-slave")) {
d2430 2
a2431 2
	} else if (streq(Tcl_GetString(*objv),"-onexec")) {
	    objc--; objv++;
d2437 1
a2437 1
	    close_onexec = atoi(Tcl_GetString(*objv));
d2452 1
a2452 1
	return(Tcl_CloseObjCmd(info.clientData,interp,objc_orig,objv_orig));
d2456 1
a2456 1
	if (!(esPtr = expStateFromChannelName(interp,chanName,1,0,0,"close"))) return TCL_ERROR;
d2458 1
a2458 1
	if (!(esPtr = expStateCurrent(interp,1,0,0))) return TCL_ERROR;
d2499 2
a2500 2
	/* come out on stderr, by using expErrorLog */
	expErrorLog("%2d",level);
d2502 1
a2502 2
	expErrorLogU(command);
	expErrorLogU("\r\n");
d2691 1
a2691 1
	if (!(esPtr = expStateCurrent(interp,0,0,1))) return TCL_ERROR;
d2693 1
a2693 1
	if (!(esPtr = expStateFromChannelName(interp,0,0,1,"wait"))) return TCL_ERROR;
d2696 3
a2698 1
    if (!expStateAnyIs(esPtr)) {
d2818 6
a2823 5
    /* If user hasn't already called close, do so on their behalf */
    /* If they have, this is just a no-op */
    exp_close(interp,esPtr);

    if (esPtr->registered) {
a2824 1
	esPtr->registered = 0;
a2825 1

d2859 1
a2859 1
	expDiagLog("fork: returns {%s}\r\n",interp->result);
d2915 1
a2915 1
	exp_close(interp,ExpGetDevtty());
d2991 1
a2991 1
		expDiagLog("overlay: mapping fd %d to %d\r\n",oldfd,newfd);
d2993 1
a2993 1
		else expDiagLog("warning: overlay: old fd == new fd (%d)\r\n",oldfd);
d3098 1
a3098 1
	if (!(esPtr = expStateCurrent(interp,1,0,0))) return TCL_ERROR;
d3100 1
a3100 1
	if (!(esPtr = expStateFromChannelName(interp,chanName,1,0,0,"exp_open")))
d3220 1
a3220 1
    exp_create_commands(interp,cmd_data);
d3223 1
a3223 1
    Tcl_InitHashTable(&slaveNames,TCL_STRING_KEYS);
d3226 1
a3226 1
    exp_close_in_child = exp_close_tcl_files;
@


5.30.2.6
log
@made stuff compile
@
text
@d145 1
a145 1
    ExpState *stderrX;   /* grr....stderr is a macro */
d204 1
a204 1
    Tcl_Interp *interp;
d206 1
a206 1
    int open;
d235 1
a235 7
expStateCheck(interp,esPtr,open,adjust,msg)
    Tcl_Interp *interp;
    ExpState *esPtr;
    int open;
    int adjust;
    char *msg;
{
d238 1
a238 1
    if ((!open) || !esPtr->open) {
d318 1
a318 1
exp_close(interp,esPtr)
d341 1
a341 2
	Tcl_VarEval(interp,"close ",Tcl_GetChannelName(esPtr->channel_orig),
		(char *)0);
d360 1
a360 1
	    Tcl_UnregisterChannel(interp,esPtr->channel);
a367 21
/* report whether this ExpState represents special spawn_id_any */
/* we need a separate function because spawn_id_any is thread-specific */
/* and can't be seen outside this file */
expStateAnyIs(esPtr)
    ExpState *esPtr;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (esPtr == tsdPtr->any);
}

expDevttyIs(esPtr)
    ExpState *esPtr;
{
    Tcl_ChannelType *channelTypePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return (esPtr == tsdPtr->devtty);
}

int
a368 1
ExpState *esPtr;
a374 1
ExpState *
a381 1
ExpState *
d397 1
a397 1
    Tcl_SetVar(interp,"error_spawn_id",tsdPtr->stderrX->name,0);
d423 1
a423 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d427 1
a427 1
    tsdPtr->stderrX = expCreateChannel(2,2,isatty(2)?exp_getpid:EXP_NOPID);
d438 30
d535 6
a540 6
    int slave;
    int pid;
    char **a;
    /* tell Saber to ignore non-use of ttyfd */
    /*SUPPRESS 591*/
    int errorfd;	/* place to stash fileno(stderr) in child */
d542 8
a549 8
    int ttyfd;
    int master;
    int write_master;	/* write fd of Tcl-opened files */
    int ttyinit = TRUE;
    int ttycopy = TRUE;
    int echo = TRUE;
    int console = FALSE;
    int pty_only = FALSE;
d556 1
a556 1
    RETSIGTYPE (*traps[NSIG])();
d558 1
a558 1
    int ignore[NSIG];		/* if true, signal in child is ignored */
d560 1
a560 1
    int i;			/* trusty overused temporary */
d562 8
a569 8
    char *argv0 = argv[0];
    char *openarg = 0;
    int leaveopen = FALSE;
    FILE *readfilePtr;
    FILE *writefilePtr;
    int rc, wc;
    char *stty_init;
    int slave_write_ioctls = 1;
d571 1
a571 1
    int slave_opens = 3;
d577 5
a581 5
    int sync_fds[2];
    int sync2_fds[2];
    int status_pipe[2];
    int child_errno;
    char sync_byte;
d583 2
a584 2
    Tcl_Channel chan;
    char buf[4];		/* enough space for a string literal */
d586 2
a587 2
    Tcl_DString dstring;
    Tcl_DStringInit(&dstring);
d590 1
a590 1
    init_traps(&traps);
d592 4
a595 4
    /* don't ignore any signals in child by default */
    for (i=1;i<NSIG;i++) {
	ignore[i] = FALSE;
    }
d597 1
a597 1
    argc--; argv++;
d599 30
a628 30
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-nottyinit")) {
	    ttyinit = FALSE;
	    slave_write_ioctls--;
	    slave_opens--;
	} else if (streq(*argv,"-nottycopy")) {
	    ttycopy = FALSE;
	} else if (streq(*argv,"-noecho")) {
	    echo = FALSE;
	} else if (streq(*argv,"-console")) {
	    console = TRUE;
	} else if (streq(*argv,"-pty")) {
	    pty_only = TRUE;
	} else if (streq(*argv,"-open")) {
	    if (argc < 2) {
		exp_error(interp,"usage: -open file-identifier");
		return TCL_ERROR;
	    }
	    openarg = argv[1];
	    argc--; argv++;
	} else if (streq(*argv,"-leaveopen")) {
	    if (argc < 2) {
		exp_error(interp,"usage: -open file-identifier");
		return TCL_ERROR;
	    }
	    openarg = argv[1];
	    leaveopen = TRUE;
	    argc--; argv++;
	} else if (streq(*argv,"-ignore")) {
	    int sig;
d630 11
a640 11
	    if (argc < 2) {
		exp_error(interp,"usage: -ignore signal");
		return TCL_ERROR;
	    }
	    sig = exp_string_to_signal(interp,argv[1]);
	    if (sig == -1) {
		exp_error(interp,"usage: -ignore %s: unknown signal name",argv[1]);
		return TCL_ERROR;
	    }
	    ignore[sig] = TRUE;
	    argc--; argv++;
d642 12
a653 12
	} else if (streq(*argv,"-trap")) {
	    /* argv[1] is action */
	    /* argv[2] is list of signals */

	    RETSIGTYPE (*sig_handler)();
	    int n;		/* number of signals in list */
	    char **list;	/* list of signals */
	    
	    if (argc < 3) {
		exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		return TCL_ERROR;
	    }
d655 8
a662 8
	    if (0 == strcmp(argv[2],"SIG_DFL")) {
		sig_handler = SIG_DFL;
	    } else if (0 == strcmp(argv[2],"SIG_IGN")) {
		sig_handler = SIG_IGN;
	    } else {
		exp_error(interp,"usage: -trap siglist SIG_DFL or SIG_IGN");
		return TCL_ERROR;
	    }
d664 15
a678 15
	    if (TCL_OK != Tcl_SplitList(interp,argv[1],&n,&list)) {
		expErrorLogU(interp->result);
		expErrorLogU("\r\n");
		exp_error(interp,"usage: -trap {siglist} ...");
		return TCL_ERROR;
	    }
	    for (i=0;i<n;i++) {
		int sig = exp_string_to_signal(interp,list[i]);
		if (sig == -1) {
		    ckfree((char *)&list);
		    return TCL_ERROR;
		}
		traps[sig] = sig_handler;
	    }
	    ckfree((char *)&list);
d680 2
a681 2
	    argc--; argv++;
	    argc--; argv++;
d683 2
a684 2
	} else break;
    }
d686 4
a689 4
    if (openarg && (argc != 0)) {
	exp_error(interp,"usage: -[leave]open [fileXX]");
	return TCL_ERROR;
    }
d691 4
a694 4
    if (!pty_only && !openarg && (argc == 0)) {
	exp_error(interp,"usage: spawn [spawn-args] program [program-args]");
	return(TCL_ERROR);
    }
d696 5
a700 5
    stty_init = exp_get_var(interp,STTY_INIT);
    if (stty_init) {
	slave_write_ioctls++;
	slave_opens++;
    }
d705 2
a706 2
    slave_write_ioctls++;
    slave_opens++;
d709 1
a709 3
    exp_pty_slave_name = 0;
    
    Tcl_ReapDetachedProcs();
d711 1
a711 9
    if (!openarg) {
	if (echo) {
	    expStdoutLogU(argv0,0);
	    for (a = argv;*a;a++) {
		expStdoutLogU(" ",0);
		expStdoutLogU(*a,0);
	    }
	    expStdoutLogU("\r\n",0);
	}
d713 7
a719 5
	if (0 > (master = getptymaster())) {
	    /*
	     * failed to allocate pty, try and figure out why
	     * so we can suggest to user what to do about it.
	     */
d721 12
a732 6
	    int testfd;
		
	    if (exp_pty_error) {
		exp_error(interp,"%s",exp_pty_error);
		return TCL_ERROR;
	    }
d734 4
a737 4
	    if (expChannelCountGet() > 10) {
		exp_error(interp,"The system only has a finite number of ptys and you have many of them in use.  The usual reason for this is that you forgot (or didn't know) to call \"wait\" after closing each of them.");
		return TCL_ERROR;
	    }
d739 2
a740 2
	    testfd = open("/",0);
	    close(testfd);
d742 7
a748 7
	    if (testfd != -1) {
		exp_error(interp,"The system has no more ptys.  Ask your system administrator to create more.");
	    } else {
		exp_error(interp,"- You have too many files are open.  Close some files or increase your per-process descriptor limit.");
	    }
	    return(TCL_ERROR);
	}
d751 43
a793 31
	Tcl_SetVar2(interp,SPAWN_OUT,"slave,name",exp_pty_slave_name,0);
    } else {
	/*
	 * process "-open $channel"
	 */
	Tcl_Channel chan;
	int mode;
	int rfd, wfd;
	
	if (echo) {
	    expStdoutLogU(argv0,0);
	    expStdoutLogU(" [open ...]\r\n",0);
	}
	if (!(chan = Tcl_GetChannel(interp,openarg,&mode))) {
	    return TCL_ERROR;
	}
	if (!mode) {
	    exp_error(interp,"channel is neither readable nor writable");
	    return TCL_ERROR;
	}
	if (mode & TCL_READABLE) {
	    if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_READABLE, (ClientData) &rfd)) {
		return TCL_ERROR;
	    }
	}
	if (mode & TCL_WRITABLE) {
	    if (TCL_ERROR == Tcl_GetChannelHandle(chan, TCL_WRITABLE, (ClientData) &wfd)) {
		return TCL_ERROR;
	    }    
	}
	master = ((mode & TCL_READABLE)?rfd:wfd);
d795 7
a801 4
	/* make a new copy of file descriptor */
	if (-1 == (write_master = master = dup(master))) {
	    exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
	    return TCL_ERROR;
d803 4
d808 6
a813 5
	/* if writefilePtr is different, dup that too */
	if ((mode & TCL_READABLE) && (mode & TCL_WRITABLE) && (wfd != rfd)) {
	    if (-1 == (write_master = dup(wfd))) {
		exp_error(interp,"fdopen: %s",Tcl_PosixError(interp));
		return TCL_ERROR;
a814 2
	    exp_close_on_exec(write_master);
	}
d816 5
a820 17
	/*
	 * It would be convenient now to tell Tcl to close its
	 * file descriptor.  Alas, if involved in a pipeline, Tcl
	 * will be unable to complete a wait on the process.
	 * So simply remember that we meant to close it.  We will
	 * do so later in our own close routine.
	 */
    }
	
    if (openarg || pty_only) {
	ExpState *esPtr;
	esPtr = expCreateChannel(master,write_master,EXP_NOPID);
	    
	if (openarg) {
	    esPtr->channel_orig = esPtr->channel;
	    esPtr->leaveopen = leaveopen;
	}
d822 2
a823 1
	if (exp_pty_slave_name) set_slave_name(esPtr,exp_pty_slave_name);
d825 2
a826 3
	/* make it appear as if process has been waited for */
	esPtr->sys_waited = TRUE;
	exp_wait_zero(&esPtr->wait);
d828 10
a837 2
	/* tell user of new spawn id */
	Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);
d839 1
a839 2
	if (!openarg) {
	    char value[20];
d841 5
a845 10
	    /*
	     * open the slave side in the same process to support
	     * the -pty flag.
	     */

	    if (0 > (esPtr->fd_slave = getptyslave(ttycopy,ttyinit,
		    stty_init))) {
		exp_error(interp,"open(slave pty): %s\r\n",Tcl_PosixError(interp));
		return TCL_ERROR;
	    }
d847 1
a847 4
	    exp_slave_control(master,1);
	    
	    sprintf(value,"%d",esPtr->fd_slave);
	    Tcl_SetVar2(interp,SPAWN_OUT,"slave,fd",value,0);
a848 2
	sprintf(interp->result,"%d",EXP_NOPID);
	expDiagLog("spawn: returns {%s}\r\n",interp->result);
d850 4
a853 2
	return TCL_OK;
    }
d855 4
a858 4
    if (NULL == (argv[0] = Tcl_TranslateFileName(interp, argv[0],
	    &dstring))) {
	goto parent_error;
    }
d860 6
a865 4
    if (-1 == pipe(sync_fds)) {
	exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
	goto parent_error;
    }
d867 6
a872 6
    if (-1 == pipe(sync2_fds)) {
	close(sync_fds[0]);
	close(sync_fds[1]);
	exp_error(interp,"too many programs spawned?  could not create pipe: %s",Tcl_PosixError(interp));
	goto parent_error;
    }
d874 4
a877 6
    if (-1 == pipe(status_pipe)) {
	close(sync_fds[0]);
	close(sync_fds[1]);
	close(sync2_fds[0]);
	close(sync2_fds[1]);
    }
d879 3
a881 4
    if ((pid = fork()) == -1) {
	exp_error(interp,"fork: %s",Tcl_PosixError(interp));
	goto parent_error;
    }
d883 3
a885 2
    if (pid) { /* parent */
	    ExpState *esPtr;
d887 2
a888 3
	    close(sync_fds[1]);
	    close(sync2_fds[0]);
	    close(status_pipe[1]);
d890 1
a890 3
	    esPtr = expCreateChannel(master,master,pid);
	    
	    if (exp_pty_slave_name) set_slave_name(esPtr,exp_pty_slave_name);
d893 1
a893 1
	    setptypid(pid);
d896 15
a910 4
	    /*
	     * wait for slave to initialize pty before allowing
	     * user to send to it
	     */ 
d912 2
a913 10
	    expDiagLog("parent: waiting for sync byte\r\n");
	    while (((rc = read(sync_fds[0],&sync_byte,1)) < 0) && (errno == EINTR)) {
		/* empty */;
	    }
	    if (rc == -1) {
		expErrorLogU("parent: sync byte read: ");
		expErrorLogU(Tcl_ErrnoMsg(errno));
		expErrorLogU("\r\n");
		exit(-1);
	    }
d915 3
a917 2
	    /* turn on detection of eof */
	    exp_slave_control(master,1);
d919 6
a924 10
	    /*
	     * tell slave to go on now now that we have initialized pty
	     */

	    expDiagLog("parent: telling child to go ahead\r\n");
	    wc = write(sync2_fds[1]," ",1);
	    if (wc == -1) {
		expErrorLog("parent: sync byte write: %s\r\n",Tcl_ErrnoMsg(errno));
		exit(-1);
	    }
d926 3
a928 3
	    expDiagLog("parent: now unsynchronized from child\r\n");
	    close(sync_fds[0]);
	    close(sync2_fds[1]);
d930 1
a930 1
	    /* see if child's exec worked */
d932 1
a932 1
	    switch (read(status_pipe[0],&child_errno,sizeof child_errno)) {
d934 5
a938 5
		    if (errno == EINTR) goto retry;
		    /* well it's not really the child's errno */
		    /* but it can be treated that way */
		    child_errno = errno;
		    break;
d940 3
a942 3
		    /* child's exec succeeded */
		    child_errno = 0;
		    break;
d944 11
a954 10
		    /* child's exec failed; err contains exec's errno  */
		    waitpid(pid, NULL, 0);
		    /* in order to get Tcl to set errorcode, we must */
		    /* hand set errno */
		    errno = child_errno;
		    exp_error(interp, "couldn't execute \"%s\": %s",
			    argv[0],Tcl_PosixError(interp));
		    goto parent_error;
	    }
	    close(status_pipe[0]);
d956 2
a957 2
	    /* tell user of new spawn id */
	    Tcl_SetVar(interp,SPAWN_ID_VARNAME,esPtr->name,0);
d959 2
a960 2
	    sprintf(interp->result,"%d",pid);
	    expDiagLog("spawn: returns {%s}\r\n",interp->result);
d962 2
a963 2
	    Tcl_DStringFree(&dstring);
	    return(TCL_OK);
d965 2
a966 2
	    Tcl_DStringFree(&dstring);
	    return TCL_ERROR;
d1226 1
a1226 1
	    chanName = *argv;
d1512 2
a1513 2
exp_new_state(esPtr)
ExpState *esPtr;
d1515 12
a1526 2
    int n;
    struct exp_state_list *fd;
d1528 7
a1534 17
    if (!exp_state_list_pool) {
	/* none avail, generate some new ones */
	exp_state_list_pool = fd = (struct exp_state_list *)ckalloc(
	    EXP_FD_INIT_COUNT * sizeof(struct exp_state_list));
	for (n=0;n<EXP_FD_INIT_COUNT-1;n++,fd++) {
	    fd->next = fd+1;
	}
	fd->next = 0;
    }

    /* now that we've made some, unlink one and give to user */

    fd = exp_state_list_pool;
    exp_state_list_pool = exp_state_list_pool->next;
    fd->esPtr = esPtr;
    /* fd->next is assumed to be changed by caller */
    return fd;
a1669 1
    int j;
d1675 2
a1676 2
    for (j = 0; j < argc; j++) {
	exp_i_add_state(i,argv[j]);
d1876 1
a1876 1
    else if (clientData == &sendCD_error) esPtr = tsdPtr->stderrX;
d2041 1
a2041 2
	if (TCL_ERROR == expLogChannelSet(Tcl_GetChannel(interp,chanName,(int
		*)0))) {
d2073 1
a2073 1
	expLogUserSet(atoi(argv[1]));
d2147 1
a2147 1
    if ((argc > 1) && streq(argv[1],"-info")) {
d2149 1
a2149 1
	oldChannel = expDiagChannelGet();
a2241 1
    char *chanName = 0;
d2522 1
a2522 2
	if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,1,"wait")))
	    return TCL_ERROR;
d2743 1
a2743 1
	exp_close(interp,expDevttyGet());
a2907 1
    Tcl_Channel channel;
d2957 4
a2960 4
    channel = Tcl_MakeFileChannel((ClientData)newfd,TCL_READABLE|TCL_WRITABLE);
    Tcl_RegisterChannel(interp, channel);
    Tcl_AppendResult(interp, Tcl_GetChannelName(channel), (char *) NULL);
    return TCL_OK;
@


5.30.2.7
log
@making expect.c compile
@
text
@d2042 4
a2045 3
	Tcl_Channel channel = Tcl_GetChannel(interp,chanName,(int *)0);
	if (!channel) return TCL_ERROR;
	expLogChannelSet(channel);
@


5.30.2.8
log
@Checkpoint
@
text
@d273 1
a273 1
    exp_ecmd_remove_state_direct_and_indirect(interp,esPtr);
d275 1
a275 1
    exp_configure_count++;
d277 8
a284 4
    Tcl_DecrRefCount(esPtr->buffer);

    if (esPtr->fg_armed) {
	exp_event_disarm(esPtr);
a285 1
    }
a456 1
    tsdPtr->stdinout->keepForever = 1;
a458 1
    tsdPtr->stderrX->keepForever = 1;
a461 1
	tsdPtr->devtty->keepForever = 1;
a2742 1
	tsdPtr->stdinout->keepForever = 1;
a2748 1
	tsdPtr->devtty->keepForever = 1;
@


5.30.2.9
log
@Fixed interact of all but regexp probs.
@
text
@d280 1
a280 1
	exp_event_disarm_fg(esPtr);
d2042 3
a2044 3
	if (TCL_ERROR == expLogChannelSet(interp,chanName)) {
	    return TCL_ERROR;
	}
d2166 1
a2166 1
	expDiagChannelClose(interp);
d2178 1
a2178 1
	expDiagChannelClose(interp);
@


5.30.2.10
log
@compiled!
@
text
@d34 11
d101 2
a102 2
int exp_getptymaster();
int exp_getptyslave();
d224 1
d242 3
a244 1
    if ((!open) || esPtr->open) {
d440 1
a440 2
exp_init_spawn_ids(interp)
    Tcl_Interp *interp;
d453 1
a453 1
    tsdPtr->stdinout = expCreateChannel(interp,0,1,isatty(0)?exp_getpid:EXP_NOPID);
d456 1
a456 1
    tsdPtr->stderrX = expCreateChannel(interp,2,2,isatty(2)?exp_getpid:EXP_NOPID);
d460 1
a460 1
	tsdPtr->devtty = expCreateChannel(interp,exp_dev_tty,exp_dev_tty,exp_getpid);
d724 1
a724 1
	if (0 > (master = exp_getptymaster())) {
d812 1
a812 1
	esPtr = expCreateChannel(interp,master,write_master,EXP_NOPID);
d836 1
a836 1
	    if (0 > (esPtr->fd_slave = exp_getptyslave(ttycopy,ttyinit,
d889 1
a889 1
	    esPtr = expCreateChannel(interp,master,master,pid);
d1036 2
a1037 2
	/* since exp_getptyslave may have to run stty, (some of which work on fd */
	/* 0 and some of which work on 1) do the dup's inside exp_getptyslave. */
d1039 1
a1039 1
	if (0 > (slave = exp_getptyslave(ttycopy,ttyinit,stty_init))) {
d1052 1
a1052 1
		expErrorLog("exp_getptyslave: slave = %d but expected 0\n",slave);
d1573 1
a1573 1
	exp_free_state(i->state_list);
d1707 1
a1707 1
		exp_free_state(i->state_list);
d1996 1
a1996 1
		if (expLogFilenameGet()) {
d1999 1
a1999 1
		    if (expLogLeaveOpenGet()) {
d2046 1
a2046 1
	expLogChannelClose(interp);
d2331 1
a2331 1
	for (i = 0;i<level;i++) expErrorLogU("  ");
d2742 1
a2742 1
	tsdPtr->stdinout = expCreateChannel(interp,0,1,EXP_NOPID);
d2749 1
a2749 1
	tsdPtr->devtty = expCreateChannel(interp,2,2,EXP_NOPID);
@


5.30.2.11
log
@Fixed:
 expect command's arg handling to work (like interact)
 spawn -open
 expect eof
and various other bugs.
Expect now runs its minimal test suite (but not the examples).
@
text
@d210 1
a211 1
    esPtr = Tcl_GetChannelInstanceData(channel);
d263 2
a305 14
static
void
expBusy(esPtr)
     ExpState *esPtr;
{     
  int x = open("/dev/null",0);
  if (x != esPtr->fdin) {
    fcntl(x,F_DUPFD,esPtr->fdin);
    close(x);
  }
  expCloseOnExec(esPtr->fdin);
  esPtr->fdBusy = TRUE;
}

d350 1
a351 3
	    Tcl_UnregisterChannel(interp,esPtr->channel);
	    /* at this point esPtr may have been freed so don't touch it
               any longer */
a352 2
    } else {
      expBusy(esPtr);
d457 1
a457 1
expCloseOnExec(fd)
d460 1
a460 1
     (void) fcntl(fd,F_SETFD,1);
a522 1
    ExpState *esPtr = 0;
d551 1
a551 1
    char *chanName = 0;
d571 1
a571 1
    Tcl_Channel channel;
d605 1
a605 1
	    chanName = argv[1];
d612 1
a612 1
	    chanName = argv[1];
d674 1
a674 1
    if (chanName && (argc != 0)) {
d679 1
a679 1
    if (!pty_only && !chanName && (argc == 0)) {
d701 1
a701 1
    if (!chanName) {
a739 6
	/* ordinarily channel creation takes care of close-on-exec
	 * but because that will occur *after* fork, force close-on-exec
	 * now in this case.
	 */
	expCloseOnExec(master);

d746 1
d754 1
a754 1
	if (!(channel = Tcl_GetChannel(interp,chanName,&mode))) {
d762 1
a762 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_READABLE, (ClientData) &rfd)) {
d767 1
a767 1
	    if (TCL_ERROR == Tcl_GetChannelHandle(channel, TCL_WRITABLE, (ClientData) &wfd)) {
d785 1
d797 2
a798 1
    if (chanName || pty_only) {
d801 2
a802 2
	if (chanName) {
	    esPtr->channel_orig = channel;
d815 1
a815 1
	if (!chanName) {
d870 2
d877 1
a877 1

d951 3
d961 1
a961 1
	expCloseOnExec(status_pipe[1]);
a1193 11
parent_error:
    Tcl_DStringFree(&dstring);
    if (esPtr) {
        exp_close(interp,esPtr);
	waitpid(esPtr->pid,&esPtr->wait,0);
	if (esPtr->registered) {
	  esPtr->registered = 0;
	  Tcl_UnregisterChannel(interp,esPtr->channel);
	}
    }
    return TCL_ERROR;
d2635 3
a2637 5
    /* If user hasn't already called close, do so on their behalf.
     * Check before calling exp_close since it will write over the
     * result that we've already written! */

    if (esPtr->open) exp_close(interp,esPtr);
d2640 1
a2641 1
	Tcl_UnregisterChannel(interp,esPtr->channel);
@


5.30.2.12
log
@fixed examples
@
text
@a191 16
expStateCheck(interp,esPtr,open,adjust,msg)
    Tcl_Interp *interp;
    ExpState *esPtr;
    int open;
    int adjust;
    char *msg;
{
    if (open && !esPtr->open) {
	exp_error(interp,"%s: spawn id %s not open",msg,esPtr->name);
	return(0);
    }
    if (adjust) expAdjust(esPtr);
    return esPtr;
}

ExpState *
a200 1
    char *chanName;
d211 1
d213 4
a216 4
    chanName = Tcl_GetChannelName(channel);
    if (0 != strncmp(chanName,"exp",3)) {
	exp_error(interp,"%s: %s is not an expect channel - use spawn -open to convert",msg,chanName);
	return(0);
d218 3
d222 14
a235 3
    esPtr = Tcl_GetChannelInstanceData(channel);

    return expStateCheck(interp,esPtr,open,adjust,msg);
@


5.30.2.13
log
@more mods
@
text
@d364 1
d1217 2
a1218 1
	    Tcl_UnregisterChannel(interp,esPtr->channel);
d2670 1
d2756 1
a2756 7
	ExpState *stdinout = tsdPtr->stdinout;
	if (stdinout->valid) {
	    exp_close(interp,stdinout);
	    if (stdinout->registered) {
		Tcl_UnregisterChannel(interp,stdinout->channel);
	    }
	}
d2759 2
a2760 2
	/* tsdPtr->stdinout = expCreateChannel(interp,0,1,EXP_NOPID);*/
	/* tsdPtr->stdinout->keepForever = 1;*/
a2762 2
	ExpState *devtty = tsdPtr->devtty;
	
d2764 1
a2764 6
	if (devtty->valid) {
	    exp_close(interp,devtty);
	    if (devtty->registered) {
		Tcl_UnregisterChannel(interp,devtty->channel);
	    }
	}
d2766 2
a2767 2
	/* tsdPtr->devtty = expCreateChannel(interp,2,2,EXP_NOPID);*/
	/* tsdPtr->devtty->keepForever = 1;*/
@


5.30.2.14
log
@Fixed interact's -input/-output.
More fixes to exp_eval_with_one_arg.
Now runs dislocate.
@
text
@d230 1
a230 1
    if (!isExpChannelName(chanName)) {
d240 3
d861 2
a862 1
    if (NULL == (argv[0] = Tcl_TranslateFileName(interp,argv[0],&dstring))) {
a1633 2
	i->direct = (isExpChannelName(arg)?EXP_DIRECT:EXP_INDIRECT);
#if OBSOLETE
a1634 1
#endif
d1676 2
a1677 3
static void
exp_i_parse_states(interp,i) /* INTL */
Tcl_Interp *interp;
a1679 1
    struct ExpState *esPtr;
d1685 3
a1687 1
    if (Tcl_SplitList(NULL, p, &argc, &argv) != TCL_OK) goto error;
d1690 1
a1690 3
        esPtr = expStateFromChannelName(interp,argv[j],1,0,0,"");
	if (!esPtr) goto error;
	exp_i_add_state(i,esPtr);
a1692 5
    return;
error:
    expDiagLogU("exp_i_parse_states: ");
    expDiagLogU(Tcl_GetStringResult(interp));
    return;
d1701 9
a1709 1
  char *p;	/* string representation of list of spawn ids */
d1711 17
a1727 26
  if (i->direct == EXP_INDIRECT) {
    p = Tcl_GetVar(interp,i->variable,TCL_GLOBAL_ONLY);
    if (!p) {
      p = "";
      /* *really* big variable names could blow up expDiagLog! */
      expDiagLog("warning: indirect variable %s undefined",i->variable);
    }
    
    if (i->value) {
      if (streq(p,i->value)) return;
      
      /* replace new value with old */
      ckfree(i->value);
    }
    i->value = ckalloc(strlen(p)+1);
    strcpy(i->value,p);

    exp_free_state(i->state_list);
    i->state_list = 0;
  } else {
    /* no free, because this should only be called on */
    /* "direct" i's once */
    i->state_list = 0;
  }
  exp_i_parse_states(interp, i);
  return;
@


5.30.2.15
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d85 1
a85 1
#define NULL_STRING "\300\200" /* hex C080 */
a184 2
    static char *user_spawn_id = "exp0";

d186 1
a186 1
    if (!name) name = user_spawn_id;
d235 1
a235 1
    esPtr = (ExpState *)Tcl_GetChannelInstanceData(channel);
d264 1
d386 1
d423 8
a430 8
    Tcl_SetVar(interp, "user_spawn_id", tsdPtr->stdinout->name,0);
    Tcl_SetVar(interp,"error_spawn_id",  tsdPtr->stderrX->name,0);
    Tcl_SetVar(interp,  "any_spawn_id",   EXP_SPAWN_ID_ANY_LIT,0);

    /* user_spawn_id is NOT /dev/tty which could (at least in theory
     * anyway) be later re-opened on a different fd, while stdin might
     * have been redirected away from /dev/tty
     */
d433 2
a508 18
static
void
expSetpgrp()
{
#ifdef MIPS_BSD
    /* required on BSD side of MIPS OS <jmsellen@@watdragon.waterloo.edu> */
#   include <sysv/sys.s>
    syscall(SYS_setpgrp);
#endif

#ifdef SETPGRP_VOID
    (void) setpgrp();
#else
    (void) setpgrp(0,0);
#endif
}


d568 2
d587 2
d998 1
a998 1
	expSetpgrp();
d1001 7
a1007 1
	expSetpgrp();
d1283 2
a1284 2
/* if this works, exact_write should disappear and function should
   call Tcl_WriteChars directly */
d1291 16
a1306 1
    Tcl_WriteChars(esPtr->channel,buffer,rembytes);
d1813 1
d1816 1
a1816 1
	"-i", "-h", "-s", "-null", "-0", "-raw", "-break", "--", (char *)0
d1838 4
d1847 1
a1847 1
		goto getString;
a1890 1
getString:
a2072 1
    expLogLeaveOpenSet(leaveOpen);
d2247 1
a2247 1
	Tcl_Exit(value);
d2596 1
a2596 1
	esPtr = expWaitOnAny();
d2798 1
a2798 1
    expSetpgrp();
d2800 1
a2800 1
    expSetpgrp();
d2807 7
a2813 1
    expSetpgrp();
d2881 1
a2881 1
Exp_InterpreterObjCmd(clientData, interp, objc, objv)
d2884 2
a2885 2
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d2887 3
a2889 27
    Tcl_Obj *eofObj = 0;
    int i;
    int index;
    int rc;

    static char *options[] = {
	"-eof", (char *)0
    };
    enum options {
	FLAG_EOF
    };

    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	case FLAG_EOF:
	    i++;
	    if (i >= objc) {
		Tcl_WrongNumArgs(interp, 1, objv,"-eof cmd");
		return TCL_ERROR;
	    }
	    eofObj = objv[i];
	    Tcl_IncrRefCount(eofObj);
	    break;
a2890 1
    }
d2892 3
a2894 5
    /* errors and ok, are caught by exp_interpreter() and discarded */
    /* to return TCL_OK, type "return" */
    rc = exp_interpreter(interp,eofObj);
    if (eofObj) Tcl_DecrRefCount(eofObj);
    return rc;
d3067 1
a3067 1
{"interpreter",	Exp_InterpreterObjCmd,	0,	0,	0},
@


5.30.2.16
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@a774 4

	if (pty_only) {
	  write_master = master;
	}
d1179 4
@


5.30.2.17
log
@Ignore errors from ioctl(TIOCSCTTY)
Update documentation
@
text
@a1076 4
	  restore_error_fd
	  expErrorLog("failed to get controlling terminal using TIOCSCTTY");
	  exit(-1);
	}
d1078 1
a1078 8
	(void) ioctl(0,TIOCSCTTY,(char *)0);
	/* ignore return value - on some systems, it is defined but it
	 * fails and it doesn't seem to cause any problems.  Or maybe
	 * it works but returns a bogus code.  Noone seems to be able
	 * to explain this to me.  The systems are an assortment of
	 * different linux systems (and FreeBSD 2.5), RedHat 5.2 and
	 * Debian 2.0
	 */
d1080 4
@


5.30.2.18
log
@Fixed Expect's standalone C library and examples.  This required some
changes to Expect since it and the library share some things.
@
text
@d1203 4
d3109 2
@


5.30.2.19
log
@Fixes for picky HP compiler.
@
text
@d76 1
@


5.29
log
@numerous edits - getting synchronized (first time I've used CVS), see
HISTORY file for more info
@
text
@d2288 4
@


5.28
log
@Initial revision
@
text
@d1250 6
a1255 1
		errorlog("open(slave pty): %s\r\n",Tcl_ErrnoMsg(errno));
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@
