head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.1.2.3
	telco-tec-win32-take2-branch:1.1.2.1.0.2
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2001.09.13.01.08.46;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.13.01.08.46;	author davygrvy;	state Exp;
branches
	1.1.2.1.2.1;
next	1.1.2.2;

1.1.2.2
date	2001.10.02.22.19.18;	author davygrvy;	state Exp;
branches;
next	;

1.1.2.1.2.1
date	2001.11.22.08.50.38;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.2;

1.1.2.1.2.2
date	2002.02.10.02.58.52;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.3;

1.1.2.1.2.3
date	2002.02.10.12.04.22;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expect.c was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.2.1
log
@snap29 "import"
@
text
@a0 3095
/*
 * expect.c --
 *
 *	expect commands
 *
 * Written by: Don Libes, NIST, 2/6/90
 *
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 *
 *
 * Windows NT by Gordon Chaffee
 * Copyright (c) 1997 by Mitel Corporations
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <sys/types.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>	/* for isspace */
#include <time.h>	/* for time(3) */

#include "exp_port.h"

#include "tclInt.h"
#include "tclPort.h"
#include "tclRegexp.h"
#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"
#include "exp_log.h"
#include "exp_event.h"
#include "exp_tstamp.h"	/* this should disappear when interact */
			/* loses ref's to it */
#ifdef TCL_DEBUGGER
#include "Dbg.h"
#endif

/* initial length of strings that we can guarantee patterns can match */
int exp_default_match_max =	2000;
#define INIT_EXPECT_TIMEOUT_LIT	"10"	/* seconds */
#define INIT_EXPECT_TIMEOUT	10	/* seconds */
int exp_default_parity =	TRUE;
int exp_default_rm_nulls =	TRUE;

/* user variable names */
#define EXPECT_TIMEOUT		"timeout"
#define EXPECT_OUT		"expect_out"

/* 1 ecase struct is reserved for each case in the expect command.  Note that
eof/timeout don't use any of theirs, but the algorithm is simpler this way. */

struct ecase {	/* case for expect command */
    struct exp_i	*i_list;
    char *pat;	/* original pattern spec */
    char *body;	/* ptr to body to be executed upon match */
#define PAT_EOF		1
#define PAT_TIMEOUT	2
#define PAT_DEFAULT	3
#define PAT_FULLBUFFER	4
#define PAT_GLOB	5 /* glob-style pattern list */
#define PAT_RE		6 /* regular expression */
#define PAT_EXACT	7 /* exact string */
#define PAT_NULL	8 /* ASCII 0 */
#define PAT_TYPES	9 /* used to size array of pattern type descriptions */
    int use;	/* PAT_XXX */
    int simple_start;/* offset from start of buffer denoting where a */
    /* glob or exact match begins */
    int transfer;	/* if false, leave matched chars in input stream */
    int indices;	/* if true, write indices */
    /*	int iwrite;*/	/* if true write spawn_id */
    int iread;	/* if true, reread indirects */
    int timestamp;	/* if true, write timestamps */
#define CASE_UNKNOWN	0
#define CASE_NORM	1
#define CASE_LOWER	2
    int Case;	/* convert case before doing match? */
    regexp *re;	/* if this is 0, then pattern match via glob */
};

/* descriptions of the pattern types, used for debugging */
char *pattern_style[PAT_TYPES];

struct exp_cases_descriptor {
    int count;
    struct ecase **cases;
};

/* This describes an Expect command */
static
struct exp_cmd_descriptor {
    int cmdtype;			/* bg, before, after */
    int duration;			/* permanent or temporary */
    int timeout_specified_by_flag;	/* if -timeout flag used */
    int timeout;			/* timeout period if flag used */
    struct exp_cases_descriptor ecd;
    struct exp_i *i_list;
} exp_cmds[4];
/* note that exp_cmds[FG] is just a fake, the real contents is stored
   in some dynamically-allocated variable.  We use exp_cmds[FG] mostly
   as a well-known address and also as a convenience and so we allocate
   just a few of its fields that we need. */

static void
exp_cmd_init(cmd,cmdtype,duration)
    struct exp_cmd_descriptor *cmd;
    int duration;
    int cmdtype;
{
    cmd->duration = duration;
    cmd->cmdtype = cmdtype;
    cmd->ecd.cases = 0;
    cmd->ecd.count = 0;
    cmd->i_list = 0;
}

static int i_read_errno;/* place to save errno, if i_read() == -1, so it
			   doesn't get overwritten before we get to read it */

void exp_background_filehandlers_run_all();

/*
 * Declarations for local procedures defined in this file:
 */

/*exp_indirect_updateX is called by Tcl when an indirect variable is set */
static char *		exp_indirect_update1 _ANSI_ARGS_((Tcl_Interp *interp,
			    struct exp_cmd_descriptor *ecmd,
			    struct exp_i *exp_i));
static char *		exp_indirect_update2 _ANSI_ARGS_((
			    ClientData clientData,
			    Tcl_Interp *interp, char *name1, char *name2,
			    int flags)); /* 2-part Tcl variable names */
static int		exp_i_read _ANSI_ARGS_((Tcl_Interp *,struct exp_f *,
			    int,int));


/*
 *----------------------------------------------------------------------
 *
 * rm_nulls --
 *
 *	Remove nulls from s.  Initially, the number of chars in s is c,
 *	not strlen(s).  This count does not include the trailing null.
 *
 * Results:
 *	Returns number of nulls removed.
 *
 *----------------------------------------------------------------------
 */

static int
rm_nulls(s,c)
    char *s;
    int c;
{
    char *s2 = s;		/* points to place in original string to put */
    /* next non-null character */
    int count = 0;
    int i;

    for (i=0;i<c;i++,s++) {
	if (0 == *s) {
	    count++;
	    continue;
	}
	if (count) *s2 = *s;
	s2++;
    }
    return(count);
}

/*
 *----------------------------------------------------------------------
 *
 * free_ecase --
 *
 *	Free up everything in ecase
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

static void
free_ecase(interp,ec,free_ilist)
    Tcl_Interp *interp;
    struct ecase *ec;
    int free_ilist;		/* if we should free ilist */
{
    if (ec->re) ckfree((char *)ec->re);

    if (ec->i_list->duration == EXP_PERMANENT) {
	if (ec->pat) ckfree(ec->pat);
	if (ec->body) ckfree(ec->body);
    }

    if (free_ilist) {
	ec->i_list->ecount--;
	if (ec->i_list->ecount == 0)
	    exp_free_i(interp,ec->i_list,exp_indirect_update2);
    }

    ckfree((char *)ec);		/* NEW */
}

/*
 *----------------------------------------------------------------------
 *
 * free_ecases --
 *
 *	Free up any argv structures in the ecases
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

static void
free_ecases(interp,eg,free_ilist)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *eg;
    int free_ilist;		/* if true, free ilists */
{
    int i;

    if (!eg->ecd.cases) return;

    for (i=0;i<eg->ecd.count;i++) {
	free_ecase(interp,eg->ecd.cases[i],free_ilist);
    }
    ckfree((char *)eg->ecd.cases);

    eg->ecd.cases = 0;
    eg->ecd.count = 0;
}


/*
 *----------------------------------------------------------------------
 *
 * save_str --
 *
 *	Make a copy of a string if necessary.  In many places, there
 *	is no need to malloc a copy of a string, since it will be
 *	freed before we return to Tcl
 *
 * Results:
 *	String is set through lhs
 *
 * Side Effects:
 *	Memory may be allocated for a copy of the string
 *
 *---------------------------------------------------------------------- 
 */

static void
save_str(lhs,rhs,nosave)
    char **lhs;	/* left hand side */
    char *rhs;	/* right hand side */
    int nosave;
{
    if (nosave || (rhs == 0)) {
	*lhs = rhs;
    } else {
	*lhs = ckalloc(strlen(rhs) + 1);
	strcpy(*lhs,rhs);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * exp_one_arg_braced --
 *
 *	The intent of this test is to support the ability of
 *	commands to have all their args braced as one.  This
 *	conflicts with the possibility of actually intending
 *	to have a single argument. The bad case is in expect
 *	which can have a single argument with embedded \n's
 *	although it's rare.  Examples that this code should handle:
 *
 *	\n		FALSE (pattern)
 *	\n\n		FALSE
 *	\n  \n \n	FALSE
 *	foo		FALSE
 *	foo\n		FALSE
 *	\nfoo\n		TRUE  (set of args)
 *	\nfoo\nbar	TRUE
 *
 *	Current test is very cheap and almost always right :-)
 *
 * Results:
 * 	TRUE if string appears to be a set of arguments
 *
 *----------------------------------------------------------------------
 */
int 
exp_one_arg_braced(p)
    char *p;
{
    int seen_nl = FALSE;

    for (;*p;p++) {
	if (*p == '\n') {
	    seen_nl = TRUE;
	    continue;
	}

	if (!isspace(*p)) {
	    return(seen_nl);
	}
    }
    return FALSE;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_eval_with_one_arg --
 *
 *	Called to execute a command of only one argument - a hack
 *	to commands to be called with all args surrounded by an
 *	outer set of braces
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
int
exp_eval_with_one_arg(clientData,interp,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    char **argv;
{
    char *buf;
    int rc;
    char *a;

    /* + 11 is for " -nobrace " and null at end */
    buf = ckalloc(strlen(argv[0]) + strlen(argv[1]) + 11);
    /* recreate statement (with -nobrace to prevent recursion) */
    sprintf(buf,"%s -nobrace %s",argv[0],argv[1]);

    /*
     * replace top-level newlines with blanks
     */

    /* Should only be necessary to run over argv[1] and then sprintf */
    /* that into the buffer, but the ICEM guys insist that writing */
    /* back over the original arguments makes their Tcl compiler very */
    /* unhappy. */
    for (a=buf;*a;) {
	for (;isspace(*a);a++) {
	    if (*a == '\n') *a = ' ';
	}
	a = TclWordEnd(a,a+strlen(a),0,(int *)0)+1;
    }

    rc = Tcl_Eval(interp,buf);

    ckfree(buf);
    return(rc);
}

static void
ecase_clear(ec)
    struct ecase *ec;
{
    ec->i_list = 0;
    ec->pat = 0;
    ec->body = 0;
    ec->transfer = TRUE;
    ec->indices = FALSE;
    /*	ec->iwrite = FALSE;*/
    ec->iread = FALSE;
    ec->timestamp = FALSE;
    ec->re = 0;
    ec->Case = CASE_NORM;
    ec->use = PAT_GLOB;
}

static struct ecase *
ecase_new()
{
    struct ecase *ec = (struct ecase *)ckalloc(sizeof(struct ecase));

    ecase_clear(ec);
    return ec;
}

/*
 *----------------------------------------------------------------------
 *
 * parse_expect_args --
 *
 *	Parses the arguments to expect or its variants. It normally
 *	returns TCL_OK, and returns TCL_ERROR for failure. (It can't
 *	return i_list directly because there is no way to differentiate
 *	between clearing, say, expect_before and signalling an error.)
 *
 *	eg (expect_global) is initialized to reflect the arguments parsed
 *	eg->ecd.cases is an array of ecases
 *	eg->ecd.count is the # of ecases
 *	eg->i_list is a linked list of exp_i's which represent the -i info
 * 
 *	Each exp_i is chained to the next so that they can be easily free'd
 *	if necessary.  Each exp_i has a reference count.  If the -i is not
 *	used (e.g., has no following patterns), the ref count will be 0.
 * 
 *	Each ecase points to an exp_i.  Several ecases may point to the
 *	same exp_i. Variables named by indirect exp_i's are read for the
 *	direct values.
 * 
 *	If called from a foreground expect and no patterns or -i are given,
 *	a default exp_i is forced so that the command "expect" works right.
 * 
 *	The exp_i chain can be broken by the caller if desired.
 *
 * Results:
 *	A standard TCL result.
 *
 *----------------------------------------------------------------------
 */

static int
parse_expect_args(interp,eg,default_spawn_id,argc,argv,argv0)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *eg;
    struct exp_f *default_spawn_id; /* suggested master if called as
				     * expect_user or _tty */
    int argc;
    char **argv;
    char *argv0;
{
    int i;
    char *arg;
    struct ecase ec;		/* temporary to collect args */

    argv++;
    argc--;

    eg->timeout_specified_by_flag = FALSE;

    ecase_clear(&ec);

    /* Allocate an array to store the ecases.  Force array even if 0 */
    /* cases.  This will often be too large (i.e., if there are flags) */
    /* but won't affect anything. */

    eg->ecd.cases = (struct ecase **)
	ckalloc(sizeof(struct ecase *) * (1+(argc/2)));

    eg->ecd.count = 0;

    for (i = 0;i<argc;i++) {
	arg = argv[i];
	
	if (exp_flageq("timeout",arg,7)) {
	    ec.use = PAT_TIMEOUT;
	} else if (exp_flageq("eof",arg,3)) {
	    ec.use = PAT_EOF;
	} else if (exp_flageq("full_buffer",arg,11)) {
	    ec.use = PAT_FULLBUFFER;
	} else if (exp_flageq("default",arg,7)) {
	    ec.use = PAT_DEFAULT;
	} else if (exp_flageq("null",arg,4)) {
	    ec.use = PAT_NULL;
	} else if (arg[0] == '-') {
	    arg++;
	    if (exp_flageq1('-',arg) /* "--" is deprecated */
		|| exp_flageq("glob",arg,2)) {
		i++;
		/* assignment here is not actually necessary */
		/* since cases are initialized this way above */
		/* ec.use = PAT_GLOB; */
	    } else if (exp_flageq("regexp",arg,2)) {
		i++;
		ec.use = PAT_RE;
		TclRegError((char *)0);
		if (!(ec.re = TclRegComp(argv[i]))) {
		    exp_error(interp,"bad regular expression: %s",
			      TclGetRegError());
		    goto error;
		}
	    } else if (exp_flageq("exact",arg,2)) {
		i++;
		ec.use = PAT_EXACT;
	    } else if (exp_flageq("notransfer",arg,1)) {
		ec.transfer = 0;
		continue;
	    } else if (exp_flageq("nocase",arg,3)) {
		ec.Case = CASE_LOWER;
		continue;
	    } else if (exp_flageq1('i',arg)) {
		i++;
		if (i>=argc) {
		    exp_error(interp,"-i requires following spawn_id");
		    goto error;
		}

		ec.i_list = exp_new_i_complex(interp,argv[i],
					      eg->duration,exp_indirect_update2,
					      argv0);
		if (ec.i_list == NULL) {
		    goto error;
		}
		ec.i_list->cmdtype = eg->cmdtype;

		/* link new i_list to head of list */
		ec.i_list->next = eg->i_list;
		eg->i_list = ec.i_list;

		continue;
	    } else if (exp_flageq("indices",arg,2)) {
		ec.indices = TRUE;
		continue;
	    } else if (exp_flageq("iwrite",arg,2)) {
		/*				ec.iwrite = TRUE;*/
		continue;
	    } else if (exp_flageq("iread",arg,2)) {
		ec.iread = TRUE;
		continue;
	    } else if (exp_flageq("timestamp",arg,2)) {
		ec.timestamp = TRUE;
		continue;
	    } else if (exp_flageq("timeout",arg,2)) {
		i++;
		if (i>=argc) {
		    exp_error(interp,"-timeout requires following # of seconds");
		    goto error;
		}

		eg->timeout = atoi(argv[i]);
		eg->timeout_specified_by_flag = TRUE;
		continue;
	    } else if (exp_flageq("nobrace",arg,7)) {
		/* nobrace does nothing but take up space */
		/* on the command line which prevents */
		/* us from re-expanding any command lines */
		/* of one argument that looks like it should */
		/* be expanded to multiple arguments. */
		continue;
	    } else {
		exp_error(interp,"usage: unrecognized flag <%s>",arg);
		goto error;
	    }
	}

	/* if no -i, use previous one */
	if (!ec.i_list) {
	    /* if no -i flag has occurred yet, use default */
	    if (!eg->i_list) {
		if (default_spawn_id != NULL) {
		    eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
		} else {
		    /* it'll be checked later, if used */
		    default_spawn_id = exp_update_master(interp,0,0);
		    eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
		}
	    }
	    ec.i_list = eg->i_list;
	}
	ec.i_list->ecount++;

	/* save original pattern spec */
	/* keywords such as "-timeout" are saved as patterns here */
	/* useful for debugging but not otherwise used */
	save_str(&ec.pat,argv[i],eg->duration == EXP_TEMPORARY);
	save_str(&ec.body,argv[i+1],eg->duration == EXP_TEMPORARY);
			
	i++;

	*(eg->ecd.cases[eg->ecd.count] = ecase_new()) = ec;

	/* clear out for next set */
	ecase_clear(&ec);

	eg->ecd.count++;
    }

    /* if no patterns at all have appeared force the current */
    /* spawn id to be added to list anyway */

    if (eg->i_list == 0) {
	if (default_spawn_id != NULL) {
	    eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
	} else {
	    /* it'll be checked later, if used */
	    default_spawn_id = exp_update_master(interp,0,0);
	    eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
	}
    }

    return(TCL_OK);

 error:
    /* very hard to free case_master_list here if it hasn't already */
    /* been attached to a case, ugh */

    /* note that i_list must be avail to free ecases! */
    free_ecases(interp,eg,0);

    /* undo temporary ecase */
    /* free_ecase doesn't quite handle this right, so do it by hand */
    if (ec.re) ckfree((char *)ec.re);
    if (eg->duration == EXP_PERMANENT) {
	if (ec.pat) ckfree(ec.pat);
	if (ec.body) ckfree(ec.body);
    }

    if (eg->i_list)
	exp_free_i(interp,eg->i_list,exp_indirect_update2);
    return(TCL_ERROR);
}

#define EXP_IS_DEFAULT(x)	((x) == EXP_TIMEOUT || (x) == EXP_EOF)

static char yes[] = "yes\r\n";
static char no[] = "no\r\n";


/* this describes status of a successful match */
struct eval_out {
    struct ecase *e;		/* ecase that matched */
    struct exp_f *f;		/* struct exp_f that matched */
    char *buffer;		/* buffer that matched */
    int match;			/* # of chars in buffer that matched */
    /* or # of chars in buffer at EOF */
};

/*
 *----------------------------------------------------------------------
 *
 * eval_case_string --
 *
 *	Like eval_cases, but handles only a single cases that needs a real
 *	string match
 *
 * Results:
 *	Returns EXP_X where X is MATCH, NOMATCH, FULLBUFFER, TCL_ERRROR
 *
 *----------------------------------------------------------------------
 */
static int
eval_case_string(interp,e,f,o,last_f,last_case,suffix)
    Tcl_Interp *interp;
    struct ecase *e;
    struct exp_f *f;
    struct eval_out *o;		/* 'output' - i.e., final case of interest */

    /* next two args are for debugging, when they change, reprint buffer */
    struct exp_f **last_f;
    int *last_case;
    char *suffix;
{
    char *buffer;
    
    /* if -nocase, use the lowerized buffer */
    buffer = ((e->Case == CASE_NORM)?f->buffer:f->lower);
    
    /* if master or case changed, redisplay debug-buffer */
    if ((f != *last_f) || e->Case != *last_case) {
	debuglog("\r\nexpect%s: does \"%s\" (spawn_id %s) match %s ",
		 suffix, dprintify(buffer),f->spawnId, pattern_style[e->use]);
	*last_f = f;
	*last_case = e->Case;
    }
    
    if (e->use == PAT_RE) {
	debuglog("\"%s\"? ",dprintify(e->pat));
	TclRegError((char *)0);
	if (buffer && TclRegExec(e->re,buffer,buffer)) {
	    o->e = e;
	    o->match = e->re->endp[0]-buffer;
	    o->buffer = buffer;
	    o->f = f;
	    debuglog(yes);
	    return(EXP_MATCH);
	} else {
	    debuglog(no);
	    if (TclGetRegError()) {
		exp_error(interp,"-re failed: %s",TclGetRegError());
		return(EXP_TCLERROR);
	    }
	}
    } else if (e->use == PAT_GLOB) {
	int match;		/* # of chars that matched */
	
	debuglog("\"%s\"? ",dprintify(e->pat));
	if (buffer && (-1 != (match = Exp_StringMatch(
						      buffer,e->pat,&e->simple_start)))) {
	    o->e = e;
	    o->match = match;
	    o->buffer = buffer;
	    o->f = f;
	    debuglog(yes);
	    return(EXP_MATCH);
	} else debuglog(no);
    } else if (e->use == PAT_EXACT) {
	char *p = strstr(buffer,e->pat);
	debuglog("\"%s\"? ",dprintify(e->pat));
	if (p) {
	    e->simple_start = p - buffer;
	    o->e = e;
	    o->match = strlen(e->pat);
	    o->buffer = buffer;
	    o->f = f;
	    debuglog(yes);
	    return(EXP_MATCH);
	} else debuglog(no);
    } else if (e->use == PAT_NULL) {
	int i = 0;
	debuglog("null? ");
	for (;i<f->size;i++) {
	    if (buffer[i] == 0) {
		o->e = e;
		o->match = i+1;	/* in this case, match is */
		/* just the # of chars + 1 */
		/* before the null */
		o->buffer = buffer;
		o->f = f;
		debuglog(yes);
		return EXP_MATCH;
	    }
	}
	debuglog(no);
    } else if ((f->size == f->msize) && (f->size > 0)) {
	debuglog("%s? ",e->pat);
	o->e = e;
	o->match = f->umsize;
	o->buffer = f->buffer;
	o->f = f;
	debuglog(yes);
	return(EXP_FULLBUFFER);
    }
    return(EXP_NOMATCH);
}

/*
 *----------------------------------------------------------------------
 *
 * eval_cases --
 *
 *	Sets o.e if successfully finds a matching pattern, eof,
 *	timeout or deflt.
 *
 * Results:
 *	Original status arg or EXP_TCLERROR
 *
 * Side Effects:
 *
 *----------------------------------------------------------------------
 */
static int
eval_cases(interp,eg,f,o,last_f,last_case,status,masters,mcount,suffix)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *eg;
    struct exp_f *f;
    struct eval_out *o;		/* 'output' - i.e., final case of interest */
    /* next two args are for debugging, when they change, reprint buffer */
    struct exp_f **last_f;
    int *last_case;
    int status;
    struct exp_fs **masters;
    int mcount;
    char *suffix;
{
    int i;
    struct exp_f *em;		/* master of ecase */
    struct ecase *e;
    
    if (o->e || status == EXP_TCLERROR || eg->ecd.count == 0) return(status);
    
    if (status == EXP_TIMEOUT) {
	for (i=0;i<eg->ecd.count;i++) {
	    e = eg->ecd.cases[i];
	    if (e->use == PAT_TIMEOUT || e->use == PAT_DEFAULT) {
		o->e = e;
		break;
	    }
	}
	return(status);
    } else if (status == EXP_EOF) {
	for (i=0;i<eg->ecd.count;i++) {
	    e = eg->ecd.cases[i];
	    if (e->use == PAT_EOF || e->use == PAT_DEFAULT) {
		struct exp_fs_list *fsl;

		for (fsl=e->i_list->fs_list; fsl ;fsl=fsl->next) {
		    em = fsl->f;
		    if (em == NULL || em == exp_f_any || em == f) {
			o->e = e;
			return(status);
		    }
		}
	    }
	}
	return(status);
    }
    
    /* the top loops are split from the bottom loop only because I can't */
    /* split'em further. */
    
    /* The bufferful condition does not prevent a pattern match from */
    /* occurring and vice versa, so it is scanned with patterns */
    for (i=0;i<eg->ecd.count;i++) {
	struct exp_fs_list *fsl;
	int j;

	e = eg->ecd.cases[i];
	if (e->use == PAT_TIMEOUT ||
	    e->use == PAT_DEFAULT ||
	    e->use == PAT_EOF) continue;

	for (fsl = e->i_list->fs_list; fsl; fsl = fsl->next) {
	    em = fsl->f;
	    /* if em == exp_f_any, then user is explicitly asking */
	    /* every case to be checked against every master */
	    if (em == NULL || em == exp_f_any) {
		/* test against each spawn_id */
		for (j=0;j<mcount;j++) {
		    status = eval_case_string(interp,e,masters[j],o,last_f,last_case,suffix);
		    if (status != EXP_NOMATCH) return(status);
		}
	    } else {
		/* reject things immediately from wrong spawn_id */
		if (em != f) continue;

		status = eval_case_string(interp,e,f,o,last_f,last_case,suffix);
		if (status != EXP_NOMATCH) return(status);
	    }
	}
    }
    return(EXP_NOMATCH);
}

static void
ecases_remove_by_expi(interp,ecmd,exp_i)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *ecmd;
    struct exp_i *exp_i;
{
    int i;

    /* delete every ecase dependent on it */
    for (i=0;i<ecmd->ecd.count;) {
	struct ecase *e = ecmd->ecd.cases[i];
	if (e->i_list == exp_i) {
	    free_ecase(interp,e,0);

	    /* shift remaining elements down */
	    /* but only if there are any left */
	    if (i+1 != ecmd->ecd.count) {
		memcpy(&ecmd->ecd.cases[i],
		       &ecmd->ecd.cases[i+1],
		       ((ecmd->ecd.count - i) - 1) * 
		       sizeof(struct exp_cmd_descriptor *));
	    }
	    ecmd->ecd.count--;
	    if (0 == ecmd->ecd.count) {
		ckfree((char *)ecmd->ecd.cases);
		ecmd->ecd.cases = 0;
	    }
	} else {
	    i++;
	}
    }
}

/* remove exp_i from list */
static void
exp_i_remove(interp,ei,exp_i)
    Tcl_Interp *interp;
    struct exp_i **ei;	/* list to remove from */
    struct exp_i *exp_i;	/* element to remove */
{
    /* since it's in middle of list, free exp_i by hand */
    for (;*ei; ei = &(*ei)->next) {
	if (*ei == exp_i) {
	    *ei = exp_i->next;
	    exp_i->next = 0;
	    exp_free_i(interp,exp_i,exp_indirect_update2);
	    break;
	}
    }
}

/* remove exp_i from list and remove any dependent ecases */
static void
exp_i_remove_with_ecases(interp,ecmd,exp_i)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *ecmd;
    struct exp_i *exp_i;
{
    ecases_remove_by_expi(interp,ecmd,exp_i);
    exp_i_remove(interp,&ecmd->i_list,exp_i);
}

/* remove ecases tied to a single direct spawn id */
static void
ecmd_remove_f(interp,ecmd,f,direct)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *ecmd;
    struct exp_f *f;
    int direct;
{
    struct exp_i *exp_i, *next;
    struct exp_fs_list **fsl;

    for (exp_i=ecmd->i_list;exp_i;exp_i=next) {
	next = exp_i->next;

	if (!(direct & exp_i->direct)) continue;

	for (fsl = &exp_i->fs_list;*fsl;) {
	    if (f == ((*fsl)->f)) {
		struct exp_fs_list *tmp = *fsl;
		*fsl = (*fsl)->next;
		exp_free_fs_single(tmp);

		/* if last bg ecase, disarm spawn id */
		if (ecmd->cmdtype == EXP_CMD_BG) {
		    f->bg_ecount--;
		    if (f->bg_ecount == 0) {
			exp_disarm_background_filehandler(f);
			f->bg_interp = 0;
		    }
		}

		continue;
	    }
	    fsl = &(*fsl)->next;
	}

	/* if left with no fds (and is direct), get rid of it */
	/* and any dependent ecases */
	if (exp_i->direct == EXP_DIRECT && !exp_i->fs_list) {
	    exp_i_remove_with_ecases(interp,ecmd,exp_i);
	}
    }
}

/* this is called from exp_close to clean up f */
void
exp_ecmd_remove_f_direct_and_indirect(interp,f)
    Tcl_Interp *interp;
    struct exp_f *f;
{
    ecmd_remove_f(interp,&exp_cmds[EXP_CMD_BEFORE],f,EXP_DIRECT|EXP_INDIRECT);
    ecmd_remove_f(interp,&exp_cmds[EXP_CMD_AFTER],f,EXP_DIRECT|EXP_INDIRECT);
    ecmd_remove_f(interp,&exp_cmds[EXP_CMD_BG],f,EXP_DIRECT|EXP_INDIRECT);

    /* force it - explanation in exp_tk.c where this func is defined */
    exp_disarm_background_filehandler_force(f);
}

/* arm a list of background f's */
static void
fs_list_arm(interp,fsl)
    Tcl_Interp *interp;
    struct exp_fs_list *fsl;
{
    struct exp_f *f;

    /* for each spawn id in list, arm if necessary */
    for (;fsl;fsl=fsl->next) {
	f = fsl->f;
	if (f == NULL || f == exp_f_any) continue;

	if (f->bg_ecount == 0) {
	    exp_arm_background_filehandler(f);
	    f->bg_interp = interp;
	}
	f->bg_ecount++;
    }
}

/* return TRUE if this ecase is used by this f */
static int
exp_i_uses_f(exp_i,f)
    struct exp_i *exp_i;
    struct exp_f *f;
{
    struct exp_fs_list *fsp;

    for (fsp = exp_i->fs_list;fsp;fsp=fsp->next) {
	if (fsp->f == f) return 1;
    }
    return 0;
}

static void
ecase_append(interp,ec)
    Tcl_Interp *interp;
    struct ecase *ec;
{
    if (!ec->transfer) Tcl_AppendElement(interp,"-notransfer");
    if (ec->indices) Tcl_AppendElement(interp,"-indices");
    /*	if (ec->iwrite) Tcl_AppendElement(interp,"-iwrite");*/
    if (!ec->Case) Tcl_AppendElement(interp,"-nocase");

    if (ec->re) Tcl_AppendElement(interp,"-re");
    else if (ec->use == PAT_GLOB) Tcl_AppendElement(interp,"-gl");
    else if (ec->use == PAT_EXACT) Tcl_AppendElement(interp,"-ex");
    Tcl_AppendElement(interp,ec->pat);
    Tcl_AppendElement(interp,ec->body?ec->body:"");
}

/* append all ecases that match this exp_i */
static void
ecase_by_exp_i_append(interp,ecmd,exp_i)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *ecmd;
    struct exp_i *exp_i;
{
    int i;
    for (i=0;i<ecmd->ecd.count;i++) {
	if (ecmd->ecd.cases[i]->i_list == exp_i) {
	    ecase_append(interp,ecmd->ecd.cases[i]);
	}
    }
}

static void
exp_i_append(interp,exp_i)
    Tcl_Interp *interp;
    struct exp_i *exp_i;
{
    Tcl_AppendElement(interp,"-i");
    if (exp_i->direct == EXP_INDIRECT) {
	Tcl_AppendElement(interp,exp_i->variable);
    } else {
	struct exp_fs_list *fsp;

	/* if more than one element, add braces */
	if (exp_i->fs_list->next)
	    Tcl_AppendResult(interp," {",(char *)0);

	for (fsp = exp_i->fs_list;fsp;fsp=fsp->next) {
	    char buf[10];	/* big enough for a small int */
	    sprintf(buf,"%s",fsp->f->spawnId);
	    Tcl_AppendElement(interp,buf);
	}

	if (exp_i->fs_list->next)
	    Tcl_AppendResult(interp,"} ",(char *)0);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * expect_info --
 *
 *	Return current setting of the permanent expect_before/after/bg
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

int
expect_info(interp,ecmd,argc,argv)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *ecmd;
    int argc;
    char **argv;
{
    struct exp_i *exp_i;
    int i;
    int direct = EXP_DIRECT|EXP_INDIRECT;
    int all = FALSE;		/* report on all fds */
    char *chanId = NULL;
    struct exp_f *f;
    char *argv0 = argv[0];

    while (*argv) {
	if (streq(argv[0],"-i") && argv[1]) {
	    chanId = argv[1];
	    argc-=2; argv+=2;
	} else if (streq(argv[0],"-all")) {
	    all = TRUE;
	    argc--; argv++;
	} else if (streq(argv[0],"-noindirect")) {
	    direct &= ~EXP_INDIRECT;
	    argc--; argv++;
	} else {
	    exp_error(interp,"usage: -info [-all | -i spawn_id]\n");
	    return TCL_ERROR;
	}
    }

    if (all) {
	/* avoid printing out -i when redundant */
	struct exp_i *previous = 0;

	for (i=0;i<ecmd->ecd.count;i++) {
	    if (previous != ecmd->ecd.cases[i]->i_list) {
		exp_i_append(interp,ecmd->ecd.cases[i]->i_list);
		previous = ecmd->ecd.cases[i]->i_list;
	    }
	    ecase_append(interp,ecmd->ecd.cases[i]);
	}
	return TCL_OK;
    }

    if (chanId == NULL) {
	f = exp_update_master(interp,0,0);
	if (f == NULL) {
	    return(TCL_ERROR);
	}
    } else {
	f = exp_chan2f(interp, chanId, 1, 0, argv0);
	if (f == NULL) {
	    /* handle as in indirect */
	    Tcl_ResetResult(interp);
	    for (i=0;i<ecmd->ecd.count;i++) {
		if (ecmd->ecd.cases[i]->i_list->direct == EXP_INDIRECT &&
		    streq(ecmd->ecd.cases[i]->i_list->variable,chanId)) {
		    ecase_append(interp,ecmd->ecd.cases[i]);
		}
	    }
	    return TCL_OK;
	}
    }

    /* print ecases of this direct_fd */
    for (exp_i=ecmd->i_list;exp_i;exp_i=exp_i->next) {
	if (!(direct & exp_i->direct)) continue;
	if (!exp_i_uses_f(exp_i,f)) continue;
	ecase_by_exp_i_append(interp,ecmd,exp_i);
    }

    return TCL_OK;
}

/* Exp_ExpectGlobalCmd is invoked to process expect_before/after */
/*ARGSUSED*/
int
Exp_ExpectGlobalCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int result = TCL_OK;
    struct exp_i *exp_i, **eip;
    struct exp_fs_list *fsl;	/* temp for interating over fs_list */
    struct exp_cmd_descriptor eg;
    int count;
    char *argv0;

    struct exp_cmd_descriptor *ecmd = (struct exp_cmd_descriptor *) clientData;

    if ((argc == 2) && exp_one_arg_braced(argv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,argv));
    } else if ((argc == 3) && streq(argv[1],"-brace")) {
	char *new_argv[2];
	new_argv[0] = argv[0];
	new_argv[1] = argv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_argv));
    }

    if (argc > 1 && (argv[1][0] == '-')) {
	if (exp_flageq("info",&argv[1][1],4)) {
	    return(expect_info(interp,ecmd,argc-2,argv+2));
	} 
    }

    argv0 = argv[0];
    exp_cmd_init(&eg,ecmd->cmdtype,EXP_PERMANENT);

    if (TCL_ERROR == parse_expect_args(interp,&eg,NULL,argc,argv,argv0)) {
	return TCL_ERROR;
    }

    /*
     * visit each NEW direct exp_i looking for spawn ids.
     * When found, remove them from any OLD exp_i's.
     */

    /* visit each exp_i */
    for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	if (exp_i->direct == EXP_INDIRECT) continue;

	/* for each spawn id, remove it from ecases */
	for (fsl=exp_i->fs_list;fsl;fsl=fsl->next) {
	    struct exp_f *f = fsl->f;

	    /* validate all input descriptors */
	    if (f != exp_f_any) {
		if (!exp_fcheck(interp,f,1,1,argv0)) {
		    result = TCL_ERROR;
		    goto cleanup;
		}
	    }

	    /* remove spawn id from exp_i */
	    ecmd_remove_f(interp,ecmd,f,EXP_DIRECT);
	}
    }
	
    /*
     * For each indirect variable, release its old ecases and 
     * clean up the matching spawn ids.
     * Same logic as in "expect_X delete" command.
     */

    for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	struct exp_i **old_i;

	if (exp_i->direct == EXP_DIRECT) continue;

	for (old_i = &ecmd->i_list;*old_i;) {
	    struct exp_i *tmp;

	    if (((*old_i)->direct == EXP_DIRECT) ||
		(!streq((*old_i)->variable,exp_i->variable))) {
		old_i = &(*old_i)->next;
		continue;
	    }

	    ecases_remove_by_expi(interp,ecmd,*old_i);

	    /* unlink from middle of list */
	    tmp = *old_i;
	    *old_i = tmp->next;
	    tmp->next = 0;
	    exp_free_i(interp,tmp,exp_indirect_update2);
	}

	/* if new one has ecases, update it */
	if (exp_i->ecount) {
	    char *msg = exp_indirect_update1(interp,ecmd,exp_i);
	    if (msg) {
		/* unusual way of handling error return */
		/* because of Tcl's variable tracing */
		strcpy(interp->result,msg);
		result = TCL_ERROR;
		goto indirect_update_abort;
	    }
	}
    }
    /* empty i_lists have to be removed from global eg.i_list */
    /* before returning, even if during error */
 indirect_update_abort:

    /*
     * New exp_i's that have 0 ecases indicate fd/vars to be deleted.
     * Now that the deletions have been done, discard the new exp_i's.
     */

    for (exp_i=eg.i_list;exp_i;) {
	struct exp_i *next = exp_i->next;

	if (exp_i->ecount == 0) {
	    exp_i_remove(interp,&eg.i_list,exp_i);
	}
	exp_i = next;
    }
    if (result == TCL_ERROR) goto cleanup;

    /*
     * arm all new bg direct fds
     */

    if (ecmd->cmdtype == EXP_CMD_BG) {
	for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	    if (exp_i->direct == EXP_DIRECT) {
		fs_list_arm(interp,exp_i->fs_list);
	    }
	}
    }

    /*
     * now that old ecases are gone, add new ecases and exp_i's (both
     * direct and indirect).
     */

    /* append ecases */

    count = ecmd->ecd.count + eg.ecd.count;
    if (eg.ecd.count) {
	int start_index;	/* where to add new ecases in old list */

	if (ecmd->ecd.count) {
	    /* append to end */
	    ecmd->ecd.cases = (struct ecase **)ckrealloc((char *)ecmd->ecd.cases, count * sizeof(struct ecase *));
	    start_index = ecmd->ecd.count;
	} else {
	    /* append to beginning */
	    ecmd->ecd.cases = (struct ecase **)ckalloc(eg.ecd.count * sizeof(struct ecase *));
	    start_index = 0;
	}
	memcpy(&ecmd->ecd.cases[start_index],eg.ecd.cases,
	       eg.ecd.count*sizeof(struct ecase *));
	ecmd->ecd.count = count;
    }

    /* append exp_i's */
    for (eip = &ecmd->i_list;*eip;eip = &(*eip)->next) {
	/* empty loop to get to end of list */
    }
    /* *exp_i now points to end of list */

    *eip = eg.i_list;		/* connect new list to end of current list */

 cleanup:
    if (result == TCL_ERROR) {
	/* in event of error, free any unreferenced ecases */
	/* but first, split up i_list so that exp_i's aren't */
	/* freed twice */

	for (exp_i=eg.i_list;exp_i;) {
	    struct exp_i *next = exp_i->next;
	    exp_i->next = 0;
	    exp_i = next;
	}
	free_ecases(interp,&eg,1);
    } else {
	if (eg.ecd.cases) ckfree((char *)eg.ecd.cases);
    }

    if (ecmd->cmdtype == EXP_CMD_BG) {
	exp_background_filehandlers_run_all();
    }

    return(result);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_adjust --
 *
 *	Adjusts file according to user's size request
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Memory may be allocated or reallocated
 *
 *---------------------------------------------------------------------- 
 */

void
exp_adjust(f)
    struct exp_f *f;
{
    int new_msize;

    /*
     * get the latest buffer size.  Double the user input for
     * two reasons.  1) Need twice the space in case the match
     * straddles two bufferfuls, 2) easier to hack the division
     * by two when shifting the buffers later on.  The extra
     * byte in the malloc's is just space for a null we can slam on the
     * end.  It makes the logic easier later.  The -1 here is so that
     * requests actually come out to even/word boundaries (if user
     * gives "reasonable" requests)
     */
    new_msize = f->umsize*2 - 1;
    if (new_msize != f->msize) {
	if (!f->buffer) {
	    /* allocate buffer space for 1st time */
	    f->buffer = ckalloc((unsigned)new_msize+1);
	    f->lower = ckalloc((unsigned)new_msize+1);
	    f->size = 0;
	} else {
	    /* buffer already exists - resize */

	    /* if truncated, forget about some data */
	    if (f->size > new_msize) {
		/* copy end of buffer down */
		memmove(f->buffer,f->buffer+(f->size - new_msize),new_msize);
		memmove(f->lower, f->lower +(f->size - new_msize),new_msize);
		f->size = new_msize;

		f->key = expect_key++;
	    }

	    f->buffer = ckrealloc(f->buffer,new_msize+1);
	    f->lower = ckrealloc(f->lower,new_msize+1);
	}
	f->msize = new_msize;
	f->buffer[f->size] = '\0';
	f->lower[f->size] = '\0';
    }
}

/*
 *----------------------------------------------------------------------
 *
 * expect_read --
 *
 *	Does the logical equivalent of a read() for the expect
 *	command.  This includes figuring out which descriptor should
 *	be read from.  The result of the read() is left in a spawn_id's
 *	buffer rather than explicitly passing it back.  Note that if
 *	someone else has modified a buffer either before or while this
 *	expect is running (i.e., if we or some event has called Tcl_Eval
 *	which did another expect/interact), expect_read will also call
 *	this a successful read (for the purposes if needing to pattern
 *	match against it).
 *
 *
 * Results:
 *	If it returns a negative number, it corresponds to a EXP_XXX result
 *	If it returns a non-negative number, it means there is data
 *	0 means nothing new was actually read, but it should be looked at again
 *
 * Side Effects
 *
 *----------------------------------------------------------------------
 */

int
expect_read(interp,masters,masters_max,m,timeout,key)
    Tcl_Interp *interp;
    struct exp_f **masters;	/* If NULL, then m is already known and set. */
    int masters_max;		/* If *masters is not-zero, then masters_max
				 * is the number of masters.
				 * If *masters is zero, then masters_max
				 * is used as the mask (ready vs except).
				 * Crude but simplifies the interface. */
    struct exp_f **m;		/* Out variable to leave new master. */
    int timeout;
    int key;
{
    struct exp_f *f;
    int cc;
    int write_count;
    int tcl_set_flags;	/* if we have to discard chars, this tells */
    /* whether to show user locally or globally */
    
    if (masters == 0) {
	/* we already know the master, just find out what happened */
	cc = exp_get_next_event_info(interp,*m,masters_max);
	tcl_set_flags = TCL_GLOBAL_ONLY;
    } else {
	cc = exp_get_next_event(interp,masters,masters_max,m,timeout,key);
	tcl_set_flags = 0;
    }
    
    if (cc == EXP_DATA_NEW) {
	/* try to read it */

	cc = exp_i_read(interp,*m,timeout,tcl_set_flags);

	/* the meaning of 0 from i_read means eof.  Muck with it a */
	/* little, so that from now on it means "no new data arrived */
	/* but it should be looked at again anyway". */
	if (cc == 0) {
	    cc = EXP_EOF;
	} else if (cc > 0) {
	    f = *m;
	    f->buffer[f->size += cc] = '\0';

	    /* strip parity if requested */
	    if (f->parity == 0) {
		/* do it from end backwards */
		char *p = f->buffer + f->size - 1;
		int count = cc;
		while (count--) {
		    *p-- &= 0x7f;
		}
	    }
	} /* else {
	     assert(cc < 0) in which case some sort of error was
	     encountered such as an interrupt with that forced an
	     error return
	     } */
    } else if (cc == EXP_DATA_OLD) {
	f = *m;
	cc = 0;
    } else if (cc == EXP_RECONFIGURE) {
	return EXP_RECONFIGURE;
    }
    
    if (cc == EXP_ABEOF) {	/* abnormal EOF */
	/* On many systems, ptys produce EIO upon EOF - sigh */
	if (i_read_errno == EIO) {
	    /* Sun, Cray, BSD, and others */
	    cc = EXP_EOF;
	} else if (i_read_errno == EINVAL) {
	    /* Solaris 2.4 occasionally returns this */
	    cc = EXP_EOF;
	} else {
	    if (i_read_errno == EBADF) {
		exp_error(interp,"bad spawn_id (process died earlier?)");
	    } else {
		exp_error(interp,"i_read(spawn_id=%d): %s",*m,
			  Tcl_PosixError(interp));
		exp_close(interp,*m);
	    }
	    return(EXP_TCLERROR);
	    /* was goto error; */
	}
    }
    
    /* EOF, TIMEOUT, and ERROR return here */
    /* In such cases, there is no need to update screen since, if there */
    /* was prior data read, it would have been sent to the screen when */
    /* it was read. */
    if (cc < 0) return (cc);
    
    /* update display */
    
    if (f->size) write_count = f->size - f->printed;
    else write_count = 0;
    
    if (write_count) {
	if (logfile_all || (loguser && logfile)) {
	    Tcl_Write(logfile, f->buffer + f->printed, write_count);
	}
	/*
	 * don't write to user if they're seeing it already,
	 * that is, typing it!
	 */
	if (loguser) {
	    if (strcmp("stdin", (*m)->spawnId) != 0) {
		Tcl_Write(Tcl_GetStdChannel(TCL_STDOUT),
			  f->buffer + f->printed, write_count);
	    }
	}
	if (debugfile) {
	    Tcl_Write(debugfile, f->buffer + f->printed, write_count);
	}

	/* remove nulls from input, since there is no way */
	/* for Tcl to deal with such strings.  Doing it here */
	/* lets them be sent to the screen, just in case */
	/* they are involved in formatting operations */
	if (f->rm_nulls) {
	    f->size -= rm_nulls(f->buffer + f->printed,write_count);
	}
	f->buffer[f->size] = '\0';

	/* copy to lowercase buffer */
	exp_lowmemcpy(f->lower+f->printed, f->buffer+f->printed,
		      1 + f->size - f->printed);

	f->printed = f->size;	/* count'm even if not logging */
    }
    return(cc);
}

/* when buffer fills, copy second half over first and */
/* continue, so we can do matches over multiple buffers */
void
exp_buffer_shuffle(interp,f,save_flags,array_name,caller_name)
    Tcl_Interp *interp;
    struct exp_f *f;
    int save_flags;
    char *array_name;
    char *caller_name;
{
    char spawn_id[10];		/* enough for a %d */
    char match_char;		/* place to hold char temporarily */
    /* uprooted by a NULL */

    int first_half = f->size/2;
    int second_half = f->size - first_half;

    /*
     * allow user to see data we are discarding
     */

    sprintf(spawn_id,"%s",f->spawnId);
    debuglog("%s: set %s(spawn_id) \"%s\"\r\n",
	     caller_name,array_name,dprintify(spawn_id));
    Tcl_SetVar2(interp,array_name,"spawn_id",spawn_id,save_flags);

    /* temporarily null-terminate buffer in middle */
    match_char = f->buffer[first_half];
    f->buffer[first_half] = 0;

    debuglog("%s: set %s(buffer) \"%s\"\r\n",
	     caller_name,array_name,dprintify(f->buffer));
    Tcl_SetVar2(interp,array_name,"buffer",f->buffer,save_flags);

    /* remove middle-null-terminator */
    f->buffer[first_half] = match_char;

    memcpy(f->buffer,f->buffer+first_half,second_half);
    memcpy(f->lower, f->lower +first_half,second_half);
    f->size = second_half;
    f->printed -= first_half;
    if (f->printed < 0) f->printed = 0;
}

/* map EXP_ style return value to TCL_ style return value */
/* not defined to work on TCL_OK */
int
exp_tcl2_returnvalue(x)
    int x;
{
    switch (x) {
    case TCL_ERROR:			return EXP_TCLERROR;
    case TCL_RETURN:		return EXP_TCLRET;
    case TCL_BREAK:			return EXP_TCLBRK;
    case TCL_CONTINUE:		return EXP_TCLCNT;
    case EXP_CONTINUE:		return EXP_TCLCNTEXP;
    case EXP_CONTINUE_TIMER:	return EXP_TCLCNTTIMER;
    case EXP_TCL_RETURN:		return EXP_TCLRETTCL;
    }
}

/* map from EXP_ style return value to TCL_ style return values */
int
exp_2tcl_returnvalue(x)
    int x;
{
    switch (x) {
    case EXP_TCLERROR:		return TCL_ERROR;
    case EXP_TCLRET:		return TCL_RETURN;
    case EXP_TCLBRK:		return TCL_BREAK;
    case EXP_TCLCNT:		return TCL_CONTINUE;
    case EXP_TCLCNTEXP:		return EXP_CONTINUE;
    case EXP_TCLCNTTIMER:		return EXP_CONTINUE_TIMER;
    case EXP_TCLRETTCL:		return EXP_TCL_RETURN;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * exp_i_read --
 *
 *	Reads from the input channel. Returns # of chars read or
 *	(non-positive) error of form EXP_XXX.
 * Results:
 *	returns 0 for end of file
 *	If timeout is non-zero, assume the read will complete immediately
 *	because data is known to be available.
 *
 * Side Effects:
 *	Data is read from a channel
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
exp_i_read(interp,f,timeout,save_flags)
    Tcl_Interp *interp;
    struct exp_f *f;
    int timeout;
    int save_flags;
{
    int nread;

    if (f->size == f->msize) 
	exp_buffer_shuffle(interp,f,save_flags,EXPECT_OUT,"expect");

    nread = Tcl_Read(f->channel, f->buffer+f->size, f->msize-f->size);
    if (nread == -1) {
	i_read_errno = errno;
    } else {
	/* {DWORD x; f->buffer[f->size] = 0; WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), f->buffer+f->size, nread, &x, NULL); printf("exp_i_read: Got %d bytes\n", nread);} */
	nread = nread;
    }

    return(nread);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_get_var --
 *
 *	Variables predefined by expect are retrieved using this routine
 *	which looks in the global space if they are not in the local space.
 *	This allows the user to localize them if desired, and also to
 *	avoid having to put "global" in procedure definitions.
 *
 * Results:
 *	The value of the variable if it exists
 *
 *----------------------------------------------------------------------
 */

char *
exp_get_var(interp,var)
    Tcl_Interp *interp;
    char *var;
{
    char *val;

    if (NULL != (val = Tcl_GetVar(interp,var,0 /* local */)))
	return(val);
    return(Tcl_GetVar(interp,var,TCL_GLOBAL_ONLY));
}

/*
 *----------------------------------------------------------------------
 *
 * get_timeout --
 *
 *	Gets the value of the 'timeout' variable
 *
 * Results:
 *	The value of the variable if it exists
 *
 *----------------------------------------------------------------------
 */

static int
get_timeout(interp)
    Tcl_Interp *interp;
{
    static int timeout = INIT_EXPECT_TIMEOUT;
    char *t;

    if (NULL != (t = exp_get_var(interp,EXPECT_TIMEOUT))) {
	timeout = atoi(t);
    }
    return(timeout);
}

/* make a copy of a linked list (1st arg) and attach to end of another (2nd
   arg) */
static int
update_expect_fds(i_list,fd_union)
    struct exp_i *i_list;
    struct exp_fs_list **fd_union;
{
    struct exp_i *p;

    /* for each i_list in an expect statement ... */
    for (p=i_list;p;p=p->next) {
	struct exp_fs_list *fsl;

	/* for each fd in the i_list */
	for (fsl=p->fs_list;fsl;fsl=fsl->next) {
	    struct exp_fs_list *tmpfsl;
	    struct exp_fs_list *u;

	    if (fsl->f == exp_f_any || fsl->f == NULL) continue;

	    /* check this one against all so far */
	    for (u = *fd_union;u;u=u->next) {
		if (fsl->f == u->f) goto found;
	    }
	    /* if not found, link in as head of list */
	    tmpfsl = exp_new_fs(fsl->f);
	    tmpfsl->next = *fd_union;
	    *fd_union = tmpfsl;
	found:;
	}
    }
    return TCL_OK;
}

char *
exp_cmdtype_printable(cmdtype)
    int cmdtype;
{
    switch (cmdtype) {
    case EXP_CMD_FG: return("expect");
    case EXP_CMD_BG: return("expect_background");
    case EXP_CMD_BEFORE: return("expect_before");
    case EXP_CMD_AFTER: return("expect_after");
    }
#ifdef LINT
    return("unknown expect command");
#endif
}

/*
 *----------------------------------------------------------------------
 *
 * exp_indirect_update2 --
 *
 *	This is called back via Tcl's trace handler whenever
 *	an indirect spawn id list is changed
 *
 * Results:
 *	A string
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static char *
exp_indirect_update2(clientData, interp, name1, name2, flags)
    ClientData clientData;
    Tcl_Interp *interp;	/* Interpreter containing variable. */
    char *name1;		/* Name of variable. */
    char *name2;		/* Second part of variable name. */
    int flags;		/* Information about what happened. */
{
    char *msg;
    
    struct exp_i *exp_i = (struct exp_i *)clientData;
    exp_configure_count++;
    msg = exp_indirect_update1(interp,&exp_cmds[exp_i->cmdtype],exp_i);
    
    exp_background_filehandlers_run_all();
    
    return msg;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_indirect_update1 --
 *
 *	Get the updated value of a variable
 *
 * Results:
 *	A string
 *
 *----------------------------------------------------------------------
 */

static char *
exp_indirect_update1(interp,ecmd,exp_i)
    Tcl_Interp *interp;
    struct exp_cmd_descriptor *ecmd;
    struct exp_i *exp_i;
{
    struct exp_fs_list *fsl;	/* temp for interating over fs_list */

    /*
     * disarm any fd's that lose all their ecases
     */

    if (ecmd->cmdtype == EXP_CMD_BG) {
	/* clean up each spawn id used by this exp_i */
	for (fsl=exp_i->fs_list;fsl;fsl=fsl->next) {
	    struct exp_f *f = fsl->f;

	    if (f == NULL || f == exp_f_any) continue;

	    /* silently skip closed or preposterous fds */
	    /* since we're just disabling them anyway */
	    /* preposterous fds will have been reported */
	    /* by code in next section already */
	    if (! exp_fcheck(interp, f, 1, 0, "")) continue;

	    f->bg_ecount--;
	    if (f->bg_ecount == 0) {
		exp_disarm_background_filehandler(f);
		f->bg_interp = 0;
	    }
	}
    }

    /*
     * reread indirect variable
     */

    exp_i_update(interp,exp_i);

    /*
     * check validity of all fd's in variable
     */

    for (fsl=exp_i->fs_list;fsl;fsl=fsl->next) {
	/* validate all input descriptors */
	if (fsl->f == NULL || fsl->f == exp_f_any) continue;

	if (!exp_fcheck(interp,fsl->f,1,1,
			exp_cmdtype_printable(ecmd->cmdtype))) {
	    static char msg[200];
	    sprintf(msg,"%s from indirect variable (%s)",
		    interp->result,exp_i->variable);
	    return msg;
	}
    }

    /* for each spawn id in list, arm if necessary */
    if (ecmd->cmdtype == EXP_CMD_BG) {
	fs_list_arm(interp,exp_i->fs_list);
    }

    return (char *)0;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_background_filehandlers_run_all --
 *
 *	See which channels need to be checked for events and
 *	start up an event handler
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Event handlers are put in place
 *
 *----------------------------------------------------------------------
 */

void
exp_background_filehandlers_run_all()
{
    struct exp_f *f;
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch search;

    hPtr = Tcl_FirstHashEntry(exp_f_table, &search);
    while (hPtr) {
	f = (struct exp_f *) Tcl_GetHashValue(hPtr);

	/* kick off any that already have input waiting */
	if (!f->valid) continue;

	/* is bg_interp the best way to check if armed? */
	if (f->bg_interp && (f->size > 0)) {
	    exp_background_filehandler((ClientData)f, 0 /*ignored*/);
	}
	hPtr = Tcl_NextHashEntry(&search);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * exp_background_filehandler --
 *
 *	This function is called from the background when input arrives
 *
 * Results:
 *	None
 *
 * Side Effects:
 *
 *---------------------------------------------------------------------- 
 */

/*ARGSUSED*/
void
exp_background_filehandler(clientData,mask)
    ClientData clientData;
    int mask;
{
    Tcl_Interp *interp;
    int cc;			/* number of chars returned in a single read
				 * or negative EXP_whatever */
    struct exp_f *f;		/* file associated with master */
    
    int i;			/* trusty temporary */
    
    struct eval_out eo;		/* final case of interest */
    struct exp_f *last_f;	/* for differentiating when multiple f's
				 * to print out better debugging messages */
    int last_case;		/* as above but for case */
    
    /* restore our environment */
    f = (struct exp_f *) clientData;
    interp = f->bg_interp;
    
    /* temporarily prevent this handler from being invoked again */
    exp_block_background_filehandler(f);
    
    /*
     * if mask == 0, then we've been called because the patterns changed
     * not because the waiting data has changed, so don't actually do
     * any I/O
     */
    
    if (mask == 0) {
	cc = 0;
    } else {
	cc = expect_read(interp,NULL,mask,&f,EXP_TIME_INFINITY,0);
    }
    
 do_more_data:
    eo.e = 0;		/* no final case yet */
    eo.f = 0;		/* no final file selected yet */
    eo.match = 0;		/* nothing matched yet */
    
    /* force redisplay of buffer when debugging */
    last_f = NULL;
    
    if (cc == EXP_EOF) {
	/* do nothing */
    } else if (cc < 0) {	/* EXP_TCLERROR or any other weird value*/
	goto finish;
	/* if we were going to do this right, we should */
	/* differentiate between things like HP ioctl-open-traps */
	/* that fall out here and should rightfully be ignored */
	/* and real errors that should be reported.  Come to */
	/* think of it, the only errors will come from HP */
	/* ioctl handshake botches anyway. */
    } else {
	/* normal case, got data */
	/* new data if cc > 0, same old data if cc == 0 */
	
	/* below here, cc as general status */
	cc = EXP_NOMATCH;
    }
    
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
		    f,&eo,&last_f,&last_case,cc,&f,1,"_background");
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_BG],
		    f,&eo,&last_f,&last_case,cc,&f,1,"_background");
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
		    f,&eo,&last_f,&last_case,cc,&f,1,"_background");
    if (cc == EXP_TCLERROR) {
	/* only likely problem here is some internal regexp botch */
	Tcl_BackgroundError(interp);
	goto finish;
    }
    /* special eof code that cannot be done in eval_cases */
    /* or above, because it would then be executed several times */
    if (cc == EXP_EOF) {
	eo.f = f;
	eo.match = eo.f->size;
	eo.buffer = eo.f->buffer;
	debuglog("expect_background: read eof\r\n");
	goto matched;
    }
    if (!eo.e) {
	/* if we get here, there must not have been a match */
	goto finish;
    }
    
 matched:
#define out(i,val)  debuglog("expect_background: set %s(%s) \"%s\"\r\n",EXPECT_OUT,i, \
			     dprintify(val)); \
     Tcl_SetVar2(interp,EXPECT_OUT,i,val,TCL_GLOBAL_ONLY);
 {
     /*		int iwrite = FALSE;*/	/* write spawn_id? */
     char *body = 0;
     char *buffer;		/* pointer to normal or lowercased data */
     struct ecase *e = 0;	/* points to current ecase */
     int match = -1;		/* characters matched */
     char match_char;		/* place to hold char temporarily */
     /* uprooted by a NULL */
     char *eof_body = 0;

     if (eo.e) {
	 e = eo.e;
	 body = e->body;
	 /*			iwrite = e->iwrite;*/
	 if (cc != EXP_TIMEOUT) {
	     f = eo.f;
	     match = eo.match;
	     buffer = eo.buffer;
	 }
     } else if (cc == EXP_EOF) {
	 /* read an eof but no user-supplied case */
	 f = eo.f;
	 match = eo.match;
	 buffer = eo.buffer;
     }			

     if (match >= 0) {
	 char name[20], value[20];

	 if (e && e->use == PAT_RE) {
	     regexp *re = e->re;

	     for (i=0;i<NSUBEXP;i++) {
		 int offset;

		 if (re->startp[i] == 0) continue;

		 if (e->indices) {
		     /* start index */
		     sprintf(name,"%d,start",i);
		     offset = re->startp[i]-buffer;
		     sprintf(value,"%d",offset);
		     out(name,value);

		     /* end index */
		     sprintf(name,"%d,end",i);
		     sprintf(value,"%d",
			     re->endp[i]-buffer-1);
		     out(name,value);
		 }

		 /* string itself */
		 sprintf(name,"%d,string",i);

		 /* temporarily null-terminate in */
		 /* middle */
		 match_char = *re->endp[i];
		 *re->endp[i] = 0;
		 out(name,re->startp[i]);
		 *re->endp[i] = match_char;
	     }
	     /* redefine length of string that */
	     /* matched for later extraction */
	     match = re->endp[0]-buffer;
	 } else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
	     char *str;

	     if (e->indices) {
		 /* start index */
		 sprintf(value,"%d",e->simple_start);
		 out("0,start",value);

		 /* end index */
		 sprintf(value,"%d",e->simple_start + match - 1);
		 out("0,end",value);
	     }

	     /* string itself */
	     str = f->buffer + e->simple_start;
	     /* temporarily null-terminate in middle */
	     match_char = str[match];
	     str[match] = 0;
	     out("0,string",str);
	     str[match] = match_char;

	     /* redefine length of string that */
	     /* matched for later extraction */
	     match += e->simple_start;
	 } else if (e && e->use == PAT_NULL && e->indices) {
	     /* start index */
	     sprintf(value,"%d",match-1);
	     out("0,start",value);
	     /* end index */
	     sprintf(value,"%d",match-1);
	     out("0,end",value);
	 } else if (e && e->use == PAT_FULLBUFFER) {
	     debuglog("expect_background: full buffer\r\n");
	 }
     }

     /* this is broken out of (match > 0) (above) since it can */
     /* that an EOF occurred with match == 0 */
     if (eo.f) {
	 char spawn_id[10];	/* enough for a %d */

	 sprintf(spawn_id,"%s",f->spawnId);
	 out("spawn_id",spawn_id);

	 /* save buf[0..match] */
	 /* temporarily null-terminate string in middle */
	 match_char = f->buffer[match];
	 f->buffer[match] = 0;
	 out("buffer",f->buffer);
	 /* remove middle-null-terminator */
	 f->buffer[match] = match_char;

	 /* "!e" means no case matched - transfer by default */
	 if (!e || e->transfer) {
	     /* delete matched chars from input buffer */
	     f->size -= match;
	     f->printed -= match;
	     if (f->size != 0) {
		 memmove(f->buffer,f->buffer+match,f->size);
		 memmove(f->lower,f->lower+match,f->size);
	     }
	     f->buffer[f->size] = '\0';
	     f->lower[f->size] = '\0';
	 }

	 if (cc == EXP_EOF) {
	     /* exp_close() deletes all background bodies */
	     /* so save eof body temporarily */
	     if (body) {
		 eof_body = ckalloc(strlen(body)+1);
		 strcpy(eof_body,body);
		 body = eof_body;
	     }

	     exp_close(interp,f);
	 }

     }

     if (body) {
	 int result = Tcl_GlobalEval(interp,body);
	 if (result != TCL_OK) Tcl_BackgroundError(interp);

	 if (eof_body) ckfree(eof_body);
     }


     /*
      * Event handler will not call us back if there is more input
      * pending but it has already arrived.  bg_status will be
      * "blocked" only if armed.
      */
     if (f->valid && (f->bg_status == blocked)
	 && (f->size > 0)) {
	 cc = f->size;
	 goto do_more_data;
     }
 }
 finish:
    /* fd could have gone away, so check before using */
    if (f->valid)
	exp_unblock_background_filehandler(f);
}
#undef out

/*
 *----------------------------------------------------------------------
 *
 * Exp_ExpectCmd --
 *
 *	Implements the 'expect', 'expect_user', and 'expect_tty'
 *	commands.
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	Input is likely to be read
 *
 * Notes:
 *	If non-null, clientData holds the name of the channel to
 *	use.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
int
Exp_ExpectCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int cc;			/* number of chars returned in a single read
				 * or negative EXP_whatever */
    struct exp_f *f;		/* file associated with master */

    int i;			/* trusty temporary */
    struct exp_cmd_descriptor eg;
    struct exp_fs_list *fs_list; /* list of masters to watch */
    struct exp_fs_list *fsl;	/* temp for interating over fs_list */
    struct exp_f **masters;	/* array of masters to watch */
    int mcount;			/* number of masters to watch */

    struct eval_out eo;		/* final case of interest */

    int result;			/* Tcl result */

    time_t start_time_total;	/* time at beginning of this procedure */
    time_t start_time = 0;	/* time when restart label hit */
    time_t current_time = 0;	/* current time (when we last looked)*/
    time_t end_time;		/* future time at which to give up */
    time_t elapsed_time_total;	/* time from now to match/fail/timeout */
    time_t elapsed_time;	/* time from restart to (ditto) */

    struct exp_f *last_f;	/* for differentiating when multiple f's
				 * to print out better debugging messages */
    int last_case;		/* as above but for case */
    int first_time = 1;		/* if not "restarted" */

    int key;			/* identify this expect command instance */
    int configure_count;	/* monitor exp_configure_count */

    int timeout;		/* seconds */
    int remtime;		/* remaining time in timeout */
    int reset_timer;		/* should timer be reset after continue? */
    char *argv0;		/* Command name */

    if ((argc == 2) && exp_one_arg_braced(argv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,argv));
    } else if ((argc == 3) && streq(argv[1],"-brace")) {
	char *new_argv[2];
	new_argv[0] = argv[0];
	new_argv[1] = argv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_argv));
    }

    argv0 = argv[0];
    time(&start_time_total);
    start_time = start_time_total;
    reset_timer = TRUE;

    /* make arg list for processing cases */
    /* do it dynamically, since expect can be called recursively */

    exp_cmd_init(&eg,EXP_CMD_FG,EXP_TEMPORARY);
    fs_list = NULL;
    masters = NULL;
    if (clientData) {
	f = exp_chan2f(interp,(char *) clientData,1,0,argv0);
	if (f == NULL) {
	    return TCL_ERROR;
	}
    } else {
	f = NULL;
    }
    if (TCL_ERROR == parse_expect_args(interp,&eg,f,argc,argv,argv0))
	return TCL_ERROR;

 restart_with_update:
    /* validate all descriptors */
    /* and flatten fds into array */

    if ((TCL_ERROR == update_expect_fds(exp_cmds[EXP_CMD_BEFORE].i_list,&fs_list))
	|| (TCL_ERROR == update_expect_fds(exp_cmds[EXP_CMD_AFTER].i_list, &fs_list))
	|| (TCL_ERROR == update_expect_fds(eg.i_list,&fs_list))) {
	result = TCL_ERROR;
	goto cleanup;
    }

    /* declare ourselves "in sync" with external view of close/indirect */
    configure_count = exp_configure_count;

    /* count and validate fs_list */
    mcount = 0;
    for (fsl=fs_list;fsl;fsl=fsl->next) {
	mcount++;
	/* validate all input descriptors */
	if (!exp_fcheck(interp,fsl->f,1,1,argv0)) {
	    result = TCL_ERROR;
	    goto cleanup;
	}
    }

    /* make into an array */
    masters = (struct exp_f **)ckalloc(mcount * sizeof(struct exp_f *));
    for (fsl=fs_list,i=0;fsl;fsl=fsl->next,i++) {
	masters[i] = fsl->f;
    }

 restart:
    if (first_time) first_time = 0;
    else time(&start_time);

    if (eg.timeout_specified_by_flag) {
	timeout = eg.timeout;
    } else {
	/* get the latest timeout */
	timeout = get_timeout(interp);
    }

    key = expect_key++;

    result = TCL_OK;
    last_f = 0;

    /* end of restart code */

    eo.e = 0;			/* no final case yet */
    eo.f = 0;			/* no final file selected yet */
    eo.match = 0;		/* nothing matched yet */

    /* timeout code is a little tricky, be very careful changing it */
    if (timeout != EXP_TIME_INFINITY) {
	/* if exp_continue -continue_timer, do not update end_time */
	if (reset_timer) {
	    time(&current_time);
	    end_time = current_time + timeout;
	} else {
	    reset_timer = TRUE;
	}
    }

    /* remtime and current_time updated at bottom of loop */
    remtime = timeout;

    for (;;) {
	if ((timeout != EXP_TIME_INFINITY) && (remtime < 0)) {
	    cc = EXP_TIMEOUT;
	} else {
	    cc = expect_read(interp,masters,mcount,&f,remtime,key);
	}

	/*SUPPRESS 530*/
	if (cc == EXP_EOF) {
	    /* do nothing */
	} else if (cc == EXP_TIMEOUT) {
	    debuglog("expect: timed out\r\n");
	} else if (cc == EXP_RECONFIGURE) {
	    reset_timer = FALSE;
	    goto restart_with_update;
	} else if (cc < 0) {	/* EXP_TCLERROR or any other weird value*/
	    goto error;
	} else {
	    /* new data if cc > 0, same old data if cc == 0 */
	    /* below here, cc as general status */
	    cc = EXP_NOMATCH;

	    /* force redisplay of buffer when debugging */
	    last_f = 0;
	}

	cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
			f,&eo,&last_f,&last_case,cc,masters,mcount,"");
	cc = eval_cases(interp,&eg,
			f,&eo,&last_f,&last_case,cc,masters,mcount,"");
	cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
			f,&eo,&last_f,&last_case,cc,masters,mcount,"");
	if (cc == EXP_TCLERROR) goto error;
	/* special eof code that cannot be done in eval_cases */
	/* or above, because it would then be executed several times */
	if (cc == EXP_EOF) {
	    eo.f = f;
	    eo.match = eo.f->size;
	    eo.buffer = eo.f->buffer;
	    debuglog("expect: read eof\r\n");
	    break;
	} else if (cc == EXP_TIMEOUT) break;
	/* break if timeout or eof and failed to find a case for it */

	if (eo.e) break;

	/* no match was made with current data, force a read */
	f->force_read = TRUE;

	if (timeout != EXP_TIME_INFINITY) {
	    time(&current_time);
	    remtime = end_time - current_time;
	}
    }

    goto done;

 error:
    result = exp_2tcl_returnvalue(cc);
 done:
#define out(i,val)  debuglog("expect: set %s(%s) \"%s\"\r\n",EXPECT_OUT,i, \
			     dprintify(val)); \
				 Tcl_SetVar2(interp,EXPECT_OUT,i,val,0);

    if (result != TCL_ERROR) {
	/*		int iwrite = FALSE;*/	/* write spawn_id? */
	char *body = 0;
	char *buffer;		/* pointer to normal or lowercased data */
	struct ecase *e = 0;	/* points to current ecase */
	int match = -1;		/* characters matched */
	char match_char;	/* place to hold char temporarily */
	/* uprooted by a NULL */
	char *eof_body = 0;

	if (eo.e) {
	    e = eo.e;
	    body = e->body;
	    /*			iwrite = e->iwrite;*/
	    if (cc != EXP_TIMEOUT) {
		f = eo.f;
		match = eo.match;
		buffer = eo.buffer;
	    }
	    if (e->timestamp) {
		char value[20];

		time(&current_time);
		elapsed_time = current_time - start_time;
		elapsed_time_total = current_time - start_time_total;
		sprintf(value,"%d",elapsed_time);
		out("seconds",value);
		sprintf(value,"%d",elapsed_time_total);
		out("seconds_total",value);

		/* deprecated */
		exp_timestamp(interp,&current_time,EXPECT_OUT);
	    }
	} else if (cc == EXP_EOF) {
	    /* read an eof but no user-supplied case */
	    f = eo.f;
	    match = eo.match;
	    buffer = eo.buffer;
	}			

	if (match >= 0) {
	    char name[20], value[20];

	    if (e && e->use == PAT_RE) {
		regexp *re = e->re;

		for (i=0;i<NSUBEXP;i++) {
		    int offset;

		    if (re->startp[i] == 0) continue;

		    if (e->indices) {
			/* start index */
			sprintf(name,"%d,start",i);
			offset = re->startp[i]-buffer;
			sprintf(value,"%d",offset);
			out(name,value);

			/* end index */
			sprintf(name,"%d,end",i);
			sprintf(value,"%d",
				re->endp[i]-buffer-1);
			out(name,value);
		    }

		    /* string itself */
		    sprintf(name,"%d,string",i);

		    /* temporarily null-terminate in */
		    /* middle */
		    match_char = *re->endp[i];
		    *re->endp[i] = 0;
		    out(name,re->startp[i]);
		    *re->endp[i] = match_char;
		}
		/* redefine length of string that */
		/* matched for later extraction */
		match = re->endp[0]-buffer;
	    } else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
		char *str;

		if (e->indices) {
		    /* start index */
		    sprintf(value,"%d",e->simple_start);
		    out("0,start",value);

		    /* end index */
		    sprintf(value,"%d",e->simple_start + match - 1);
		    out("0,end",value);
		}

		/* string itself */
		str = f->buffer + e->simple_start;
		/* temporarily null-terminate in middle */
		match_char = str[match];
		str[match] = 0;
		out("0,string",str);
		str[match] = match_char;

		/* redefine length of string that */
		/* matched for later extraction */
		match += e->simple_start;
	    } else if (e && e->use == PAT_NULL && e->indices) {
		/* start index */
		sprintf(value,"%d",match-1);
		out("0,start",value);
		/* end index */
		sprintf(value,"%d",match-1);
		out("0,end",value);
	    } else if (e && e->use == PAT_FULLBUFFER) {
		debuglog("expect: full buffer\r\n");
	    }
	}

	/* this is broken out of (match > 0) (above) since it can */
	/* that an EOF occurred with match == 0 */
	if (eo.f) {
	    char spawn_id[10];	/* enough for a %d */

	    /*			if (iwrite) {*/
	    sprintf(spawn_id,"%s",f->spawnId);
	    out("spawn_id",spawn_id);
	    /*			}*/

	    /* save buf[0..match] */
	    /* temporarily null-terminate string in middle */
	    match_char = f->buffer[match];
	    f->buffer[match] = 0;
	    out("buffer",f->buffer);
	    /* remove middle-null-terminator */
	    f->buffer[match] = match_char;

	    /* "!e" means no case matched - transfer by default */
	    if (!e || e->transfer) {
		/* delete matched chars from input buffer */
		f->size -= match;
		f->printed -= match;
		if (f->size != 0) {
		    memmove(f->buffer,f->buffer+match,f->size);
		    memmove(f->lower,f->lower+match,f->size);
		}
		f->buffer[f->size] = '\0';
		f->lower[f->size] = '\0';
	    }

	    if (cc == EXP_EOF) {
		/* exp_close() deletes all background bodies */
		/* so save eof body temporarily */
		if (body) {
		    eof_body = ckalloc(strlen(body)+1);
		    strcpy(eof_body,body);
		    body = eof_body;
		}

		exp_close(interp,f);
	    }

	}

	if (body) {
	    result = Tcl_Eval(interp,body);

	    if (eof_body) ckfree(eof_body);
	}
    }

 cleanup:
    if (result == EXP_CONTINUE_TIMER) {
	reset_timer = FALSE;
	result = EXP_CONTINUE;
    }

    if ((result == EXP_CONTINUE)
	&& (configure_count == exp_configure_count)) {
	debuglog("expect: continuing expect\r\n");
	goto restart;
    }

    if (fs_list) {
	exp_free_fs(fs_list);
	fs_list = 0;
    }
    if (masters) {
	ckfree((char *)masters);
	masters = 0;
    }

    if (result == EXP_CONTINUE) {
	debuglog("expect: continuing expect after update\r\n");
	goto restart_with_update;
    }

    free_ecases(interp,&eg,0);	/* requires i_lists to be avail */
    exp_free_i(interp,eg.i_list,exp_indirect_update2);

    return(result);
}
#undef out

/* beginning of deprecated code */

#define out(elt)		Tcl_SetVar2(interp,array,elt,ascii,0);
void
exp_timestamp(interp,timeval,array)
Tcl_Interp *interp;
time_t *timeval;
char *array;
{
	struct tm *tm;
	char *ascii;

	tm = localtime(timeval);	/* split */
	ascii = asctime(tm);		/* print */
	ascii[24] = '\0';		/* zap trailing \n */

	out("timestamp");

	sprintf(ascii,"%ld",*timeval);
	out("epoch");

	sprintf(ascii,"%d",tm->tm_sec);
	out("sec");
	sprintf(ascii,"%d",tm->tm_min);
	out("min");
	sprintf(ascii,"%d",tm->tm_hour);
	out("hour");
	sprintf(ascii,"%d",tm->tm_mday);
	out("mday");
	sprintf(ascii,"%d",tm->tm_mon);
	out("mon");
	sprintf(ascii,"%d",tm->tm_year);
	out("year");
	sprintf(ascii,"%d",tm->tm_wday);
	out("wday");
	sprintf(ascii,"%d",tm->tm_yday);
	out("yday");
	sprintf(ascii,"%d",tm->tm_isdst);
	out("isdst");
}
/* end of deprecated code */

/*ARGSUSED*/
static int
Exp_TimestampCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	char *format = 0;
	time_t seconds = -1;
	int gmt = FALSE;	/* local time by default */
	struct tm *tm;
	Tcl_DString dstring;

	argc--; argv++;

	while (*argv) {
		if (streq(*argv,"-format")) {
			argc--; argv++;
			if (!*argv) goto usage_error;
			format = *argv;
			argc--; argv++;
		} else if (streq(*argv,"-seconds")) {
			argc--; argv++;
			if (!*argv) goto usage_error;
			seconds = atoi(*argv);
			argc--; argv++;
		} else if (streq(*argv,"-gmt")) {
			gmt = TRUE;
			argc--; argv++;
		} else break;
	}

	if (argc) goto usage_error;

	if (seconds == -1) {
		time(&seconds);
	}

	Tcl_DStringInit(&dstring);

	if (format) {
		if (gmt) {
			tm = gmtime(&seconds);
		} else {
			tm = localtime(&seconds);
		}
/*		exp_strftime(interp->result,TCL_RESULT_SIZE,format,tm);*/
		exp_strftime(format,tm,&dstring);
		Tcl_DStringResult(interp,&dstring);
	} else {
		sprintf(interp->result,"%ld",seconds);
	}
	
	return TCL_OK;
 usage_error:
	exp_error(interp,"args: [-seconds #] [-format format]");
	return TCL_ERROR;

}

/* lowmemcpy - like memcpy but it lowercases result */
void
exp_lowmemcpy(dest,src,n)
    char *dest;
    char *src;
    int n;
{
    for (;n>0;n--) {
	*dest = ((isascii(*src) && isupper(*src))?tolower(*src):*src);
	src++;	dest++;
    }
}

/*ARGSUSED*/
int
Exp_MatchMaxCmd(clientData,interp,argc,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int size = -1;
    struct exp_f *f;
    int Default = FALSE;
    char *chan = NULL;
    
    argc--; argv++;
    
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chan = *argv;
	} else break;
    }
    
    if (!Default) {
	if (chan == NULL) {
	    if (!(f = exp_update_master(interp,0,0)))
		return(TCL_ERROR);
	} else {
	    if (!(f = exp_chan2f(interp,chan,0,0,"match_max")))
		return(TCL_ERROR);
	}
    } else if (chan != NULL) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }
    
    if (argc == 0) {
	if (Default) {
	    size = exp_default_match_max;
	} else {
	    size = f->umsize;
	}
	sprintf(interp->result,"%d",size);
	return(TCL_OK);
    }
    
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
    }
    
    /* all that's left is to set the size */
    size = atoi(argv[0]);
    if (size <= 0) {
	exp_error(interp,"must be positive");
	return(TCL_ERROR);
    }
    
    if (Default) exp_default_match_max = size;
    else f->umsize = size;
    
    return(TCL_OK);
}

/*ARGSUSED*/
int
Exp_RemoveNullsCmd(clientData,interp,argc,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int value = -1;
    struct exp_f *f;
    int Default = FALSE;
    char *chan = NULL;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chan = *argv;
	} else break;
    }

    if (!Default) {
	if (chan == NULL) {
	    if (!(f = exp_update_master(interp,0,0)))
		return(TCL_ERROR);
	} else {
	    if (!(f = exp_chan2f(interp,chan,0,0,"remove_nulls")))
		return(TCL_ERROR);
	}
    } else if (chan != NULL) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

    if (argc == 0) {
	if (Default) {
	    value = exp_default_match_max;
	} else {
	    value = f->rm_nulls;
	}
	sprintf(interp->result,"%d",value);
	return(TCL_OK);
    }

    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
    }

    /* all that's left is to set the value */
    value = atoi(argv[0]);
    if (value != 0 && value != 1) {
	exp_error(interp,"must be 0 or 1");
	return(TCL_ERROR);
    }

    if (Default) exp_default_rm_nulls = value;
    else f->rm_nulls = value;

    return(TCL_OK);
}

/*ARGSUSED*/
int
Exp_ParityCmd(clientData,interp,argc,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int parity;
    int m = -1;
    struct exp_f *f;
    int Default = FALSE;
    char *chan = NULL;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chan = *argv;
	} else break;
    }

    if (!Default) {
	if (chan == NULL) {
	    if (!(f = exp_update_master(interp,0,0)))
		return(TCL_ERROR);
	} else {
	    if (!(f = exp_chan2f(interp,chan,0,0,"parity")))
		return(TCL_ERROR);
	}
    } else if (chan != NULL) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

    if (argc == 0) {
	if (Default) {
	    parity = exp_default_parity;
	} else {
	    parity = f->parity;
	}
	sprintf(interp->result,"%d",parity);
	return(TCL_OK);
    }

    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
    }

    /* all that's left is to set the parity */
    parity = atoi(argv[0]);

    if (Default) exp_default_parity = parity;
    else f->parity = parity;

    return(TCL_OK);
}

#if DEBUG_PERM_ECASES
/* This big chunk of code is just for debugging the permanent */
/* expect cases */
void
exp_fd_print(fsl)
    struct exp_fs_list *fsl;
{
    if (!fsl) return;
    printf("%s ",fsl->spawnId);
    exp_fd_print(fsl->next);
}

void
exp_i_print(exp_i)
    struct exp_i *exp_i;
{
    if (!exp_i) return;
    printf("exp_i %x",exp_i);
    printf((exp_i->direct == EXP_DIRECT)?" direct":" indirect");
    printf((exp_i->duration == EXP_PERMANENT)?" perm":" tmp");
    printf("  ecount = %d\n",exp_i->ecount);
    printf("variable %s, value %s\n",
	   ((exp_i->variable)?exp_i->variable:"--"),
	   ((exp_i->value)?exp_i->value:"--"));
    printf("fds: ");
    exp_fd_print(exp_i->fs_list); printf("\n");
    exp_i_print(exp_i->next);
}

void
exp_ecase_print(ecase)
    struct ecase *ecase;
{
    printf("pat <%s>\n",ecase->pat);
    printf("exp_i = %x\n",ecase->i_list);
}

void
exp_ecases_print(ecd)
    struct exp_cases_descriptor *ecd;
{
    int i;

    printf("%d cases\n",ecd->count);
    for (i=0;i<ecd->count;i++) exp_ecase_print(ecd->cases[i]);
}

void
exp_cmd_print(ecmd)
    struct exp_cmd_descriptor *ecmd;
{
    printf("expect cmd type: %17s",exp_cmdtype_printable(ecmd->cmdtype));
    printf((ecmd->duration==EXP_PERMANENT)?" perm ": "tmp ");
    /* printdict */
    exp_ecases_print(&ecmd->ecd);
    exp_i_print(ecmd->i_list);
}

void
exp_cmds_print()
{
    exp_cmd_print(&exp_cmds[EXP_CMD_BEFORE]);
    exp_cmd_print(&exp_cmds[EXP_CMD_AFTER]);
    exp_cmd_print(&exp_cmds[EXP_CMD_BG]);
}

/*ARGSUSED*/
int
cmdX(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    exp_cmds_print();
    return TCL_OK;
}
#endif /*DEBUG_PERM_ECASES*/

static struct exp_cmd_data
cmd_data[]  = {
{"expect",	Exp_ExpectCmd,	(ClientData) NULL,	0},
{"expect_after",Exp_ExpectGlobalCmd,(ClientData)&exp_cmds[EXP_CMD_AFTER],0},
{"expect_before",Exp_ExpectGlobalCmd,(ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
{"expect_user",	Exp_ExpectCmd,	(ClientData)"exp_user",	0},
{"expect_tty",	Exp_ExpectCmd,	(ClientData)"exp_tty",	0},
{"expect_background",Exp_ExpectGlobalCmd,(ClientData)&exp_cmds[EXP_CMD_BG],0},
{"match_max",	Exp_MatchMaxCmd,	0,	0},
{"remove_nulls",Exp_RemoveNullsCmd,	0,	0},
{"parity",	Exp_ParityCmd,		0,	0},
{"timestamp",	Exp_TimestampCmd,	0,	0},
{0}};

/*
 *----------------------------------------------------------------------
 *
 * exp_init_expect_cmds --
 *
 *	Initialize all the 'expect' type commands.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Commands are added to and variables are set in the interpreter.
 *
 *----------------------------------------------------------------------
 */

void
exp_init_expect_cmds(interp)
    Tcl_Interp *interp;
{
    exp_create_commands(interp,cmd_data);

    Tcl_SetVar(interp,EXPECT_TIMEOUT,INIT_EXPECT_TIMEOUT_LIT,0);
    Tcl_SetVar(interp,EXP_SPAWN_ID_ANY_VARNAME,EXP_SPAWN_ID_ANY,0);

    exp_cmd_init(&exp_cmds[EXP_CMD_BEFORE],EXP_CMD_BEFORE,EXP_PERMANENT);
    exp_cmd_init(&exp_cmds[EXP_CMD_AFTER ],EXP_CMD_AFTER, EXP_PERMANENT);
    exp_cmd_init(&exp_cmds[EXP_CMD_BG    ],EXP_CMD_BG,    EXP_PERMANENT);
    exp_cmd_init(&exp_cmds[EXP_CMD_FG    ],EXP_CMD_FG,    EXP_TEMPORARY);

    /* preallocate to one element, so future realloc's work */
    exp_cmds[EXP_CMD_BEFORE].ecd.cases = 0;
    exp_cmds[EXP_CMD_AFTER ].ecd.cases = 0;
    exp_cmds[EXP_CMD_BG    ].ecd.cases = 0;

    pattern_style[PAT_EOF] = "eof";
    pattern_style[PAT_TIMEOUT] = "timeout";
    pattern_style[PAT_DEFAULT] = "default";
    pattern_style[PAT_FULLBUFFER] = "full buffer";
    pattern_style[PAT_GLOB] = "glob pattern";
    pattern_style[PAT_RE] = "regular expression";
    pattern_style[PAT_EXACT] = "exact string";
    pattern_style[PAT_NULL] = "null";
}

void
exp_init_sig() {
}
@


1.1.2.1.2.1
log
@A working set of code against Tcl8.4!
@
text
@a33 3

#define BUILD_expect

d84 1
a84 1
    Tcl_RegExp *re;	/* if this is 0, then pattern match via glob */
d307 2
a308 2
exp_one_arg_braced(objPtr)	/* INTL */
    Tcl_Obj *objPtr;
d310 1
a310 2
	int seen_nl = FALSE;
	char *p = Tcl_GetString(objPtr);
d312 5
a316 5
	for (;*p;p++) {
		if (*p == '\n') {
			seen_nl = TRUE;
			continue;
		}
d318 2
a319 3
		if (!isspace(*p)) { /* INTL: ISO space */
			return(seen_nl);
		}
d321 2
a322 1
	return FALSE;
a340 4
/* called to execute a command of only one argument - a hack to commands */
/* to be called with all args surrounded by an outer set of braces */
/* returns TCL_whatever */
/*ARGSUSED*/
d342 1
a342 1
exp_eval_with_one_arg(clientData,interp,objv) /* INTL */
d345 1
a345 1
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d347 1
a347 5
#define NUM_STATIC_OBJS 20
    Tcl_Obj *staticObjArray[NUM_STATIC_OBJS];
    int maxobjs = NUM_STATIC_OBJS;
    Tcl_Token *tokenPtr;
    char *p, *next;
d349 1
a349 13
    Tcl_Obj **objs = staticObjArray;
    int objc, bytesLeft, numWords, i;
    Tcl_Parse parse;

    /*
     * Prepend the command name and the -nobrace switch so we can
     * reinvoke without recursing.
     */
    objc = 2;
    objs[0] = objv[0];
    objs[1] = Tcl_NewStringObj("-nobrace", -1);
    Tcl_IncrRefCount(objs[0]);
    Tcl_IncrRefCount(objs[1]);
d351 4
a354 1
    p = Tcl_GetStringFromObj(objv[1], &bytesLeft);
d357 1
a357 4
     * Treat the pattern/action block like a series of Tcl commands.
     * For each command, parse the command words, perform substititions
     * on each word, and add the words to an array of values.  We don't
     * actually evaluate the individual commands, just the substitutions.
d360 7
a366 38
    do {
	if (Tcl_ParseCommand(interp, p, bytesLeft, 0, &parse)
	        != TCL_OK) {
	    rc = TCL_ERROR;
	    goto done;
	}
	numWords = parse.numWords;
 	if (numWords > 0) {
	    /*
	     * Generate an array of objects for the words of the command.
	     */
    
	    if (objc + numWords > maxobjs) {
		Tcl_Obj ** newobjs;
		maxobjs = (objc + numWords) * 2;
		newobjs = (Tcl_Obj **)ckalloc(maxobjs * sizeof (Tcl_Obj *));
		memcpy(newobjs, objs, objc*sizeof(Tcl_Obj *));
		if (objs != staticObjArray) {
		    ckfree((char*)objs);
		}
		objs = newobjs;   
	    }

	    /*
	     * For each word, perform substitutions then store the
	     * result in the objs array.
	     */
	    
	    for (tokenPtr = parse.tokenPtr; numWords > 0;
		 numWords--, tokenPtr += (tokenPtr->numComponents + 1)) {
		objs[objc] = Tcl_EvalTokens(interp, tokenPtr+1,
			tokenPtr->numComponents);
		if (objs[objc] == NULL) {
		    rc = TCL_ERROR;
		    goto done;
		}
		objc++;
	    }
d368 2
d371 1
a371 8
	/*
	 * Advance to the next command in the script.
	 */
	next = parse.commandStart + parse.commandSize;
	bytesLeft -= next - p;
	p = next;
	Tcl_FreeParse(&parse);
    } while (bytesLeft > 0);
d373 1
a373 12
    /*
     * Now evaluate the entire command with no further substitutions.
     */

    rc = Tcl_EvalObjv(interp, objc, objs, 0);
 done:
    for (i = 0; i < objc; i++) {
	Tcl_DecrRefCount(objs[i]);
    }
    if (objs != staticObjArray) {
	ckfree((char *) objs);
    }
a374 1
#undef NUM_STATIC_OBJS
a376 1

d438 1
a438 1
parse_expect_args(interp,eg,default_spawn_id,objc,objv)
d443 3
a445 2
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d448 1
a448 1
    char *string;
d451 3
d462 2
a463 1
    eg->ecd.cases = (struct ecase **)ckalloc(sizeof(struct ecase *) * (1+(objc/2)));
d467 17
a483 28
    for (i = 1;i<objc;i++) {
	int index;
	string = Tcl_GetString(objv[i]);
	if (string[0] == '-') {
	    static char *flags[] = {
		"-glob", "-regexp", "-exact", "-notransfer", "-nocase",
		"-i", "-indices", "-iread", "-timestamp", "-timeout",
		"-nobrace", "--", (char *)0
	    };
	    enum flags {
		EXP_ARG_GLOB, EXP_ARG_REGEXP, EXP_ARG_EXACT,
		EXP_ARG_NOTRANSFER, EXP_ARG_NOCASE, EXP_ARG_SPAWN_ID,
		EXP_ARG_INDICES, EXP_ARG_IREAD, EXP_ARG_TIMESTAMP,
		EXP_ARG_DASH_TIMEOUT, EXP_ARG_NOBRACE, EXP_ARG_DASH
	    };

	    /*
	     * Allow abbreviations of switches and report an error if we
	     * get an invalid switch.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
		    &index) != TCL_OK) {
		return TCL_ERROR;
	    }
	    switch ((enum flags) index) {
	    case EXP_ARG_GLOB:
	    case EXP_ARG_DASH:
d488 1
a488 6
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-glob pattern");
		    return TCL_ERROR;
		}
		goto pattern;
	    case EXP_ARG_REGEXP:
a489 4
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-regexp regexp");
		    return TCL_ERROR;
		}
d491 4
a494 9

		/*
		 * Try compiling the expression so we can report
		 * any errors now rather then when we first try to
		 * use it.
		 */

		if (!(Tcl_GetRegExpFromObj(interp, objv[i],
					   TCL_REG_ADVANCED))) {
d497 1
a497 2
		goto pattern;
	    case EXP_ARG_EXACT:
a498 4
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-exact string");
		    return TCL_ERROR;
		}
d500 1
a500 2
		goto pattern;
	    case EXP_ARG_NOTRANSFER:
d502 2
a503 2
		break;
	    case EXP_ARG_NOCASE:
d505 2
a506 2
		break;
	    case EXP_ARG_SPAWN_ID:
d508 9
a516 2
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-i spawn_id");
a518 3
		ec.i_list = exp_new_i_complex(interp,
				      Tcl_GetString(objv[i]),
				      eg->duration, exp_indirect_update2,Tcl_GetString(objv[0]));
d524 3
a526 2
		break;
	    case EXP_ARG_INDICES:
d528 5
a532 2
		break;
	    case EXP_ARG_IREAD:
d534 2
a535 2
		break;
	    case EXP_ARG_TIMESTAMP:
d537 2
a538 2
		break;
	    case EXP_ARG_DASH_TIMEOUT:
d540 2
a541 6
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-timeout seconds");
		    goto error;
		}
		if (Tcl_GetIntFromObj(interp, objv[i],
				      &eg->timeout) != TCL_OK) {
d544 2
d547 2
a548 2
		break;
	    case EXP_ARG_NOBRACE:
d554 4
a557 1
		break;
d559 12
a570 57
	    /*
	     * Keep processing arguments, we aren't ready for the
	     * pattern yet.
	     */
	    continue;
	} else {
	    /*
	     * We have a pattern or keyword.
	     */

	    static char *keywords[] = {
		"timeout", "eof", "full_buffer", "default", "null",
		(char *)NULL
	    };
	    enum keywords {
		EXP_ARG_TIMEOUT, EXP_ARG_EOF, EXP_ARG_FULL_BUFFER,
		EXP_ARG_DEFAULT, EXP_ARG_NULL
	    };

	    /*
	     * Match keywords exactly, otherwise they are patterns.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv[i], keywords, "keyword",
		    1 /* exact */, &index) != TCL_OK) {
		Tcl_ResetResult(interp);
		goto pattern;
	    }
	    switch ((enum keywords) index) {
	    case EXP_ARG_TIMEOUT:
		ec.use = PAT_TIMEOUT;
		break;
	    case EXP_ARG_EOF:
		ec.use = PAT_EOF;
		break;
	    case EXP_ARG_FULL_BUFFER:
		ec.use = PAT_FULLBUFFER;
		break;
	    case EXP_ARG_DEFAULT:
		ec.use = PAT_DEFAULT;
		break;
	    case EXP_ARG_NULL:
		ec.use = PAT_NULL;
		break;
	    }
pattern:
	    /* if no -i, use previous one */
	    if (!ec.i_list) {
		/* if no -i flag has occurred yet, use default */
		if (!eg->i_list) {
		    if (default_spawn_id != NULL) {
			eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
		    } else {
			/* it'll be checked later, if used */
			default_spawn_id = exp_update_master(interp,0,0);
			eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
		    }
a571 1
		ec.i_list = eg->i_list;
d573 3
a575 1
	    ec.i_list->ecount++;
d577 7
a583 7
	    /* save original pattern spec */
	    /* keywords such as "-timeout" are saved as patterns here */
	    /* useful for debugging but not otherwise used */
	    save_str(&ec.pat,Tcl_GetString(objv[i]),eg->duration == EXP_TEMPORARY);
	    save_str(&ec.body,Tcl_GetString(objv[i+1]),eg->duration == EXP_TEMPORARY);
			    
	    i++;
d585 1
a585 1
	    *(eg->ecd.cases[eg->ecd.count] = ecase_new()) = ec;
d587 2
a588 2
	    /* clear out for next set */
	    ecase_clear(&ec);
d590 1
a590 2
	    eg->ecd.count++;
	}
a627 1

d669 1
a669 2
    Tcl_RegExpInfo info;

d683 2
a684 2
	//TclRegError((char *)0);
	if (buffer && Tcl_RegExpExec(interp,*e->re,buffer,buffer)) {
d686 1
a686 2
	    Tcl_RegExpGetInfo(*e->re, &info);
	    o->match = Tcl_UtfAtIndex(buffer, info.matches[0].end)-buffer;
d693 2
a694 2
	    //if (TclGetRegError()) {
	//	exp_error(interp,"-re failed: %s",TclGetRegError());
d696 1
a696 1
	  //  }
d1153 1
a1153 1
Exp_ExpectGlobalCmd(clientData, interp, objc, objv)
d1156 2
a1157 2
    int objc;
    Tcl_Obj *CONST objv[];
d1164 1
a1164 1
    //char *argv0;
d1168 7
a1174 7
    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d1177 3
a1179 3
    if (objc > 1 && (Tcl_GetString(objv[1])[0] == '-')) {
	if (exp_flageq("info",Tcl_GetString(objv[1])+1,4)) {
	    return(expect_info(interp,ecmd,objc,objv));
d1183 1
d1186 1
a1186 2
    if (TCL_ERROR == parse_expect_args(interp,&eg,EXP_SPAWN_ID_BAD,
	    objc,objv)) {
d1205 1
a1205 1
		if (!exp_fcheck(interp,f,1,1,Tcl_GetString(objv[0]))) {
a1620 1
    return -1;
a1636 1
    return -1;
d1779 1
a1779 1
//#ifdef LINT
d1781 1
a1781 1
//#endif
d2071 4
a2074 2
	     Tcl_RegExpInfo info;
	     Tcl_RegExpGetInfo(*e->re, &info);
d2076 1
a2076 7
	     for (i=0;i<info.nsubs;i++) {
		 int start, end;
		 Tcl_Obj *val;
		 
		 start = info.matches[i].start;
		 end = info.matches[i].end-1;
		 if (start == -1) continue;
d2079 11
a2089 9
		    /* start index */
		    sprintf(name,"%d,start",i);
		    sprintf(value,"%d",start);
		    out(name,value);

		    /* end index */
		    sprintf(name,"%d,end",i);
		    sprintf(value,"%d",end);
		    out(name,value);
d2094 7
a2100 2
		 val = Tcl_GetRange(Tcl_NewStringObj(buffer,-1), start, end);
		 out(name,Tcl_GetString(val));
d2102 3
d2233 1
a2233 1
Exp_ExpectCmd(clientData, interp, objc, objv)
d2236 2
a2237 2
    int objc;
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d2272 1
d2274 7
a2280 7
    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d2283 1
d2295 1
a2295 1
	f = exp_chan2f(interp,(char *) clientData,1,0,Tcl_GetString(objv[0]));
d2302 1
a2302 1
    if (TCL_ERROR == parse_expect_args(interp,&eg,f,objc,objv,Tcl_GetString(objv[0])))
d2324 1
a2324 1
	if (!exp_fcheck(interp,fsl->f,1,1,Tcl_GetString(objv[0]))) {
d2480 4
a2483 2
	     Tcl_RegExpInfo info;
	     Tcl_RegExpGetInfo(*e->re, &info);
d2485 1
a2485 7
	     for (i=0;i<info.nsubs;i++) {
		 int start, end;
		 Tcl_Obj *val;
		 
		 start = info.matches[i].start;
		 end = info.matches[i].end-1;
		 if (start == -1) continue;
d2487 13
a2499 5
		 if (e->indices) {
		    /* start index */
		    sprintf(name,"%d,start",i);
		    sprintf(value,"%d",start);
		    out(name,value);
d2501 2
a2502 5
		    /* end index */
		    sprintf(name,"%d,end",i);
		    sprintf(value,"%d",end);
		    out(name,value);
		 }
d2504 10
a2513 5
		 /* string itself */
		 sprintf(name,"%d,string",i);
		 val = Tcl_GetRange(Tcl_NewStringObj(buffer,-1), start, end);
		 out(name,Tcl_GetString(val));
	     }
d3036 10
a3045 10
{"expect",	Exp_ExpectCmd,	0, (ClientData) NULL,	0},
{"expect_after",Exp_ExpectGlobalCmd, 0, (ClientData)&exp_cmds[EXP_CMD_AFTER],0},
{"expect_before",Exp_ExpectGlobalCmd, 0, (ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
{"expect_user",	Exp_ExpectCmd,	0, (ClientData)"exp_user",	0},
{"expect_tty",	Exp_ExpectCmd,	0, (ClientData)"exp_tty",	0},
{"expect_background",Exp_ExpectGlobalCmd, 0, (ClientData)&exp_cmds[EXP_CMD_BG],0},
{"match_max",	0, Exp_MatchMaxCmd,	0,	0},
{"remove_nulls",0, Exp_RemoveNullsCmd,	0,	0},
{"parity",	0, Exp_ParityCmd,		0,	0},
{"timestamp",	0, Exp_TimestampCmd,	0,	0},
@


1.1.2.1.2.2
log
@moved all header files over to a more core style with the beginnings of a
Stubs table.  This work is far from complete.
@
text
@a20 1
/*
d26 3
a28 3
#include <ctype.h>	*//* for isspace */
/*#include <time.h>	*//* for time(3) */
/*
d35 2
d42 1
a42 1
#include "exp_tstamp.h"	*//* this should disappear when interact */
a43 2
#include "expInt.h"

d812 1
a812 1
	exp_debuglog("\r\nexpect%s: does \"%s\" (spawn_id %s) match %s ",
d819 1
a819 1
	exp_debuglog("\"%s\"? ",dprintify(e->pat));
d827 1
a827 1
	    exp_debuglog(yes);
d830 1
a830 1
	    exp_debuglog(no);
d839 1
a839 1
	exp_debuglog("\"%s\"? ",dprintify(e->pat));
d846 1
a846 1
	    exp_debuglog(yes);
d848 1
a848 1
	} else exp_debuglog(no);
d851 1
a851 1
	exp_debuglog("\"%s\"? ",dprintify(e->pat));
d858 1
a858 1
	    exp_debuglog(yes);
d860 1
a860 1
	} else exp_debuglog(no);
d863 1
a863 1
	exp_debuglog("null? ");
d872 1
a872 1
		exp_debuglog(yes);
d876 1
a876 1
	exp_debuglog(no);
d878 1
a878 1
	exp_debuglog("%s? ",e->pat);
d883 1
a883 1
	exp_debuglog(yes);
d1665 2
a1666 2
	if (exp_logfile_all || (exp_loguser && exp_logfile)) {
	    Tcl_Write(exp_logfile, f->buffer + f->printed, write_count);
d1672 1
a1672 1
	if (exp_loguser) {
d1678 2
a1679 2
	if (exp_debugfile) {
	    Tcl_Write(exp_debugfile, f->buffer + f->printed, write_count);
d1722 1
a1722 1
    exp_debuglog("%s: set %s(spawn_id) \"%s\"\r\n",
d1730 1
a1730 1
    exp_debuglog("%s: set %s(buffer) \"%s\"\r\n",
d1837 1
a1837 1
CONST char *
d1842 1
a1842 1
    CONST char *val;
d1867 1
a1867 1
    CONST char *t;
d2169 1
a2169 1
	exp_debuglog("expect_background: read eof\r\n");
d2178 1
a2178 1
#define out(i,val)  exp_debuglog("expect_background: set %s(%s) \"%s\"\r\n",EXPECT_OUT,i, \
d2271 1
a2271 1
	     exp_debuglog("expect_background: full buffer\r\n");
d2515 1
a2515 1
	    exp_debuglog("expect: timed out\r\n");
d2543 1
a2543 1
	    exp_debuglog("expect: read eof\r\n");
d2564 1
a2564 1
#define out(i,val)  exp_debuglog("expect: set %s(%s) \"%s\"\r\n",EXPECT_OUT,i, \
d2672 1
a2672 1
		exp_debuglog("expect: full buffer\r\n");
d2736 1
a2736 1
	exp_debuglog("expect: continuing expect\r\n");
d2750 1
a2750 1
	exp_debuglog("expect: continuing expect after update\r\n");
d2868 1
a2868 1
    CONST char *src;
d3162 11
a3172 12
    {"expect",	Exp_ExpectCmd,	0, (ClientData) NULL,	0},
    {"expect_after",Exp_ExpectGlobalCmd, 0, (ClientData)&exp_cmds[EXP_CMD_AFTER],0},
    {"expect_before",Exp_ExpectGlobalCmd, 0, (ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
    {"expect_user",	Exp_ExpectCmd,	0, (ClientData)"exp_user",	0},
    {"expect_tty",	Exp_ExpectCmd,	0, (ClientData)"exp_tty",	0},
    {"expect_background",Exp_ExpectGlobalCmd, 0, (ClientData)&exp_cmds[EXP_CMD_BG],0},
    {"match_max",	0, Exp_MatchMaxCmd,	0,	0},
    {"remove_nulls",0, Exp_RemoveNullsCmd,	0,	0},
    {"parity",	0, Exp_ParityCmd,		0,	0},
    {"timestamp",	0, Exp_TimestampCmd,	0,	0},
    {0}
};
@


1.1.2.1.2.3
log
@All file comments have the same form.
@
text
@d1 1
a1 1
/* ----------------------------------------------------------------------------
d4 1
a4 1
 *	expect commands.
d6 1
a6 1
 * ----------------------------------------------------------------------------
a7 2
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
d11 8
a18 14
 * 
 * Copyright (c) 1997 Mitel Corporation
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
 *
 * Copyright (c) 2001-2002 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
 *
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: exp.h,v 1.1.4.4 2002/02/10 10:17:04 davygrvy Exp $
 * ----------------------------------------------------------------------------
d21 22
@


1.1.2.2
log
@fixed numerous warnings and errors.  code is from 5.32.2
@
text
@d1 19
a19 9
/* expect.c - expect commands

Written by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/
d24 1
a28 1
//#include "expect_cf.h"
a30 8
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

d33 1
a33 3

#include "string.h"

a38 1
#include "exp_tty.h"
d42 1
a42 1
#include "tcldbg.h"
a55 14
typedef struct ThreadSpecificData {
    int timeout;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 * addr of these placeholders appear as clientData in ExpectCmd * when called
 * as expect_user and expect_tty.  It would be nicer * to invoked
 * expDevttyGet() but C doesn't allow this in an array initialization, sigh.
 */
static ExpState StdinoutPlaceholder;
static ExpState DevttyPlaceholder;

d60 3
a62 3
	struct exp_i	*i_list;
	Tcl_Obj *pat;	/* original pattern spec */
	Tcl_Obj *body;	/* ptr to body to be executed upon match */
d72 8
a79 7
	int use;	/* PAT_XXX */
	int simple_start;/* offset from start of buffer denoting where a */
			/* glob or exact match begins */
	int transfer;	/* if false, leave matched chars in input stream */
	int indices;	/* if true, write indices */
	int iread;	/* if true, reread indirects */
	int timestamp;	/* if true, write timestamps */
d83 2
a84 1
	int Case;	/* convert case before doing match? */
d91 2
a92 2
	int count;
	struct ecase **cases;
d98 6
a103 6
	int cmdtype;			/* bg, before, after */
	int duration;			/* permanent or temporary */
	int timeout_specified_by_flag;	/* if -timeout flag used */
	int timeout;			/* timeout period if flag used */
	struct exp_cases_descriptor ecd;
	struct exp_i *i_list;
d112 9
a120 9
struct exp_cmd_descriptor *cmd;
int duration;
int cmdtype;
{
	cmd->duration = duration;
	cmd->cmdtype = cmdtype;
	cmd->ecd.cases = 0;
	cmd->ecd.count = 0;
	cmd->i_list = 0;
d126 16
a141 3
#ifdef SIMPLE_EVENT
static int alarm_fired;	/* if alarm occurs */
#endif
a142 1
//extern void exp_background_channelhandlers_run_all();
d144 13
a156 19
/* exp_indirect_updateX is called by Tcl when an indirect variable is set */
/* 1-part Tcl variable names */
static char *exp_indirect_update1 _ANSI_ARGS_((Tcl_Interp *interp,
					       struct exp_cmd_descriptor *ecmd,
					       struct exp_i *exp_i));
/* 2-part Tcl variable names */
static char *exp_indirect_update2 _ANSI_ARGS_((ClientData clientData,
					      Tcl_Interp *interp,
					      char *name1,
					      char *name2,
					      int flags));

static Tcl_ObjCmdProc Exp_ExpectObjCmd;
static Tcl_ObjCmdProc Exp_ExpectGlobalObjCmd;
static Tcl_ObjCmdProc Exp_ExpectObjCmd;
static Tcl_CmdProc Exp_MatchMaxCmd;
static Tcl_CmdProc Exp_RemoveNullsCmd;
static Tcl_CmdProc Exp_ParityCmd;
static Tcl_CmdProc Exp_TimestampCmd;
d158 9
d168 9
a176 7
#ifdef SIMPLE_EVENT
/*ARGSUSED*/
static RETSIGTYPE
sigalarm_handler(n)
int n;		       	/* unused, for compatibility with STDC */
{
	alarm_fired = TRUE;
a177 1
#endif /*SIMPLE_EVENT*/
d179 13
a191 1
/* free up everything in ecase */
d194 3
a196 3
Tcl_Interp *interp;
struct ecase *ec;
int free_ilist;		/* if we should free ilist */
d198 2
d201 2
a202 2
	if (ec->pat) Tcl_DecrRefCount(ec->pat);
	if (ec->body) Tcl_DecrRefCount(ec->body);
d211 1
a211 1
    ckfree((char *)ec);	/* NEW */
d214 13
a226 1
/* free up any argv structures in the ecases */
d229 3
a231 3
Tcl_Interp *interp;
struct exp_cmd_descriptor *eg;
int free_ilist;		/* if true, free ilists */
d233 1
a233 1
	int i;
d235 1
a235 1
	if (!eg->ecd.cases) return;
d237 4
a240 4
	for (i=0;i<eg->ecd.count;i++) {
		free_ecase(interp,eg->ecd.cases[i],free_ilist);
	}
	ckfree((char *)eg->ecd.cases);
d242 2
a243 2
	eg->ecd.cases = 0;
	eg->ecd.count = 0;
d247 17
a263 11
#if 0
/* no standard defn for this, and some systems don't even have it, so avoid */
/* the whole quagmire by calling it something else */
static char *exp_strdup(s)
char *s;
{
	char *news = ckalloc(strlen(s) + 1);
	strcpy(news,s);
	return(news);
}
#endif
a264 2
/* In many places, there is no need to malloc a copy of a string, since it */
/* will be freed before we return to Tcl */
d267 3
a269 3
char **lhs;	/* left hand side */
char *rhs;	/* right hand side */
int nosave;
d271 6
a276 6
	if (nosave || (rhs == 0)) {
		*lhs = rhs;
	} else {
		*lhs = ckalloc(strlen(rhs) + 1);
		strcpy(*lhs,rhs);
	}
d279 27
a305 16
/* return TRUE if string appears to be a set of arguments
   The intent of this test is to support the ability of commands to have
   all their args braced as one.  This conflicts with the possibility of
   actually intending to have a single argument.
   The bad case is in expect which can have a single argument with embedded
   \n's although it's rare.  Examples that this code should handle:
   \n		FALSE (pattern)
   \n\n		FALSE
   \n  \n \n	FALSE
   foo		FALSE
   foo\n	FALSE
   \nfoo\n	TRUE  (set of args)
   \nfoo\nbar	TRUE

   Current test is very cheap and almost always right :-)
*/
d307 2
a308 2
exp_one_arg_braced(objPtr)	/* INTL */
Tcl_Obj *objPtr;
d310 1
a310 2
	int seen_nl = FALSE;
	char *p = Tcl_GetString(objPtr);
d312 5
a316 5
	for (;*p;p++) {
		if (*p == '\n') {
			seen_nl = TRUE;
			continue;
		}
d318 2
a319 3
		if (!isspace(*p)) { /* INTL: ISO space */
			return(seen_nl);
		}
d321 2
a322 1
	return FALSE;
d325 15
a339 3
/* called to execute a command of only one argument - a hack to commands */
/* to be called with all args surrounded by an outer set of braces */
/* returns TCL_whatever */
d342 4
a345 4
exp_eval_with_one_arg(clientData,interp,objv) /* INTL */
ClientData clientData;
Tcl_Interp *interp;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d347 1
a347 5
#define NUM_STATIC_OBJS 20
    Tcl_Obj *staticObjArray[NUM_STATIC_OBJS];
    int maxobjs = NUM_STATIC_OBJS;
    Tcl_Token *tokenPtr;
    char *p, *next;
d349 1
a349 3
    Tcl_Obj **objs = staticObjArray;
    int objc, bytesLeft, numWords, i;
    Tcl_Parse parse;
d351 4
a354 11
    /*
     * Prepend the command name and the -nobrace switch so we can
     * reinvoke without recursing.
     */
    objc = 2;
    objs[0] = objv[0];
    objs[1] = Tcl_NewStringObj("-nobrace", -1);
    Tcl_IncrRefCount(objs[0]);
    Tcl_IncrRefCount(objs[1]);

    p = Tcl_GetStringFromObj(objv[1], &bytesLeft);
d357 1
a357 4
     * Treat the pattern/action block like a series of Tcl commands.
     * For each command, parse the command words, perform substititions
     * on each word, and add the words to an array of values.  We don't
     * actually evaluate the individual commands, just the substitutions.
d360 7
a366 38
    do {
	if (Tcl_ParseCommand(interp, p, bytesLeft, 0, &parse)
	        != TCL_OK) {
	    rc = TCL_ERROR;
	    goto done;
	}
	numWords = parse.numWords;
 	if (numWords > 0) {
	    /*
	     * Generate an array of objects for the words of the command.
	     */
    
	    if (objc + numWords > maxobjs) {
		Tcl_Obj ** newobjs;
		maxobjs = (objc + numWords) * 2;
		newobjs = (Tcl_Obj **)ckalloc(maxobjs * sizeof (Tcl_Obj *));
		memcpy(newobjs, objs, objc*sizeof(Tcl_Obj *));
		if (objs != staticObjArray) {
		    ckfree((char*)objs);
		}
		objs = newobjs;   
	    }

	    /*
	     * For each word, perform substitutions then store the
	     * result in the objs array.
	     */
	    
	    for (tokenPtr = parse.tokenPtr; numWords > 0;
		 numWords--, tokenPtr += (tokenPtr->numComponents + 1)) {
		objs[objc] = Tcl_EvalTokens(interp, tokenPtr+1,
			tokenPtr->numComponents);
		if (objs[objc] == NULL) {
		    rc = TCL_ERROR;
		    goto done;
		}
		objc++;
	    }
d368 2
d371 1
a371 8
	/*
	 * Advance to the next command in the script.
	 */
	next = parse.commandStart + parse.commandSize;
	bytesLeft -= next - p;
	p = next;
	Tcl_FreeParse(&parse);
    } while (bytesLeft > 0);
d373 1
a373 12
    /*
     * Now evaluate the entire command with no further substitutions.
     */

    rc = Tcl_EvalObjv(interp, objc, objs, 0);
 done:
    for (i = 0; i < objc; i++) {
	Tcl_DecrRefCount(objs[i]);
    }
    if (objs != staticObjArray) {
	ckfree((char *) objs);
    }
a374 1
#undef NUM_STATIC_OBJS
d379 1
a379 1
struct ecase *ec;
d381 11
a391 9
	ec->i_list = 0;
	ec->pat = 0;
	ec->body = 0;
	ec->transfer = TRUE;
	ec->indices = FALSE;
	ec->iread = FALSE;
	ec->timestamp = FALSE;
	ec->Case = CASE_NORM;
	ec->use = PAT_GLOB;
d397 1
a397 1
	struct ecase *ec = (struct ecase *)ckalloc(sizeof(struct ecase));
d399 2
a400 2
	ecase_clear(ec);
	return ec;
d404 32
a435 24

parse_expect_args parses the arguments to expect or its variants. 
It normally returns TCL_OK, and returns TCL_ERROR for failure.
(It can't return i_list directly because there is no way to differentiate
between clearing, say, expect_before and signalling an error.)

eg (expect_global) is initialized to reflect the arguments parsed
eg->ecd.cases is an array of ecases
eg->ecd.count is the # of ecases
eg->i_list is a linked list of exp_i's which represent the -i info

Each exp_i is chained to the next so that they can be easily free'd if
necessary.  Each exp_i has a reference count.  If the -i is not used
(e.g., has no following patterns), the ref count will be 0.

Each ecase points to an exp_i.  Several ecases may point to the same exp_i.
Variables named by indirect exp_i's are read for the direct values.

If called from a foreground expect and no patterns or -i are given, a
default exp_i is forced so that the command "expect" works right.

The exp_i chain can be broken by the caller if desired.

*/
d438 8
a445 6
parse_expect_args(interp,eg,default_esPtr,objc,objv)
Tcl_Interp *interp;
struct exp_cmd_descriptor *eg;
ExpState *default_esPtr;	/* suggested ExpState if called as expect_user or _tty */
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d448 5
a452 2
    char *string;
    struct ecase ec;	/* temporary to collect args */
d462 2
a463 1
    eg->ecd.cases = (struct ecase **)ckalloc(sizeof(struct ecase *) * (1+(objc/2)));
d467 17
a483 28
    for (i = 1;i<objc;i++) {
	int index;
	string = Tcl_GetString(objv[i]);
	if (string[0] == '-') {
	    static char *flags[] = {
		"-glob", "-regexp", "-exact", "-notransfer", "-nocase",
		"-i", "-indices", "-iread", "-timestamp", "-timeout",
		"-nobrace", "--", (char *)0
	    };
	    enum flags {
		EXP_ARG_GLOB, EXP_ARG_REGEXP, EXP_ARG_EXACT,
		EXP_ARG_NOTRANSFER, EXP_ARG_NOCASE, EXP_ARG_SPAWN_ID,
		EXP_ARG_INDICES, EXP_ARG_IREAD, EXP_ARG_TIMESTAMP,
		EXP_ARG_DASH_TIMEOUT, EXP_ARG_NOBRACE, EXP_ARG_DASH
	    };

	    /*
	     * Allow abbreviations of switches and report an error if we
	     * get an invalid switch.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
		    &index) != TCL_OK) {
		return TCL_ERROR;
	    }
	    switch ((enum flags) index) {
	    case EXP_ARG_GLOB:
	    case EXP_ARG_DASH:
d488 1
a488 6
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-glob pattern");
		    return TCL_ERROR;
		}
		goto pattern;
	    case EXP_ARG_REGEXP:
a489 4
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-regexp regexp");
		    return TCL_ERROR;
		}
d491 4
a494 9

		/*
		 * Try compiling the expression so we can report
		 * any errors now rather then when we first try to
		 * use it.
		 */

		if (!(Tcl_GetRegExpFromObj(interp, objv[i],
					   TCL_REG_ADVANCED))) {
d497 1
a497 2
		goto pattern;
	    case EXP_ARG_EXACT:
a498 4
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-exact string");
		    return TCL_ERROR;
		}
d500 1
a500 2
		goto pattern;
	    case EXP_ARG_NOTRANSFER:
d502 2
a503 2
		break;
	    case EXP_ARG_NOCASE:
d505 2
a506 2
		break;
	    case EXP_ARG_SPAWN_ID:
d508 9
a516 2
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-i spawn_id");
a518 3
		ec.i_list = exp_new_i_complex(interp,
				      Tcl_GetString(objv[i]),
				      eg->duration, exp_indirect_update2);
d524 3
a526 2
		break;
	    case EXP_ARG_INDICES:
d528 5
a532 2
		break;
	    case EXP_ARG_IREAD:
d534 2
a535 2
		break;
	    case EXP_ARG_TIMESTAMP:
d537 2
a538 2
		break;
	    case EXP_ARG_DASH_TIMEOUT:
d540 2
a541 6
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-timeout seconds");
		    goto error;
		}
		if (Tcl_GetIntFromObj(interp, objv[i],
				      &eg->timeout) != TCL_OK) {
d544 2
d547 2
a548 2
		break;
	    case EXP_ARG_NOBRACE:
d554 4
a557 1
		break;
d559 12
a570 57
	    /*
	     * Keep processing arguments, we aren't ready for the
	     * pattern yet.
	     */
	    continue;
	} else {
	    /*
	     * We have a pattern or keyword.
	     */

	    static char *keywords[] = {
		"timeout", "eof", "full_buffer", "default", "null",
		(char *)NULL
	    };
	    enum keywords {
		EXP_ARG_TIMEOUT, EXP_ARG_EOF, EXP_ARG_FULL_BUFFER,
		EXP_ARG_DEFAULT, EXP_ARG_NULL
	    };

	    /*
	     * Match keywords exactly, otherwise they are patterns.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv[i], keywords, "keyword",
		    1 /* exact */, &index) != TCL_OK) {
		Tcl_ResetResult(interp);
		goto pattern;
	    }
	    switch ((enum keywords) index) {
	    case EXP_ARG_TIMEOUT:
		ec.use = PAT_TIMEOUT;
		break;
	    case EXP_ARG_EOF:
		ec.use = PAT_EOF;
		break;
	    case EXP_ARG_FULL_BUFFER:
		ec.use = PAT_FULLBUFFER;
		break;
	    case EXP_ARG_DEFAULT:
		ec.use = PAT_DEFAULT;
		break;
	    case EXP_ARG_NULL:
		ec.use = PAT_NULL;
		break;
	    }
pattern:
	    /* if no -i, use previous one */
	    if (!ec.i_list) {
		/* if no -i flag has occurred yet, use default */
		if (!eg->i_list) {
		    if (default_esPtr != EXP_SPAWN_ID_BAD) {
			eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
		    } else {
		        default_esPtr = expStateCurrent(interp,0,0,1);
		        if (!default_esPtr) goto error;
		        eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
		    }
a571 1
		ec.i_list = eg->i_list;
d573 3
a575 5
	    ec.i_list->ecount++;

	    /* save original pattern spec */
	    /* keywords such as "-timeout" are saved as patterns here */
	    /* useful for debugging but not otherwise used */
d577 7
a583 2
	    ec.pat = objv[i];
	    if (eg->duration == EXP_PERMANENT) Tcl_IncrRefCount(ec.pat);
d585 1
a585 7
	    i++;
	    if (i < objc) {
		ec.body = objv[i];
		if (eg->duration == EXP_PERMANENT) Tcl_IncrRefCount(ec.body);
	    } else {
		ec.body = NULL;
	    }
d587 2
a588 1
	    *(eg->ecd.cases[eg->ecd.count] = ecase_new()) = ec;
d590 1
a590 5
		/* clear out for next set */
	    ecase_clear(&ec);

	    eg->ecd.count++;
	}
d597 2
a598 2
	if (default_esPtr != EXP_SPAWN_ID_BAD) {
	    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
d600 3
a602 3
	    default_esPtr = expStateCurrent(interp,0,0,1);
	    if (!default_esPtr) goto error;
	    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
d615 8
d633 1
d637 4
a640 4
    ExpState *esPtr;		/* ExpState that matched */
    Tcl_Obj *buffer;		/* buffer that matched */
    int match;			/* # of bytes in buffer that matched */
			        /* or # of bytes in buffer at EOF */
a642 3



d646 1
a646 1
 * string_case_first --
d648 2
a649 1
 *	Find the first instance of a pattern in a string.
d652 1
a652 5
 *	Returns the pointer to the first instance of the pattern
 *	in the given string, or NULL if no match was found.
 *
 * Side effects:
 *	None.
d656 6
d663 15
a677 59
char *
string_case_first(string,pattern)	/* INTL */
    register char *string;	/* String. */
    register char *pattern;	/* Pattern, which may contain
				 * special characters. */
{
    char *s, *p;
    int offset;
    Tcl_UniChar ch1, ch2;
    
    while (*string != 0) {
	s = string;
	p = pattern;
	while (*s) {
	    s += Tcl_UtfToUniChar(s, &ch1);
	    offset = Tcl_UtfToUniChar(p, &ch2);
	    if (Tcl_UniCharToLower(ch1) != Tcl_UniCharToLower(ch2)) {
		break;
	    }
	    p += offset;
	}
	if (*p == '\0') {
	    return string;
	}
	string++;
    }
    return NULL;
}

/* like eval_cases, but handles only a single cases that needs a real */
/* string match */
/* returns EXP_X where X is MATCH, NOMATCH, FULLBUFFER, TCLERRROR */
static int
eval_case_string(interp,e,esPtr,o,last_esPtr,last_case,suffix)
Tcl_Interp *interp;
struct ecase *e;
ExpState *esPtr;
struct eval_out *o;		/* 'output' - i.e., final case of interest */
/* next two args are for debugging, when they change, reprint buffer */
ExpState **last_esPtr;
int *last_case;
char *suffix;
{
    Tcl_Obj *buffer;
    Tcl_RegExp re;
    Tcl_RegExpInfo info;
    char *str;
    int length, flags;
    int result;

    buffer = esPtr->buffer;
    str = Tcl_GetStringFromObj(buffer, &length);

    /* if ExpState or case changed, redisplay debug-buffer */
    if ((esPtr != *last_esPtr) || e->Case != *last_case) {
	expDiagLog("\r\nexpect%s: does \"",suffix);
	expDiagLogU(expPrintify(str));
	expDiagLog("\" (spawn_id %s) match %s ",esPtr->name,pattern_style[e->use]);
	*last_esPtr = esPtr;
d680 1
a680 1

d682 9
a690 5
	expDiagLog("\"");
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
	expDiagLog("\"? ");
	if (e->Case == CASE_NORM) {
	    flags = TCL_REG_ADVANCED;
d692 5
a696 1
	    flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
d698 6
a703 7
		    
	re = Tcl_GetRegExpFromObj(interp, e->pat, flags);

	result = Tcl_RegExpExecObj(interp, re, buffer, 0 /* offset */,
		-1 /* nmatches */, 0 /* eflags */);
	if (result > 0) {

d705 1
a705 8

	    /*
	     * Retrieve the byte offset of the end of the
	     * matched string.  
	     */

	    Tcl_RegExpGetInfo(re, &info);
	    o->match = Tcl_UtfAtIndex(str, info.matches[0].end) - str;
d707 2
a708 2
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
d710 1
a710 26
	} else if (result == 0) {
	    expDiagLogU(no);
	} else { /* result < 0 */
	    return(EXP_TCLERROR);
	}
    } else if (e->use == PAT_GLOB) {
	int match; /* # of bytes that matched */

	expDiagLog("\"");
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
	expDiagLog("\"? ");
	if (buffer) {
	    match = Exp_StringCaseMatch(Tcl_GetString(buffer),
		    Tcl_GetString(e->pat),
		    (e->Case == CASE_NORM) ? 0 : 1,
		    &e->simple_start);
	    if (match != -1) {
		o->e = e;
		o->match = match;
		o->buffer = buffer;
		o->esPtr = esPtr;
		expDiagLogU(yes);
		return(EXP_MATCH);
	    }
	}
	expDiagLogU(no);
d712 2
a713 13
	int patLength;
	char *pat = Tcl_GetStringFromObj(e->pat, &patLength);
	char *p;

	if (e->Case == CASE_NORM) {
	    p = strstr(str, pat);
	} else {
	    p = string_case_first(str, pat);
	}	    

	expDiagLog("\"");
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
	expDiagLog("\"? ");
d715 1
a715 1
	    e->simple_start = p - str;
d717 1
a717 1
	    o->match = patLength;
d719 2
a720 2
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
d722 1
a722 1
	} else expDiagLogU(no);
d724 17
a740 17
	char *p;
	expDiagLogU("null? ");
	p = Tcl_UtfFindFirst(str, 0);

	if (p) {
	    o->e = e;
	    o->match = p-str;
	    o->buffer = buffer;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return EXP_MATCH;
	}
	expDiagLogU(no);
    } else if ((Tcl_GetCharLength(esPtr->buffer) == esPtr->msize)
	    && (length > 0)) {
	expDiagLogU(Tcl_GetString(e->pat));
	expDiagLogU("? ");
d742 4
a745 4
	o->match = length;
	o->buffer = esPtr->buffer;
	o->esPtr = esPtr;
	expDiagLogU(yes);
d751 15
a765 2
/* sets o.e if successfully finds a matching pattern, eof, timeout or deflt */
/* returns original status arg or EXP_TCLERROR */
d767 12
a778 12
eval_cases(interp,eg,esPtr,o,last_esPtr,last_case,status,esPtrs,mcount,suffix)
Tcl_Interp *interp;
struct exp_cmd_descriptor *eg;
ExpState *esPtr;
struct eval_out *o;		/* 'output' - i.e., final case of interest */
/* next two args are for debugging, when they change, reprint buffer */
ExpState **last_esPtr;
int *last_case;
int status;
ExpState *(esPtrs[]);
int mcount;
char *suffix;
d781 1
a781 1
    ExpState *em;   /* ExpState of ecase */
d783 1
a783 1

d785 1
a785 1

d799 1
a799 1
		struct exp_state_list *slPtr;
d801 3
a803 3
		for (slPtr=e->i_list->state_list; slPtr ;slPtr=slPtr->next) {
		    em = slPtr->esPtr;
		    if (expStateAnyIs(em) || em == esPtr) {
d812 1
a812 1

d815 1
a815 1

d819 1
a819 1
	struct exp_state_list *slPtr;
d824 2
a825 2
		e->use == PAT_DEFAULT ||
		e->use == PAT_EOF) continue;
d827 5
a831 5
	for (slPtr = e->i_list->state_list; slPtr; slPtr = slPtr->next) {
	    em = slPtr->esPtr;
	    /* if em == EXP_SPAWN_ID_ANY, then user is explicitly asking */
	    /* every case to be checked against every ExpState */
	    if (expStateAnyIs(em)) {
d834 1
a834 2
		    status = eval_case_string(interp,e,esPtrs[j],o,
			    last_esPtr,last_case,suffix);
d839 1
a839 1
		if (em != esPtr) continue;
d841 1
a841 1
		status = eval_case_string(interp,e,esPtr,o,last_esPtr,last_case,suffix);
d851 3
a853 3
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d855 1
a855 1
	int i;
d857 21
a877 22
	/* delete every ecase dependent on it */
	for (i=0;i<ecmd->ecd.count;) {
		struct ecase *e = ecmd->ecd.cases[i];
		if (e->i_list == exp_i) {
			free_ecase(interp,e,0);

			/* shift remaining elements down */
			/* but only if there are any left */
			if (i+1 != ecmd->ecd.count) {
				memcpy(&ecmd->ecd.cases[i],
				       &ecmd->ecd.cases[i+1],
					((ecmd->ecd.count - i) - 1) * 
					sizeof(struct exp_cmd_descriptor *));
			}
			ecmd->ecd.count--;
			if (0 == ecmd->ecd.count) {
				ckfree((char *)ecmd->ecd.cases);
				ecmd->ecd.cases = 0;
			}
		} else {
			i++;
		}
d879 1
d885 3
a887 3
Tcl_Interp *interp;
struct exp_i **ei;	/* list to remove from */
struct exp_i *exp_i;	/* element to remove */
d889 7
a895 8
	/* since it's in middle of list, free exp_i by hand */
	for (;*ei; ei = &(*ei)->next) {
		if (*ei == exp_i) {
			*ei = exp_i->next;
			exp_i->next = 0;
			exp_free_i(interp,exp_i,exp_indirect_update2);
			break;
		}
d897 1
d903 3
a905 3
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d907 2
a908 2
	ecases_remove_by_expi(interp,ecmd,exp_i);
	exp_i_remove(interp,&ecmd->i_list,exp_i);
d913 5
a917 5
ecmd_remove_state(interp,ecmd,esPtr,direct)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
ExpState *esPtr;
int direct;
d920 1
a920 1
    struct exp_state_list **slPtr;
d927 5
a931 5
	for (slPtr = &exp_i->state_list;*slPtr;) {
	    if (esPtr == ((*slPtr)->esPtr)) {
		struct exp_state_list *tmp = *slPtr;
		*slPtr = (*slPtr)->next;
		exp_free_state_single(tmp);
d934 5
a938 5
		if ((ecmd->cmdtype == EXP_CMD_BG) && (expStateAnyIs(esPtr))) {
		    esPtr->bg_ecount--;
		    if (esPtr->bg_ecount == 0) {
			exp_disarm_background_channelhandler(esPtr);
			esPtr->bg_interp = 0;
d941 1
a941 1
		
d944 1
a944 1
	    slPtr = &(*slPtr)->next;
d947 1
a947 1
	/* if left with no ExpStates (and is direct), get rid of it */
d949 1
a949 1
	if (exp_i->direct == EXP_DIRECT && !exp_i->state_list) {
d955 1
a955 1
/* this is called from exp_close to clean up the ExpState */
d957 3
a959 3
exp_ecmd_remove_state_direct_and_indirect(interp,esPtr)
Tcl_Interp *interp;
ExpState *esPtr;
d961 3
a963 3
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_BEFORE],esPtr,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_AFTER],esPtr,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_BG],esPtr,EXP_DIRECT|EXP_INDIRECT);
d965 2
a966 2
	/* force it - explanation in exp_tk.c where this func is defined */
	exp_disarm_background_channelhandler_force(esPtr);
d969 1
a969 1
/* arm a list of background ExpState's */
d971 3
a973 3
state_list_arm(interp,slPtr)
Tcl_Interp *interp;
struct exp_state_list *slPtr;
d975 2
d978 3
a980 3
    for (;slPtr;slPtr=slPtr->next) {
	ExpState *esPtr = slPtr->esPtr;    
	if (expStateAnyIs(esPtr)) continue;
d982 3
a984 3
	if (esPtr->bg_ecount == 0) {
	    exp_arm_background_channelhandler(esPtr);
	    esPtr->bg_interp = interp;
d986 1
a986 1
	esPtr->bg_ecount++;
d990 1
a990 1
/* return TRUE if this ecase is used by this fd */
d992 3
a994 3
exp_i_uses_state(exp_i,esPtr)
struct exp_i *exp_i;
ExpState *esPtr;
d996 1
a996 1
	struct exp_state_list *fdp;
d998 4
a1001 4
	for (fdp = exp_i->state_list;fdp;fdp=fdp->next) {
		if (fdp->esPtr == esPtr) return 1;
	}
	return 0;
d1006 2
a1007 2
Tcl_Interp *interp;
struct ecase *ec;
d1009 10
a1018 9
	if (!ec->transfer) Tcl_AppendElement(interp,"-notransfer");
	if (ec->indices) Tcl_AppendElement(interp,"-indices");
	if (!ec->Case) Tcl_AppendElement(interp,"-nocase");

	if (ec->use == PAT_RE) Tcl_AppendElement(interp,"-re");
	else if (ec->use == PAT_GLOB) Tcl_AppendElement(interp,"-gl");
	else if (ec->use == PAT_EXACT) Tcl_AppendElement(interp,"-ex");
	Tcl_AppendElement(interp,Tcl_GetString(ec->pat));
	Tcl_AppendElement(interp,ec->body?Tcl_GetString(ec->body):"");
d1024 3
a1026 3
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d1028 4
a1031 5
	int i;
	for (i=0;i<ecmd->ecd.count;i++) {
		if (ecmd->ecd.cases[i]->i_list == exp_i) {
			ecase_append(interp,ecmd->ecd.cases[i]);
		}
d1033 1
d1038 2
a1039 2
Tcl_Interp *interp;
struct exp_i *exp_i;
d1041 5
a1045 5
	Tcl_AppendElement(interp,"-i");
	if (exp_i->direct == EXP_INDIRECT) {
		Tcl_AppendElement(interp,exp_i->variable);
	} else {
		struct exp_state_list *fdp;
d1047 3
a1049 9
		/* if more than one element, add braces */
		if (exp_i->state_list->next)
			Tcl_AppendResult(interp," {",(char *)0);

		for (fdp = exp_i->state_list;fdp;fdp=fdp->next) {
			char buf[10];	/* big enough for a small int */
			sprintf(buf,"%d",fdp->esPtr);
			Tcl_AppendElement(interp,buf);
		}
d1051 4
a1054 2
		if (exp_i->state_list->next)
			Tcl_AppendResult(interp,"} ",(char *)0);
d1056 4
d1062 13
a1074 1
/* return current setting of the permanent expect_before/after/bg */
d1076 5
a1080 5
expect_info(interp,ecmd,objc,objv)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d1085 10
a1094 28
    char *iflag = 0;
    int all = FALSE;	/* report on all fds */
    ExpState *esPtr = 0;

    static char *flags[] = {"-i", "-all", "-noindirect", (char *)0};
    enum flags {EXP_ARG_I, EXP_ARG_ALL, EXP_ARG_NOINDIRECT};

    /* start with 2 to skip over "cmdname -info" */
    for (i = 2;i<objc;i++) {
	/*
	 * Allow abbreviations of switches and report an error if we
	 * get an invalid switch.
	 */

	int index;
	if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum flags) index) {
	case EXP_ARG_I:
	    i++;
	    if (i >= objc) {
		Tcl_WrongNumArgs(interp, 1, objv,"-i spawn_id");
		return TCL_ERROR;
	    }
	    break;
	case EXP_ARG_ALL:
d1096 2
a1097 2
	    break;
	case EXP_ARG_NOINDIRECT:
d1099 4
a1102 1
	    break;
d1120 4
a1123 3
    if (!iflag) {
	if (!(esPtr = expStateCurrent(interp,0,0,0))) {
	    return TCL_ERROR;
d1125 10
a1134 7
    } else if (!(esPtr = expStateFromChannelName(interp,iflag,0,0,0,"dummy"))) {
	/* not a valid ExpState so assume it is an indirect variable */
	Tcl_ResetResult(interp);
	for (i=0;i<ecmd->ecd.count;i++) {
	    if (ecmd->ecd.cases[i]->i_list->direct == EXP_INDIRECT &&
		    streq(ecmd->ecd.cases[i]->i_list->variable,iflag)) {
		ecase_append(interp,ecmd->ecd.cases[i]);
d1136 1
a1137 1
	return TCL_OK;
d1139 1
a1139 1
    
d1143 1
a1143 1
	if (!exp_i_uses_state(exp_i,esPtr)) continue;
d1150 1
a1150 1
/* Exp_ExpectGlobalObjCmd is invoked to process expect_before/after/background */
d1153 5
a1157 5
Exp_ExpectGlobalObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d1161 1
a1161 1
    struct exp_state_list *slPtr;   /* temp for interating over state_list */
d1164 1
d1168 7
a1174 7
    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d1177 3
a1179 3
    if (objc > 1 && (Tcl_GetString(objv[1])[0] == '-')) {
	if (exp_flageq("info",Tcl_GetString(objv[1])+1,4)) {
	    return(expect_info(interp,ecmd,objc,objv));
d1183 1
d1186 1
a1186 2
    if (TCL_ERROR == parse_expect_args(interp,&eg,EXP_SPAWN_ID_BAD,
	    objc,objv)) {
d1200 2
a1201 2
	for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
	    ExpState *esPtr = slPtr->esPtr;
d1204 2
a1205 2
	    if (!expStateAnyIs(esPtr)) {
		if (!expStateCheck(interp,esPtr,1,1,"expect")) {
d1210 1
a1210 1
	    
d1212 1
a1212 1
	    ecmd_remove_state(interp,ecmd,esPtr,EXP_DIRECT);
d1231 1
a1231 1
		    (!streq((*old_i)->variable,exp_i->variable))) {
d1237 1
a1237 1
	    
d1283 1
a1283 1
		state_list_arm(interp,exp_i->state_list);
d1297 1
a1297 1
	int start_index; /* where to add new ecases in old list */
d1309 1
a1309 1
		eg.ecd.count*sizeof(struct ecase *));
d1319 1
a1319 1
    *eip = eg.i_list;	/* connect new list to end of current list */
d1321 1
a1321 1
  cleanup:
d1338 1
a1338 1
	exp_background_channelhandlers_run_all();
d1344 16
a1359 1
/* adjusts file according to user's size request */
d1361 2
a1362 2
expAdjust(esPtr)
ExpState *esPtr;
a1364 6
    int length;
    Tcl_Obj *newObj;
    char *string;
    int excessBytes;
    char *excessGuess;
    char *p;
d1367 35
a1401 208
     * Resize buffer to user's request * 2 + 1.
     * x2: in case the match straddles two bufferfuls.
     * +1: for trailing null.
     */

    new_msize = esPtr->umsize*2 + 1;

    if (new_msize != esPtr->msize) {
	string = Tcl_GetStringFromObj(esPtr->buffer, &length);
	if (length > new_msize) {
	    /*
	     * too much data, forget about data at beginning of buffer
	     */

	    excessBytes = length - new_msize;	/* initial guess */

	    /*
	     * Alas, string + excessBytes may be in the middle of a UTF char.
	     * Find out for sure.
	     */
	    excessGuess = string + excessBytes;
	    for (p=string;;p=Tcl_UtfNext(p)) {
		if (p >= excessGuess) break;
	    }

	    /* now we can calculate a valid # of excess bytes */
	    excessBytes = p - string;
	    newObj = Tcl_NewStringObj(string + excessBytes,length - excessBytes);
	} else {
	    /*
	     * too little data
	     */

	    /* first copy what's there */
	    newObj = Tcl_NewStringObj(string,length);

	    /*
	     * Force object to allocate a buffer at least new_msize bytes long,
	     * then reset correct string length.
	     */

	    Tcl_SetObjLength(newObj,new_msize);
	    Tcl_SetObjLength(newObj,length);
	}
	Tcl_IncrRefCount(newObj);
	Tcl_DecrRefCount(esPtr->buffer);
	esPtr->buffer = newObj;

	esPtr->key = expect_key++;
	esPtr->msize = new_msize;
    }
}

#if OBSOLETE
/* Strip parity */
static void
expParityStrip(obj,offsetBytes)
    Tcl_Obj *obj;
    int offsetBytes;
{
    char *p, ch;
    
    int changed = FALSE;
    
    for (p = Tcl_GetString(obj) + offsetBytes;*p;p++) {
	ch = *p & 0x7f;
	if (ch != *p) changed = TRUE;
	else *p &= 0x7f;
    }

    if (changed) {
	/* invalidate the unicode rep */
	if (obj->typePtr->freeIntRepProc) {
	    obj->typePtr->freeIntRepProc(obj);
	}
    }
}
#endif /*OBSOLETE*/

/* This function is only used when debugging.  It checks when a string's
   internal UTF is sane and whether an offset into the string appears to
   be at a UTF boundary.
*/
static void
expValid(obj,offset)
     Tcl_Obj *obj;
     int offset;
{
  char *s, *end;
  int len;

  s = Tcl_GetStringFromObj(obj,&len);

  if (offset > len) {
    printf("offset (%d) > length (%d)\n",offset,len);
    fflush(stdout);
    abort();
  }

  /* first test for null terminator */
  end = s + len;
  if (*end != '\0') {
    printf("obj lacks null terminator\n");
    fflush(stdout);
    abort();
  }

  /* check for valid UTF sequence */
  while (*s) {
    Tcl_UniChar uc;

    s += Tcl_UtfToUniChar(s,&uc);
    if (s > end) {
      printf("UTF out of sync with terminator\n");
      fflush(stdout);
      abort();
    }
  }
  s += offset;
  while (*s) {
    Tcl_UniChar uc;

    s += Tcl_UtfToUniChar(s,&uc);
    if (s > end) {
      printf("UTF from offset out of sync with terminator\n");
      fflush(stdout);
      abort();
    }
  }
}

/* Strip UTF-encoded nulls from object, beginning at offset */
static int
expNullStrip(obj,offsetBytes)
    Tcl_Obj *obj;
    int offsetBytes;
{
    char *src, *src2;
    char *dest;
    Tcl_UniChar uc;
    int newsize;       /* size of obj after all nulls removed */

    src2 = src = dest = Tcl_GetString(obj) + offsetBytes;

    while (*src) {
	src += Tcl_UtfToUniChar(src,&uc);
	if (uc != 0) {
	    dest += Tcl_UniCharToUtf(uc,dest);
	}
    }
    newsize = offsetBytes + (dest - src2);
    Tcl_SetObjLength(obj,newsize);
    return newsize;
}

/* returns # of bytes read or (non-positive) error of form EXP_XXX */
/* returns 0 for end of file */
/* If timeout is non-zero, set an alarm before doing the read, else assume */
/* the read will complete immediately. */
/*ARGSUSED*/
static int
expIRead(interp,esPtr,timeout,save_flags) /* INTL */
Tcl_Interp *interp;
ExpState *esPtr;
int timeout;
int save_flags;
{
    int cc = EXP_TIMEOUT;
    int size = expSizeGet(esPtr);

    if (size + TCL_UTF_MAX >= esPtr->msize) 
	exp_buffer_shuffle(interp,esPtr,save_flags,EXPECT_OUT,"expect");
    size = expSizeGet(esPtr);

#ifdef SIMPLE_EVENT
 restart:

    alarm_fired = FALSE;

    if (timeout > -1) {
	signal(SIGALRM,sigalarm_handler);
	alarm((timeout > 0)?timeout:1);
    }
#endif

    
    cc = Tcl_ReadChars(esPtr->channel,
	    esPtr->buffer,
	    esPtr->msize - (size / TCL_UTF_MAX),
	    1 /* append */);
    i_read_errno = errno;

#ifdef SIMPLE_EVENT
    alarm(0);

    if (cc == -1) {
	/* check if alarm went off */
	if (i_read_errno == EINTR) {
	    if (alarm_fired) {
		return EXP_TIMEOUT;
	    } else {
		if (Tcl_AsyncReady()) {
		    int rc = Tcl_AsyncInvoke(interp,TCL_OK);
		    if (rc != TCL_OK) return(exp_tcl2_returnvalue(rc));
		}
		goto restart;
	    }
	}
a1402 2
#endif
    return cc;	
d1406 19
a1424 2
 * expRead() does the logical equivalent of a read() for the expect command.
 * This includes figuring out which descriptor should be read from.
d1426 3
a1428 6
 * The result of the read() is left in a spawn_id's buffer rather than
 * explicitly passing it back.  Note that if someone else has modified a buffer
 * either before or while this expect is running (i.e., if we or some event has
 * called Tcl_Eval which did another expect/interact), expRead will also call
 * this a successful read (for the purposes if needing to pattern match against
 * it).
a1430 3
/* if it returns a negative number, it corresponds to a EXP_XXX result */
/* if it returns a non-negative number, it means there is data */
/* (0 means nothing new was actually read, but it should be looked at again) */
d1432 11
a1442 7
expRead(interp,esPtrs,esPtrsMax,esPtrOut,timeout,key)
Tcl_Interp *interp;
ExpState *(esPtrs[]);		/* If 0, then esPtrOut already known and set */
int esPtrsMax;			/* number of esPtrs */
ExpState **esPtrOut;		/* Out variable to leave new ExpState. */
int timeout;
int key;
d1444 1
a1444 3
    ExpState *esPtr;

    int size;
d1448 5
a1452 5
			/* whether to show user locally or globally */

    if (esPtrs == 0) {
	/* we already know the ExpState, just find out what happened */
	cc = exp_get_next_event_info(interp,*esPtrOut);
d1455 1
a1455 1
	cc = exp_get_next_event(interp,esPtrs,esPtrsMax,esPtrOut,timeout,key);
d1458 1
a1458 2
    esPtr = *esPtrOut;

d1461 3
a1463 2
	cc = expIRead(interp,esPtr,timeout,tcl_set_flags);
	
d1470 17
a1486 6
	    /* successfully read data */
	} else {
	    /* failed to read data - some sort of error was encountered such as
	     * an interrupt with that forced an error return
	     */
	}
d1488 1
d1493 1
a1493 1

d1506 3
a1508 3
		exp_error(interp,"i_read(spawn_id fd=%d): %s",esPtr->fdin,
			Tcl_PosixError(interp));
		exp_close(interp,esPtr);
d1514 1
a1514 1

d1520 4
a1523 7

    /*
     * update display
     */

    size = expSizeGet(esPtr);
    if (size) write_count = size - esPtr->printed;
d1527 3
d1531 2
a1532 3
	 * Show chars to user if they've requested it, UNLESS they're seeing it
	 * already because they're typing it and tty driver is echoing it.
	 * Also send to Diag and Log if appropriate.
d1534 24
a1557 9
	expLogInteractionU(esPtr,Tcl_GetString(esPtr->buffer) + esPtr->printed);
	    
	/*
	 * strip nulls from input, since there is no way for Tcl to deal with
	 * such strings.  Doing it here lets them be sent to the screen, just
	 * in case they are involved in formatting operations
	 */
	if (esPtr->rm_nulls) size = expNullStrip(esPtr->buffer,esPtr->printed);
	esPtr->printed = size; /* count'm even if not logging */
d1565 6
a1570 6
exp_buffer_shuffle(interp,esPtr,save_flags,array_name,caller_name) /* INTL */
Tcl_Interp *interp;
ExpState *esPtr;
int save_flags;
char *array_name;
char *caller_name;
d1572 6
a1577 6
    char *str;
    char *middleGuess;
    char *p;
    int length, newlen;
    int skiplen;
    char lostByte;
d1583 21
a1603 62
    expDiagLog("%s: set %s(spawn_id) \"%s\"\r\n",
	    caller_name,array_name,esPtr->name);
    Tcl_SetVar2(interp,array_name,"spawn_id",esPtr->name,save_flags);

    /*
     * The internal storage buffer object should only be referred
     * to by the channel that uses it.  We always copy the contents
     * out of the object before passing the data to anyone outside
     * of these routines.  This ensures that the object always has
     * a refcount of 1 so we can safely modify the contents in place.
     */

    if (Tcl_IsShared(esPtr->buffer)) {
	panic("exp_buffer_shuffle called with shared buffer object");
    }

    str = Tcl_GetStringFromObj(esPtr->buffer,&length);

    /* guess at the middle */
    middleGuess = str + length/2;

    /* crawl our way into the middle of the string
     * to make sure we are at a UTF char boundary
     */
    for (p=str;*p;p = Tcl_UtfNext(p)) {
	if (p > middleGuess) break;   /* ok, that's enough */
    }

    /*
     * p is now at the beginning of a UTF char in the middle of the string
     */

    /*
     * before doing move, show user data we are discarding
     */
    skiplen = p-str;
    lostByte = *p;
    /* temporarily stick null in middle of string */
    Tcl_SetObjLength(esPtr->buffer,skiplen);

    expDiagLog("%s: set %s(buffer) \"",caller_name,array_name);
    expDiagLogU(expPrintify(Tcl_GetString(esPtr->buffer)));
    expDiagLogU("\"\r\n");
    Tcl_SetVar2(interp,array_name,"buffer",Tcl_GetString(esPtr->buffer),
	    save_flags);

    /*
     * restore damage
     */
    *p = lostByte;

    /*
     * move 2nd half of string down to 1st half
     */

    newlen = length - skiplen;
    memmove(str,p, newlen);

    Tcl_SetObjLength(esPtr->buffer,newlen);

    esPtr->printed -= skiplen;
    if (esPtr->printed < 0) esPtr->printed = 0;
a1607 3
#ifdef _MSC_VER
#   pragma warning(disable: 4715)
#endif
d1610 1
a1610 1
int x;
d1612 9
a1620 9
	switch (x) {
	case TCL_ERROR:			return EXP_TCLERROR;
	case TCL_RETURN:		return EXP_TCLRET;
	case TCL_BREAK:			return EXP_TCLBRK;
	case TCL_CONTINUE:		return EXP_TCLCNT;
	case EXP_CONTINUE:		return EXP_TCLCNTEXP;
	case EXP_CONTINUE_TIMER:	return EXP_TCLCNTTIMER;
	case EXP_TCL_RETURN:		return EXP_TCLRETTCL;
	}
d1626 38
a1663 1
int x;
d1665 14
a1678 9
	switch (x) {
	case EXP_TCLERROR:		return TCL_ERROR;
	case EXP_TCLRET:		return TCL_RETURN;
	case EXP_TCLBRK:		return TCL_BREAK;
	case EXP_TCLCNT:		return TCL_CONTINUE;
	case EXP_TCLCNTEXP:		return EXP_CONTINUE;
	case EXP_TCLCNTTIMER:		return EXP_CONTINUE_TIMER;
	case EXP_TCLRETTCL:		return EXP_TCL_RETURN;
	}
a1679 3
#ifdef _MSC_VER
#   pragma warning(default: 4715)
#endif
d1681 16
a1696 5
/* variables predefined by expect are retrieved using this routine
which looks in the global space if they are not in the local space.
This allows the user to localize them if desired, and also to
avoid having to put "global" in procedure definitions.
*/
d1699 2
a1700 2
Tcl_Interp *interp;
char *var;
d1709 13
d1724 1
a1724 1
Tcl_Interp *interp;
d1726 1
a1726 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d1730 1
a1730 1
	tsdPtr->timeout = atoi(t);
d1732 1
a1732 1
    return(tsdPtr->timeout);
d1736 1
a1736 1
arg) */
d1738 3
a1740 3
update_expect_states(i_list,i_union)
struct exp_i *i_list;
struct exp_state_list **i_union;
d1746 1
a1746 1
	struct exp_state_list *slPtr;
d1748 6
a1753 4
	/* for each esPtr in the i_list */
	for (slPtr=p->state_list;slPtr;slPtr=slPtr->next) {
	    struct exp_state_list *tmpslPtr;
	    struct exp_state_list *u;
a1754 2
	    if (expStateAnyIs(slPtr->esPtr)) continue;
	    
d1756 2
a1757 2
	    for (u = *i_union;u;u=u->next) {
		if (slPtr->esPtr == u->esPtr) goto found;
d1760 4
a1763 4
	    tmpslPtr = exp_new_state(slPtr->esPtr);
	    tmpslPtr->next = *i_union;
	    *i_union = tmpslPtr;
	    found:;
a1768 3
#ifdef _MSC_VER
#   pragma warning(disable: 4715)
#endif
d1771 1
a1771 1
int cmdtype;
d1773 6
a1778 6
	switch (cmdtype) {
	case EXP_CMD_FG: return("expect");
	case EXP_CMD_BG: return("expect_background");
	case EXP_CMD_BEFORE: return("expect_before");
	case EXP_CMD_AFTER: return("expect_after");
	}
d1780 1
a1780 1
	return("unknown expect command");
a1782 3
#ifdef _MSC_VER
#   pragma warning(default: 4715)
#endif
d1784 14
a1797 2
/* exp_indirect_update2 is called back via Tcl's trace handler whenever */
/* an indirect spawn id list is changed */
d1801 5
a1805 5
ClientData clientData;
Tcl_Interp *interp;	/* Interpreter containing variable. */
char *name1;		/* Name of variable. */
char *name2;		/* Second part of variable name. */
int flags;		/* Information about what happened. */
d1807 10
a1816 1
	char *msg;
d1818 12
a1829 8
	struct exp_i *exp_i = (struct exp_i *)clientData;
	exp_configure_count++;
	msg = exp_indirect_update1(interp,&exp_cmds[exp_i->cmdtype],exp_i);

	exp_background_channelhandlers_run_all();

	return msg;
}
d1833 3
a1835 3
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d1837 1
a1837 1
	struct exp_state_list *slPtr;	/* temp for interating over state_list */
d1839 3
a1841 3
	/*
	 * disarm any ExpState's that lose all their ecases
	 */
d1843 4
a1846 57
	if (ecmd->cmdtype == EXP_CMD_BG) {
		/* clean up each spawn id used by this exp_i */
		for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
			ExpState *esPtr = slPtr->esPtr;

			if (expStateAnyIs(esPtr)) continue;

			/* silently skip closed or preposterous fds */
			/* since we're just disabling them anyway */
			/* preposterous fds will have been reported */
			/* by code in next section already */
			if (!expStateCheck(interp,slPtr->esPtr,1,0,"")) continue;

			/* check before decrementing, ecount may not be */
			/* positive if update is called before ecount is */
			/* properly synchronized */
			if (esPtr->bg_ecount > 0) {
				esPtr->bg_ecount--;
			}
			if (esPtr->bg_ecount == 0) {
				exp_disarm_background_channelhandler(esPtr);
				esPtr->bg_interp = 0;
			}
		}
	}

	/*
	 * reread indirect variable
	 */

	exp_i_update(interp,exp_i);

	/*
	 * check validity of all fd's in variable
	 */

	for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
	    /* validate all input descriptors */

	    if (expStateAnyIs(slPtr->esPtr)) continue;

	    if (!expStateCheck(interp,slPtr->esPtr,1,1,
		    exp_cmdtype_printable(ecmd->cmdtype))) {
		static char msg[200];
		sprintf(msg,"%s from indirect variable (%s)",
			interp->result,exp_i->variable);
		return msg;
	    }
	}

	/* for each spawn id in list, arm if necessary */
	if (ecmd->cmdtype == EXP_CMD_BG) {
		state_list_arm(interp,exp_i->state_list);
	}

	return (char *)0;
}
d1848 1
a1848 17
int
expMatchProcess(interp, eo, cc, bg, detail)
    Tcl_Interp *interp;
    struct eval_out *eo;	/* final case of interest */
    int cc;			/* EOF, TIMEOUT, etc... */
    int bg;			/* 1 if called from background handler, */
				/* else 0 */
    char *detail;
{
    ExpState *esPtr = 0;
    Tcl_Obj *body = 0;
    Tcl_Obj *buffer;
    struct ecase *e = 0;	/* points to current ecase */
    int match = -1;		/* characters matched */
    char match_char;	/* place to hold char temporarily */
    /* uprooted by a NULL */
    int result = TCL_OK;
d1850 5
a1854 29
#define out(indexName, value) \
 expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,indexName); \
 expDiagLogU(expPrintify(value)); \
 expDiagLogU("\"\r\n"); \
 Tcl_SetVar2(interp, EXPECT_OUT,indexName,value,(bg ? TCL_GLOBAL_ONLY : 0));

    if (eo->e) {
	e = eo->e;
	body = e->body;
	if (cc != EXP_TIMEOUT) {
	    esPtr = eo->esPtr;
	    match = eo->match;
	    buffer = eo->buffer;
	}
    } else if (cc == EXP_EOF) {
	/* read an eof but no user-supplied case */
	esPtr = eo->esPtr;
	match = eo->match;
	buffer = eo->buffer;
    }			

    if (match >= 0) {
	char name[20], value[20];
	int i;

	if (e && e->use == PAT_RE) {
	    Tcl_RegExp re;
	    int flags;
	    Tcl_RegExpInfo info;
d1856 4
a1859 4
	    if (e->Case == CASE_NORM) {
		flags = TCL_REG_ADVANCED;
	    } else {
		flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
d1861 2
a1862 11
		    
	    re = Tcl_GetRegExpFromObj(interp, e->pat, flags);
	    Tcl_RegExpGetInfo(re, &info);

	    for (i=0;i<=info.nsubs;i++) {
		int start, end;
		Tcl_Obj *val;

		start = info.matches[i].start;
		end = info.matches[i].end-1;
		if (start == -1) continue;
d1864 3
a1866 5
		if (e->indices) {
		    /* start index */
		    sprintf(name,"%d,start",i);
		    sprintf(value,"%d",start);
		    out(name,value);
d1868 1
a1868 5
		    /* end index */
		    sprintf(name,"%d,end",i);
		    sprintf(value,"%d",end);
		    out(name,value);
		}
d1870 3
a1872 10
				/* string itself */
		sprintf(name,"%d,string",i);
		val = Tcl_GetRange(buffer, start, end);
		expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,name);
		expDiagLogU(expPrintifyObj(val));
		expDiagLogU("\"\r\n");
		Tcl_SetVar2Ex(interp,EXPECT_OUT,name,val,(bg ? TCL_GLOBAL_ONLY : 0));
	    }
	} else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
	    char *str;
d1874 3
a1876 4
	    if (e->indices) {
		/* start index */
		sprintf(value,"%d",e->simple_start);
		out("0,start",value);
d1878 8
a1885 4
		/* end index */
		sprintf(value,"%d",e->simple_start + match - 1);
		out("0,end",value);
	    }
d1887 3
a1889 21
	    /* string itself */
	    str = Tcl_GetString(esPtr->buffer) + e->simple_start;
	    /* temporarily null-terminate in middle */
	    match_char = str[match];
	    str[match] = 0;
	    out("0,string",str);
	    str[match] = match_char;

				/* redefine length of string that */
				/* matched for later extraction */
	    match += e->simple_start;
	} else if (e && e->use == PAT_NULL && e->indices) {
				/* start index */
	    sprintf(value,"%d",match-1);
	    out("0,start",value);
				/* end index */
	    sprintf(value,"%d",match-1);
	    out("0,end",value);
	} else if (e && e->use == PAT_FULLBUFFER) {
	    expDiagLogU("expect_background: full buffer\r\n");
	}
d1892 30
a1921 26
    /* this is broken out of (match > 0) (above) since it can */
    /* that an EOF occurred with match == 0 */
    if (eo->esPtr) {
	char *str;
	int length;

	out("spawn_id",esPtr->name);

	str = Tcl_GetStringFromObj(esPtr->buffer, &length);
	/* Save buf[0..match] */
	/* temporarily null-terminate string in middle */
	match_char = str[match];
	str[match] = 0;
	out("buffer",str);
	/* remove middle-null-terminator */
	str[match] = match_char;

	/* "!e" means no case matched - transfer by default */
	if (!e || e->transfer) {
	    /* delete matched chars from input buffer */
	    esPtr->printed -= match;
	    if (length != 0) {
		memmove(str,str+match,length-match);
	    }
	    Tcl_SetObjLength(esPtr->buffer, length-match);
	}
d1923 2
a1924 7
	if (cc == EXP_EOF) {
	    /* exp_close() deletes all background bodies */
	    /* so save eof body temporarily */
	    if (body) Tcl_IncrRefCount(body);
	    exp_close(interp,esPtr);
	}
    }
d1926 3
a1928 6
    if (body) {
	if (!bg) {
	    result = Tcl_EvalObjEx(interp,body,0);
	} else {
	    result = Tcl_EvalObjEx(interp,body,TCL_EVAL_GLOBAL);
	    if (result != TCL_OK) Tcl_BackgroundError(interp);
d1930 1
a1930 1
	if (cc == EXP_EOF) Tcl_DecrRefCount(body);
a1931 1
    return result;
d1934 15
a1948 1
/* this function is called from the background when input arrives */
d1951 3
a1953 3
exp_background_channelhandler(clientData,mask) /* INTL */
ClientData clientData;
int mask;
a1954 1
    ExpState *esPtr;
d1956 6
a1961 2
    int cc;			/* number of bytes returned in a single read */
				/* or negative EXP_whatever */
d1963 2
a1964 2
    ExpState *last_esPtr;	/* for differentiating when multiple esPtrs */
				/* to print out better debugging messages */
d1966 1
a1966 1

d1968 3
a1970 3
    esPtr = (ExpState *)clientData;
    interp = esPtr->bg_interp;

d1972 2
a1973 2
    exp_block_background_channelhandler(esPtr);

d1975 3
a1977 2
     * if mask == 0, then we've been called because the patterns changed not
     * because the waiting data has changed, so don't actually do any I/O
d1979 1
d1983 1
a1983 3
	esPtr->notifiedMask = mask;
	esPtr->notified = FALSE;
	cc = expRead(interp,(ExpState **)0,0,&esPtr,EXP_TIME_INFINITY,0);
d1985 2
a1986 2

do_more_data:
d1988 1
a1988 1
    eo.esPtr = 0;		/* no final file selected yet */
d1990 1
a1990 1

d1992 2
a1993 2
    last_esPtr = 0;

d1996 1
a1996 1
    } else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
d1998 6
a2003 7
	/* 
	 * if we were going to do this right, we should differentiate between
	 * things like HP ioctl-open-traps that fall out here and should
	 * rightfully be ignored and real errors that should be reported.  Come
	 * to think of it, the only errors will come from HP ioctl handshake
	 * botches anyway.
	 */
d2007 1
a2007 1

d2011 1
a2011 1

d2013 1
a2013 1
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
d2015 1
a2015 1
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
d2017 1
a2017 1
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
d2019 3
a2021 3
		/* only likely problem here is some internal regexp botch */
		Tcl_BackgroundError(interp);
		goto finish;
d2026 4
a2029 4
	eo.esPtr = esPtr;
	eo.match = expSizeGet(eo.esPtr);
	eo.buffer = eo.esPtr->buffer;
	expDiagLogU("expect_background: read eof\r\n");
d2036 1
a2036 1

d2038 165
a2202 19
    expMatchProcess(interp, &eo, cc, 1 /* bg */,"expect_background");

    /*
     * Event handler will not call us back if there is more input
     * pending but it has already arrived.  bg_status will be
     * "blocked" only if armed.
     */

    /*
     * Connection could have been closed on us.  In this case,
     * exitWhenBgStatusUnblocked will be 1 and we should disable the channel
     * handler and release the esPtr.
     */

    if ((!esPtr->freeWhenBgHandlerUnblocked) && (esPtr->bg_status == blocked)) {
	if (0 != (cc = expSizeGet(esPtr))) {
	    goto do_more_data;
	}
    }
d2204 3
a2206 3
    exp_unblock_background_channelhandler(esPtr);
    if (esPtr->freeWhenBgHandlerUnblocked)
	expStateFree(esPtr);
d2208 22
d2233 5
a2237 5
Exp_ExpectObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d2239 3
a2241 3
    int cc;			/* number of chars returned in a single read */
				/* or negative EXP_whatever */
    ExpState *esPtr = 0;
d2243 1
a2243 1
    int i;			/* misc temporary */
d2245 4
a2248 4
    struct exp_state_list *state_list;	/* list of ExpStates to watch */
    struct exp_state_list *slPtr;	/* temp for interating over state_list */
    ExpState **esPtrs;
    int mcount;			/* number of esPtrs to watch */
d2253 1
a2253 1
    
d2258 2
d2261 2
a2262 2
    ExpState *last_esPtr;	/* for differentiating when multiple f's */
				/* to print out better debugging messages */
d2265 1
a2265 1
    
d2272 1
d2274 7
a2280 7
    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d2283 1
d2287 1
a2287 7
    
    if (&StdinoutPlaceholder == (ExpState *)clientData) {
	clientData = (ClientData) expStdinoutGet();
    } else if (&DevttyPlaceholder == (ExpState *)clientData) {
	clientData = (ClientData) expDevttyGet();
    }
	
d2292 11
a2302 4
    state_list = 0;
    esPtrs = 0;
    if (TCL_ERROR == parse_expect_args(interp,&eg,
	    (ExpState *)clientData,objc,objv))
d2306 2
a2307 1
    /* validate all descriptors and flatten ExpStates into array */
d2309 3
a2311 3
    if ((TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_BEFORE].i_list,&state_list))
	    || (TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_AFTER].i_list, &state_list))
	    || (TCL_ERROR == update_expect_states(eg.i_list,&state_list))) {
d2319 1
a2319 1
    /* count and validate state_list */
d2321 1
a2321 1
    for (slPtr=state_list;slPtr;slPtr=slPtr->next) {
d2324 1
a2324 1
	if (!expStateCheck(interp,slPtr->esPtr,1,1,"expect")) {
d2331 3
a2333 3
    esPtrs = (ExpState **)ckalloc(mcount * sizeof(ExpState *));
    for (slPtr=state_list,i=0;slPtr;slPtr=slPtr->next,i++) {
	esPtrs[i] = slPtr->esPtr;
d2336 1
a2336 1
  restart:
d2350 1
a2350 1
    last_esPtr = 0;
d2352 1
a2352 3
    /*
     * end of restart code
     */
d2354 3
a2356 3
    eo.e = 0;		/* no final case yet */
    eo.esPtr = 0;	/* no final ExpState selected yet */
    eo.match = 0;	/* nothing matched yet */
d2376 1
a2376 1
	    cc = expRead(interp,esPtrs,mcount,&esPtr,remtime,key);
d2383 1
a2383 1
	    expDiagLogU("expect: timed out\r\n");
d2387 1
a2387 1
	} else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
a2390 1
	    
d2395 1
a2395 1
	    last_esPtr = 0;
d2399 1
a2399 1
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
d2401 1
a2401 1
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
d2403 1
a2403 1
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
d2408 4
a2411 4
	    eo.esPtr = esPtr;
	    eo.match = expSizeGet(eo.esPtr);
	    eo.buffer = eo.esPtr->buffer;
	    expDiagLogU("expect: read eof\r\n");
d2419 1
a2419 1
	esPtr->force_read = TRUE;
d2429 1
a2429 1
error:
d2432 4
d2437 163
a2599 1
	result = expMatchProcess(interp, &eo, cc, 0 /* not bg */,"expect");
d2608 3
a2610 2
    if ((result == EXP_CONTINUE) && (configure_count == exp_configure_count)) {
	expDiagLogU("expect: continuing expect\r\n");
d2614 7
a2620 7
    if (state_list) {
	exp_free_state(state_list);
	state_list = 0;
    }
    if (esPtrs) {
	ckfree((char *)esPtrs);
	esPtrs = 0;
d2624 1
a2624 1
	expDiagLogU("expect: continuing expect after update\r\n");
d2633 43
d2738 13
d2754 4
a2757 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2760 1
a2760 2
    ExpState *esPtr = 0;
    char *chanName = 0;
d2762 2
a2763 1

d2765 1
a2765 1

d2775 1
a2775 1
	    chanName = *argv;
d2778 1
a2778 6

    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

d2780 2
a2781 2
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
a2782 1
	    }
d2784 1
a2784 2
	    
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"match_max")))
d2787 3
d2791 1
a2791 1

d2796 1
a2796 1
	    size = esPtr->umsize;
d2801 1
a2801 1

d2807 1
a2807 4
    /*
     * All that's left is to set the size
     */

d2813 1
a2813 1

d2815 2
a2816 2
    else esPtr->umsize = size;

d2823 4
a2826 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2829 1
a2829 2
    ExpState *esPtr = 0;
    char *chanName = 0;
d2831 1
d2844 1
a2844 1
	    chanName = *argv;
a2847 5
    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

d2849 2
a2850 2
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0)))
d2853 1
a2853 1
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"remove_nulls")))
d2856 3
d2863 1
a2863 1
	  value = exp_default_rm_nulls;
d2865 1
a2865 1
	  value = esPtr->rm_nulls;
d2884 1
a2884 1
    else esPtr->rm_nulls = value;
d2892 4
a2895 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2898 2
a2899 2
    ExpState *esPtr = 0;
    char *chanName = 0;
d2901 1
d2914 1
a2914 1
	    chanName = *argv;
a2917 5
    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

d2919 2
a2920 2
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
a2921 1
	    }
d2923 1
a2923 1
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"parity"))) {
a2924 1
	    }
d2926 3
d2935 1
a2935 1
	    parity = esPtr->parity;
d2950 1
a2950 1
    else esPtr->parity = parity;
d2959 2
a2960 2
exp_fd_print(slPtr)
struct exp_state_list *slPtr;
d2962 3
a2964 3
	if (!slPtr) return;
	printf("%d ",slPtr->esPtr);
	exp_fd_print(slPtr->next);
d2969 1
a2969 1
struct exp_i *exp_i;
d2971 11
a2981 11
	if (!exp_i) return;
	printf("exp_i %x",exp_i);
	printf((exp_i->direct == EXP_DIRECT)?" direct":" indirect");
	printf((exp_i->duration == EXP_PERMANENT)?" perm":" tmp");
	printf("  ecount = %d\n",exp_i->ecount);
	printf("variable %s, value %s\n",
		((exp_i->variable)?exp_i->variable:"--"),
		((exp_i->value)?exp_i->value:"--"));
	printf("ExpStates: ");
	exp_fd_print(exp_i->state_list); printf("\n");
	exp_i_print(exp_i->next);
d2986 1
a2986 1
struct ecase *ecase;
d2988 2
a2989 2
	printf("pat <%s>\n",ecase->pat);
	printf("exp_i = %x\n",ecase->i_list);
d2994 1
a2994 1
struct exp_cases_descriptor *ecd;
d2996 1
a2996 1
	int i;
d2998 2
a2999 2
	printf("%d cases\n",ecd->count);
	for (i=0;i<ecd->count;i++) exp_ecase_print(ecd->cases[i]);
d3004 1
a3004 1
struct exp_cmd_descriptor *ecmd;
d3006 5
a3010 5
	printf("expect cmd type: %17s",exp_cmdtype_printable(ecmd->cmdtype));
	printf((ecmd->duration==EXP_PERMANENT)?" perm ": "tmp ");
	/* printdict */
	exp_ecases_print(&ecmd->ecd);
	exp_i_print(ecmd->i_list);
d3016 3
a3018 3
	exp_cmd_print(&exp_cmds[EXP_CMD_BEFORE]);
	exp_cmd_print(&exp_cmds[EXP_CMD_AFTER]);
	exp_cmd_print(&exp_cmds[EXP_CMD_BG]);
d3024 4
a3027 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d3029 2
a3030 2
	exp_cmds_print();
	return TCL_OK;
a3033 8
void
expExpectVarsInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->timeout = INIT_EXPECT_TIMEOUT;
}

d3036 10
a3045 10
{"expect",	Exp_ExpectObjCmd,	0,	(ClientData)0,	0},
{"expect_after",Exp_ExpectGlobalObjCmd, 0,	(ClientData)&exp_cmds[EXP_CMD_AFTER],0},
{"expect_before",Exp_ExpectGlobalObjCmd,0,	(ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
{"expect_user",	Exp_ExpectObjCmd,	0,	(ClientData)&StdinoutPlaceholder,0},
{"expect_tty",	Exp_ExpectObjCmd,	0,	(ClientData)&DevttyPlaceholder,0},
{"expect_background",Exp_ExpectGlobalObjCmd,0,	(ClientData)&exp_cmds[EXP_CMD_BG],0},
{"match_max",	exp_proc(Exp_MatchMaxCmd),	0,	0},
{"remove_nulls",exp_proc(Exp_RemoveNullsCmd),	0,	0},
{"parity",	exp_proc(Exp_ParityCmd),	0,	0},
{"timestamp",	exp_proc(Exp_TimestampCmd),	0,	0},
d3048 16
d3066 1
a3066 1
Tcl_Interp *interp;
d3068 1
a3068 1
	exp_create_commands(interp,cmd_data);
d3070 2
d3073 18
a3090 26

	Tcl_SetVar(interp,EXPECT_TIMEOUT,INIT_EXPECT_TIMEOUT_LIT,0);

	exp_cmd_init(&exp_cmds[EXP_CMD_BEFORE],EXP_CMD_BEFORE,EXP_PERMANENT);
	exp_cmd_init(&exp_cmds[EXP_CMD_AFTER ],EXP_CMD_AFTER, EXP_PERMANENT);
	exp_cmd_init(&exp_cmds[EXP_CMD_BG    ],EXP_CMD_BG,    EXP_PERMANENT);
	exp_cmd_init(&exp_cmds[EXP_CMD_FG    ],EXP_CMD_FG,    EXP_TEMPORARY);

	/* preallocate to one element, so future realloc's work */
	exp_cmds[EXP_CMD_BEFORE].ecd.cases = 0;
	exp_cmds[EXP_CMD_AFTER ].ecd.cases = 0;
	exp_cmds[EXP_CMD_BG    ].ecd.cases = 0;

	pattern_style[PAT_EOF] = "eof";
	pattern_style[PAT_TIMEOUT] = "timeout";
	pattern_style[PAT_DEFAULT] = "default";
	pattern_style[PAT_FULLBUFFER] = "full buffer";
	pattern_style[PAT_GLOB] = "glob pattern";
	pattern_style[PAT_RE] = "regular expression";
	pattern_style[PAT_EXACT] = "exact string";
	pattern_style[PAT_NULL] = "null";

#if 0
	Tcl_CreateCommand(interp,"x",
		cmdX,(ClientData)0,exp_deleteProc);
#endif
a3094 4
#if 0
	signal(SIGALRM,sigalarm_handler);
	signal(SIGINT,sigint_handler);
#endif
@


