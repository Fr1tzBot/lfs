head	5.39;
access;
symbols
	expect_5_45:5.39
	expect_6_branch:5.39.0.2
	expect_5_44_1_15:5.39
	activestate_win32_port_start:5.33
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.12
	scriptics-sc-2-0-b5:5.28.1.1.2.12
	scriptics-sc-2-0-fixed:5.28.1.1.2.12
	scriptics-sc-2-0-b2:5.28.1.1.2.12
	scriptics-sc-2-0-b1:5.28.1.1.2.12
	scriptics-sc-1-1:5.28.1.1.2.12
	scriptics-sc-1-1-b1:5.28.1.1.2.12
	scriptics-sc-1-1-branch:5.28.1.1.2.12.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.12
	scriptics-sc-1-0:5.28.1.1.2.12
	scriptics-sc-1-0-branch:5.28.1.1.2.12.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.12
	expect-5-31-3:5.28.1.1.2.12
	scriptics-bc-1-0-b1:5.28.1.1.2.10
	scriptics-tclpro-1-3-0:5.28.1.1.2.9
	scriptics-tclpro-1-3-b4:5.28.1.1.2.9
	scriptics-tclpro-1-3-b3:5.28.1.1.2.9
	expect-5-31:5.28.1.1.2.9
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.39
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.38;

5.38
date	2010.03.17.23.47.50;	author eee;	state Exp;
branches;
next	5.37;

5.37
date	2007.12.13.22.33.53;	author hobbs;	state Exp;
branches;
next	5.36;

5.36
date	2007.07.11.21.35.08;	author andreas_kupries;	state Exp;
branches;
next	5.35;

5.35
date	2005.02.15.18.11.08;	author andreas_kupries;	state Exp;
branches;
next	5.34;

5.34
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2003.02.03.23.56.38;	author andreas_kupries;	state Exp;
branches;
next	5.32;

5.32
date	2002.04.16.21.00.28;	author libes;	state Exp;
branches;
next	5.31;

5.31
date	2002.03.25.20.55.20;	author andreas_kupries;	state Exp;
branches;
next	5.30;

5.30
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.03;	author wart;	state Exp;
branches
	5.29.2.1
	5.29.4.1
	5.29.6.1;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.10.22.01.43;	author don;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.14.20.36.48;	author don;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.14.23.54.05;	author don;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.06.15.19.11.57;	author don;	state Exp;
branches;
next	5.28.1.1.2.5;

5.28.1.1.2.5
date	99.06.15.22.52.57;	author don;	state Exp;
branches;
next	5.28.1.1.2.6;

5.28.1.1.2.6
date	99.06.16.03.02.38;	author don;	state Exp;
branches;
next	5.28.1.1.2.7;

5.28.1.1.2.7
date	99.06.22.19.50.53;	author libes;	state Exp;
branches;
next	5.28.1.1.2.8;

5.28.1.1.2.8
date	99.06.23.17.25.18;	author libes;	state Exp;
branches;
next	5.28.1.1.2.9;

5.28.1.1.2.9
date	99.06.28.06.29.25;	author libes;	state Exp;
branches;
next	5.28.1.1.2.10;

5.28.1.1.2.10
date	99.09.01.03.54.02;	author libes;	state Exp;
branches;
next	5.28.1.1.2.11;

5.28.1.1.2.11
date	99.10.06.05.54.17;	author libes;	state Exp;
branches;
next	5.28.1.1.2.12;

5.28.1.1.2.12
date	99.10.29.18.50.42;	author libes;	state Exp;
branches;
next	5.28.1.1.2.13;

5.28.1.1.2.13
date	99.12.04.06.18.24;	author libes;	state Exp;
branches;
next	;

5.29.2.1
date	2002.02.07.23.34.16;	author andreas_kupries;	state Exp;
branches;
next	;

5.29.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.29.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.39
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@/* exp_log.c - logging routines and other things common to both Expect
   program and library.  Note that this file must NOT have any
   references to Tcl except for including tclInt.h
*/

#include "expect_cf.h"
#include <stdio.h>
/*#include <varargs.h>		tclInt.h drags in varargs.h.  Since Pyramid */
/*				objects to including varargs.h twice, just */
/*				omit this one. */
#include "tclInt.h"
#ifdef NO_STDLIB_H
#include "../compat/stdlib.h"
#else
#include <stdlib.h>		/* for malloc */
#endif
#include <ctype.h>

#include "expect_comm.h"
#include "exp_int.h"
#include "exp_rename.h"
#include "exp_command.h"
#include "exp_log.h"

typedef struct ThreadSpecificData {
    Tcl_Channel diagChannel;
    Tcl_DString diagFilename;
    int diagToStderr;

    Tcl_Channel logChannel;
    Tcl_DString logFilename;	/* if no name, then it came from -open or -leaveopen */
    int logAppend;
    int logLeaveOpen;
    int logAll;			/* if TRUE, write log of all interactions
				 * despite value of logUser - i.e., even if
				 * user is not seeing it (via stdout)
				 */
    int logUser;		/* TRUE if user sees interactions on stdout */
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 * create a reasonably large buffer for the bulk of the output routines
 * that are not too large
 */
static char bigbuf[2000];

static void expDiagWriteCharsUni _ANSI_ARGS_((Tcl_UniChar *str,int len));

/*
 * Following this are several functions that log the conversation.  Some
 * general notes on all of them:
 */

/*
 * ignore sprintf return value ("character count") because it's not
 * defined in terms of UTF so it would be misinterpreted if we passed
 * it on.
 */

/*
 * if necessary, they could be made more efficient by skipping vsprintf based
 * on booleans
 */

/* Most of them have multiple calls to printf-style functions.  */
/* At first glance, it seems stupid to reformat the same arguments again */
/* but we have no way of telling how long the formatted output will be */
/* and hence cannot allocate a buffer to do so. */
/* Fortunately, in production code, most of the duplicate reformatting */
/* will be skipped, since it is due to handling errors and debugging. */

/*
 * Name: expWriteBytesAndLogIfTtyU
 *
 * Output to channel (and log if channel is stdout or devtty)
 *
 * Returns: TCL_OK or TCL_ERROR;
 */

int
expWriteBytesAndLogIfTtyU(esPtr,buf,lenChars)
    ExpState *esPtr;
    Tcl_UniChar *buf;
    int lenChars;
{
    int wc;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (esPtr->valid)
	wc = expWriteCharsUni(esPtr,buf,lenChars);

    if (tsdPtr->logChannel && ((esPtr->fdout == 1) || expDevttyIs(esPtr))) {
      Tcl_DString ds;
      Tcl_DStringInit (&ds);
      Tcl_UniCharToUtfDString (buf,lenChars,&ds);
      Tcl_WriteChars(tsdPtr->logChannel,Tcl_DStringValue (&ds), Tcl_DStringLength (&ds));
      Tcl_DStringFree (&ds);
    }
    return wc;
}

/*
 * Name: expLogDiagU
 *
 * Send to the Log (and Diag if open).  This is for writing to the log.
 * (In contrast, expDiagLog... is for writing diagnostics.)
 */

void
expLogDiagU(buf)
char *buf;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    expDiagWriteChars(buf,-1);
    if (tsdPtr->logChannel) {
	Tcl_WriteChars(tsdPtr->logChannel, buf, -1);
    }
}

/*
 * Name: expLogInteractionU
 *
 * Show chars to user if they've requested it, UNLESS they're seeing it
 * already because they're typing it and tty driver is echoing it.
 * Also send to Diag and Log if appropriate.
 */
void
expLogInteractionU(esPtr,buf,buflen)
    ExpState *esPtr;
    Tcl_UniChar *buf;
    int buflen;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (tsdPtr->logAll || (tsdPtr->logUser && tsdPtr->logChannel)) {
      Tcl_DString ds;
      Tcl_DStringInit (&ds);
      Tcl_UniCharToUtfDString (buf,buflen,&ds);
      Tcl_WriteChars(tsdPtr->logChannel,Tcl_DStringValue (&ds), Tcl_DStringLength (&ds));
      Tcl_DStringFree (&ds);
    }

    /* hmm.... if stdout is closed such as by disconnect, loguser
       should be forced FALSE */

    /* don't write to user if they're seeing it already, i.e., typing it! */
    if (tsdPtr->logUser && (!expStdinoutIs(esPtr)) && (!expDevttyIs(esPtr))) {
	ExpState *stdinout = expStdinoutGet();
	if (stdinout->valid) {
	    (void) expWriteCharsUni(stdinout,buf,buflen);
	}
    }
    expDiagWriteCharsUni(buf,buflen);
}

/* send to log if open */
/* send to stderr if debugging enabled */
/* use this for logging everything but the parent/child conversation */
/* (this turns out to be almost nothing) */
/* uppercase L differentiates if from math function of same name */
#define LOGUSER		(tsdPtr->logUser || force_stdout)
/*VARARGS*/
void
expStdoutLog TCL_VARARGS_DEF(int,arg1)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int force_stdout;
    char *fmt;
    va_list args;

    force_stdout = TCL_VARARGS_START(int,arg1,args);
    fmt = va_arg(args,char *);

    if ((!tsdPtr->logUser) && (!force_stdout) && (!tsdPtr->logAll)) return;

    (void) vsprintf(bigbuf,fmt,args);
    expDiagWriteBytes(bigbuf,-1);
    if (tsdPtr->logAll || (LOGUSER && tsdPtr->logChannel)) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
    if (LOGUSER) fprintf(stdout,"%s",bigbuf);
    va_end(args);
}

/* just like log but does no formatting */
/* send to log if open */
/* use this function for logging the parent/child conversation */
void
expStdoutLogU(buf,force_stdout)
char *buf;
int force_stdout;	/* override value of logUser */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int length;

    if ((!tsdPtr->logUser) && (!force_stdout) && (!tsdPtr->logAll)) return;

    length = strlen(buf);
    expDiagWriteBytes(buf,length);
    if (tsdPtr->logAll || (LOGUSER && tsdPtr->logChannel)) Tcl_WriteChars(tsdPtr->logChannel,buf,-1);
    if (LOGUSER) {
#if (TCL_MAJOR_VERSION > 8) || ((TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 1))
      Tcl_WriteChars (Tcl_GetStdChannel (TCL_STDOUT), buf, length);
      Tcl_Flush      (Tcl_GetStdChannel (TCL_STDOUT));
#else
      fwrite(buf,1,length,stdout);
#endif
    }
}

/* send to log if open */
/* send to stderr */
/* use this function for error conditions */
/*VARARGS*/
void
expErrorLog TCL_VARARGS_DEF(char *,arg1)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    char *fmt;
    va_list args;

    fmt = TCL_VARARGS_START(char *,arg1,args);
    (void) vsprintf(bigbuf,fmt,args);

    expDiagWriteChars(bigbuf,-1);
    fprintf(stderr,"%s",bigbuf);
    if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
    
    va_end(args);
}

/* just like errorlog but does no formatting */
/* send to log if open */
/* use this function for logging the parent/child conversation */
/*ARGSUSED*/
void
expErrorLogU(buf)
char *buf;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    int length = strlen(buf);
    fwrite(buf,1,length,stderr);
    expDiagWriteChars(buf,-1);
    if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,buf,-1);
}



/* send diagnostics to Diag, Log, and stderr */
/* use this function for recording unusual things in the log */
/*VARARGS*/
void
expDiagLog TCL_VARARGS_DEF(char *,arg1)
{
    char *fmt;
    va_list args;

    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((tsdPtr->diagToStderr == 0) && (tsdPtr->diagChannel == 0)) return;

    fmt = TCL_VARARGS_START(char *,arg1,args);

    (void) vsprintf(bigbuf,fmt,args);

    expDiagWriteBytes(bigbuf,-1);
    if (tsdPtr->diagToStderr) {
	fprintf(stderr,"%s",bigbuf);
	if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
    }

    va_end(args);
}


/* expDiagLog for unformatted strings
   this also takes care of arbitrary large strings */
void
expDiagLogU(str)
char *str;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((tsdPtr->diagToStderr == 0) && (tsdPtr->diagChannel == 0)) return;

    expDiagWriteBytes(str,-1);

    if (tsdPtr->diagToStderr) {
      fprintf(stderr,"%s",str);
      if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,str,-1);
    }
}

/* expPrintf prints to stderr.  It's just a utility for making
   debugging easier. */

/*VARARGS*/
void
expPrintf TCL_VARARGS_DEF(char *,arg1)
{
  char *fmt;
  va_list args;
  char bigbuf[2000];
  int len, rc;

  fmt = TCL_VARARGS_START(char *,arg1,args);
  len = vsprintf(bigbuf,arg1,args);
 retry:
  rc = write(2,bigbuf,len);
  if ((rc == -1) && (errno == EAGAIN)) goto retry;

  va_end(args);
}


void
expDiagToStderrSet(val)
    int val;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->diagToStderr = val;
}
    

int
expDiagToStderrGet() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->diagToStderr;
}

Tcl_Channel
expDiagChannelGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->diagChannel;
}

void
expDiagChannelClose(interp)
    Tcl_Interp *interp;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;
    Tcl_UnregisterChannel(interp,tsdPtr->diagChannel);
    Tcl_DStringFree(&tsdPtr->diagFilename);
    tsdPtr->diagChannel = 0;
}

/* currently this registers the channel, however the exp_internal
   command doesn't currently give the channel name to the user so
   this is kind of useless - but we might change this someday */
int
expDiagChannelOpen(interp,filename)
    Tcl_Interp *interp;
    char *filename;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *newfilename;

    Tcl_ResetResult(interp);
    newfilename = Tcl_TranslateFileName(interp,filename,&tsdPtr->diagFilename);
    if (!newfilename) return TCL_ERROR;

    /* Tcl_TildeSubst doesn't store into dstring */
    /* if no ~, so force string into dstring */
    /* this is only needed so that next time around */
    /* we can get dstring for -info if necessary */
    if (Tcl_DStringValue(&tsdPtr->diagFilename)[0] == '\0') {
	Tcl_DStringAppend(&tsdPtr->diagFilename,filename,-1);
    }

    tsdPtr->diagChannel = Tcl_OpenFileChannel(interp,newfilename,"a",0777);
    if (!tsdPtr->diagChannel) {
	Tcl_DStringFree(&tsdPtr->diagFilename);
	return TCL_ERROR;
    }
    Tcl_RegisterChannel(interp,tsdPtr->diagChannel);
    Tcl_SetChannelOption(interp,tsdPtr->diagChannel,"-buffering","none");
    return TCL_OK;
}

void
expDiagWriteObj(obj)
    Tcl_Obj *obj;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_WriteObj(tsdPtr->diagChannel,obj);
}

/* write 8-bit bytes */
void
expDiagWriteBytes(str,len)
char *str;
int len;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_Write(tsdPtr->diagChannel,str,len);
}

/* write UTF chars */
void
expDiagWriteChars(str,len)
char *str;
int len;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_WriteChars(tsdPtr->diagChannel,str,len);
}

/* write Unicode chars */
static void
expDiagWriteCharsUni(str,len)
Tcl_UniChar *str;
int len;
{
    Tcl_DString ds;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_DStringInit (&ds);
    Tcl_UniCharToUtfDString (str,len,&ds);
    Tcl_WriteChars(tsdPtr->diagChannel,Tcl_DStringValue (&ds), Tcl_DStringLength (&ds));
    Tcl_DStringFree (&ds);
}

char *
expDiagFilename()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return Tcl_DStringValue(&tsdPtr->diagFilename);
}

void
expLogChannelClose(interp)
    Tcl_Interp *interp;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->logChannel) return;

    if (Tcl_DStringLength(&tsdPtr->logFilename)) {
	/* it's a channel that we created */
	Tcl_UnregisterChannel(interp,tsdPtr->logChannel);
	Tcl_DStringFree(&tsdPtr->logFilename);
    } else {
	/* it's a channel that tcl::open created */
	if (!tsdPtr->logLeaveOpen) {
	    Tcl_UnregisterChannel(interp,tsdPtr->logChannel);
	}
    }
    tsdPtr->logChannel = 0;
    tsdPtr->logAll = 0; /* can't write to log if none open! */
}

/* currently this registers the channel, however the exp_log_file
   command doesn't currently give the channel name to the user so
   this is kind of useless - but we might change this someday */
int
expLogChannelOpen(interp,filename,append)
    Tcl_Interp *interp;
    char *filename;
    int append;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *newfilename;
    char mode[2];

    if (append) {
      strcpy(mode,"a");
    } else {
      strcpy(mode,"w");
    }

    Tcl_ResetResult(interp);
    newfilename = Tcl_TranslateFileName(interp,filename,&tsdPtr->logFilename);
    if (!newfilename) return TCL_ERROR;

    /* Tcl_TildeSubst doesn't store into dstring */
    /* if no ~, so force string into dstring */
    /* this is only needed so that next time around */
    /* we can get dstring for -info if necessary */
    if (Tcl_DStringValue(&tsdPtr->logFilename)[0] == '\0') {
	Tcl_DStringAppend(&tsdPtr->logFilename,filename,-1);
    }

    tsdPtr->logChannel = Tcl_OpenFileChannel(interp,newfilename,mode,0777);
    if (!tsdPtr->logChannel) {
	Tcl_DStringFree(&tsdPtr->logFilename);
	return TCL_ERROR;
    }
    Tcl_RegisterChannel(interp,tsdPtr->logChannel);
    Tcl_SetChannelOption(interp,tsdPtr->logChannel,"-buffering","none");
    expLogAppendSet(append);
    return TCL_OK;
}

int
expLogAppendGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logAppend;
}

void
expLogAppendSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logAppend = app;
}

int
expLogAllGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logAll;
}

void
expLogAllSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logAll = app;
    /* should probably confirm logChannel != 0 */
}

int
expLogToStdoutGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logUser;
}

void
expLogToStdoutSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logUser = app;
}

int
expLogLeaveOpenGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logLeaveOpen;
}

void
expLogLeaveOpenSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logLeaveOpen = app;
}

Tcl_Channel
expLogChannelGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logChannel;
}

/* to set to a pre-opened channel (presumably by tcl::open) */
int
expLogChannelSet(interp,name)
    Tcl_Interp *interp;
    char *name;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    int mode;
    
    if (0 == (tsdPtr->logChannel = Tcl_GetChannel(interp,name,&mode))) {
	return TCL_ERROR;
    }
    if (!(mode & TCL_WRITABLE)) {
	tsdPtr->logChannel = 0;
	Tcl_SetResult(interp,"channel is not writable",TCL_VOLATILE);
	return TCL_ERROR;
    }
    return TCL_OK;
}

char *
expLogFilenameGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return Tcl_DStringValue(&tsdPtr->logFilename);
}

int
expLogUserGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return tsdPtr->logUser;
}

void
expLogUserSet(logUser)
    int logUser;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->logUser = logUser;
}



/* generate printable versions of random ASCII strings.  Primarily used */
/* in diagnostic mode, "expect -d" */
static char *
expPrintifyReal(s)
char *s;
{
	static int destlen = 0;
	static char *dest = 0;
	char *d;		/* ptr into dest */
	unsigned int need;
	Tcl_UniChar ch;

	if (s == 0) return("<null>");

	/* worst case is every character takes 4 to printify */
	need = strlen(s)*6 + 1;
	if (need > destlen) {
		if (dest) ckfree(dest);
		dest = ckalloc(need);
		destlen = need;
	}

	for (d = dest;*s;) {
	    s += Tcl_UtfToUniChar(s, &ch);
	    if (ch == '\r') {
		strcpy(d,"\\r");		d += 2;
	    } else if (ch == '\n') {
		strcpy(d,"\\n");		d += 2;
	    } else if (ch == '\t') {
		strcpy(d,"\\t");		d += 2;
	    } else if ((ch < 0x80) && isprint(UCHAR(ch))) {
		*d = (char)ch;			d += 1;
	    } else {
		sprintf(d,"\\u%04x",ch);	d += 6;
	    }
	}
	*d = '\0';
	return(dest);
}

/* generate printable versions of random ASCII strings.  Primarily used */
/* in diagnostic mode, "expect -d" */
static char *
expPrintifyRealUni(s,numchars)
Tcl_UniChar *s;
int numchars;
{
  static int destlen = 0;
  static char *dest = 0;
  char *d;		/* ptr into dest */
  unsigned int need;
  Tcl_UniChar ch;

  if (s == 0) return("<null>");
  if (numchars == 0) return("");

  /* worst case is every character takes 6 to printify */
  need = numchars*6 + 1;
  if (need > destlen) {
    if (dest) ckfree(dest);
    dest = ckalloc(need);
    destlen = need;
  }

  for (d = dest;numchars > 0;numchars--) {
    ch = *s; s++;

    if (ch == '\r') {
      strcpy(d,"\\r");		d += 2;
    } else if (ch == '\n') {
      strcpy(d,"\\n");		d += 2;
    } else if (ch == '\t') {
      strcpy(d,"\\t");		d += 2;
    } else if ((ch < 0x80) && isprint(UCHAR(ch))) {
      *d = (char)ch;			d += 1;
    } else {
      sprintf(d,"\\u%04x",ch);	d += 6;
    }
  }
  *d = '\0';
  return(dest);
}

char *
expPrintifyObj(obj)
    Tcl_Obj *obj;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* don't bother writing into bigbuf if we're not going to ever use it */
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return((char *)0);
    
    return expPrintifyReal(Tcl_GetString(obj));
}

char *
expPrintify(s) /* INTL */
char *s;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* don't bother writing into bigbuf if we're not going to ever use it */
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return((char *)0);

    return expPrintifyReal(s);
}
 
char *
expPrintifyUni(s,numchars) /* INTL */
Tcl_UniChar *s;
int numchars;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* don't bother writing into bigbuf if we're not going to ever use it */
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return((char *)0);

    return expPrintifyRealUni(s,numchars);
}
 
void
expDiagInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    Tcl_DStringInit(&tsdPtr->diagFilename);
    tsdPtr->diagChannel = 0;
    tsdPtr->diagToStderr = 0;
}

void
expLogInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    Tcl_DStringInit(&tsdPtr->logFilename);
    tsdPtr->logChannel = 0;
    tsdPtr->logAll = FALSE;
    tsdPtr->logUser = TRUE;
}
@


5.38
log
@ANSIfication changes
@
text
@d8 3
a10 2
#include <varargs.h>

d12 5
a16 1
#include <stdlib.h>
d49 1
a49 1
static void expDiagWriteCharsUni (Tcl_UniChar *str,int len);
d83 4
a86 1
expWriteBytesAndLogIfTtyU( ExpState *esPtr, Tcl_UniChar *buf, int lenChars)
d112 2
a113 1
expLogDiagU( char *buf)
d131 4
a134 1
expLogInteractionU( ExpState *esPtr, Tcl_UniChar *buf, int buflen)
d190 3
a192 1
expStdoutLogU( char *buf, int force_stdout)
d239 2
a240 1
expErrorLogU( char *buf)
d282 2
a283 1
expDiagLogU( char *str)
d320 2
a321 1
expDiagToStderrSet( int val)
d336 1
a336 1
expDiagChannelGet(void)
d343 2
a344 1
expDiagChannelClose( Tcl_Interp *interp)
d358 3
a360 1
expDiagChannelOpen( Tcl_Interp *interp, char *filename)
d388 2
a389 1
expDiagWriteObj( Tcl_Obj *obj)
d400 3
a402 1
expDiagWriteBytes( char *str, int len)
d413 3
a415 1
expDiagWriteChars( char *str, int len)
d426 3
a428 1
expDiagWriteCharsUni( Tcl_UniChar *str, int len)
d442 1
a442 1
expDiagFilename(void)
d450 2
a451 1
expLogChannelClose( Tcl_Interp *interp)
d475 4
a478 1
expLogChannelOpen( Tcl_Interp *interp, char *filename, int append)
d514 1
a514 1
expLogAppendGet(void)
d521 2
a522 1
expLogAppendSet( int app)
d529 1
a529 1
expLogAllGet(void)
d536 2
a537 1
expLogAllSet( int app)
d545 1
a545 1
expLogToStdoutGet(void)
d552 2
a553 1
expLogToStdoutSet( int app)
d560 1
a560 1
expLogLeaveOpenGet(void)
d567 2
a568 1
expLogLeaveOpenSet( int app)
d575 1
a575 1
expLogChannelGet(void)
d583 3
a585 1
expLogChannelSet( Tcl_Interp *interp, char *name)
d603 1
a603 1
expLogFilenameGet(void)
d611 1
a611 1
expLogUserGet(void)
d619 2
a620 1
expLogUserSet( int logUser)
d632 2
a633 1
expPrintifyReal( char *s)
d672 3
a674 1
expPrintifyRealUni( Tcl_UniChar *s, int numchars)
d713 2
a714 1
expPrintifyObj( Tcl_Obj *obj)
d725 2
a726 1
expPrintify(char *s) /* INTL */
d737 3
a739 1
expPrintifyUni( Tcl_UniChar *s, int numchars) /* INTL */
d750 1
a750 1
expDiagInit(void)
d760 1
a760 1
expLogInit(void)
@


5.37
log
@* exp_log.c (expStdoutLogU): correct which buf is output
@
text
@d8 2
a9 3
/*#include <varargs.h>		tclInt.h drags in varargs.h.  Since Pyramid */
/*				objects to including varargs.h twice, just */
/*				omit this one. */
d11 1
a11 5
#ifdef NO_STDLIB_H
#include "../compat/stdlib.h"
#else
#include <stdlib.h>		/* for malloc */
#endif
d44 1
a44 1
static void expDiagWriteCharsUni _ANSI_ARGS_((Tcl_UniChar *str,int len));
d78 1
a78 4
expWriteBytesAndLogIfTtyU(esPtr,buf,lenChars)
    ExpState *esPtr;
    Tcl_UniChar *buf;
    int lenChars;
d104 1
a104 2
expLogDiagU(buf)
char *buf;
d122 1
a122 4
expLogInteractionU(esPtr,buf,buflen)
    ExpState *esPtr;
    Tcl_UniChar *buf;
    int buflen;
d178 1
a178 3
expStdoutLogU(buf,force_stdout)
char *buf;
int force_stdout;	/* override value of logUser */
d225 1
a225 2
expErrorLogU(buf)
char *buf;
d267 1
a267 2
expDiagLogU(str)
char *str;
d304 1
a304 2
expDiagToStderrSet(val)
    int val;
d319 1
a319 1
expDiagChannelGet()
d326 1
a326 2
expDiagChannelClose(interp)
    Tcl_Interp *interp;
d340 1
a340 3
expDiagChannelOpen(interp,filename)
    Tcl_Interp *interp;
    char *filename;
d368 1
a368 2
expDiagWriteObj(obj)
    Tcl_Obj *obj;
d379 1
a379 3
expDiagWriteBytes(str,len)
char *str;
int len;
d390 1
a390 3
expDiagWriteChars(str,len)
char *str;
int len;
d401 1
a401 3
expDiagWriteCharsUni(str,len)
Tcl_UniChar *str;
int len;
d415 1
a415 1
expDiagFilename()
d423 1
a423 2
expLogChannelClose(interp)
    Tcl_Interp *interp;
d447 1
a447 4
expLogChannelOpen(interp,filename,append)
    Tcl_Interp *interp;
    char *filename;
    int append;
d483 1
a483 1
expLogAppendGet()
d490 1
a490 2
expLogAppendSet(app)
    int app;
d497 1
a497 1
expLogAllGet()
d504 1
a504 2
expLogAllSet(app)
    int app;
d512 1
a512 1
expLogToStdoutGet()
d519 1
a519 2
expLogToStdoutSet(app)
    int app;
d526 1
a526 1
expLogLeaveOpenGet()
d533 1
a533 2
expLogLeaveOpenSet(app)
    int app;
d540 1
a540 1
expLogChannelGet()
d548 1
a548 3
expLogChannelSet(interp,name)
    Tcl_Interp *interp;
    char *name;
d566 1
a566 1
expLogFilenameGet()
d574 1
a574 1
expLogUserGet()
d582 1
a582 2
expLogUserSet(logUser)
    int logUser;
d594 1
a594 2
expPrintifyReal(s)
char *s;
d633 1
a633 3
expPrintifyRealUni(s,numchars)
Tcl_UniChar *s;
int numchars;
d672 1
a672 2
expPrintifyObj(obj)
    Tcl_Obj *obj;
d683 1
a683 2
expPrintify(s) /* INTL */
char *s;
d694 1
a694 3
expPrintifyUni(s,numchars) /* INTL */
Tcl_UniChar *s;
int numchars;
d705 1
a705 1
expDiagInit()
d715 1
a715 1
expLogInit()
@


5.36
log
@
	* exp_chan.c: Converted the buffering system from UTF-8 in Tcl_Obj
	* exp_command.h: to UTF-16 C-array, to avoid the repeated conversion
	* expect.c: of the input from utf-8 to utf-16. Updated the glob
	* exp_glob.c: matching code to use the same tricks for speed which
	* exp_inter.c: are used by the Tcl core. Extended the regexp
	* exp_log.c: matching path with a glob matcher which uses a gate
	* exp_log.h: keeper glob pattern to weed out most non-candidates
	* retoglob.c (New file): in a speedy manner. Regexp matching now
	  has to be done only for the small number of candidates
	  identified by the gate keeper. Overall speed improvement as glob
	  matching is faster than regexp matching. Added code translating
	  regular expressions into their gate keeper glob pattern.
@
text
@d201 1
a201 1
    if (tsdPtr->logAll || (LOGUSER && tsdPtr->logChannel)) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
@


5.35
log
@
	* Merged changes from the official versions 5.42.1 and 5.43.0 of
	  expect into the SF sources. See the details below.

	  --------------------
	  Martin Forssen <maf@@tkrat.xorg> fixed bug in ExpOutputProc
	  that caused misbehavior during partial writes.

	  Someone noted that gets stdin behaves differently (returns -1
	  immediately) from tclsh because with 5.42, stdin is unblocked by
	  defaults.

	  Robroy Gregg <robroy@@armory.xcom> noted that expect_background
	  ignores timeouts.  Added to documentation.

	  Jens Peterson <peterson@@redhat.xcom> provided patch for
	  "mkpasswd -vo".

	  Gary Bliesener <gary.bliesener@@nextel.xcom> noted that
	  multixterm failed on his system which had an old Tk that didn't
	  support the Tk package.

	  Removed beta designation.

	  Daniel A. Steffen <steffen@@ics.mq.edu.xau> provided patch for
	  MacOS to avoid panic-redefinition.
	  --------------------
@
text
@d49 2
d83 1
a83 1
expWriteBytesAndLogIfTtyU(esPtr,buf,lenBytes)
d85 2
a86 2
    char *buf;
    int lenBytes;
d92 1
a92 1
	wc = expWriteChars(esPtr,buf,lenBytes);
d95 5
a99 1
	Tcl_WriteChars(tsdPtr->logChannel,buf,lenBytes);
d131 1
a131 1
expLogInteractionU(esPtr,buf)
d133 2
a134 1
    char *buf;
d139 5
a143 1
	Tcl_WriteChars(tsdPtr->logChannel,buf,-1);
d153 1
a153 1
	    (void) expWriteChars(stdinout,buf,-1);
d156 1
a156 1
    expDiagWriteChars(buf,-1);
d424 17
d669 43
d736 13
@


5.34
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@d281 2
a282 2
	fprintf(stderr,"%s",str);
	if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,str,-1);
d286 22
@


5.33
log
@
	* exp_log.c (expLogChannelOpen): Fixed the bug reported on
	  comp.lang.tcl by Mordechai T. Abzug
	  <morty@@sanctuary.arbutus.md.us>. The bugfix itself was provided
	  by Don Libes.
@
text
@d90 1
a90 1
	wc = Tcl_WriteChars(esPtr->channel,buf,lenBytes);
d142 1
a142 1
	    Tcl_WriteChars(stdinout->channel,buf,-1);
@


5.32
log
@misc updates
@
text
@d459 1
@


5.31
log
@
 	* exp_log.c (expStdoutLogU): Merged fix for SF Bug #513382 into
	  the HEAD (The source of the patch is "expect-sf418892-sf439042-branch").

	  Use Tcl_WriteChars/Tcl_Flush instead of 'fwrite' for tcl 8.1 and
	  beyond to enforce correct conversion of the internal UTF/8 into
	  the external representation.
@
text
@d180 1
a180 1
CONST char *buf;
d229 1
a229 1
CONST char *buf;
d272 1
a272 1
    CONST char *str;
d368 2
a369 2
    CONST char *str;
    int len;
d381 2
a382 2
    CONST char *str;
    int len;
@


5.30
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d191 8
a198 1
    if (LOGUSER) fwrite(buf,1,length,stdout);
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d180 1
a180 1
char *buf;
d222 1
a222 1
char *buf;
d265 1
a265 1
    char *str;
d361 1
a361 1
    char *str;
d374 1
a374 1
    char *str;
@


5.29.2.1
log
@
	* exp_log.c (expStdoutLogU): Use Tcl_WriteChars/Tcl_Flush instead
	  of 'fwrite' for tcl 8.1 and beyond to enforce correct conversion
	  of the internal UTF/8 into the external representation.
@
text
@d191 1
a191 8
    if (LOGUSER) {
#if (TCL_MAJOR_VERSION > 8) || ((TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 1))
      Tcl_WriteChars (Tcl_GetStdChannel (TCL_STDOUT), buf, length);
      Tcl_Flush      (Tcl_GetStdChannel (TCL_STDOUT));
#else
      fwrite(buf,1,length,stdout);
#endif
    }
@


5.29.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.29.4.1
log
@Top-level source files removed.
@
text
@@


5.28
log
@Initial revision
@
text
@d12 7
d22 1
d25 39
a63 6
int loguser = TRUE;		/* if TRUE, expect/spawn may write to stdout */
int logfile_all = FALSE;	/* if TRUE, write log of all interactions */
				/* despite value of loguser. */
FILE *logfile = 0;
FILE *debugfile = 0;
int exp_is_debugging = FALSE;
a64 1
/* Following this are several functions that log the conversation. */
d72 76
d153 1
a153 1
#define LOGUSER		(loguser || force_stdout)
d156 17
a172 16
exp_log TCL_VARARGS_DEF(int,arg1)
/*exp_log(va_alist)*/
/*va_dcl*/
{
	int force_stdout;
	char *fmt;
	va_list args;

	force_stdout = TCL_VARARGS_START(int,arg1,args);
	/*va_start(args);*/
	/*force_stdout = va_arg(args,int);*/
	fmt = va_arg(args,char *);
	if (debugfile) vfprintf(debugfile,fmt,args);
	if (logfile_all || (LOGUSER && logfile)) vfprintf(logfile,fmt,args);
	if (LOGUSER) vfprintf(stdout,fmt,args);
	va_end(args);
d179 1
a179 1
exp_nflog(buf,force_stdout)
d181 1
a181 1
int force_stdout;	/* override value of loguser */
d183 2
a184 1
	int length = strlen(buf);
d186 1
a186 11
	if (debugfile) fwrite(buf,1,length,debugfile);
	if (logfile_all || (LOGUSER && logfile)) fwrite(buf,1,length,logfile);
	if (LOGUSER) fwrite(buf,1,length,stdout);
#if 0
	if (logfile_all || (LOGUSER && logfile)) {
		int newlength = exp_copy_out(length);
		fwrite(exp_out_buffer,1,newlength,logfile);
	}
#endif
}
#undef LOGUSER
d188 4
a191 22
/* send to log if open and debugging enabled */
/* send to stderr if debugging enabled */
/* use this function for recording unusual things in the log */
/*VARARGS*/
void
debuglog TCL_VARARGS_DEF(char *,arg1)
/*debuglog(va_alist)*/
/*va_dcl*/
{
	char *fmt;
	va_list args;

	fmt = TCL_VARARGS_START(char *,arg1,args);
	/*va_start(args);*/
	/*fmt = va_arg(args,char *);*/
	if (debugfile) vfprintf(debugfile,fmt,args);
	if (is_debugging) {
		vfprintf(stderr,fmt,args);
		if (logfile) vfprintf(logfile,fmt,args);
	}

	va_end(args);
d199 15
a213 14
exp_errorlog TCL_VARARGS_DEF(char *,arg1)
/*exp_errorlog(va_alist)*/
/*va_dcl*/
{
	char *fmt;
	va_list args;

	fmt = TCL_VARARGS_START(char *,arg1,args);
	/*va_start(args);*/
	/*fmt = va_arg(args,char *);*/
	vfprintf(stderr,fmt,args);
	if (debugfile) vfprintf(debugfile,fmt,args);
	if (logfile) vfprintf(logfile,fmt,args);
	va_end(args);
d221 1
a221 1
exp_nferrorlog(buf,force_stdout)
a222 2
int force_stdout;	/* not used, only declared here for compat with */
			/* exp_nflog() */
d224 34
a257 4
	int length = strlen(buf);
	fwrite(buf,1,length,stderr);
	if (debugfile) fwrite(buf,1,length,debugfile);
	if (logfile) fwrite(buf,1,length,logfile);
a259 6
#if 0
static int out_buffer_size;
static char *outp_last;
static char *out_buffer;
static char *outp;	/* pointer into out_buffer - static in order */
			/* to update whenever out_buffer is enlarged */
d261 17
d280 2
a281 1
exp_init_log()
d283 99
a381 3
	out_buffer = ckalloc(BUFSIZ);
	out_buffer_size = BUFSIZ;
	outp_last = out_buffer + BUFSIZ - 1;
d385 10
a394 1
enlarge_out_buffer()
d396 1
a396 1
	int offset = outp - out_buffer;
d398 1
a398 2
	int new_out_buffer_size = out_buffer_size = BUFSIZ;
	realloc(out_buffer,new_out_buffer_size);
d400 8
a407 74
	out_buffer_size = new_out_buffer_size;
	outp = out_buffer + offset;

	outp_last = out_buffer + out_buffer_size - 1;

	return(out_buffer);
}

/* like sprintf, but uses a static buffer enlarged as necessary */
/* currently supported are %s, %d, and %#d where # is a single-digit */
void
exp_sprintf TCL_VARARGS_DEF(char *,arg1)
/* exp_sprintf(va_alist)*/
/*va_dcl*/
{
	char *fmt;
	va_list args;
	char int_literal[20];	/* big enough for an int literal? */
	char *int_litp;		/* pointer into int_literal */
	char *width;
	char *string_arg;
	int int_arg;
	char *int_fmt;

	fmt = TCL_VARARGS_START(char *,arg1,args);
	/*va_start(args);*/
	/*fmt = va_arg(args,char *);*/

	while (*fmt != '\0') {
		if (*fmt != '%') {
			*outp++ = *fmt++;
			continue;
		}

		/* currently, only single-digit widths are used */
		if (isdigit(*fmt)) {
			width = fmt++;
		} else width = 0;

		switch (*fmt) {
		case 's':	/* interpolate string */
			string_arg = va_arg(args,char *);

			while (*string_arg) {
				if (outp == outp_last) {
					if (enlarge_out_buffer() == 0) {
						/* FAIL */
						return;
					}
				}
				*outp++ = *string_arg++;
			}
			fmt++;
			break;
		case 'd':	/* interpolate int */
			int_arg = va_arg(args,int);

			if (width) int_fmt = width;
			else int_fmt = fmt;

			sprintf(int_literal,int_fmt,int_arg);

			int_litp = int_literal;
			for (int_litp;*int_litp;) {
				if (enlarge_out_buffer() == 0) return;
				*outp++ = *int_litp++;
			}
			fmt++;
			break;
		default:	/* anything else is literal */
			if (enlarge_out_buffer() == 0) return;	/* FAIL */
			*outp++ = *fmt++;
			break;
		}
d409 44
a454 2
/* copy input string to exp_output, replacing \r\n sequences by \n */
/* return length of new string */
d456 1
a456 1
exp_copy_out(char *s)
d458 3
a460 2
	outp = out_buffer;
	int count = 0;
d462 144
a605 8
	while (*s) {
		if ((*s == '\r') && (*(s+1) =='\n')) s++;
		if (enlarge_out_buffer() == 0) {
			/* FAIL */
			break;
		}
		*outp = *s;
		count++;
d607 47
a653 1
	return count;
a654 1
#endif
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Added Exp channel driver and modified rest to support it.
@
text
@d85 1
a85 1
exp_debuglog TCL_VARARGS_DEF(char *,arg1)
@


5.28.1.1.2.2
log
@fixed Log/Diag and ExpectCmd
@
text
@a11 7
#ifdef NO_STDLIB_H
#include "../compat/stdlib.h"
#else
#include <stdlib.h>		/* for malloc */
#endif
#include <ctype.h>

d17 6
a22 39
typedef struct ThreadSpecificData {
    Tcl_Channel *diagChannel;
    Tcl_DString diagFilename;
    int diagToStderr;

    Tcl_Channel *logChannel;
    Tcl_DString logFilename;	/* if no name, then it came from -open or -leaveopen */
    int logAppend;
    int logLeaveOpen;
    int logAll;			/* if TRUE, write log of all interactions
				 * despite value of logUser - i.e., even if
				 * user is not seeing it (via stdout)
				 */
    int logUser;		/* TRUE if user sees interactions on stdout */
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 * create a reasonably large buffer for the bulk of the output routines
 * that are not too large
 */
static char bigbuf[2000];

/*
 * Following this are several functions that log the conversation.  Some
 * general notes on all of them:
 */

/*
 * ignore sprintf return value ("character count") because it's not
 * defined in terms of UTF so it would be misinterpreted if we passed
 * it on.
 */

/*
 * if necessary, they could be made more efficient by skipping vsprintf based
 * on booleans
 */
d24 1
a31 68
/*
 * Name: expWriteBytesAndLogIfTtyU
 *
 * Output to channel (and log if channel is stdout or devtty)
 *
 * Returns: TCL_OK or TCL_ERROR;
 */

int
expWriteBytesAndLogIfTtyU(esPtr,buf,lenBytes)
    ExpState *esPtr;
    char *buf;
    int lenBytes;
{
    int wc;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    wc = Tcl_Write(fdp->esPtr->channel,buf,lenBytes);

    if (tsdPtr->logChannel && ((esPtr->fdout == 1) || expDevTtyIs(esPtr))) {
	Tcl_Write(tsdPtr->logChannel,buf,lenBytes);
    }
    return wc;
}

/*
 * Name: expLogDiagU
 *
 * Send to the Log (and Diag if open).  This is for writing to the log.
 * (In contrast, expDiagLog... is for writing diagnostics.)
 */

void
expLogDiagU(buf)
char *buf;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    expDiagWriteChars(string,-1);
    if (tsdPtr->logChannel) {
	Tcl_WriteChars(tsdPtr->logChannel, string, -1);
    }
}

/*
 * Name: expLogInteractionU
 *
 * Show chars to user if they've requested it, UNLESS they're seeing it
 * already because they're typing it and tty driver is echoing it.
 * Also send to Diag and Log if appropriate.
 */
void
expLogInteractionU(esPtr,buf)
    ExpState *esPtr;
    char *buf;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int length;

    if (tsdPtr->logAll || (tsdPtr->logUser && tsdPtr->logChannel)) {
	Tcl_WriteChars(tsdPtr->logChannel,buf,-1);
    }
    /* don't write to user if they're seeing it already, i.e., typing it! */
    if (tsdPtr->logUser && (!expStdinoutIs(esPtr)) && (!expDevttyIs(esPtr)))
	Tcl_WriteChars(tsdPtr->logChannel,buf,-1);
    expWriteDiagChars(buf,-1);
}

d37 1
a37 1
#define LOGUSER		(tsdPtr->logUser || force_stdout)
d40 16
a55 17
expStdoutLog TCL_VARARGS_DEF(int,arg1)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int force_stdout;
    char *fmt;
    va_list args;

    force_stdout = TCL_VARARGS_START(int,arg1,args);
    fmt = va_arg(args,char *);

    if ((!tsdPtr->logUser) && (!force_stdout) && (!tsdPtr->logAll)) return;

    (void) vsprintf(bigbuf,fmt,args);
    expDiagWriteBytes(bigbuf,-1);
    if (tsdPtr->logAll || (LOGUSER && tsdPtr->logChannel)) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
    if (LOGUSER) fprintf(stdout,bigbuf);
    va_end(args);
d62 1
a62 1
expStdoutLogU(buf,force_stdout)
d64 1
a64 1
int force_stdout;	/* override value of logUser */
d66 13
a78 2
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int length;
d80 20
a99 1
    if ((!tsdPtr->logUser) && (!force_stdout) && (!tsdPtr->logAll)) return;
d101 1
a101 4
    length = strlen(buf);
    expDiagWriteBytes(buf,length);
    if (tsdPtr->logAll || (LOGUSER && tsdPtr->logChannel)) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
    if (LOGUSER) fwrite(buf,1,length,stdout);
d109 14
a122 15
expErrorLog TCL_VARARGS_DEF(char *,arg1)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    char *fmt;
    va_list args;

    fmt = TCL_VARARGS_START(char *,arg1,args);
    (void) vsprintf(bigbuf,fmt,args);

    expDiagWriteChars(bigbuf,-1);
    fprintf(stderr,bigbuf);
    if (tsdPtr->logChannel) Tcl_WriteChars(logChannel,bigbuf,-1);
    
    va_end(args);
d130 1
a130 1
expErrorLogU(buf,force_stdout)
d135 4
a138 4
    int length = strlen(buf);
    fwrite(buf,1,length,stderr);
    expDiagWriteChars(buf,-1);
    if (tsdPtr->logChannel) Tcl_WriteChars(logChannel,buf,-1);
d141 6
a148 2
/* send diagnostics to Diag, Log, and stderr */
/* use this function for recording unusual things in the log */
d150 1
a150 1
expDiagLog TCL_VARARGS_DEF(char *,arg1)
d152 3
a154 142
    char *fmt;
    va_list args;

    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((tsdPtr->diagToStderr == 0) && (tsdPtr->diagChannel == 0)) return;

    fmt = TCL_VARARGS_START(char *,arg1,args);

    (void) vsprintf(bigbuf,fmt,args);

    expDiagWriteBytes(bigbuf,-1);
    if (tsdPtr->diagToStderr) {
	fprintf(stderr,bigbuf);
	if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
    }

    va_end(args);
}


/* expDiagLog for unformatted strings
   this also takes care of arbitrary large strings */
void
expDiagLogU(str)
    char *str;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((tsdPtr->diagToStderr == 0) && (tsdPtr->diagChannel == 0)) return;

    expDiagWriteBytes(str,-1);

    if (tsdPtr->diagToStderr) {
	fprintf(stderr,str);
	if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,str,-1);
    }
}

void
expDiagToStderrSet(val)
    int val;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->diagToStderr = val;
}
    

int
expDiagToStderrGet() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->diagToStderr;
}

Tcl_Channel
expDiagChannelGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->diagChannel;
}

int
expDiagChannelClose()
    Tcl_Interp *interp;
    Tcl_Channel channel;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (tsdPtr->diagChannel) return;
    Tcl_UnregisterChannel(tsdPtr->diagChannel);
    Tcl_DStringFree(tsdPtr->diagFilename);
    tsdPtr->diagChannel = 0;
}

/* currently this registers the channel, however the exp_internal
   command doesn't currently give the channel name to the user so
   this is kind of useless - but we might change this someday */
int
expDiagChannelOpen(interp,filename)
    char *filename;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *newfilename;

    Tcl_ResetResult(interp);
    newfilename = Tcl_TranslateFileName(interp,filename,tsdPtr->diagFilename);
    if (!newfilename) return TCL_ERROR;

    /* Tcl_TildeSubst doesn't store into dstring */
    /* if no ~, so force string into dstring */
    /* this is only needed so that next time around */
    /* we can get dstring for -info if necessary */
    if (Tcl_DStringValue(tsdPtr->diagFilename)[0] == '\0') {
	Tcl_DStringAppend(tsdPtr->diagFilename,argv[0],-1);
    }

    tsdPtr->diagChannel = Tcl_OpenFileChannel(interp,newfilename,"a",0777);
    if (!tsdPtr->diagChannel) {
	Tcl_DStringFree(tsdPtr->diagFilename);
	return TCL_ERROR;
    }
    Tcl_RegisterChannel(interp,diagChannel);
    Tcl_SetChannelOption(interp,diagChannel,"-buffering","none");
    return TCL_OK;
}

void
expDiagWriteObj(str)
    char *str;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_WriteObj(tsdPtr->diagChannel,str);
}

/* write 8-bit bytes */
void
expDiagWriteBytes(str,len)
    char *str;
    int len;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_Write(tsdPtr->diagChannel,str,len)
}

/* write UTF chars */
void
expDiagWriteChars(str,len)
    char *str;
    int len;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!tsdPtr->diagChannel) return;

    Tcl_WriteChars(tsdPtr->diagChannel,str,len);
d158 1
a158 1
expDiagFilename()
d160 1
a160 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d162 2
a163 2
    return Tcl_DStringValue(tsdPtr->diagFilename);
}
d165 74
a238 17
void
expLogChannelClose()
    Tcl_Interp *interp;
    Tcl_Channel channel;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (tsdPtr->logChannel) return;

    if (Tcl_DStringLength(tsdPtr->logFilename)) {
	/* it's a channel that we created */
	Tcl_UnregisterChannel(tsdPtr->logChannel);
	Tcl_DStringFree(tsdPtr->logFilename);
    } else {
	/* it's a channel that tcl::open created */
	if (!tsdPtr->logLeaveOpen) {
	    Tcl_UnregisterChannel(tsdPtr->logChannel);
a239 118
    }
    tsdPtr->logChannel = 0;
    tsdPtr->logAll = 0; /* can't write to log if none open! */
}

/* currently this registers the channel, however the exp_log_file
   command doesn't currently give the channel name to the user so
   this is kind of useless - but we might change this someday */
int
expLogChannelOpen(interp,filename,append)
    Tcl_Interp *interp;
    char *filename;
    int append;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *newfilename;
    mode = (append?"a":"w");

    Tcl_ResetResult(interp);
    newfilename = Tcl_TranslateFileName(interp,filename,tsdPtr->logFilename);
    if (!newfilename) return TCL_ERROR;

    /* Tcl_TildeSubst doesn't store into dstring */
    /* if no ~, so force string into dstring */
    /* this is only needed so that next time around */
    /* we can get dstring for -info if necessary */
    if (Tcl_DStringValue(tsdPtr->logFilename)[0] == '\0') {
	Tcl_DStringAppend(tsdPtr->logFilename,argv[0],-1);
    }

    tsdPtr->logChannel = Tcl_OpenFileChannel(interp,newfilename,mode,0777);
    if (!tsdPtr->logChannel) {
	Tcl_DStringFree(tsdPtr->logFilename);
	return TCL_ERROR;
    }
    Tcl_RegisterChannel(interp,logChannel);
    Tcl_SetChannelOption(interp,logChannel,"-buffering","none");
    return TCL_OK;
}

int
expLogAppendGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logAppend;
}

int
expLogAppendSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logAppend = app;
}

int
expLogAllGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logAll;
}

int
expLogAllSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logAll = app;
}

int
expLogToStdoutGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logToStdout;
}

int
expLogToStdoutSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logToStdout = app;
}

int
expLogLeaveOpenGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logLeaveOpen;
}

int
expLogLeaveOpenSet(app)
    int app;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->logLeaveOpen = app;
}

Tcl_Channel
expLogChannelGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->logChannel;
}

/* to set to a pre-opened channel (presumably by tcl::open)
void
expLogChannelSet(channel)
    Tcl_Channel channel;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* indicate it is from Tcl, by zeroing the name */
    Tcl_DStringSetLength(tsdPtr->logFilename,0);

    tsdPtr->logChannel = channel;
d242 2
d245 1
a245 20
expLogChannelSet(interp,name)
    Tcl_Channel *channel;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    int mode;
    
    if (0 == (tsdPtr->logChannel = Tcl_GetChannel(interp,name,&mode))) {
	return TCL_ERROR;
    }
    if (!(mode & TCL_WRITABLE)) {
	tsdPtr->logChannel = 0;
	exp_error(interp,"channel is not writable");
	return TCL_ERROR;
    }
    return TCL_OK;
}

char *
expLogFilenameGet()
d247 2
a248 4
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return Tcl_DStringValue(tsdPtr->logFilename);
}
d250 8
a257 38
int
expLogUserGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    return tsdPtr->logUser;
}

void
expLogUserSet(logUser)
    int logUser;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->logUser = logUser;
}



/* generate printable versions of random ASCII strings.  Primarily used */
/* in diagnostic mode, "expect -d" */
static char *
exp_printify(s)
{
	static int destlen = 0;
	static char *dest = 0;
	char *d;		/* ptr into dest */
	unsigned int need;
	Tcl_UniChar ch;

	if (s == 0) return("<null>");

	/* worst case is every character takes 4 to printify */
	need = strlen(s)*6 + 1;
	if (need > destlen) {
		if (dest) ckfree(dest);
		dest = ckalloc(need);
		destlen = need;
d259 1
a259 60

	for (d = dest;*s;) {
	    s += Tcl_UtfToUniChar(s, &ch);
	    if (ch == '\r') {
		strcpy(d,"\\r");		d += 2;
	    } else if (ch == '\n') {
		strcpy(d,"\\n");		d += 2;
	    } else if (ch == '\t') {
		strcpy(d,"\\t");		d += 2;
	    } else if ((ch < 0x80) && isprint(UCHAR(ch))) {
		*d = (char)ch;			d += 1;
	    } else {
		sprintf(d,"\\u%04x",ch);	d += 6;
	    }
	}
	*d = '\0';
	return(dest);
}

char *
expPrintifyObj(obj)
    Tcl_Obj *obj;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* don't bother writing into bigbuf if we're not going to ever use it */
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return(tsdPtr->bigbuf);
    
    return exp_printify(Tcl_GetString(obj));
}

char *
expPrintify(s) /* INTL */
char *s;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* don't bother writing into bigbuf if we're not going to ever use it */
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return(tsdPtr->bigbuf);

    return exp_printify(s);
}
 
void
expDiagInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    Tcl_DStringInit(&tsdPtr->diagFilename);
    tsdPtr->diagChannel = 0;
    tsdPtr->diagToStderr = 0;
}

expLogInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    Tcl_DStringInit(&tsdPtr->logFilename);
    tsdPtr->logChannel = 0;
    tsdPtr-> = 0;
d261 1
@


5.28.1.1.2.3
log
@made stuff compile
@
text
@d212 1
a212 1
expErrorLogU(buf)
d214 2
d569 1
a569 1
expPrintifyReal(s)
d614 1
a614 1
    return expPrintifyReal(Tcl_GetString(obj));
d626 1
a626 1
    return expPrintifyReal(s);
@


5.28.1.1.2.4
log
@Fixed interact of all but regexp probs.
@
text
@a21 1
#include "exp_command.h"
d25 1
a25 1
    Tcl_Channel diagChannel;
d29 1
a29 1
    Tcl_Channel logChannel;
d88 1
a88 1
    wc = Tcl_Write(esPtr->channel,buf,lenBytes);
d109 1
a109 1
    expDiagWriteChars(buf,-1);
d111 1
a111 1
	Tcl_WriteChars(tsdPtr->logChannel, buf, -1);
d202 1
a202 1
    if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,bigbuf,-1);
a214 2
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

d218 1
a218 1
    if (tsdPtr->logChannel) Tcl_WriteChars(tsdPtr->logChannel,buf,-1);
d290 2
a291 2
void
expDiagChannelClose(interp)
d293 1
d298 2
a299 2
    Tcl_UnregisterChannel(interp,tsdPtr->diagChannel);
    Tcl_DStringFree(&tsdPtr->diagFilename);
a307 1
    Tcl_Interp *interp;
d314 1
a314 1
    newfilename = Tcl_TranslateFileName(interp,filename,&tsdPtr->diagFilename);
d321 2
a322 2
    if (Tcl_DStringValue(&tsdPtr->diagFilename)[0] == '\0') {
	Tcl_DStringAppend(&tsdPtr->diagFilename,filename,-1);
d327 1
a327 1
	Tcl_DStringFree(&tsdPtr->diagFilename);
d330 2
a331 2
    Tcl_RegisterChannel(interp,tsdPtr->diagChannel);
    Tcl_SetChannelOption(interp,tsdPtr->diagChannel,"-buffering","none");
d336 2
a337 2
expDiagWriteObj(obj)
    Tcl_Obj *obj;
d343 1
a343 1
    Tcl_WriteObj(tsdPtr->diagChannel,obj);
d356 1
a356 1
    Tcl_Write(tsdPtr->diagChannel,str,len);
d377 1
a377 1
    return Tcl_DStringValue(&tsdPtr->diagFilename);
d381 1
a381 1
expLogChannelClose(interp)
d383 1
d389 1
a389 1
    if (Tcl_DStringLength(&tsdPtr->logFilename)) {
d391 2
a392 2
	Tcl_UnregisterChannel(interp,tsdPtr->logChannel);
	Tcl_DStringFree(&tsdPtr->logFilename);
d396 1
a396 1
	    Tcl_UnregisterChannel(interp,tsdPtr->logChannel);
d414 1
a414 3
    char mode[2] = "w";   /* doing it this way forces the null terminator */

    if (append) mode[0] = 'a';
d417 1
a417 1
    newfilename = Tcl_TranslateFileName(interp,filename,&tsdPtr->logFilename);
d424 2
a425 2
    if (Tcl_DStringValue(&tsdPtr->logFilename)[0] == '\0') {
	Tcl_DStringAppend(&tsdPtr->logFilename,filename,-1);
d430 1
a430 1
	Tcl_DStringFree(&tsdPtr->logFilename);
d433 2
a434 2
    Tcl_RegisterChannel(interp,tsdPtr->logChannel);
    Tcl_SetChannelOption(interp,tsdPtr->logChannel,"-buffering","none");
d445 1
a445 1
void
d460 1
a460 1
void
d472 1
a472 1
    return tsdPtr->logUser;
d475 1
a475 1
void
d480 1
a480 1
    tsdPtr->logUser = app;
d490 1
a490 1
void
d505 13
a517 1
/* to set to a pre-opened channel (presumably by tcl::open) */
@


5.28.1.1.2.5
log
@Everything but Dbg.c
@
text
@d512 1
a512 2
    Tcl_Interp *interp;
    char *name;
d534 1
a534 1
    return Tcl_DStringValue(&tsdPtr->logFilename);
a559 1
char *s;
d602 1
a602 1
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return((char *)0);
d614 1
a614 1
    if ((!tsdPtr->diagToStderr) && (!tsdPtr->diagChannel)) return((char *)0);
a628 1
void
d635 1
a635 1
    tsdPtr->logAll = TRUE;
@


5.28.1.1.2.6
log
@compiled!
@
text
@d91 1
a91 1
    if (tsdPtr->logChannel && ((esPtr->fdout == 1) || expDevttyIs(esPtr))) {
d137 1
a137 1
    expDiagWriteChars(buf,-1);
a469 1
    /* should probably confirm logChannel != 0 */
d638 1
a638 1
    tsdPtr->logAll = FALSE;
@


5.28.1.1.2.7
log
@more mods
@
text
@d89 1
a89 2
    if (esPtr->valid)
	wc = Tcl_Write(esPtr->channel,buf,lenBytes);
@


5.28.1.1.2.8
log
@Fixed interact's -input/-output.
More fixes to exp_eval_with_one_arg.
Now runs dislocate.
@
text
@a134 4

    /* hmm.... if stdout is closed such as by disconnect, loguser
       should be forced FALSE */

d136 2
a137 6
    if (tsdPtr->logUser && (!expStdinoutIs(esPtr)) && (!expDevttyIs(esPtr))) {
	ExpState *stdinout = expStdinoutGet();
	if (stdinout->valid) {
	    Tcl_WriteChars(stdinout->channel,buf,-1);
	}
    }
a640 1
    tsdPtr->logUser = TRUE;
@


5.28.1.1.2.9
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d130 1
a236 1
/*VARARGS*/
d534 1
a534 1
	Tcl_SetResult(interp,"channel is not writable",TCL_VOLATILE);
@


5.28.1.1.2.10
log
@Fixed exp_internal (didn't work at all!) and log_file.
@
text
@d308 1
a308 1
    if (!tsdPtr->diagChannel) return;
d398 1
a398 1
    if (!tsdPtr->logChannel) return;
@


5.28.1.1.2.11
log
@In interact, fixed encoding bug and -echo bug.
Made Makefile.in support CodeCenter better.
Fixed regexp bug in debugger.
@
text
@d90 1
a90 1
	wc = Tcl_WriteChars(esPtr->channel,buf,lenBytes);
d93 1
a93 1
	Tcl_WriteChars(tsdPtr->logChannel,buf,lenBytes);
@


5.28.1.1.2.12
log
@Fixes for picky HP compiler.
@
text
@d425 1
a425 1
    char mode[2];
d427 1
a427 5
    if (append) {
      strcpy(mode,"a");
    } else {
      strcpy(mode,"w");
    }
@


5.28.1.1.2.13
log
@Fixes to library.
Testing new fix to system command.
@
text
@d171 1
a171 1
    if (LOGUSER) fprintf(stdout,"%s",bigbuf);
d210 1
a210 1
    fprintf(stderr,"%s",bigbuf);
d253 1
a253 1
	fprintf(stderr,"%s",bigbuf);
d274 1
a274 1
	fprintf(stderr,"%s",str);
@


