head	5.30;
access;
symbols
	expect_5_45:5.30
	expect_6_branch:5.29.0.8
	expect_5_44_1_15:5.29
	activestate_win32_port_start:5.29
	win32-jump-point-1:5.29
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.4
	scriptics-sc-2-0-b5:5.28.1.1.2.4
	scriptics-sc-2-0-fixed:5.28.1.1.2.4
	scriptics-sc-2-0-b2:5.28.1.1.2.4
	scriptics-sc-2-0-b1:5.28.1.1.2.4
	scriptics-sc-1-1:5.28.1.1.2.4
	scriptics-sc-1-1-b1:5.28.1.1.2.4
	scriptics-sc-1-1-branch:5.28.1.1.2.4.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.4
	scriptics-sc-1-0:5.28.1.1.2.4
	scriptics-sc-1-0-branch:5.28.1.1.2.4.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.4
	expect-5-31-3:5.28.1.1.2.4
	scriptics-bc-1-0-b1:5.28.1.1.2.4
	scriptics-tclpro-1-3-0:5.28.1.1.2.4
	scriptics-tclpro-1-3-b4:5.28.1.1.2.4
	scriptics-tclpro-1-3-b3:5.28.1.1.2.4
	expect-5-31:5.28.1.1.2.4
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.30
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.07;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.22.05.03.31;	author libes;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.23.17.25.19;	author libes;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.28.06.29.28;	author libes;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.06.29.02.27.48;	author libes;	state Exp;
branches;
next	;


desc
@@


5.30
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# dislocate - allow disconnection and reconnection to a background program
# Author: Don Libes, NIST

exp_version -exit 5.1

# The following code attempts to intuit whether cat buffers by default.
# The -u flag is required on HPUX (8 and 9) and IBM AIX (3.2) systems.
if {[file exists $exp_exec_library/cat-buffers]} {
    set catflags "-u"
} else {
    set catflags ""
}
# If this fails, you can also force it by commenting in one of the following.
# Or, you can use the -catu flag to the script.
#set catflags ""
#set catflags "-u"

set escape \035			;# control-right-bracket
set escape_printable "^\]"

set pidfile "~/.dislocate"
set prefix "disc"
set timeout -1
set debug_flag 0

while {$argc} {
    set flag [lindex $argv 0]
    switch -- $flag \
	    "-catu" {
	set catflags "-u"
	set argv [lrange $argv 1 end]
	incr argc -1
    } "-escape" {
	set escape [lindex $argv 1]
	set escape_printable $escape
	set argv [lrange $argv 2 end]
	incr argc -2
    } "-debug" {
	log_file [lindex $argv 1]
	set debug_flag 1
	set argv [lrange $argv 2 end]
	incr argc -2
    } default {
	break
    }
}

# These are correct from parent's point of view.
# In child, we will reset these so that they appear backwards
# thus allowing following two routines to be used by both parent and child
set  infifosuffix ".i"
set outfifosuffix ".o"

proc infifoname {pid} {
    return "/tmp/$::prefix$pid$::infifosuffix"
}

proc outfifoname {pid} {
    return "/tmp/$::prefix$pid$::outfifosuffix"
}

proc pid_remove {pid} {
    say "removing $pid $::proc($pid)"

    unset ::date($pid)
    unset ::proc($pid)
}

# lines in data file look like this:
# pid#date-started#argv

# allow element lookups on empty arrays
set date(dummy) dummy;	unset date(dummy)
set proc(dummy) dummy;	unset proc(dummy)

proc say {msg} {
    if {!$::debug_flag} return

    if {[catch {puts "parent: $msg"}]} {
	send_log "child: $msg\n"
    }
}

# load pidfile into memory
proc pidfile_read {} {
    global date proc pidfile

    say "opening $pidfile"
    if {[catch {open $pidfile} fp]} return

    #
    # read info from file
    #

    say "reading pidfile"
    set line 0
    while {[gets $fp buf]!=-1} {
	# while pid and date can't have # in it, proc can
	if {[regexp "(\[^#]*)#(\[^#]*)#(.*)" $buf junk pid xdate xproc]} {
	    set date($pid) $xdate
	    set proc($pid) $xproc
	} else {
	    puts "warning: inconsistency in $pidfile line $line"
	}
	incr line
    }
    close $fp
    say "read $line entries"

    #
    # see if pids and fifos are still around
    #

    foreach pid [array names date] {
	if {$pid && [catch {exec /bin/kill -0 $pid}]} {
	    say "$pid no longer exists, removing"
	    pid_remove $pid
	    continue
	}

	# pid still there, see if fifos are
	if {![file exists [infifoname $pid]] || ![file exists [outfifoname $pid]]} {
	    say "$pid fifos no longer exists, removing"
	    pid_remove $pid
	    continue
	}
    }
}

proc pidfile_write {} {
    global pidfile date proc

    say "writing pidfile"

    set fp [open $pidfile w]
    foreach pid [array names date] {
	puts $fp "$pid#$date($pid)#$proc($pid)"
	say "wrote $pid#$date($pid)#$proc($pid)"
    }
    close $fp
}

proc fifo_pair_remove {pid} {
    global date proc prefix

    pidfile_read
    pid_remove $pid
    pidfile_write

    file delete -force [infifoname $pid] [outfifoname $pid]
}

proc fifo_pair_create {pid argdate argv} {
    global prefix date proc

    pidfile_read
    set date($pid) $argdate
    set proc($pid) $argv
    pidfile_write

    mkfifo [infifoname $pid]
    mkfifo [outfifoname $pid]
}

proc mkfifo {f} {
    if {[file exists $f]} {
	say "uh, fifo already exists?"
	return
    }

    if {0==[catch {exec mkfifo $f}]} return		;# POSIX
    if {0==[catch {exec mknod $f p}]} return
    # some systems put mknod in wierd places
    if {0==[catch {exec /usr/etc/mknod $f p}]} return	;# Sun
    if {0==[catch {exec /etc/mknod $f p}]} return	;# AIX, Cray
    puts "Couldn't figure out how to make a fifo - where is mknod?"
    exit
}

proc child {argdate argv} {
    global infifosuffix outfifosuffix

    disconnect
    # these are backwards from the child's point of view so that
    # we can make everything else look "right"
    set  infifosuffix ".o"
    set outfifosuffix ".i"
    set pid 0

    eval spawn $argv
    set proc_spawn_id $spawn_id

    while {1} {
	say "opening [infifoname $pid] for read"
	
	set catfid [open "|cat $::catflags < [infifoname $pid]" "r"]
	set ::catpid $catfid
	spawn -open $catfid
	set in $spawn_id

	say "opening [outfifoname $pid] for write"
	spawn -open [open [outfifoname $pid] w]
	set out $spawn_id

	fifo_pair_remove $pid

	say "interacting"
	interact {
	    -u $proc_spawn_id eof exit
	    -output $out
	    -input $in
	}

	# parent has closed connection
	say "parent closed connection"
	catch {close -i $in}
	catch {wait -i $in}
	catch {close -i $out}
	catch {wait -i $out}

	# switch to using real pid
	set pid [pid]
	# put entry back
	fifo_pair_create $pid $argdate $argv
    }
}

proc escape {} {
    # export process handles so that user can get at them
    global in out

    puts "\nto disconnect, enter: exit (or ^D)"
    puts "to suspend, press appropriate job control sequence"
    puts "to return to process, enter: return"
    interpreter -eof exit
    puts "returning ..."
}

# interactively query user to choose process, return pid
proc choose {} {
    while {1} {
	send_user "enter # or pid: "
	expect_user -re "(.*)\n" {set buf $expect_out(1,string)}
	if {[info exists ::index($buf)]} {
	    set pid $::index($buf)
	} elseif {[info exists ::date($buf)]} {
	    set pid $buf
	} else {
	    puts "no such # or pid"
	    continue
	}
	return $pid
    }
}

if {$argc} {
    # initial creation occurs before fork because if we do it after
    # then either the child or the parent may have to spin retrying
    # the fifo open.  Unfortunately, we cannot know the pid ahead of
    # time so use "0".  This will be set to the real pid when the
    # parent does its initial disconnect.  There is no collision
    # problem because the fifos are deleted immediately anyway.

    set datearg [clock format [clock seconds]]

    fifo_pair_create 0 $datearg $argv

    # to debug by faking child, comment out fork and set pid to a
    # non-zero int, then you can read/write to pipes manually

    set pid [fork]
    say "after fork, pid = $pid"
    if {$pid==0} {
	child $datearg $argv
    }

    # parent thinks of child as pid==0 for reason given earlier
    set pid 0
}

say "examining pid"

if {![info exists pid]} {
    global fifos date proc

    say "pid does not exist"

    pidfile_read

    set count 0
    foreach pid [array names date] {
	incr count
    }

    if {$count==0} {
	puts "no connectable processes"
	exit
    } elseif {$count==1} {
	puts "one connectable process: $proc($pid)"
	puts "pid $pid, started $date($pid)"
	send_user "connect? \[y] "
	expect_user -re "(.*)\n" {set buf $expect_out(1,string)}
	if {$buf!="y" && $buf!=""} exit
    } else {
	puts "connectable processes:"
	set count 1
	puts " #   pid      date started      process"
	foreach pid [array names date] {
	    puts [format "%2d %6d  %.19s  %s" \
		    $count $pid $date($pid) $proc($pid)]
	    set index($count) $pid
	    incr count
	}
	set pid [choose]
    }
}

say "opening [outfifoname $pid] for write"
spawn -noecho -open [open [outfifoname $pid] w]
set out $spawn_id

say "opening [infifoname $pid] for read"
set catfid [open "|cat $catflags < [infifoname $pid]" "r"]
set catpid [pid $catfid]
spawn -noecho -open $catfid
set in $spawn_id

puts "Escape sequence is $escape_printable"

proc prompt1 {} {
    return "$::argv0[history nextid]> "
}

rename exit exitReal

proc exit {} {
    exec /bin/kill $::catpid
    exitReal
}

interact {
    -reset $escape escape
    -output $out
    -input $in
}


@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d1 8
a8 1
#!../expect --
@


5.28
log
@Initial revision
@
text
@d9 2
a10 2
if [file exists $exp_exec_library/cat-buffers] {
	set catflags "-u"
d12 1
a12 1
	set catflags ""
d28 19
a46 19
	set flag [lindex $argv 0]
	switch -- $flag \
	"-catu" {
		set catflags "-u"
		set argv [lrange $argv 1 end]
		incr argc -1
	} "-escape" {
		set escape [lindex $argv 1]
		set escape_printable $escape
		set argv [lrange $argv 2 end]
		incr argc -2
	} "-debug" {
		log_file [lindex $argv 1]
		set debug_flag 1
		set argv [lrange $argv 2 end]
		incr argc -2
	} default {
		break
	}
d56 1
a56 3
	global prefix infifosuffix

	return "/tmp/$prefix$pid$infifosuffix"
d60 1
a60 3
	global prefix outfifosuffix

	return "/tmp/$prefix$pid$outfifosuffix"
d64 1
a64 1
	global date proc
d66 2
a67 4
	say "removing $pid $proc($pid)"

	unset date($pid)
	unset proc($pid)
d70 1
a70 1
# lines in data file looks like this:
d77 8
d87 1
a87 1
	global date proc pidfile
d89 2
a90 1
	if [catch {open $pidfile} fp] return
d92 13
a104 15
	#
	# read info out of file
	#

	say "reading pidfile"
	set line 0
	while {[gets $fp buf]!=-1} {
		# while pid and date can't have # in it, proc can
		if [regexp "(\[^#]*)#(\[^#]*)#(.*)" $buf junk pid xdate xproc] {
			set date($pid) $xdate
			set proc($pid) $xproc
		} else {
			puts "warning: inconsistency in $pidfile line $line"
		}
		incr line
d106 21
a126 20
	close $fp
	say "read $line entries"

	#
	# see if pids and fifos are still around
	#

	foreach pid [array names date] {
		if {$pid && [catch {exec /bin/kill -0 $pid}]} {
			say "$pid no longer exists, removing"
			pid_remove $pid
			continue
		}

		# pid still there, see if fifos are
		if {![file exists [infifoname $pid]] || ![file exists [outfifoname $pid]]} {
			say "$pid fifos no longer exists, removing"
			pid_remove $pid
			continue
		}
d128 1
d132 1
a132 1
	global pidfile date proc
d134 1
a134 1
	say "writing pidfile"
d136 6
a141 6
	set fp [open $pidfile w]
	foreach pid [array names date] {
		puts $fp "$pid#$date($pid)#$proc($pid)"
		say "wrote $pid#$date($pid)#$proc($pid)"
	}
	close $fp
d145 1
a145 1
	global date proc prefix
d147 3
a149 3
	pidfile_read
	pid_remove $pid
	pidfile_write
d151 1
a151 1
	catch {exec rm -f [infifoname $pid] [outfifoname $pid]}
d155 1
a155 1
	global prefix date proc
d157 4
a160 4
	pidfile_read
	set date($pid) $argdate
	set proc($pid) $argv
	pidfile_write
d162 2
a163 2
	mkfifo [infifoname $pid]
	mkfifo [outfifoname $pid]
d167 12
a178 12
	if [file exists $f] {
		say "uh, fifo already exists?"
		return
	}

	if 0==[catch {exec mkfifo $f}] return		;# POSIX
	if 0==[catch {exec mknod $f p}] return
	# some systems put mknod in wierd places
	if 0==[catch {exec /usr/etc/mknod $f p}] return	;# Sun
	if 0==[catch {exec /etc/mknod $f p}] return	;# AIX, Cray
	puts "Couldn't figure out how to make a fifo - where is mknod?"
	exit
d182 1
a182 3
	global catflags infifosuffix outfifosuffix

	disconnect
d184 43
a226 49
	# these are backwards from the child's point of view so that
	# we can make everything else look "right"
	set  infifosuffix ".o"
	set outfifosuffix ".i"
	set pid 0

	eval spawn $argv
	set proc_spawn_id $spawn_id

	while {1} {
		say "opening [infifoname $pid] for read"
	 	spawn -open [open "|cat $catflags < [infifoname $pid]" "r"]
		set in $spawn_id

		say "opening [outfifoname $pid] for write"
		spawn -open [open [outfifoname $pid] w]
		set out $spawn_id

		fifo_pair_remove $pid

		say "interacting"
		interact {
			-u $proc_spawn_id eof exit
			-output $out
			-input $in
		}

		# parent has closed connection
		say "parent closed connection"
		catch {close -i $in}
		catch {wait -i $in}
		catch {close -i $out}
		catch {wait -i $out}

		# switch to using real pid
		set pid [pid]
		# put entry back
		fifo_pair_create $pid $argdate $argv
	}
}

proc say {msg} {
	global debug_flag

	if !$debug_flag return

	if [catch {puts "parent: $msg"}] {
		send_log "child: $msg\n"
	}
d230 2
a231 2
	# export process handles so that user can get at them
	global in out
d233 5
a237 5
	puts "\nto disconnect, enter: exit (or ^D)"
	puts "to suspend, press appropriate job control sequence"
	puts "to return to process, enter: return"
	interpreter
	puts "returning ..."
d242 10
a251 14
	global index date

	while 1 {
		send_user "enter # or pid: "
		expect_user -re "(.*)\n" {set buf $expect_out(1,string)}
		if [info exists index($buf)] {
			set pid $index($buf)
		} elseif [info exists date($buf)] {
			set pid $buf
		} else {
			puts "no such # or pid"
			continue
		}
		return $pid
d253 2
d258 22
a279 17
	# initial creation occurs before fork because if we do it after
	# then either the child or the parent may have to spin retrying
	# the fifo open.  Unfortunately, we cannot know the pid ahead of
	# time so use "0".  This will be set to the real pid when the
	# parent does its initial disconnect.  There is no collision
	# problem because the fifos are deleted immediately anyway.

	set datearg [exec date]
	fifo_pair_create 0 $datearg $argv

	set pid [fork]
	say "after fork, pid = $pid"
	if $pid==0 {
		child $datearg $argv
	}
	# parent thinks of child as pid==0 for reason given earlier
	set pid 0
d284 4
a287 2
if ![info exists pid] {
	global fifos date proc
d289 1
a289 1
	say "pid does not exist"
d291 4
a294 1
	pidfile_read
d296 13
a308 1
	set count 0
d310 4
a313 23
		incr count
	}

	if $count==0 {
		puts "no connectable processes"
		exit
	} elseif $count==1 {
		puts "one connectable process: $proc($pid)"
		puts "pid $pid, started $date($pid)"
		send_user "connect? \[y] "
		expect_user -re "(.*)\n" {set buf $expect_out(1,string)}
		if {$buf!="y" && $buf!=""} exit
	} else {
		puts "connectable processes:"
		set count 1
		puts " #   pid      date started      process"
		foreach pid [array names date] {
			puts [format "%2d %6d  %.19s  %s" \
				$count $pid $date($pid) $proc($pid)]
			set index($count) $pid
			incr count
		}
		set pid [choose]
d315 2
d324 3
a326 1
spawn -noecho -open [open "|cat $catflags < [infifoname $pid]" "r"]
d332 2
a333 1
	global argv0
d335 5
a339 1
	return "$argv0[history nextid]> "
d343 3
a345 3
	-reset $escape escape
	-output $out
	-input $in
d347 1
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@fixed examples
@
text
@d9 2
a10 2
if {[file exists $exp_exec_library/cat-buffers]} {
    set catflags "-u"
d12 1
a12 1
    set catflags ""
d28 19
a46 19
    set flag [lindex $argv 0]
    switch -- $flag \
	    "-catu" {
	set catflags "-u"
	set argv [lrange $argv 1 end]
	incr argc -1
    } "-escape" {
	set escape [lindex $argv 1]
	set escape_printable $escape
	set argv [lrange $argv 2 end]
	incr argc -2
    } "-debug" {
	log_file [lindex $argv 1]
	set debug_flag 1
	set argv [lrange $argv 2 end]
	incr argc -2
    } default {
	break
    }
d56 3
a58 1
    return "/tmp/$::prefix$pid$::infifosuffix"
d62 3
a64 1
    return "/tmp/$::prefix$pid$::outfifosuffix"
d68 1
a68 1
    say "removing $pid $::proc($pid)"
d70 4
a73 2
    unset ::date($pid)
    unset ::proc($pid)
d76 1
a76 1
# lines in data file look like this:
a82 8
proc say {msg} {
    if {!$::debug_flag} return

    if {[catch {puts "parent: $msg"}]} {
	send_log "child: $msg\n"
    }
}

d85 1
a85 1
    global date proc pidfile
d87 1
a87 2
    say "opening $pidfile"
    if {[catch {open $pidfile} fp]} return
d89 15
a103 13
    #
    # read info from file
    #

    say "reading pidfile"
    set line 0
    while {[gets $fp buf]!=-1} {
	# while pid and date can't have # in it, proc can
	if {[regexp "(\[^#]*)#(\[^#]*)#(.*)" $buf junk pid xdate xproc]} {
	    set date($pid) $xdate
	    set proc($pid) $xproc
	} else {
	    puts "warning: inconsistency in $pidfile line $line"
d105 20
a124 21
	incr line
    }
    close $fp
    say "read $line entries"

    #
    # see if pids and fifos are still around
    #

    foreach pid [array names date] {
	if {$pid && [catch {exec /bin/kill -0 $pid}]} {
	    say "$pid no longer exists, removing"
	    pid_remove $pid
	    continue
	}

	# pid still there, see if fifos are
	if {![file exists [infifoname $pid]] || ![file exists [outfifoname $pid]]} {
	    say "$pid fifos no longer exists, removing"
	    pid_remove $pid
	    continue
a125 1
    }
d129 1
a129 1
    global pidfile date proc
d131 1
a131 1
    say "writing pidfile"
d133 6
a138 6
    set fp [open $pidfile w]
    foreach pid [array names date] {
	puts $fp "$pid#$date($pid)#$proc($pid)"
	say "wrote $pid#$date($pid)#$proc($pid)"
    }
    close $fp
d142 1
a142 1
    global date proc prefix
d144 3
a146 3
    pidfile_read
    pid_remove $pid
    pidfile_write
d148 1
a148 1
    file delete -force [infifoname $pid] [outfifoname $pid]
d152 1
a152 1
    global prefix date proc
d154 4
a157 4
    pidfile_read
    set date($pid) $argdate
    set proc($pid) $argv
    pidfile_write
d159 2
a160 2
    mkfifo [infifoname $pid]
    mkfifo [outfifoname $pid]
d164 12
a175 12
    if {[file exists $f]} {
	say "uh, fifo already exists?"
	return
    }

    if {0==[catch {exec mkfifo $f}]} return		;# POSIX
    if {0==[catch {exec mknod $f p}]} return
    # some systems put mknod in wierd places
    if {0==[catch {exec /usr/etc/mknod $f p}]} return	;# Sun
    if {0==[catch {exec /etc/mknod $f p}]} return	;# AIX, Cray
    puts "Couldn't figure out how to make a fifo - where is mknod?"
    exit
d179 1
a179 1
    global infifosuffix outfifosuffix
d181 1
a181 1
    disconnect
d183 49
a231 39
    # these are backwards from the child's point of view so that
    # we can make everything else look "right"
    set  infifosuffix ".o"
    set outfifosuffix ".i"
    set pid 0

    eval spawn $argv
    set proc_spawn_id $spawn_id

    while {1} {
	say "opening [infifoname $pid] for read"
	spawn -open [open "|cat $::catflags < [infifoname $pid]" "r"]
	set in $spawn_id

	say "opening [outfifoname $pid] for write"
	spawn -open [open [outfifoname $pid] w]
	set out $spawn_id

	fifo_pair_remove $pid

	say "interacting"
	interact {
	    -u $proc_spawn_id eof exit
	    -output $out
	    -input $in
	}

	# parent has closed connection
	say "parent closed connection"
	catch {close -i $in}
	catch {wait -i $in}
	catch {close -i $out}
	catch {wait -i $out}

	# switch to using real pid
	set pid [pid]
	# put entry back
	fifo_pair_create $pid $argdate $argv
    }
d235 2
a236 2
    # export process handles so that user can get at them
    global in out
d238 5
a242 5
    puts "\nto disconnect, enter: exit (or ^D)"
    puts "to suspend, press appropriate job control sequence"
    puts "to return to process, enter: return"
    interpreter
    puts "returning ..."
d247 14
a260 10
    while 1 {
	send_user "enter # or pid: "
	expect_user -re "(.*)\n" {set buf $expect_out(1,string)}
	if {[info exists ::index($buf)]} {
	    set pid $::index($buf)
	} elseif {[info exists ::date($buf)]} {
	    set pid $buf
	} else {
	    puts "no such # or pid"
	    continue
a261 2
	return $pid
    }
d265 17
a281 19
    # initial creation occurs before fork because if we do it after
    # then either the child or the parent may have to spin retrying
    # the fifo open.  Unfortunately, we cannot know the pid ahead of
    # time so use "0".  This will be set to the real pid when the
    # parent does its initial disconnect.  There is no collision
    # problem because the fifos are deleted immediately anyway.

    set datearg [clock format [clock seconds]]

    fifo_pair_create 0 $datearg $argv
after 4000

    set pid [fork]
    say "after fork, pid = $pid"
    if {$pid==0} {
	child $datearg $argv
    }
    # parent thinks of child as pid==0 for reason given earlier
    set pid 0
d286 2
a287 2
if {![info exists pid]} {
    global fifos date proc
d289 1
a289 1
    say "pid does not exist"
d291 1
a291 1
    pidfile_read
d293 4
a296 4
    set count 0
    foreach pid [array names date] {
	incr count
    }
d298 20
a317 18
    if {$count==0} {
	puts "no connectable processes"
	exit
    } elseif {$count==1} {
	puts "one connectable process: $proc($pid)"
	puts "pid $pid, started $date($pid)"
	send_user "connect? \[y] "
	expect_user -re "(.*)\n" {set buf $expect_out(1,string)}
	if {$buf!="y" && $buf!=""} exit
    } else {
	puts "connectable processes:"
	set count 1
	puts " #   pid      date started      process"
	foreach pid [array names date] {
	    puts [format "%2d %6d  %.19s  %s" \
		    $count $pid $date($pid) $proc($pid)]
	    set index($count) $pid
	    incr count
a318 2
	set pid [choose]
    }
d332 3
a334 1
    return "$::argv0[history nextid]> "
d338 3
a340 3
    -reset $escape escape
    -output $out
    -input $in
@


5.28.1.1.2.2
log
@Fixed interact's -input/-output.
More fixes to exp_eval_with_one_arg.
Now runs dislocate.
@
text
@d185 1
d266 1
a266 3

    # to debug by faking child, comment out fork and set pid to a
    # non-zero int, then you can read/write to pipes manually
@


5.28.1.1.2.3
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d196 1
a196 4
	
	set catfid [open "|cat $::catflags < [infifoname $pid]" "r"]
	set ::catpid $catfid
	spawn -open $catfid
d233 1
a233 1
    interpreter -eof exit
a273 1

d320 1
a320 3
set catfid [open "|cat $catflags < [infifoname $pid]" "r"]
set catpid [pid $catfid]
spawn -noecho -open $catfid
a328 7
rename exit exitReal

proc exit {} {
    exec /bin/kill $::catpid
    exitReal
}

a333 1

@


5.28.1.1.2.4
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d242 1
a242 1
    while {1} {
@


