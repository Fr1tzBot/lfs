head	5.30;
access;
symbols
	expect_5_45:5.30
	expect_6_branch:5.29.0.8
	expect_5_44_1_15:5.29
	activestate_win32_port_start:5.29
	win32-jump-point-1:5.29
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.1
	scriptics-sc-2-0-b5:5.28.1.1.2.1
	scriptics-sc-2-0-fixed:5.28.1.1.2.1
	scriptics-sc-2-0-b2:5.28.1.1.2.1
	scriptics-sc-2-0-b1:5.28.1.1.2.1
	scriptics-sc-1-1:5.28.1.1.2.1
	scriptics-sc-1-1-b1:5.28.1.1.2.1
	scriptics-sc-1-1-branch:5.28.1.1.2.1.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.1
	scriptics-sc-1-0:5.28.1.1.2.1
	scriptics-sc-1-0-branch:5.28.1.1.2.1.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.1
	expect-5-31-3:5.28.1.1.2.1
	scriptics-bc-1-0-b1:5.28.1.1.2.1
	scriptics-tclpro-1-3-0:5.28.1.1.2.1
	scriptics-tclpro-1-3-b4:5.28.1.1.2.1
	scriptics-tclpro-1-3-b3:5.28.1.1.2.1
	expect-5-31:5.28.1.1.2.1
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.30
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.06;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.29.02.27.48;	author libes;	state Exp;
branches;
next	;


desc
@@


5.30
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# expect script to connect two UNIX chess programs together.
# written by Don Libes - May 9, 1990

# Note, this depends on the "usual" UNIX chess output.  Other chess programs
# will almost certainly not work.

# Moves and counter-moves are printed out in different formats, sigh...
# But I guess that's what makes this Expect script challenging to write.
# In particular, the 1st player outputs:
#
# p/k2-k4		(echo from 2nd player)
# 1. ... p/k2-k4	(reprint it with a number in front - god knows why)
# 2. n/kn1-kb3		(our new move)
#
# and the 2nd player outputs the following
#
# n/kn1-kb3		(echo from first player)
# 2. n/kn1-kb3		(reprint it as above, but differently - god knows why)
# 2. ... p/k4-k5	(our new countermove - written differently, of course)

set timeout -1;			# wait forever
expect_before {
    -i $any_spawn_id eof {
	send_user "player resigned!\n"
	exit
    }
}

# start things rolling
spawn chess
set id1 $spawn_id
expect "Chess\r\n"
send "first\r"
# read_first_move
expect -re "1. (.*)\n"

spawn chess
set id2 $spawn_id
expect "Chess\r\n"
send $expect_out(1,string)

while {1} {
    expect {
	-i $id2 -re "\\.\\. (.*)\n" {
	    send -i $id1 $expect_out(1,string)
	}
	-i $id1 -re "\\.\\. .*\\. (.*)\n" {
	    send -i $id2 $expect_out(1,string)
	}
    }
}
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d1 8
a8 1
#!../expect -f
@


5.28
log
@Initial revision
@
text
@d24 4
a27 4
	-i $any_spawn_id eof {
		send_user "player resigned!\n"
		exit
	}
d43 7
a49 8
for {} 1 {} {
	expect {
		-i $id2 -re "\\.\\. (.*)\n" {
			send -i $id1 $expect_out(1,string)
		}
		-i $id1 -re "\\.\\. .*\\. (.*)\n" {
			send -i $id2 $expect_out(1,string)
		}
d51 1
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d24 4
a27 4
    -i $any_spawn_id eof {
	send_user "player resigned!\n"
	exit
    }
d43 8
a50 7
while {1} {
    expect {
	-i $id2 -re "\\.\\. (.*)\n" {
	    send -i $id1 $expect_out(1,string)
	}
	-i $id1 -re "\\.\\. .*\\. (.*)\n" {
	    send -i $id2 $expect_out(1,string)
a51 1
    }
@

