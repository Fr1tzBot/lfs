head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.2
	telco-tec-win32-take2-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2002.03.12.16.42.07;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.12.16.42.07;	author davygrvy;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.12.18.10.43;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.22.05.27.00;	author davygrvy;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.08.30.02.49.52;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file TclHash.hpp was initially added on branch telco-tec-win32-take2-branch.
@
text
@@


1.1.2.1
log
@Wait a sec.  I'm not happy with the STL's map template.  It adds too much bloat.  Let's go back to Tcl's hash tables.
@
text
@a0 92
/*
 ------------------------------------------------------------------------------
 * TclHash.hpp --
 *
 *   Tcl's hash table done as a template.
 *
 * Copyright (c) 1999-2001 Tomahawk Software Group
 *
 * See the file "license.txt" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: TclHash.hpp,v 1.9 2001/09/02 04:19:47 daveg Exp $
 ------------------------------------------------------------------------------
 */
#ifndef INC_tclhash_hpp__
#define INC_tclhash_hpp__

namespace Tcl {

    template <class T, int keytype = TCL_STRING_KEYS>
	class Hash
    {
    public:
	Hash () { Tcl_InitHashTable(&HashTbl, keytype); }
	~Hash () { Tcl_DeleteHashTable(&HashTbl); }
	Tcl_Obj *Stats ();
	int Add (void *key, T result);
	int Find (void *key, T *result);
	int Delete (void *key);

	Tcl_HashTable HashTbl;
    };

    template <class T, int keytype>
	Tcl_Obj *Hash<T, keytype>::Stats ()
    {
	char *stats;
	Tcl_Obj *oStats;

	stats = Tcl_HashStats(&HashTbl);
	oStats = Tcl_NewStringObj(stats, -1);
	ckfree(stats);
	return oStats;
    }

    template <class T, int keytype>
	int Hash<T, keytype>::Add (void *key, T result)
    {
	int created;
	Tcl_HashEntry *entryPtr;

	entryPtr = Tcl_CreateHashEntry(&HashTbl, static_cast<const char *>(key),
	    &created);

	if (!created) {
	    return TCL_ERROR;
	}
	Tcl_SetHashValue(entryPtr, result);
	return TCL_OK;
    }

    template <class T, int keytype>
	int Hash<T, keytype>::Find (void *key, T *result)
    {
	Tcl_HashEntry *entryPtr;

	entryPtr = Tcl_FindHashEntry(&HashTbl, static_cast<const char *>(key));
	if (entryPtr == 0L) {
	    return TCL_ERROR;
	}
	if (result != 0L) {
	    *result = static_cast<T>(Tcl_GetHashValue(entryPtr));
	}
	return TCL_OK;
    }

    template <class T, int keytype>
	int Hash<T, keytype>::Delete (void *key)
    {
	Tcl_HashEntry *entryPtr;

	entryPtr = Tcl_FindHashEntry(&HashTbl, static_cast<const char *>(key));
	if (entryPtr == 0L) {
	    return TCL_ERROR;
	}
	Tcl_DeleteHashEntry(entryPtr);
	return TCL_OK;
    }

};	// namespace Tcl
#endif	// #ifndef INC_tclhash_hpp__

@


1.1.2.2
log
@Added a Top() and Next() for hash searches.
@
text
@d7 1
a7 1
 * Copyright (c) 1999-2001 David Gravereaux
d12 1
a12 1
 * RCS: @@(#) $Id: TclHash.hpp,v 1.1.2.1 2002/03/12 16:42:07 davygrvy Exp $
a14 1

a17 2
#include "tcl.h"

a29 2
	int Top (T *result);
	int Next (T *result);
a30 2
    protected:
	Tcl_HashSearch HashSrch;
a86 30
	return TCL_OK;
    }

    template <class T, int keytype>
	int Hash<T, keytype>::Top (T *result)
    {
	Tcl_HashEntry *entryPtr;

	entryPtr = Tcl_FirstHashEntry(&HashTbl, &HashSrch);
	if (entryPtr == 0L) {
	    return TCL_ERROR;
	}
	if (result != 0L) {
	    *result = static_cast<T>(Tcl_GetHashValue(entryPtr));
	}
	return TCL_OK;
    }

    template <class T, int keytype>
	int Hash<T, keytype>::Next (T *result)
    {
	Tcl_HashEntry *entryPtr;

	entryPtr = Tcl_NextHashEntry(&HashSrch);
	if (entryPtr == 0L) {
	    return TCL_ERROR;
	}
	if (result != 0L) {
	    *result = static_cast<T>(Tcl_GetHashValue(entryPtr));
	}
@


1.1.2.3
log
@new Extract() functions.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: TclHash.hpp,v 1.1.2.2 2002/03/12 18:10:43 davygrvy Exp $
a31 1
	int Extract (void *key, T *result);
a123 16
	return TCL_OK;
    }

    template <class T, int keytype>
	int Hash<T, keytype>::Extract (void *key, T *result)
    {
	Tcl_HashEntry *entryPtr;

	entryPtr = Tcl_FindHashEntry(&HashTbl, static_cast<const char *>(key));
	if (entryPtr == 0L) {
	    return TCL_ERROR;
	}
	if (result != 0L) {
	    *result = static_cast<T>(Tcl_GetHashValue(entryPtr));
	}
	Tcl_DeleteHashEntry(entryPtr);
@


1.1.2.4
log
@name change and needs config.hpp
@
text
@d7 1
a7 1
 * Copyright (c) 1999-2001 TomaSoft Engineering
d12 1
a12 1
 * RCS: @@(#) $Id: TclHash.hpp,v 1.15 2002/08/27 01:27:44 davygrvy Exp $
a18 4
#ifndef INC_config_hpp__
#   include "config.hpp"
#endif

d21 1
a21 1
CPPTCL_BEGIN_NAMESPACE(Tcl)
d23 120
a142 128
template <class T, int keytype = TCL_STRING_KEYS>
    class Hash
{
public:
    Hash () { Tcl_InitHashTable(&HashTbl, keytype); }
    ~Hash () { Tcl_DeleteHashTable(&HashTbl); }
    Tcl_Obj *Stats ();
    int Add (const void *key, T result);
    int Find (const void *key, T *result);
    int Extract (const void *key, T *result);
    int Delete (const void *key);
    int Top (T *result, const void **key = 0L);
    int Next (T *result, const void **key = 0L);

protected:
    Tcl_HashSearch HashSrch;
    Tcl_HashTable HashTbl;
};

template <class T, int keytype>
    Tcl_Obj *Hash<T, keytype>::Stats ()
{
    const char *stats;
    Tcl_Obj *oStats;

    stats = Tcl_HashStats(&HashTbl);
    oStats = Tcl_NewStringObj(stats, -1);
    ckfree((char *)stats);
    return oStats;
}

template <class T, int keytype>
    int Hash<T, keytype>::Add (const void *key, T result)
{
    int created;
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_CreateHashEntry(&HashTbl, static_cast<const char *>(key),
	&created);

    if (!created) {
	return TCL_ERROR;
    }
    Tcl_SetHashValue(entryPtr, result);
    return TCL_OK;
}

template <class T, int keytype>
    int Hash<T, keytype>::Find (const void *key, T *result)
{
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_FindHashEntry(&HashTbl, static_cast<const char *>(key));
    if (entryPtr == 0L) {
	return TCL_ERROR;
    }
    if (result != 0L) {
	*result = reinterpret_cast<T>(Tcl_GetHashValue(entryPtr));
    }
    return TCL_OK;
}

template <class T, int keytype>
    int Hash<T, keytype>::Delete (const void *key)
{
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_FindHashEntry(&HashTbl, static_cast<const char *>(key));
    if (entryPtr == 0L) {
	return TCL_ERROR;
    }
    Tcl_DeleteHashEntry(entryPtr);
    return TCL_OK;
}

template <class T, int keytype>
    int Hash<T, keytype>::Top (T *result, const void **key)
{
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_FirstHashEntry(&HashTbl, &HashSrch);
    if (entryPtr == 0L) {
	return TCL_ERROR;
    }
    if (result != 0L) {
	*result = reinterpret_cast<T>(Tcl_GetHashValue(entryPtr));
    }
    if (key != 0L) {
	*key = Tcl_GetHashKey(&HashTbl, entryPtr);
    }
    return TCL_OK;
}

template <class T, int keytype>
    int Hash<T, keytype>::Next (T *result, const void **key)
{
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_NextHashEntry(&HashSrch);
    if (entryPtr == 0L) {
	return TCL_ERROR;
    }
    if (result != 0L) {
	*result = reinterpret_cast<T>(Tcl_GetHashValue(entryPtr));
    }
    if (key != 0L) {
	*key = Tcl_GetHashKey(&HashTbl, entryPtr);
    }
    return TCL_OK;
}

template <class T, int keytype>
    int Hash<T, keytype>::Extract (const void *key, T *result)
{
    Tcl_HashEntry *entryPtr;

    entryPtr = Tcl_FindHashEntry(&HashTbl, static_cast<const char *>(key));
    if (entryPtr == 0L) {
	return TCL_ERROR;
    }
    if (result != 0L) {
	*result = reinterpret_cast<T>(Tcl_GetHashValue(entryPtr));
    }
    Tcl_DeleteHashEntry(entryPtr);
    return TCL_OK;
}

CPPTCL_END_NAMESPACE
d144 1
@


