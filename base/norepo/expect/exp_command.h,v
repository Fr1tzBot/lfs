head	5.46;
access;
symbols
	expect_5_45:5.45
	expect_6_branch:5.45.0.2
	expect_5_44_1_15:5.45
	activestate_win32_port_start:5.34
	telco-tec-win32-take2-branch:5.30.0.6
	telco-tec-win32-branch:5.30.0.4
	expect-sf418892-sf439042-branch:5.30.0.2
	tclpro-1-5-0:5.30
	tclpro-1-4-1:5.30
	tclpro-1-4-0:5.30
	expect-5-32-2:5.30
	expect-5-32-0:5.30
	ajuba-ajuba2-2-0:5.28.1.1.2.14
	scriptics-sc-2-0-b5:5.28.1.1.2.14
	scriptics-sc-2-0-fixed:5.28.1.1.2.14
	scriptics-sc-2-0-b2:5.28.1.1.2.14
	scriptics-sc-2-0-b1:5.28.1.1.2.14
	scriptics-sc-1-1:5.28.1.1.2.14
	scriptics-sc-1-1-b1:5.28.1.1.2.14
	scriptics-sc-1-1-branch:5.28.1.1.2.14.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.14
	scriptics-sc-1-0:5.28.1.1.2.14
	scriptics-sc-1-0-branch:5.28.1.1.2.14.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.14
	expect-5-31-3:5.28.1.1.2.14
	scriptics-bc-1-0-b1:5.28.1.1.2.14
	scriptics-tclpro-1-3-0:5.28.1.1.2.14
	scriptics-tclpro-1-3-b4:5.28.1.1.2.14
	scriptics-tclpro-1-3-b3:5.28.1.1.2.14
	expect-5-31:5.28.1.1.2.14
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.46
date	2012.08.15.22.25.31;	author andreas_kupries;	state Exp;
branches;
next	5.45;

5.45
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.44;

5.44
date	2010.03.24.19.28.18;	author eee;	state Exp;
branches;
next	5.43;

5.43
date	2010.03.15.23.17.39;	author eee;	state Exp;
branches;
next	5.42;

5.42
date	2010.03.11.21.55.37;	author eee;	state Exp;
branches;
next	5.41;

5.41
date	2008.04.03.19.19.41;	author andreas_kupries;	state Exp;
branches;
next	5.40;

5.40
date	2007.07.11.21.35.08;	author andreas_kupries;	state Exp;
branches;
next	5.39;

5.39
date	2005.06.22.17.03.39;	author andreas_kupries;	state Exp;
branches;
next	5.38;

5.38
date	2005.02.15.18.11.06;	author andreas_kupries;	state Exp;
branches;
next	5.37;

5.37
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.36;

5.36
date	2004.02.26.01.02.43;	author andreas_kupries;	state Exp;
branches;
next	5.35;

5.35
date	2003.09.05.19.01.56;	author andreas_kupries;	state Exp;
branches;
next	5.34;

5.34
date	2003.02.15.00.02.39;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2002.04.16.21.00.28;	author libes;	state Exp;
branches;
next	5.32;

5.32
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.31;

5.31
date	2002.02.07.23.46.49;	author andreas_kupries;	state Exp;
branches;
next	5.30;

5.30
date	2000.02.01.06.50.29;	author libes;	state Exp;
branches
	5.30.2.1
	5.30.4.1
	5.30.6.1;
next	5.29;

5.29
date	2000.01.06.23.22.03;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.21;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.21;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.07.17.49.38;	author libes;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.10.22.01.41;	author don;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.11.02.10.19;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.06.11.20.11.49;	author don;	state Exp;
branches;
next	5.28.1.1.2.5;

5.28.1.1.2.5
date	99.06.14.20.36.47;	author don;	state Exp;
branches;
next	5.28.1.1.2.6;

5.28.1.1.2.6
date	99.06.14.23.54.04;	author don;	state Exp;
branches;
next	5.28.1.1.2.7;

5.28.1.1.2.7
date	99.06.15.01.32.09;	author don;	state Exp;
branches;
next	5.28.1.1.2.8;

5.28.1.1.2.8
date	99.06.15.10.02.35;	author don;	state Exp;
branches;
next	5.28.1.1.2.9;

5.28.1.1.2.9
date	99.06.16.03.02.35;	author don;	state Exp;
branches;
next	5.28.1.1.2.10;

5.28.1.1.2.10
date	99.06.20.06.32.19;	author libes;	state Exp;
branches;
next	5.28.1.1.2.11;

5.28.1.1.2.11
date	99.06.23.17.25.17;	author libes;	state Exp;
branches;
next	5.28.1.1.2.12;

5.28.1.1.2.12
date	99.06.28.06.29.24;	author libes;	state Exp;
branches;
next	5.28.1.1.2.13;

5.28.1.1.2.13
date	99.06.29.18.12.10;	author wart;	state Exp;
branches;
next	5.28.1.1.2.14;

5.28.1.1.2.14
date	99.07.03.03.44.14;	author libes;	state Exp;
branches;
next	;

5.30.2.1
date	2002.02.07.23.46.00;	author andreas_kupries;	state Exp;
branches;
next	;

5.30.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.30.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.46
log
@
	* exp_main_sub.c: Updated EXP_VERSION to 5.45.1
	* configure, configure.in: Updated expect to version 5.45.1

	* exp_chan.c: Applied patch sent in by Ogawa Hirofumi
	  <hirofumi@@mail.parknet.co.jp>. The patch fixes a problem when
	  talking a tty where the writer has died. Some operating systems
	  report the condition as EIO with nothing read, while this
	  actually an EOF. Without the patch the returned data is
	  incomplete due to the error reported immediately and dropping
	  data in buffers.

	* exp_chan.c: [Bug 3526461]: Applied patch by Michael Cleverly
	  <cleverly@@users.sourceforge.net> fixing a problem with the
	  iteration over the expect channel list where the loop code may
	  modify the list, breaking the iterator.

	* exp_chan.c: [Bug 3526707]: Applied patch by Michael Cleverly
	* exp_command.h: <cleverly@@users.sourceforge.net> fixing problem
	* expect.c: with an insufficient test for a lost channel in
	  exp_background_channelhandler.
@
text
@/* command.h - definitions for expect commands

Written by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.
*/

#ifdef HAVE_SYS_WAIT_H
  /* ISC doesn't def WNOHANG unless _POSIX_SOURCE is def'ed */
# ifdef WNOHANG_REQUIRES_POSIX_SOURCE
#  define _POSIX_SOURCE
# endif
# include <sys/wait.h>
# ifdef WNOHANG_REQUIRES_POSIX_SOURCE
#  undef _POSIX_SOURCE
# endif
#endif

#ifdef __APPLE__
/* From: "Daniel A. Steffen" <steffen@@ics.mq.edu.au> */
# undef panic
#endif

#include <tclPort.h>

#define EXP_CHANNELNAMELEN (16 + TCL_INTEGER_SPACE)

EXTERN char *		exp_get_var _ANSI_ARGS_((Tcl_Interp *,char *));

EXTERN int exp_default_match_max;
EXTERN int exp_default_parity;
EXTERN int exp_default_rm_nulls;
EXTERN int exp_default_close_on_eof;

EXTERN int		exp_one_arg_braced _ANSI_ARGS_((Tcl_Obj *));

EXTERN Tcl_Obj*		exp_eval_with_one_arg _ANSI_ARGS_((ClientData,
				Tcl_Interp *, struct Tcl_Obj * CONST objv[]));

EXTERN void		exp_lowmemcpy _ANSI_ARGS_((char *,char *,int));

EXTERN int exp_flageq_code _ANSI_ARGS_((char *,char *,int));

#define exp_flageq(flag,string,minlen) \
(((string)[0] == (flag)[0]) && (exp_flageq_code(((flag)+1),((string)+1),((minlen)-1))))

/* exp_flageq for single char flags */
#define exp_flageq1(flag,string) \
	((string[0] == flag) && (string[1] == '\0'))

#define EXP_SPAWN_ID_USER		0
#define EXP_SPAWN_ID_ANY_LIT		"-1"

#define EXP_CHANNEL_PREFIX "exp"
#define EXP_CHANNEL_PREFIX_LENGTH 3
#define isExpChannelName(name) \
    (0 == strncmp(name,EXP_CHANNEL_PREFIX,EXP_CHANNEL_PREFIX_LENGTH))

#define exp_is_stdinfd(x)	((x) == 0)
#define exp_is_devttyfd(x)	((x) == exp_dev_tty)

#define EXP_NOPID	0	/* Used when there is no associated pid to */
				/* wait for.  For example: */
				/* 1) When fd opened by someone else, e.g., */
				/* Tcl's open */
				/* 2) When entry not in use */
				/* 3) To tell user pid of "spawn -open" */
				/* 4) stdin, out, error */

#define EXP_NOFD	-1

/* these are occasionally useful to distinguish between various expect */
/* commands and are also used as array indices into the per-fd eg[] arrays */
#define EXP_CMD_BEFORE	0
#define EXP_CMD_AFTER	1
#define EXP_CMD_BG	2
#define EXP_CMD_FG	3

/*
 * This structure describes per-instance state of an Exp channel.
 */

typedef struct ExpOrigin {
  int         refCount;       /* Number of times this channel is used. */
  Tcl_Channel channel_orig;   /* If opened by someone else, i.e. tcl::open */
} ExpOrigin;


typedef struct ExpUniBuf {
    Tcl_UniChar* buffer;    /* char buffer, holdings unicode chars (fixed width) */
    int          max;       /* number of CHARS the buffer has space for (== old msize) */
    int          use;       /* number of CHARS the buffer is currently holding */
    Tcl_Obj*     newchars;  /* Object to hold newly read characters */
} ExpUniBuf;

typedef struct ExpState {
    Tcl_Channel channel;	/* Channel associated with this file. */
    char name[EXP_CHANNELNAMELEN+1]; /* expect and interact set variables
				   to channel name, so for efficiency
				   cache it here */
    int fdin;		/* input fd */
    int fdout;		/* output fd - usually the same as fdin, although
			   may be different if channel opened by tcl::open */
    ExpOrigin* chan_orig;   /* If opened by someone else, i.e. tcl::open */
    int fd_slave;	/* slave fd if "spawn -pty" used */

    /* this may go away if we find it is not needed */
    /* it might be needed by inherited channels */
    int validMask;		/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which operations are valid on the file. */

    int pid;		/* pid or EXP_NOPID if no pid */

    ExpUniBuf input;    /* input buffer */

    int umsize;	        /* # of bytes (min) that is guaranteed to match */
			/* this comes from match_max command */
    int printed;	/* # of characters! written to stdout (if logging on) */
                        /* but not actually returned via a match yet */
    int echoed;	        /* additional # of characters (beyond "printed" above) */
                        /* echoed back but not actually returned via a match */
                        /* yet.  This supports interact -echo */

    int rm_nulls;	/* if nulls should be stripped before pat matching */
    int open;		/* if fdin/fdout open */
    int user_waited;    /* if user has issued "wait" command */
    int sys_waited;	/* if wait() (or variant) has been called */
    int registered;	/* if channel registered */
    WAIT_STATUS_TYPE wait;	/* raw status from wait() */
    int parity;	        /* if parity should be preserved */
    int close_on_eof;   /* if channel should be closed automatically on eof */
    int key;	        /* unique id that identifies what command instance */
                        /* last touched this buffer */
    int force_read;	/* force read to occur (even if buffer already has */
                        /* data).  This supports interact CAN_MATCH */
    int notified;	/* If Tcl_NotifyChannel has been called and we */
		        /* have not yet read from the channel. */
    int notifiedMask;	/* Mask reported when notified. */

    int fg_armed;	/* If we have requested Tk_CreateFileHandler to be */
			/* responding to foreground events.  Note that */
		        /* other handlers can have stolen it away so this */
			/* doesn't necessarily mean the handler is set.  */
			/* However, if fg_armed is 0, then the handlers */
			/* definitely needs to be set.  The significance of */
			/* this flag is so we can remember to turn it off. */
#ifdef HAVE_PTYTRAP
    char *slave_name;   /* Full name of slave, i.e., /dev/ttyp0 */
#endif /* HAVE_PTYTRAP */
    /* may go away */
    int leaveopen;	/* If we should not call Tcl's close when we close - */
                        /* only relevant if Tcl does the original open */

    Tcl_Interp *bg_interp;	/* interp to process the bg cases */
    int bg_ecount;		/* number of background ExpStates */
    enum {
	blocked,	/* blocked because we are processing the */
			/* file handler */
	armed,		/* normal state when bg handler in use */
	unarmed,	/* no bg handler in use */
	disarm_req_while_blocked	/* while blocked, a request */
				/* was received to disarm it.  Rather than */
				/* processing the request immediately, defer */
				/* it so that when we later try to unblock */
				/* we will see at that time that it should */
				/* instead be disarmed */
    } bg_status;

    /*
     * If the channel is freed while in the middle of a bg event handler,
     * remember that and defer freeing of the ExpState structure until
     * it is safe.
     */
    int freeWhenBgHandlerUnblocked;

    /* If channel is closed but not yet waited on, we tie up the fd by
     * attaching it to /dev/null.  We play this little game so that we
     * can embed the fd in the channel name.  If we didn't tie up the
     * fd, we'd get channel name collisions.  I'd consider naming the
     * channels independently of the fd, but this makes debugging easier.
     */
    int fdBusy;

    /* 
     * stdinout and stderr never go away so that our internal refs to them
     * don't have to be invalidated.  Having to worry about invalidating them
     * would be a major pain.  */
    int keepForever;

    /*  Remember that "reserved" esPtrs are no longer in use. */
    int valid;
    
    struct ExpState *nextPtr;	/* Pointer to next file in list of all
				 * file channels. */
} ExpState;

#define EXP_SPAWN_ID_BAD	((ExpState *)0)

#define EXP_TIME_INFINITY	-1

extern Tcl_ChannelType expChannelType;

#define EXP_TEMPORARY	1	/* expect */
#define EXP_PERMANENT	2	/* expect_after, expect_before, expect_bg */

#define EXP_DIRECT	1
#define EXP_INDIRECT	2

EXTERN void		expAdjust _ANSI_ARGS_((ExpState *));
EXTERN int		expWriteChars _ANSI_ARGS_((ExpState *,char *,int));
EXTERN int		expWriteCharsUni _ANSI_ARGS_((ExpState *,Tcl_UniChar *,int));
EXTERN void		exp_buffer_shuffle _ANSI_ARGS_((Tcl_Interp *,ExpState *,int,char *,char *));
EXTERN int		exp_close _ANSI_ARGS_((Tcl_Interp *,ExpState *));
EXTERN void		exp_close_all _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_ecmd_remove_fd_direct_and_indirect 
				_ANSI_ARGS_((Tcl_Interp *,int));
EXTERN void		exp_trap_on _ANSI_ARGS_((int));
EXTERN int		exp_trap_off _ANSI_ARGS_((char *));

EXTERN void		exp_strftime(char *format, const struct tm *timeptr,Tcl_DString *dstring);

#define exp_deleteProc (void (*)())0
#define exp_deleteObjProc (void (*)())0

EXTERN int expect_key;
EXTERN int exp_configure_count;	/* # of times descriptors have been closed */
				/* or indirect lists have been changed */
EXTERN int exp_nostack_dump;	/* TRUE if user has requested unrolling of */
				/* stack with no trace */

EXTERN void		exp_init_pty _ANSI_ARGS_((void));
EXTERN void		exp_pty_exit _ANSI_ARGS_((void));
EXTERN void		exp_init_tty _ANSI_ARGS_((void));
EXTERN void		exp_init_stdio _ANSI_ARGS_((void));
/*EXTERN void		exp_init_expect _ANSI_ARGS_((Tcl_Interp *));*/
EXTERN void		exp_init_spawn_ids _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_spawn_id_vars _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_trap _ANSI_ARGS_((void));
EXTERN void		exp_init_send _ANSI_ARGS_((void));
EXTERN void		exp_init_unit_random _ANSI_ARGS_((void));
EXTERN void		exp_init_sig _ANSI_ARGS_((void));
EXTERN void		expChannelInit _ANSI_ARGS_((void));
EXTERN int		expChannelCountGet _ANSI_ARGS_((void));
EXTERN int              expChannelStillAlive _ANSI_ARGS_((ExpState *, char *));

EXTERN int		exp_tcl2_returnvalue _ANSI_ARGS_((int));
EXTERN int		exp_2tcl_returnvalue _ANSI_ARGS_((int));

EXTERN void		exp_rearm_sigchld _ANSI_ARGS_((Tcl_Interp *));
EXTERN int		exp_string_to_signal _ANSI_ARGS_((Tcl_Interp *,char *));

EXTERN char *exp_onexit_action;

#define exp_new(x)	(x *)malloc(sizeof(x))

struct exp_state_list {
	ExpState *esPtr;
	struct exp_state_list *next;
};

/* describes a -i flag */
struct exp_i {
	int cmdtype;	/* EXP_CMD_XXX.  When an indirect update is */
			/* triggered by Tcl, this helps tell us in what */
			/* exp_i list to look in. */
	int direct;	/* if EXP_DIRECT, then the spawn ids have been given */
			/* literally, else indirectly through a variable */
	int duration;	/* if EXP_PERMANENT, char ptrs here had to be */
			/* malloc'd because Tcl command line went away - */
			/* i.e., in expect_before/after */
	char *variable;
	char *value;	/* if type == direct, this is the string that the */
			/* user originally supplied to the -i flag.  It may */
			/* lose relevance as the fd_list is manipulated */
			/* over time.  If type == direct, this is  the */
			/* cached value of variable use this to tell if it */
			/* has changed or not, and ergo whether it's */
			/* necessary to reparse. */

	int ecount;	/* # of ecases this is used by */

	struct exp_state_list *state_list;
	struct exp_i *next;
};

EXTERN struct exp_i *	exp_new_i_complex _ANSI_ARGS_((Tcl_Interp *,
					char *, int, Tcl_VarTraceProc *));
EXTERN struct exp_i *	exp_new_i_simple _ANSI_ARGS_((ExpState *,int));
EXTERN struct exp_state_list *exp_new_state _ANSI_ARGS_((ExpState *));
EXTERN void		exp_free_i _ANSI_ARGS_((Tcl_Interp *,struct exp_i *,
					Tcl_VarTraceProc *));
EXTERN void		exp_free_state _ANSI_ARGS_((struct exp_state_list *));
EXTERN void		exp_free_state_single _ANSI_ARGS_((struct exp_state_list *));
EXTERN int		exp_i_update _ANSI_ARGS_((Tcl_Interp *,
					struct exp_i *));

/*
 * definitions for creating commands
 */

#define EXP_NOPREFIX	1	/* don't define with "exp_" prefix */
#define EXP_REDEFINE	2	/* stomp on old commands with same name */

#define exp_proc(cmdproc) 0, cmdproc

struct exp_cmd_data {
	char		*name;
	Tcl_ObjCmdProc	*objproc;
	Tcl_CmdProc	*proc;
	ClientData	data;
	int 		flags;
};

EXTERN void		exp_create_commands _ANSI_ARGS_((Tcl_Interp *,
						struct exp_cmd_data *));
EXTERN void		exp_init_main_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_expect_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_most_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_trap_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_interact_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_tty_cmds();

EXTERN ExpState *	expStateCheck _ANSI_ARGS_((Tcl_Interp *,ExpState *,int,int,char *));
EXTERN ExpState *       expStateCurrent _ANSI_ARGS_((Tcl_Interp *,int,int,int));
EXTERN ExpState *       expStateFromChannelName _ANSI_ARGS_((Tcl_Interp *,char *,int,int,int,char *));
EXTERN void		expStateFree _ANSI_ARGS_((ExpState *));

EXTERN ExpState *	expCreateChannel _ANSI_ARGS_((Tcl_Interp *,int,int,int));
EXTERN ExpState *	expWaitOnAny _ANSI_ARGS_((void));
EXTERN ExpState *	expWaitOnOne _ANSI_ARGS_((void));
EXTERN void		expExpectVarsInit _ANSI_ARGS_((void));
EXTERN int		expStateAnyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expDevttyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expStdinoutIs _ANSI_ARGS_((ExpState *));
EXTERN ExpState *	expStdinoutGet _ANSI_ARGS_((void));
EXTERN ExpState *	expDevttyGet _ANSI_ARGS_((void));

/* generic functions that really should be provided by Tcl */
#if 0 /* Redefined as macros. */
EXTERN int		expSizeGet _ANSI_ARGS_((ExpState *));
EXTERN int		expSizeZero _ANSI_ARGS_((ExpState *));
#else
#define expSizeGet(esPtr)  ((esPtr)->input.use)
#define expSizeZero(esPtr) (((esPtr)->input.use) == 0)
#endif

#define EXP_CMDINFO_CLOSE  "expect/cmdinfo/close"
#define EXP_CMDINFO_RETURN "expect/cmdinfo/return"

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.45
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@d247 1
@


5.44
log
@more ANSIfications
@
text
@d30 1
a30 1
EXTERN char *		exp_get_var (Tcl_Interp *,char *);
d37 1
a37 1
EXTERN int		exp_one_arg_braced (Tcl_Obj *);
d39 2
a40 1
EXTERN Tcl_Obj*		exp_eval_with_one_arg (ClientData, Tcl_Interp *, struct Tcl_Obj * CONST objv[]);
d42 1
a42 1
EXTERN void		exp_lowmemcpy (char *,char *,int);
d44 1
a44 1
EXTERN int exp_flageq_code (char *,char *,int);
d93 2
a94 2
    int          max;       /* number of chars the buffer has space for (== old msize) */
    int          use;       /* number of chars the buffer is currently holding */
d212 10
a221 9
EXTERN void		expAdjust (ExpState *);
EXTERN int		expWriteChars (ExpState *,char *,int);
EXTERN int		expWriteCharsUni (ExpState *,Tcl_UniChar *,int);
EXTERN void		exp_buffer_shuffle (Tcl_Interp *,ExpState *,int,char *,char *);
EXTERN int		exp_close (Tcl_Interp *,ExpState *);
EXTERN void		exp_close_all (Tcl_Interp *);
EXTERN void		exp_ecmd_remove_fd_direct_and_indirect (Tcl_Interp *,int);
EXTERN void		exp_trap_on (int);
EXTERN int		exp_trap_off (char *);
d234 13
a246 13
EXTERN void		exp_init_pty (void);
EXTERN void		exp_pty_exit (void);
EXTERN void		exp_init_tty (void);
EXTERN void		exp_init_stdio (void);
/*EXTERN void		exp_init_expect (Tcl_Interp *);*/
EXTERN void		exp_init_spawn_ids (Tcl_Interp *);
EXTERN void		exp_init_spawn_id_vars (Tcl_Interp *);
EXTERN void		exp_init_trap (void);
EXTERN void		exp_init_send (void);
EXTERN void		exp_init_unit_random (void);
EXTERN void		exp_init_sig (void);
EXTERN void		expChannelInit (void);
EXTERN int		expChannelCountGet (void);
d248 2
a249 2
EXTERN int		exp_tcl2_returnvalue (int);
EXTERN int		exp_2tcl_returnvalue (int);
d251 2
a252 2
EXTERN void		exp_rearm_sigchld (Tcl_Interp *);
EXTERN int		exp_string_to_signal (Tcl_Interp *,char *);
d288 10
a297 7
EXTERN struct exp_i *	exp_new_i_complex (Tcl_Interp *, char *, int, Tcl_VarTraceProc *);
EXTERN struct exp_i *	exp_new_i_simple (ExpState *,int);
EXTERN struct exp_state_list *exp_new_state (ExpState *);
EXTERN void		exp_free_i (Tcl_Interp *,struct exp_i *, Tcl_VarTraceProc *);
EXTERN void		exp_free_state (struct exp_state_list *);
EXTERN void		exp_free_state_single (struct exp_state_list *);
EXTERN int		exp_i_update (Tcl_Interp *, struct exp_i *);
d316 7
a322 6
EXTERN void		exp_create_commands (Tcl_Interp *, struct exp_cmd_data *);
EXTERN void		exp_init_main_cmds (Tcl_Interp *);
EXTERN void		exp_init_expect_cmds (Tcl_Interp *);
EXTERN void		exp_init_most_cmds (Tcl_Interp *);
EXTERN void		exp_init_trap_cmds (Tcl_Interp *);
EXTERN void		exp_init_interact_cmds (Tcl_Interp *);
d325 14
a338 14
EXTERN ExpState *	expStateCheck (Tcl_Interp *,ExpState *,int,int,char *);
EXTERN ExpState *       expStateCurrent (Tcl_Interp *,int,int,int);
EXTERN ExpState *       expStateFromChannelName (Tcl_Interp *,char *,int,int,int,char *);
EXTERN void		expStateFree (ExpState *);

EXTERN ExpState *	expCreateChannel (Tcl_Interp *,int,int,int);
EXTERN ExpState *	expWaitOnAny (void);
EXTERN ExpState *	expWaitOnOne (void);
EXTERN void		expExpectVarsInit (void);
EXTERN int		expStateAnyIs (ExpState *);
EXTERN int		expDevttyIs (ExpState *);
EXTERN int		expStdinoutIs (ExpState *);
EXTERN ExpState *	expStdinoutGet (void);
EXTERN ExpState *	expDevttyGet (void);
d342 2
a343 2
EXTERN int		expSizeGet (ExpState *);
EXTERN int		expSizeZero (ExpState *);
d351 1
a351 1

@


5.43
log
@ANSIfication changes.
@
text
@d92 2
a93 2
    int          max;       /* number of CHARS the buffer has space for (== old msize) */
    int          use;       /* number of CHARS the buffer is currently holding */
@


5.42
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d30 1
a30 1
EXTERN char *		exp_get_var _ANSI_ARGS_((Tcl_Interp *,char *));
d37 1
a37 1
EXTERN int		exp_one_arg_braced _ANSI_ARGS_((Tcl_Obj *));
d39 1
a39 2
EXTERN Tcl_Obj*		exp_eval_with_one_arg _ANSI_ARGS_((ClientData,
				Tcl_Interp *, struct Tcl_Obj * CONST objv[]));
d41 1
a41 1
EXTERN void		exp_lowmemcpy _ANSI_ARGS_((char *,char *,int));
d43 1
a43 1
EXTERN int exp_flageq_code _ANSI_ARGS_((char *,char *,int));
d211 9
a219 10
EXTERN void		expAdjust _ANSI_ARGS_((ExpState *));
EXTERN int		expWriteChars _ANSI_ARGS_((ExpState *,char *,int));
EXTERN int		expWriteCharsUni _ANSI_ARGS_((ExpState *,Tcl_UniChar *,int));
EXTERN void		exp_buffer_shuffle _ANSI_ARGS_((Tcl_Interp *,ExpState *,int,char *,char *));
EXTERN int		exp_close _ANSI_ARGS_((Tcl_Interp *,ExpState *));
EXTERN void		exp_close_all _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_ecmd_remove_fd_direct_and_indirect 
				_ANSI_ARGS_((Tcl_Interp *,int));
EXTERN void		exp_trap_on _ANSI_ARGS_((int));
EXTERN int		exp_trap_off _ANSI_ARGS_((char *));
d232 13
a244 13
EXTERN void		exp_init_pty _ANSI_ARGS_((void));
EXTERN void		exp_pty_exit _ANSI_ARGS_((void));
EXTERN void		exp_init_tty _ANSI_ARGS_((void));
EXTERN void		exp_init_stdio _ANSI_ARGS_((void));
/*EXTERN void		exp_init_expect _ANSI_ARGS_((Tcl_Interp *));*/
EXTERN void		exp_init_spawn_ids _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_spawn_id_vars _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_trap _ANSI_ARGS_((void));
EXTERN void		exp_init_send _ANSI_ARGS_((void));
EXTERN void		exp_init_unit_random _ANSI_ARGS_((void));
EXTERN void		exp_init_sig _ANSI_ARGS_((void));
EXTERN void		expChannelInit _ANSI_ARGS_((void));
EXTERN int		expChannelCountGet _ANSI_ARGS_((void));
d246 2
a247 2
EXTERN int		exp_tcl2_returnvalue _ANSI_ARGS_((int));
EXTERN int		exp_2tcl_returnvalue _ANSI_ARGS_((int));
d249 2
a250 2
EXTERN void		exp_rearm_sigchld _ANSI_ARGS_((Tcl_Interp *));
EXTERN int		exp_string_to_signal _ANSI_ARGS_((Tcl_Interp *,char *));
d286 7
a292 10
EXTERN struct exp_i *	exp_new_i_complex _ANSI_ARGS_((Tcl_Interp *,
					char *, int, Tcl_VarTraceProc *));
EXTERN struct exp_i *	exp_new_i_simple _ANSI_ARGS_((ExpState *,int));
EXTERN struct exp_state_list *exp_new_state _ANSI_ARGS_((ExpState *));
EXTERN void		exp_free_i _ANSI_ARGS_((Tcl_Interp *,struct exp_i *,
					Tcl_VarTraceProc *));
EXTERN void		exp_free_state _ANSI_ARGS_((struct exp_state_list *));
EXTERN void		exp_free_state_single _ANSI_ARGS_((struct exp_state_list *));
EXTERN int		exp_i_update _ANSI_ARGS_((Tcl_Interp *,
					struct exp_i *));
d311 6
a316 7
EXTERN void		exp_create_commands _ANSI_ARGS_((Tcl_Interp *,
						struct exp_cmd_data *));
EXTERN void		exp_init_main_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_expect_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_most_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_trap_cmds _ANSI_ARGS_((Tcl_Interp *));
EXTERN void		exp_init_interact_cmds _ANSI_ARGS_((Tcl_Interp *));
d319 14
a332 14
EXTERN ExpState *	expStateCheck _ANSI_ARGS_((Tcl_Interp *,ExpState *,int,int,char *));
EXTERN ExpState *       expStateCurrent _ANSI_ARGS_((Tcl_Interp *,int,int,int));
EXTERN ExpState *       expStateFromChannelName _ANSI_ARGS_((Tcl_Interp *,char *,int,int,int,char *));
EXTERN void		expStateFree _ANSI_ARGS_((ExpState *));

EXTERN ExpState *	expCreateChannel _ANSI_ARGS_((Tcl_Interp *,int,int,int));
EXTERN ExpState *	expWaitOnAny _ANSI_ARGS_((void));
EXTERN ExpState *	expWaitOnOne _ANSI_ARGS_((void));
EXTERN void		expExpectVarsInit _ANSI_ARGS_((void));
EXTERN int		expStateAnyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expDevttyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expStdinoutIs _ANSI_ARGS_((ExpState *));
EXTERN ExpState *	expStdinoutGet _ANSI_ARGS_((void));
EXTERN ExpState *	expDevttyGet _ANSI_ARGS_((void));
d336 2
a337 2
EXTERN int		expSizeGet _ANSI_ARGS_((ExpState *));
EXTERN int		expSizeZero _ANSI_ARGS_((ExpState *));
@


5.41
log
@
	* configure.in: Bumped version to 5.44.1.7.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* exp_command.c: Fixed more compiler warnings, and started
	* exp_command.h: to ansify the code base, beginning with
	* exp_inter.c: the introduction of proper function prototypes.
	* exp_main_exp.c:
	* exp_pty.h:
	* exp_tty.c:
	* exp_tty.h:
	* exp_win.c:
	* expect.c:
	* pty_termios.c:
	* retoglob.c:
@
text
@d351 1
a351 1

@


5.40
log
@
	* exp_chan.c: Converted the buffering system from UTF-8 in Tcl_Obj
	* exp_command.h: to UTF-16 C-array, to avoid the repeated conversion
	* expect.c: of the input from utf-8 to utf-16. Updated the glob
	* exp_glob.c: matching code to use the same tricks for speed which
	* exp_inter.c: are used by the Tcl core. Extended the regexp
	* exp_log.c: matching path with a glob matcher which uses a gate
	* exp_log.h: keeper glob pattern to weed out most non-candidates
	* retoglob.c (New file): in a speedy manner. Regexp matching now
	  has to be done only for the small number of candidates
	  identified by the gate keeper. Overall speed improvement as glob
	  matching is faster than regexp matching. Added code translating
	  regular expressions into their gate keeper glob pattern.
@
text
@d223 1
a223 1
EXTERN void		exp_strftime();
@


5.39
log
@
	* exp_chan.c:    Fixed bug causing crash of expect on exit when a
	* exp_command.c: Tcl channel is used with -(leave)open more than
	* exp_command.h: once. It tried to close such channels multiple
	  times, going through already freed memory. Added data structures
	  to track and refcount all such channels, to close them only when
	  the last user goes away.
@
text
@d38 2
a39 1
EXTERN int		exp_eval_with_one_arg _ANSI_ARGS_((ClientData,
d41 1
d90 8
a115 1
    Tcl_Obj *buffer;	/* input buffer */
d117 2
a118 1
    int msize;	        /* # of bytes that buffer can hold (max) */
d121 1
a121 1
    int printed;	/* # of bytes written to stdout (if logging on) */
d123 1
a123 1
    int echoed;	        /* additional # of bytes (beyond "printed" above) */
d214 1
d336 1
a336 1
EXTERN int		expStdinOutIs _ANSI_ARGS_((ExpState *));
d341 1
d344 4
d351 8
@


5.38
log
@
	* Merged changes from the official versions 5.42.1 and 5.43.0 of
	  expect into the SF sources. See the details below.

	  --------------------
	  Martin Forssen <maf@@tkrat.xorg> fixed bug in ExpOutputProc
	  that caused misbehavior during partial writes.

	  Someone noted that gets stdin behaves differently (returns -1
	  immediately) from tclsh because with 5.42, stdin is unblocked by
	  defaults.

	  Robroy Gregg <robroy@@armory.xcom> noted that expect_background
	  ignores timeouts.  Added to documentation.

	  Jens Peterson <peterson@@redhat.xcom> provided patch for
	  "mkpasswd -vo".

	  Gary Bliesener <gary.bliesener@@nextel.xcom> noted that
	  multixterm failed on his system which had an old Tk that didn't
	  support the Tk package.

	  Removed beta designation.

	  Daniel A. Steffen <steffen@@ics.mq.edu.xau> provided patch for
	  MacOS to avoid panic-redefinition.
	  --------------------
@
text
@d83 5
d96 1
a96 1
    Tcl_Channel channel_orig;   /* If opened by someone else, i.e. tcl::open */
@


5.37
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@d21 5
@


5.36
log
@
	* Merged changes from the official version 5.40 of expect into the
	  SF sources. See details below. Partially already done (Rich
	  Kennedy's patch).

	  --------------------
	  Eric Raymond <esr@@snark.thyrsus.xcom> provided troff-related
	  fixes for the expect, lib, and dislocate man pages.

	  Rich Kennedy <rickenne@@cisco.xcom> noted a bug having to do
	  with our caching of whether we have registered a filehandler.
	  This broke when Tcl was setting a handler on the same file.

	  Ken Pizzini <ken.pizzini@@explicate.xorg> provided patch for
	  leak in spawn error handling.

	  Pete Lancashire <plancashire@@columbia.xcom> noted autopasswd
	  example broke on Solaris which capitalized prompts.
	  --------------------
@
text
@d30 1
d114 1
d193 1
@


5.35
log
@
	* Merged changes from the official version 5.39 of expect into the
	  SF sources. See details below. Partially already done.

	  --------------------
	  Poorva Gupta <poorva@@cup.hp.xcom> noted that grantpt/unlockpt
	  order was backward.  Strange that this was never a prob before!

	  Eric Raymond <esr@@snark.thyrsus.xcom> provided a troff-related
	  fix for the multixterm man page.

	  Nicolas Roeser <n-roeser@@gmx.xnet> noted confusion with md5 so I
	  made the Expect page more explicit about which file that hash
	  was based on.

	  Josh Purinton noted that earlier fix wasn't quite right.  Exit
	  on INT/TERM should cause Expect to exit with signal embedded in
	  status.  He also requested I obfuscate email addresses in this
	  file.

	  Guido Ostkamp <Guido.Ostkamp@@t-online.xde> and Igor Sobrado
	  <sobrado@@string1.ciencias.uniovi.xes> noted that fixline1
	  rewrote scripts to be expect scripts even if they were expectk
	  scripts.

	  Dirk Petera <dirkpetera@@yahoo.xcom> noted that any_spawn_id used
	  to work but did no longer.  Looks like a bug left over from the
	  the I18L conversion.  Fixed.

	  Steve Szabo noted exp_log_file -open channel failed.  Fixed.

	  Fixed bug from 5.31 that prevent stty from returning messages
	  from underlying program.

	  Thomas Dickey <dickey@@herndon4.his.xcom> noted that ncurses
	  ignores 2-char term names because of, well, poor assumptions and
	  coding.  Changed tkterm to use longer names.

	  Heath Moore <hmoore@@systran.xcom> noted that exp_clib could lock
	  up if remtime happened to be precisely 0.  Recoded to avoid.

	  At request of Per Otterholm <otterholm@@telia.xcom>, wrote script
	  to read from stdin and echo passwords (exercise 9 in Tk chapter
	  of Expect book).  Added to example directory as passwdprompt.

	  Josh Purinton <josh@@purinton.xorg> pointed out that by default,
	  SIGINT/TERM should cause expect's return status to be 1, not 0.

	  Paul Reithmuller <paul.reithmuller@@eng.sun.xcom> noted that
	  unbuffer shouldn't postprocess its output.  Added stty_init.

	  Mordechai T. Abzug <morty@@sanctuary.arbutus.md.xus> noted that
	  log_file wasn't recording -append status.

	  James Kelly <macubergeek@@comcast.xnet> noted weather example
	  needed new source.

	  Dimitar Haralanov <mitko@@tahoenetworks.xcom> noted that interact
	  dumped core with interact { timeout 1 }
	  --------------------
@
text
@d120 8
a127 2
    int fg_armed;	/* If Tk_CreateFileHandler is active for responding */
                        /* to foreground events */	   
@


5.34
log
@
	* configure.in:   Made expect aware of tcl stubs. Derived from the
	* exp_command.h:  patches to expect done by Steve Landers
	* exp_command.c:  <stevel@@digital-smarties.com>. Modifications:
	* exp_main_sub.c  No global cmdinfo structures for 'close' and
	* exp_main_exp.c: 'return'. Made this per-interpreter information
	* exp_main_tk.c:  as it should be. Using interp assoc data for this.

	NOTE: stubs is not default, but has to be activated via '--enable-stubs'.

	* configure:      Regenerated.
@
text
@d130 1
a130 1
    int bg_ecount;		/* number of background ecases */
@


5.33
log
@misc updates
@
text
@d313 3
@


5.32
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d25 1
a25 1
EXTERN CONST char *		exp_get_var _ANSI_ARGS_((Tcl_Interp *,char *));
d297 1
a297 1
EXTERN ExpState *       expStateFromChannelName _ANSI_ARGS_((Tcl_Interp *,CONST char *,int,int,int,char *));
@


5.31
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@d25 1
a25 1
EXTERN char *		exp_get_var _ANSI_ARGS_((Tcl_Interp *,char *));
d297 1
a297 1
EXTERN ExpState *       expStateFromChannelName _ANSI_ARGS_((Tcl_Interp *,char *,int,int,int,char *));
@


5.30
log
@Made exp_wait with no spawned processes behave like in 5.29 - see HISTORY.
@
text
@d266 1
a266 1
EXTERN void		exp_i_update _ANSI_ARGS_((Tcl_Interp *,
@


5.30.2.1
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@d266 1
a266 1
EXTERN int		exp_i_update _ANSI_ARGS_((Tcl_Interp *,
@


5.30.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.30.4.1
log
@Top-level source files removed.
@
text
@@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d46 1
a46 1
#define EXP_SPAWN_ID_ANY_LIT		"exp?"
@


5.28
log
@Initial revision
@
text
@d10 15
a24 2
EXTERN struct exp_f *	exp_update_master
				_ANSI_ARGS_((Tcl_Interp *,int *,int,int));
d31 1
a31 1
EXTERN int		exp_one_arg_braced _ANSI_ARGS_((char *));
d33 1
a33 1
				Tcl_Interp *,char **));
d45 2
a46 85
/*
 * The type of the status returned by wait varies from UNIX system
 * to UNIX system.  The macro below defines it:
 * (stolen from tclUnix.h)
 */

#define WAIT_STATUS_TYPE int
#if 0
#ifdef AIX
#   define WAIT_STATUS_TYPE pid_t
#else
#ifndef NO_UNION_WAIT
#   define WAIT_STATUS_TYPE union wait
#else
#   define WAIT_STATUS_TYPE int
#endif
#endif /* AIX */

/* These macros are taken from tclUnix.h */

#undef WIFEXITED
#ifndef WIFEXITED
#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xff) == 0)
#endif

#undef WEXITSTATUS
#ifndef WEXITSTATUS
#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#undef WIFSIGNALED
#ifndef WIFSIGNALED
#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
#endif

#undef WTERMSIG
#ifndef WTERMSIG
#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
#endif

#undef WIFSTOPPED
#ifndef WIFSTOPPED
#   define WIFSTOPPED(stat)  (((*((int *) &(stat))) & 0xff) == 0177)
#endif

#undef WSTOPSIG
#ifndef WSTOPSIG
#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#endif /* 0 */

/* These macros are suggested by the autoconf documentation. */

#undef WIFEXITED
#ifndef WIFEXITED
#   define WIFEXITED(stat)  (((stat) & 0xff) == 0)
#endif

#undef WEXITSTATUS
#ifndef WEXITSTATUS
#   define WEXITSTATUS(stat) (((stat) >> 8) & 0xff)
#endif

#undef WIFSIGNALED
#ifndef WIFSIGNALED
#   define WIFSIGNALED(stat) ((stat) && ((stat) == ((stat) & 0x00ff)))
#endif

#undef WTERMSIG
#ifndef WTERMSIG
#   define WTERMSIG(stat)    ((stat) & 0x7f)
#endif

#undef WIFSTOPPED
#ifndef WIFSTOPPED
#   define WIFSTOPPED(stat)  (((stat) & 0xff) == 0177)
#endif

#undef WSTOPSIG
#ifndef WSTOPSIG
#   define WSTOPSIG(stat)    (((stat) >> 8) & 0xff)
#endif


d48 4
a51 7
#define EXP_SPAWN_ID_ANY_VARNAME	"any_spawn_id"
#define EXP_SPAWN_ID_ANY_LIT		"-1"
#define EXP_SPAWN_ID_ANY		-1

#define EXP_SPAWN_ID_ERROR_LIT		"2"
#define EXP_SPAWN_ID_USER_LIT		"0"
#define EXP_SPAWN_ID_USER		0
d73 49
a121 53
/* each process is associated with a 'struct exp_f'.  An array of these */
/* ('exp_fs') keeps track of all processes.  They are indexed by the true fd */
/* to the master side of the pty */
struct exp_f {
	int *fd_ptr;
#if 0
	struct exp_f **ptr;	/* our own address to this exp_f */
			/* since address can change, provide this indirect */
			/* pointer for people (Tk) who require a fixed ptr */
#endif
	int pid;	/* pid or EXP_NOPID if no pid */
	char *buffer;	/* input buffer */
	char *lower;	/* input buffer in lowercase */
	int size;	/* current size of data */
	int msize;	/* size of buffer (true size is one greater
			   for trailing null) */
	int umsize;	/* user view of size of buffer */
	int rm_nulls;	/* if nulls should be stripped before pat matching */
	int valid;	/* if any of the other fields should be believed */
	int user_closed;/* if user has issued "close" command or close has */
			/* occurred implicitly */
	int sys_closed;	/* if close() has been called */
	int user_waited;/* if user has issued "wait" command */
	int sys_waited;	/* if wait() (or variant) has been called */
	WAIT_STATUS_TYPE wait;	/* raw status from wait() */
	int parity;	/* strip parity if false */
	int printed;	/* # of characters written to stdout (if logging on) */
			/* but not actually returned via a match yet */
	int echoed;	/* additional # of chars (beyond "printed" above) */
			/* echoed back but not actually returned via a match */
			/* yet.  This supports interact -echo */
	int key;	/* unique id that identifies what command instance */
			/* last touched this buffer */
	int force_read;	/* force read to occur (even if buffer already has */
			/* data).  This supports interact CAN_MATCH */
	int fg_armed;	/* If Tk_CreateFileHandler is active for responding */
			/* to foreground events */


#if TCL_MAJOR_VERSION < 8
	Tcl_File Master;	/* corresponds to master fd */
	Tcl_File Slave;		/* corresponds to slave_fd */
	Tcl_File MasterOutput;	/* corresponds to tcl_output */
	/*
	 *  Following comment only applies to Tcl 7.6:
	 *  Explicit fds aren't necessary now, but since the code is already
	 *  here from before Tcl required Tcl_File, we'll continue using
	 *  the old fds.  If we ever port this code to a non-UNIX system,
	 *  we'll dump the fds totally.
	 */
#endif /* TCL_MAJOR_VERSION < 8 */
	   
	int slave_fd;	/* slave fd if "spawn -pty" used */
d123 1
a123 1
	char *slave_name;/* Full name of slave, i.e., /dev/ttyp0 */
d125 12
a136 13
	char *tcl_handle;/* If opened by someone else, i.e. Tcl's open */
	int tcl_output;	/* output fd if opened by someone else */
			/* input fd is the index of this struct (see above) */
	int leaveopen;	/* If we should not call Tcl's close when we close - */
			/* only relevant if Tcl does the original open */
	Tcl_Interp *bg_interp;	/* interp to process the bg cases */
	int bg_ecount;		/* number of background ecases */
	enum {
		blocked,	/* blocked because we are processing the */
				/* file handler */
		armed,		/* normal state when bg handler in use */
		unarmed,	/* no bg handler in use */
		disarm_req_while_blocked	/* while blocked, a request */
d142 31
a172 2
	} bg_status;
};
d174 1
a174 1
extern int exp_fd_max;		/* highest fd ever used */
d176 1
d184 3
a186 6
EXTERN struct exp_f *exp_fs;

EXTERN struct exp_f *	exp_fd2f _ANSI_ARGS_((Tcl_Interp *,int,int,int,char *));
EXTERN void		exp_adjust _ANSI_ARGS_((struct exp_f *));
EXTERN void		exp_buffer_shuffle _ANSI_ARGS_((Tcl_Interp *,struct exp_f *,int,char *,char *));
EXTERN int		exp_close _ANSI_ARGS_((Tcl_Interp *,int));
d209 1
a209 1
EXTERN void		exp_init_spawn_ids _ANSI_ARGS_((void));
d212 1
d215 2
d228 3
a230 3
struct exp_fd_list {
	int fd;
	struct exp_fd_list *next;
d254 1
a254 1
	struct exp_fd_list *fd_list;
d260 2
a261 2
EXTERN struct exp_i *	exp_new_i_simple _ANSI_ARGS_((int,int));
EXTERN struct exp_fd_list *exp_new_fd _ANSI_ARGS_((int));
d264 2
a265 2
EXTERN void		exp_free_fd _ANSI_ARGS_((struct exp_fd_list *));
EXTERN void		exp_free_fd_single _ANSI_ARGS_((struct exp_fd_list *));
a275 5
/* a hack for easily supporting both Tcl 7 and 8 CreateCommand/Obj split */
/* Can be discarded with Tcl 7 is. */
#if TCL_MAJOR_VERSION < 8
#define exp_proc(cmdproc) cmdproc
#else
a276 1
#endif
a279 1
#if TCL_MAJOR_VERSION >= 8
a280 1
#endif
d295 18
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Initial 8.1 changes.
@
text
@d182 16
a197 1
			/* to foreground events */	   
d324 5
d330 1
d334 1
d336 1
@


5.28.1.1.2.2
log
@Added Exp channel driver and modified rest to support it.
@
text
@a9 8
EXTERN ExpState *       expGetCurrentState _ANSI_ARGS_((Tcl_Interp *,int,int));
EXTERN ExpState *       expGetState _ANSI_ARGS_((Tcl_Interp
	*,Tcl_Channel,int,int,char *));

#define EXP_CHANNELNAMELEN (16 + TCL_INTEGER_SPACE)

#ifdef OBSOLETE 
EXTERN struct exp_f *	exp_fd2f _ANSI_ARGS_((Tcl_Interp *,int,int,int,char *));
a11 2
#endif

d116 8
a124 1
#define EXP_SPAWN_ID_ANY_LIT		"-1"
d146 15
a160 32
/*
 * This structure describes per-instance state of an Exp channel.
 */

typedef struct ExpState {
    Tcl_Channel channel;	/* Channel associated with this file. */
    char name[EXP_CHANNELNAMELEN+1]; /* expect and interact set variables
				   to channel name, so for efficiency
				   cache it here */
    int fdin;			/* File handle */
    int fdout;			/* In some special cases (such as stdin), fd
				   (above) is only for input and fd_output is
				   only for output. */
    Tcl_Channel channel_orig;   /* If opened by someone else, i.e. Tcl's open */
    int fd_slave;		/* slave fd if "spawn -pty" used */

    /* this may go away if we find it is not needed */
    /* it might be needed by inherited channels */
    int validMask;		/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which operations are valid on the file. */

    int pid;		/* pid or EXP_NOPID if no pid */
    Tcl_Obj *buffer;	/* input buffer */

    /* hmm - thought we deleted this, Scott */
    /* Tcl_Obj *lower;	/* input buffer in lowercase */

    /* no longer necessary?
    /* int size;	/* current size of data */

    int msize;	        /* size of buffer (true size is one greater
d162 22
a183 20
    int umsize;	        /* user view of size of buffer */
    int rm_nulls;	/* if nulls should be stripped before pat matching */
    int user_closed;    /* if user has issued "close" command or close has */
    		        /* occurred implicitly */
    int sys_closed;	/* if close() has been called */
    int user_waited;    /* if user has issued "wait" command */
    int sys_waited;	/* if wait() (or variant) has been called */
    WAIT_STATUS_TYPE wait;	/* raw status from wait() */
    int parity;	        /* strip parity if false */
    int printed;	/* # of characters written to stdout (if logging on) */
                        /* but not actually returned via a match yet */
    int echoed;	        /* additional # of chars (beyond "printed" above) */
                        /* echoed back but not actually returned via a match */
                        /* yet.  This supports interact -echo */
    int key;	        /* unique id that identifies what command instance */
                        /* last touched this buffer */
    int force_read;	/* force read to occur (even if buffer already has */
                        /* data).  This supports interact CAN_MATCH */
    int fg_armed;	/* If Tk_CreateFileHandler is active for responding */
                        /* to foreground events */	   
d185 1
a185 1
    char *slave_name;   /* Full name of slave, i.e., /dev/ttyp0 */
d187 13
a199 12
    /* may go away */
    int leaveopen;	/* If we should not call Tcl's close when we close - */
                        /* only relevant if Tcl does the original open */

    Tcl_Interp *bg_interp;	/* interp to process the bg cases */
    int bg_ecount;		/* number of background ecases */
    enum {
	blocked,	/* blocked because we are processing the */
			/* file handler */
	armed,		/* normal state when bg handler in use */
	unarmed,	/* no bg handler in use */
	disarm_req_while_blocked	/* while blocked, a request */
d205 4
a208 4
    } bg_status;
    struct ExpState *nextPtr;	/* Pointer to next file in list of all
				 * file channels. */
} ExpState;
a209 1
extern Tcl_ChannelType expChannelType;
d219 1
a247 1
EXTERN void		exp_init_send _ANSI_ARGS_((void));
d261 3
a263 3
struct exp_state_list {
	ExpState *esPtr;
	struct exp_state_list *next;
d287 1
a287 1
	struct exp_state_list *state_list;
d294 1
a294 1
EXTERN struct exp_state_list *exp_new_state _ANSI_ARGS_((int));
d297 2
a298 2
EXTERN void		exp_free_state _ANSI_ARGS_((struct exp_state_list *));
EXTERN void		exp_free_state_single _ANSI_ARGS_((struct exp_state_list *));
a326 14

EXTERN ExpState *	expCreateChannel _ANSI_ARGS_((int,int,int));
EXTERN ExpState *	expWaitOnAny _ANSI_ARGS_((Tcl_Interp *));
EXTERN int		expIsStateAny _ANSI_ARGS_((ExpState *));
EXTERN int		expIsStateStdinOut _ANSI_ARGS_((ExpState *));
EXTERN int		expIsStateDevtty _ANSI_ARGS_((ExpState *));
EXTERN ExpState *	expGetChannel _ANSI_ARGS_((Tcl_Interp *,char *));
EXTERN void		expSysClose _ANSI_ARGS_((ExpState *));
EXTERN void		expInitExpectVars _ANSI_ARGS_((void));
EXTERN int		expIsExpChannelName _ANSI_ARGS_((char *));
EXTERN int		expIsStdinout _ANSI_ARGS((ExpState *));
EXTERN ExpState *	expStdinout _ANSI_ARGS((void));
EXTERN ExpState *	expDevtty _ANSI_ARGS((void));

@


5.28.1.1.2.3
log
@modified expect command to use new regexp interfaces, made various
I18N changes
@
text
@d180 3
a182 3
    int msize;	        /* maximum number of characters to hold in the */
			/* buffer*/
    int umsize;	        /* user view of size of buffer (in characters) */
d191 1
a191 1
    int printed;	/* # of bytes written to stdout (if logging on) */
d193 1
a193 1
    int echoed;	        /* additional # of bytes (beyond "printed" above) */
@


5.28.1.1.2.4
log
@got rid of remaining references to exp_fs and friends and exp_update_masters
@
text
@d11 2
a12 1
EXTERN ExpState *       expGetStateFromChannelName _ANSI_ARGS_((Tcl_Interp *,char *,int,int,char *));
a16 1
EXTERN struct exp_f *exp_fs;
d235 4
a238 2
EXTERN void		exp_adjust _ANSI_ARGS_((ExpState *));
EXTERN void		exp_buffer_shuffle _ANSI_ARGS_((Tcl_Interp *,ExpState *,int,char *,char *));
@


5.28.1.1.2.5
log
@fixed Log/Diag and ExpectCmd
@
text
@d10 3
d15 7
d158 6
a163 5
    int fdin;		/* input fd */
    int fdout;		/* output fd - usually the same as fdin, although
			   may be different if channel opened by tcl::open */
    Tcl_Channel channel_orig;   /* If opened by someone else, i.e. tcl::open */
    int fd_slave;	/* slave fd if "spawn -pty" used */
d174 17
a190 3
    int msize;	        /* # of bytes that buffer can hold (max) */
    int umsize;	        /* # of bytes (min) that is guaranteed to match */
			/* this comes from match_max command */
a195 8

    int rm_nulls;	/* if nulls should be stripped before pat matching */
    int open;		/* if fdin/fdout open */
    int user_waited;    /* if user has issued "wait" command */
    int sys_waited;	/* if wait() (or variant) has been called */
    int registered;	/* if channel registered */
    WAIT_STATUS_TYPE wait;	/* raw status from wait() */
    int parity;	        /* if parity should be preserved */
d235 1
a235 1
EXTERN void		expAdjust _ANSI_ARGS_((ExpState *));
a343 3
EXTERN ExpState *       expStateCurrent _ANSI_ARGS_((Tcl_Interp *,int,int,int));
EXTERN ExpState *       expStateFromChannelName _ANSI_ARGS_((Tcl_Interp *,char *,int,int,int,char *));

d346 12
a357 11
EXTERN int		expStateAnyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expStateStdinOutIs _ANSI_ARGS_((ExpState *));
EXTERN int		expStateDevttyIs _ANSI_ARGS_((ExpState *));
EXTERN void		expExpectVarsInit _ANSI_ARGS_((void));
EXTERN int		expStdinoutIs _ANSI_ARGS_((ExpState *));
EXTERN ExpState *	expStdinoutGet _ANSI_ARGS_((void));
EXTERN ExpState *	expDevttyGet _ANSI_ARGS_((void));

/* generic functions that really should be provided by Tcl */
EXTERN int		expSizeGet _ANSI_ARGS_((ExpState *));
EXTERN int		expSizeZero _ANSI_ARGS_((ExpState *));
@


5.28.1.1.2.6
log
@made stuff compile
@
text
@d18 1
a18 1
EXTERN int		exp_one_arg_braced _ANSI_ARGS_((Tcl_Obj *));
d20 1
a20 1
				Tcl_Interp *,objv **));
d220 1
a220 1
EXTERN int		exp_close _ANSI_ARGS_((Tcl_Interp *,ExpState *));
a248 2
EXTERN void		expChannelInit _ANSI_ARGS_((void));
EXTERN int		expChannelCountGet _ANSI_ARGS_((void));
d292 2
a293 2
EXTERN struct exp_i *	exp_new_i_simple _ANSI_ARGS_((ExpState *,int));
EXTERN struct exp_state_list *exp_new_state _ANSI_ARGS_((ExpState *));
d332 3
d336 1
a336 3
EXTERN int		expStateAnyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expDevttyIs _ANSI_ARGS_((ExpState *));
EXTERN int		expStdinOutIs _ANSI_ARGS_((ExpState *));
@


5.28.1.1.2.7
log
@making expect.c compile
@
text
@d20 1
a20 1
				Tcl_Interp *, struct Tcl_Obj * CONST objv[]));
@


5.28.1.1.2.8
log
@Checkpoint
@
text
@a205 17

    /*
     * If the channel is freed while in the middle of a bg event handler,
     * remember that and defer freeing of the ExpState structure until
     * it is safe.
     */
    int freeWhenBgHandlerUnblocked;

    /* 
     * stdinout and stderr never go away so that our internal refs to them
     * don't have to be invalidated.  Having to worry about invalidating them
     * would be a major pain.  */
    int keepForever;

    /*  Remember that "reserved" esPtrs are no longer in use. */
    int valid;
    
a330 1
EXTERN void		expStateFree _ANSI_ARGS_((ExpState *));
@


5.28.1.1.2.9
log
@compiled!
@
text
@a9 13
#ifdef HAVE_SYS_WAIT_H
  /* ISC doesn't def WNOHANG unless _POSIX_SOURCE is def'ed */
# ifdef WNOHANG_REQUIRES_POSIX_SOURCE
#  define _POSIX_SOURCE
# endif
# include <sys/wait.h>
# ifdef WNOHANG_REQUIRES_POSIX_SOURCE
#  undef _POSIX_SOURCE
# endif
#endif

#include "../unix/tclUnixPort.h"

d32 84
d260 1
a260 1
EXTERN void		exp_init_spawn_ids _ANSI_ARGS_((Tcl_Interp *));
d350 1
a350 1
EXTERN ExpState *	expCreateChannel _ANSI_ARGS_((Tcl_Interp *,int,int,int));
@


5.28.1.1.2.10
log
@Fixed:
 expect command's arg handling to work (like interact)
 spawn -open
 expect eof
and various other bugs.
Expect now runs its minimal test suite (but not the examples).
@
text
@a142 8
    /* If channel is closed but not yet waited on, we tie up the fd by
     * attaching it to /dev/null.  We play this little game so that we
     * can embed the fd in the channel name.  If we didn't tie up the
     * fd, we'd get channel name collisions.  I'd consider naming the
     * channels independently of the fd, but this makes debugging easier.
     */
    int fdBusy;

@


5.28.1.1.2.11
log
@Fixed interact's -input/-output.
More fixes to exp_eval_with_one_arg.
Now runs dislocate.
@
text
@d46 1
a46 6
#define EXP_SPAWN_ID_ANY_LIT		"exp?"

#define EXP_CHANNEL_PREFIX "exp"
#define EXP_CHANNEL_PREFIX_LENGTH 3
#define isExpChannelName(name) \
    (0 == strncmp(name,EXP_CHANNEL_PREFIX,EXP_CHANNEL_PREFIX_LENGTH))
@


5.28.1.1.2.12
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@a116 3
    int notified;	/* If Tcl_NotifyChannel has been called and we */
		        /* have not yet read from the channel. */
    int notifiedMask;	/* Mask reported when notified. */
a287 1
EXTERN ExpState *	expStateCheck _ANSI_ARGS_((Tcl_Interp *,ExpState *,int,int,char *));
d293 1
a293 2
EXTERN ExpState *	expWaitOnAny _ANSI_ARGS_((void));
EXTERN ExpState *	expWaitOnOne _ANSI_ARGS_((void));
@


5.28.1.1.2.13
log
@exp_chan.c:  Fixed incompatible type assignment in expWaitOnOne()
exp_command.h:  Now includes <tclPort.h> instead of ../unix/tclUnixPort.h

Other files touched but not changed.
@
text
@d21 1
a21 1
#include <tclPort.h>
@


5.28.1.1.2.14
log
@Fixed Expect's standalone C library and examples.  This required some
changes to Expect since it and the library share some things.
@
text
@a171 4
#define EXP_SPAWN_ID_BAD	((ExpState *)0)

#define EXP_TIME_INFINITY	-1

@


