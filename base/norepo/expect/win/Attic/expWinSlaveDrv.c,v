head	1.1;
access;
symbols
	telco-tec-win32-take2-branch:1.1.2.1.0.2
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2001.09.13.02.01.49;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.13.02.01.49;	author davygrvy;	state Exp;
branches
	1.1.2.1.2.1;
next	1.1.2.2;

1.1.2.2
date	2001.10.11.02.41.47;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.11.13.29.43;	author davygrvy;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.26.09.34.34;	author davygrvy;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.26.11.49.18;	author davygrvy;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.11.07.10.04.57;	author davygrvy;	state Exp;
branches;
next	;

1.1.2.1.2.1
date	2001.11.22.08.50.38;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.2;

1.1.2.1.2.2
date	2001.11.22.11.03.38;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.3;

1.1.2.1.2.3
date	2001.12.17.07.15.06;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.4;

1.1.2.1.2.4
date	2001.12.18.00.29.59;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.5;

1.1.2.1.2.5
date	2001.12.19.01.00.34;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.6;

1.1.2.1.2.6
date	2001.12.21.12.17.22;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.7;

1.1.2.1.2.7
date	2001.12.22.05.29.22;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.8;

1.1.2.1.2.8
date	2002.02.10.06.25.50;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.9;

1.1.2.1.2.9
date	2002.03.12.07.53.12;	author davygrvy;	state dead;
branches;
next	;


desc
@@


1.1
log
@file expWinSlaveDrv.c was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.2.1
log
@snap29 "import"
@
text
@a0 1419
/* 
 * expWinSlaveDrv.c --
 *
 *	This file implements the Windows NT specific expect slave driver.
 *	The slave driver is used to control a subprocess, but it does it
 *	in an unshared console.  Because a process can only be attached
 *	to a single console, we need to have a separate executable 
 *	driving the slave process.  Hence, a slave driver.
 *
 * Copyright (c) 1997 by Mitel Corporation
 * Copyright (c) 1997-1998 by Gordon Chaffee
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 *
 * XXX: Make sure to check at initialization time in Expect that we are
 * not trying to run on Win32s or Windows 95.  Named pipes will fail
 * rather quickly on Win95 anyway.
 *
 */

/*
 *----------------------------------------------------------------------
 * Communication Protocol Between Master and Slave Driver
 *
 * The master sends over a single byte command.  Depending on
 * the command, further data may follow.  Not all of this is
 * implemented, and some may have changed.
 *
 * EXP_SLAVE_WRITE:
 *	Further Data: Followed by binary 4 bytes specifying length data
 *		to write to slave.
 *	Response: None
 *
 * EXP_SLAVE_KEY:
 *	Further Data: Not defined yet.  Will correspond to the
 *	   KEY_EVENT_RECORD structure.
 *		BOOL bKeyDown; 
 *		WORD wRepeatCount; 
 *		WORD wVirtualKeyCode; 
 *		WORD wVirtualScanCode; 
 *		union { 
 *			WCHAR UnicodeChar; 
 *			CHAR  AsciiChar; 
 *		} uChar; 
 *		DWORD dwControlKeyState; 
 *	Response: None
 *
 *----------------------------------------------------------------------
 */

/*
 * Even though we won't have access to most of the commands, use the
 * normal headers 
 */

#include <winsock2.h>
#include "tcl.h"
#include "tclPort.h"
#include "expWin.h"
#include "expWinSlave.h"

#define STATE_WAIT_CMD   0	/* Waiting for the next command */
#define STATE_CREATE     1	/* Doesn't happen currently */
#define STATE_KEY        2	/* Waiting for key params */
#define STATE_KILL       3	/* 1 Param: type of kill to do */
#define STATE_MOUSE      4	/*  */
#define STATE_WRITE      5	/* Wait for the length of the data */
#define STATE_WRITE_DATA 6	/* Wait for the data itself */

#define BUFSIZE 4096

typedef struct PassThrough {
    HANDLE in;
    HANDLE hMaster;		/* Output when we are using pipes */
    int useSocket;
    BOOL running;
    HANDLE thread;
} PassThrough;

static HANDLE hMutex;

HANDLE hShutdown;   /* Event is set when the slave driver is shutting down. */

HANDLE ExpConsoleOut;
int    ExpDebug;

typedef struct ExpFunctionKey {
    char *sequence;
    DWORD keyval;
} ExpFunctionKey;

ExpFunctionKey VtFunctionKeys[] =
{
    {"OP",  EXP_KEY_F1},
    {"OQ",  EXP_KEY_F2},
    {"OR",  EXP_KEY_F3},
    {"OS",  EXP_KEY_F4},
    {"[A",  EXP_KEY_UP},
    {"[B",  EXP_KEY_DOWN},
    {"[C",  EXP_KEY_RIGHT},
    {"[D",  EXP_KEY_LEFT},
    {"[F",  EXP_KEY_END},
    {"[H",  EXP_KEY_HOME},
    {"[2~", EXP_KEY_INSERT},
    {"[3~", EXP_KEY_DELETE},
    {"[4~", EXP_KEY_SELECT},
    {"[5~", EXP_KEY_PAGEUP},
    {"[6~", EXP_KEY_PAGEDOWN},
    {"[11~", EXP_KEY_F1},
    {"[12~", EXP_KEY_F2},
    {"[13~", EXP_KEY_F3},
    {"[14~", EXP_KEY_F4},
    {"[15~", EXP_KEY_F5},
    {"[17~", EXP_KEY_F6},
    {"[18~", EXP_KEY_F7},
    {"[19~", EXP_KEY_F8},
    {"[20~", EXP_KEY_F9},
    {"[21~", EXP_KEY_F10},
    {"[23~", EXP_KEY_F11},
    {"[24~", EXP_KEY_F12},
    {"[25~", EXP_KEY_F13},
    {"[26~", EXP_KEY_F14},
    {"[28~", EXP_KEY_F15},
    {"[29~", EXP_KEY_F16},
    {"[31~", EXP_KEY_F17},
    {"[32~", EXP_KEY_F18},
    {"[33~", EXP_KEY_F19},
    {"[34~", EXP_KEY_F20},
    {"[39~", EXP_WIN_RESIZE},
    {NULL, 0}
};

#define EXP_MAX_QLEN 200
HANDLE ExpWaitEvent;		/* Set after modifying wait queue */
HANDLE ExpWaitMutex;		/* Grab before modifying wait queue */
DWORD  ExpWaitCount;		/* Current number of wait handles */
HANDLE ExpWaitQueue[EXP_MAX_QLEN];/* wait handles */
DWORD  ExpConsoleInputMode;	/* Current flags for the console */

static void		InitializeWaitQueue(void);
static BOOL 		PipeRespondToMaster(int useSocket, HANDLE handle,
			    DWORD value, DWORD pid);
static void		ExpProcessInput(HANDLE hMaster,
			    HANDLE hConsole, HANDLE hConsoleOut,
			    int useSocket, ExpSlaveDebugArg *debugInfo);
static void		SshdProcessInput(HANDLE sock, HANDLE hConsoleInW,
			    HANDLE hConsoleOut);
static BOOL		WriteBufferToSlave(int sshd, int useSocket,
			    int noEscapes, HANDLE hMaster,
			    HANDLE hConsoleInW, HANDLE hConsoleOut,
			    PUCHAR buf, DWORD n, LPOVERLAPPED over);
static DWORD WINAPI	PassThroughThread(LPVOID *arg);
static DWORD WINAPI	WaitQueueThread(LPVOID *arg);
static void		SetArgv(char *cmdLine, int *argcPtr, char ***argvPtr);

/*
 *----------------------------------------------------------------------
 *
 * main --
 *
 *	Main entry point from Windows.  The arguments to this program
 *	are used to create the subprocess that this will control.
 *	However, it will not execute the subprocess immediately.
 *	It waits to hear from the expect process about setting
 *	things like the CTRL-C handler and such.
 *
 *	argv[1] is the named pipe base that we need to connect to.
 *	argv[2] Flags:	bit 0: Use pipes or not.
 *	argv[3] is the program we will run, and all the following
 *	  are its arguments.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	The launch of this program will have caused a console to be
 *	allocated.  This will then send commands to subprocesses.
 *
 * Notes:
 *	Because we are dealing with anonymous pipes, all actions
 *	on pipes are blocking.  To deal with this, after a process
 *	is created, we need to create two additional threads that
 *	read from the child's STDOUT and STDERR.  Anything read
 *	from the pipe will be forwarded directly to the master on
 *	the appropriate pipes.  This should also take care of the
 *	problems associated with blocking pipes.
 *
 *----------------------------------------------------------------------
 */

void
main(argc, argv)
    int argc;
    char **argv;
{
    HANDLE hConsoleInW;		/* Console, writeable input handle */
    HANDLE hConsoleOut;	/* Console, readable output handle */
    HANDLE hMaster;		/* Pipe between master and us */
    HANDLE hSlaveOut;		/* Pipe from slave's STDOUT to us */
    HANDLE hSlaveOutW;		/* Pipe from slave's STDOUT to us */
    HANDLE hProcess;		/* Current process handle */
    UCHAR cmdline[BUFSIZE];
    BOOL bRet;
    DWORD dwResult;
    HANDLE hThread;
    DWORD threadId;
    ExpSlaveDebugArg debugInfo;
    PassThrough thruSlaveOut;
    int passThrough = 0;
    int useSocket = 0;
    int n;
    int sshd = 0;

    struct sockaddr_in sin;
    WSADATA	SockData;

#if 0
    Sleep(22000);		/* XXX: For debugging purposes */
#endif

    if (argc < 2) {
	exit(1);
    }
    if (argc == 2) {
	/* This is how we use it from sshd */
	useSocket = 1;
	sshd = 1;
    } else {
	if (argv[2][0] == '1') {
	    passThrough = 1;
	}
	if (argv[3][0] == '1') {
	    ExpDebug = 1;
	}
    
	if (argv[1][0] != '\\' && argv[1][0] >= '0' && argv[1][0] <= '9') {
	    useSocket = 1;
	} else {
	    useSocket = 0;
	}
    }

    if (!useSocket) {
	hMaster = CreateFile(argv[1], GENERIC_READ | GENERIC_WRITE,
			     0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
	if (hMaster == NULL) {
	    EXP_LOG("Unexpected error 0x%x", GetLastError());
	    Sleep(5000);
	    ExitProcess(255);
	}
    } else {
	SOCKET fdmaster;
	dwResult = WSAStartup(MAKEWORD(2, 0), &SockData);
	if (dwResult != 0) {
	    fprintf(stderr, "Unexpected error 0x%x\n", WSAGetLastError());
	    EXP_LOG("Unexpected error 0x%x", WSAGetLastError());
	    Sleep(5000);
	    ExitProcess(255);
	}

	fdmaster = WSASocket(PF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0,
			     WSA_FLAG_OVERLAPPED);

	/*
	 * Now attach this to a specific port.
	 */
	sin.sin_family = AF_INET;
	sin.sin_port = htons((short) strtoul(argv[1], NULL, 10));
	sin.sin_addr.s_addr = inet_addr("127.0.0.1");
	if (connect(fdmaster, (struct sockaddr *) &sin, sizeof(sin)) == SOCKET_ERROR) {
	    fprintf(stderr, "Unexpected error 0x%x\n", WSAGetLastError());
	    EXP_LOG("Unexpected error 0x%x", WSAGetLastError());
	    Sleep(5000);
	    ExitProcess(255);
	}
	hMaster = (HANDLE) fdmaster;
    }

    ExpConsoleOut = CreateFile("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, 
			  OPEN_EXISTING, 0, NULL);

    /*
     * After the subprocess is created, send back the status (success or not)
     * and the process id of the child so the master can kill it.
     */

    hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (passThrough) {
	bRet = CreatePipe(&hSlaveOut, &hSlaveOutW, NULL, 0);
	if (bRet == FALSE) {
	    PipeRespondToMaster(useSocket, hMaster, GetLastError(), 0);
	    ExitProcess(255);
	}
    } else {
	hSlaveOutW = NULL;
    }
    hMutex = CreateMutex(NULL, FALSE, NULL);
    if (hMutex == NULL) {
	PipeRespondToMaster(useSocket, hMaster, GetLastError(), 0);
	ExitProcess(255);
    }

    InitializeWaitQueue();

    if (sshd) {
	OVERLAPPED over;
	memset(&over, 0, sizeof(over));
	over.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	bRet = ExpReadMaster(useSocket, hMaster, cmdline, BUFSIZE, &n, &over,
			     &dwResult);
	CloseHandle(over.hEvent);
	cmdline[n] = 0;
	SetArgv(cmdline, &debugInfo.argc, &debugInfo.argv);
    } else {
	debugInfo.argc = argc-4;
	debugInfo.argv = &argv[4];
    }

    /*
     * The subprocess needs to be created in the debugging thread.
     * Set all the args in debugInfo and start it up.
     */
     
    hConsoleInW = CreateFile("CONIN$", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, 
			     OPEN_EXISTING, 0, NULL);
    if (hConsoleInW == NULL) {
	EXP_LOG("Unexpected error 0x%x", GetLastError());
	ExitProcess(255);
    }
    hConsoleOut = CreateFile("CONOUT$", GENERIC_READ|GENERIC_WRITE,
			      FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, 
			      OPEN_EXISTING, 0, NULL);
    if (hConsoleOut == NULL) {
	EXP_LOG("Unexpected error 0x%x", GetLastError());
	ExitProcess(255);
    }

    ExpConsoleInputMode = ENABLE_LINE_INPUT|ENABLE_ECHO_INPUT|
	ENABLE_PROCESSED_INPUT|ENABLE_MOUSE_INPUT;

    debugInfo.passThrough = passThrough;
    debugInfo.useSocket = useSocket;
    debugInfo.hConsole = hConsoleOut;
    debugInfo.hMaster = hMaster;
    debugInfo.slaveStdin = NULL;
    debugInfo.slaveStdout = hSlaveOutW;
    debugInfo.slaveStderr = hSlaveOutW;
    debugInfo.event = CreateEvent(NULL, TRUE, FALSE, NULL);
    debugInfo.thread = CreateThread(NULL, 65536, ExpSlaveDebugThread,
	(LPVOID) &debugInfo, 0, &threadId);
    ExpAddToWaitQueue(debugInfo.thread);

    WaitForSingleObject(debugInfo.event, INFINITE);
    CloseHandle(debugInfo.event);
    if (passThrough) {
	CloseHandle(hSlaveOutW);
    }

    bRet = PipeRespondToMaster(useSocket, hMaster, debugInfo.result, debugInfo.globalPid);
    if (bRet == FALSE) {
	ExitProcess(255);
    }
    if (debugInfo.result) {
	ExitProcess(0);
    }

    if (passThrough) {
	hProcess = GetCurrentProcess();
	thruSlaveOut.in = hSlaveOut;
	thruSlaveOut.useSocket = useSocket;
	thruSlaveOut.hMaster = hMaster;
	thruSlaveOut.thread = CreateThread(NULL, 8192, PassThroughThread,
	    (LPVOID) &thruSlaveOut, 0, &threadId);
	ExpAddToWaitQueue(thruSlaveOut.thread);
    }
    
    hThread = CreateThread(NULL, 8192, WaitQueueThread,
			   (LPVOID) &debugInfo.process, 0, &threadId);
    CloseHandle(hThread);

    if (sshd) {
	SshdProcessInput(hMaster, hConsoleInW, hConsoleOut);
    } else {
	ExpProcessInput(hMaster, hConsoleInW, hConsoleOut,
			useSocket, &debugInfo);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ExpProcessInput --
 *
 *	The master in this case is Expect.  Drives until everything exits.
 *
 * Results:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
ExpProcessInput(HANDLE hMaster, HANDLE hConsoleInW, HANDLE hConsoleOut,
		int useSocket, ExpSlaveDebugArg *debugInfo)
{
    OVERLAPPED over;
    UCHAR buffer[BUFSIZE];
    DWORD dwState;
    DWORD dwHave;
    DWORD dwNeeded;
    DWORD dwTotalNeeded;
    BOOL bRet;
    DWORD dwResult;
    DWORD driverInCnt;		/* Number of bytes read from expect pipe */

    dwHave = 0;
    dwState = STATE_WAIT_CMD;
    dwNeeded = 1;

    memset(&over, 0, sizeof(over));
    over.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    while (1) {
	bRet = ExpReadMaster(useSocket, hMaster, &buffer[dwHave],
			     dwNeeded-dwHave, &driverInCnt, &over, &dwResult);
	if ((bRet == TRUE && driverInCnt == 0) ||
	    (bRet == FALSE && dwResult == ERROR_BROKEN_PIPE))
	{
	    if( useSocket )
	    {
		/*
		 * We should always break out because the hShutdown event got set
		 * as the wait queue thread exited.
		 */
		if( WaitForSingleObject(hShutdown, 0) == WAIT_OBJECT_0 )
		{
		    fd_set		   monitor;
		    int			   sts;
		    /*
		     * This means that all of the other threads have shut down cleanly.
		     */
		    
		    /*
		     * This will signal shutdown to the other end, by sending the
		     * FD_CLOSE.  We need to hold the connection open until the
		     * master side has closed it's end of the socket.
		     */
		    shutdown((SOCKET) hMaster, SD_SEND);
		    FD_ZERO(&monitor);
		    FD_SET((unsigned int) hMaster, &monitor);
		    sts = select(0, &monitor, NULL, NULL, NULL);
		    
		    /*
		     * Once we get the FD_CLOSE back from the master, then it is
		     * safe to close the socket.
		     */
		    closesocket((SOCKET) hMaster);
		}
		else
		{
		    EXP_LOG("Unclean shutdown 0x%x", dwResult);
		}
	    }
	    ExpKillProcessList();
	    ExitProcess(0);
	} else if (bRet == FALSE) {
	    EXP_LOG("Unexpected error 0x%x", dwResult);
	    ExpKillProcessList();
	    ExitProcess(255);
	}

	dwHave += driverInCnt;
	if (dwHave != dwNeeded) {
	    continue;
	}
	dwHave = 0;
	switch (dwState) {
	case STATE_WAIT_CMD:
	    switch (buffer[0]) {
	    case EXP_SLAVE_KILL:
		dwState = STATE_KILL;
		dwNeeded = 1;
		break;
	    case EXP_SLAVE_KEY:
		/* XXX: To be implemented */
		dwState = STATE_KEY;
		dwNeeded = 13;
		break;
	    case EXP_SLAVE_MOUSE:
		/* XXX: To be implemented */
		dwState = STATE_MOUSE;
		dwNeeded = 13 /* XXX */;
		break;
	    case EXP_SLAVE_WRITE:
		dwNeeded = 4;
		dwState = STATE_WRITE;
		break;
	    }
	    break;
	case STATE_KILL:
	    dwResult = buffer[0];
	    if (dwResult & EXP_KILL_CTRL_C) {
		GenerateConsoleCtrlEvent(CTRL_C_EVENT, debugInfo->globalPid);
	    } else if (dwResult & EXP_KILL_CTRL_BREAK) {
		GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,debugInfo->globalPid);
	    } else if (dwResult & EXP_KILL_TERMINATE) {
		Exp_KillProcess((Tcl_Pid) debugInfo->process);
	    }
	    dwState = STATE_WAIT_CMD;
	    dwNeeded = 1;
	    break;
	case STATE_WRITE:
	    dwTotalNeeded = buffer[0] | (buffer[1] << 8) |
		(buffer[2] << 16) | (buffer[3] << 24);
	    dwNeeded = (dwTotalNeeded > BUFSIZE) ? BUFSIZE : dwTotalNeeded;
	    dwState = STATE_WRITE_DATA;
	    break;
	case STATE_WRITE_DATA:
	    if (WriteBufferToSlave(FALSE, useSocket, FALSE, hMaster,
				   hConsoleInW, hConsoleOut,
				   buffer, dwNeeded, &over) == FALSE)
	    {
		EXP_LOG("Unable to write to slave: 0x%x", GetLastError());
	    }
	    dwTotalNeeded -= dwNeeded;
	    if (dwTotalNeeded) {
		dwNeeded = (dwTotalNeeded > BUFSIZE) ?
		    BUFSIZE : dwTotalNeeded;
	    } else {
		dwNeeded = 1;
		dwState = STATE_WAIT_CMD;
	    }
	    break;
	case STATE_KEY:
	case STATE_MOUSE:
	    /* XXX: To be implemented */
	    break;
	default:
	    /* If we ever get here, there is a problem */
	    EXP_LOG("Unexpected state\n", 0);
	    break;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SshdProcessInput --
 *
 *	The master in this case is sshd.  Drives until everything exits.
 *
 * Results:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
SshdProcessInput(HANDLE hMaster, HANDLE hConsoleInW, HANDLE hConsoleOut)
{
    int n;
    UCHAR buffer[BUFSIZE];
    BOOL b;
    DWORD dwError;
    OVERLAPPED over;

    memset(&over, 0, sizeof(over));
    over.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    ExpNewConsoleSequences(TRUE, hMaster, &over);

    while (1) {
	ResetEvent(over.hEvent);
	b = ExpReadMaster(TRUE, hMaster, buffer, BUFSIZE, &n, &over, &dwError);
	/*
	 * FIXME(eric) - the changes I put in for process shutdown have probably broken
	 * this.
	 */
	if (!b) {
	    ExpKillProcessList();
	    ExitProcess(0);
	}

	if (WriteBufferToSlave(TRUE, TRUE, FALSE, hMaster, hConsoleInW,
			       hConsoleOut, buffer, n, &over) == FALSE)
	{
	    EXP_LOG("Unable to write to slave: 0x%x", GetLastError());
	}
    }

}


/*
 *----------------------------------------------------------------------
 *
 * InitializeWaitQueue --
 *
 *	Set up the initial wait queue
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */
static void
InitializeWaitQueue(void)
{
    int i;
    ExpWaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ExpWaitMutex = CreateMutex(NULL, FALSE, NULL);
    ExpWaitCount = 0;
    for (i = 0; i < EXP_MAX_QLEN; i++) {
	ExpWaitQueue[i] = INVALID_HANDLE_VALUE;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ExpAddToWaitQueue --
 *
 *	Adds a handle to the wait queue.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */
void
ExpAddToWaitQueue(HANDLE handle)
{
    DWORD i;

    WaitForSingleObject(ExpWaitMutex, INFINITE);
    for (i = 0; i < EXP_MAX_QLEN; i++) {
	if (ExpWaitQueue[i] == INVALID_HANDLE_VALUE) {
	    ExpWaitQueue[i] = handle;
	    ExpWaitCount++;
	    break;
	}
    }
    ReleaseMutex(ExpWaitMutex);
    SetEvent(ExpWaitEvent);
}

/*
 *----------------------------------------------------------------------
 *
 * PipeRespondToMaster --
 *
 *	Sends back an error response to the Expect master.
 *
 * Results:
 *	TRUE if successful, FALSE if not
 *
 *----------------------------------------------------------------------
 */
static BOOL
PipeRespondToMaster(int useSocket, HANDLE handle, DWORD value, DWORD pid)
{
    UCHAR buf[8];

    buf[0] = (UCHAR) (value & 0x000000ff);
    buf[1] = (UCHAR) ((value & 0x0000ff00) >> 8);
    buf[2] = (UCHAR) ((value & 0x00ff0000) >> 16);
    buf[3] = (UCHAR) ((value & 0xff000000) >> 24);
    buf[4] = (UCHAR) (pid & 0x000000ff);
    buf[5] = (UCHAR) ((pid & 0x0000ff00) >> 8);
    buf[6] = (UCHAR) ((pid & 0x00ff0000) >> 16);
    buf[7] = (UCHAR) ((pid & 0xff000000) >> 24);

    return ExpWriteMaster(useSocket, handle, buf, sizeof(buf), NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * ExpWriteMaster --
 *
 *	Write to the Expect master using either a socket or a pipe
 *
 * Results:
 *	TRUE if successful, FALSE if not
 *
 *----------------------------------------------------------------------
 */

BOOL
ExpWriteMaster(int useSocket, HANDLE hFile, void *buf, DWORD n,
	       LPOVERLAPPED over)
{
    DWORD count, dwResult;
    BOOL bRet;
    WSABUF wsabuf[1];

    if (! useSocket) {
	bRet = WriteFile(hFile, buf, n, &count, over);
	if (!bRet && over) {
	    dwResult = GetLastError();
	    if (dwResult == ERROR_IO_PENDING) {
		bRet = GetOverlappedResult(hFile, over, &count, TRUE);
	    }
	}
	return bRet;
    } else {
	int ret;
	wsabuf[0].buf = buf;
	wsabuf[0].len = n;
	ret = WSASend((SOCKET) hFile, wsabuf, 1, &count, 0, over, NULL);
	if (ret == -1 && over) {
	    dwResult = GetLastError();
	    if (dwResult == ERROR_IO_PENDING) {
		bRet = GetOverlappedResult(hFile, over, &count, TRUE);
	    }
	}
	if (count == n) {
	    return TRUE;
	}
	return FALSE;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ExpReadMaster --
 *
 *	Read from the Expect master using either a socket or a pipe
 *
 * Results:
 *	TRUE if successful, FALSE if not.  If we hit and end of file
 *	condition, returns TRUE with *pCount = 0
 *
 *----------------------------------------------------------------------
 */

BOOL
ExpReadMaster(int useSocket, HANDLE hFile, void *buf, DWORD n,
	      PDWORD pCount, LPOVERLAPPED over, PDWORD pError)
{
    int x;
    WSABUF wsabuf[1];
    HANDLE hnd[2];
    BOOL bRet;
    DWORD dwResult;
    DWORD flags;

    *pError = 0;
    if (! useSocket) {
	bRet = ReadFile(hFile, buf, n, pCount, over);
	if (!bRet) {
	    dwResult = GetLastError();
	}
    } else {
	wsabuf[0].buf = buf;
	wsabuf[0].len = n;
	flags = 0;
	bRet = TRUE;
	x = WSARecv((SOCKET) hFile, wsabuf, 1, pCount, &flags, over, NULL);
	if (x == SOCKET_ERROR) {
	    bRet = FALSE;
	    dwResult = WSAGetLastError();
	}
    }
    if (bRet == FALSE) {
	if (dwResult == ERROR_IO_PENDING) {
	    hnd[0] = hShutdown;
	    hnd[1] = over->hEvent;
	    bRet = WaitForMultipleObjects(2, hnd, FALSE, INFINITE);
	    if( bRet == WAIT_OBJECT_0 )
	    {
		/*
		 * We have been instructed to shut down.
		 */
		*pCount = 0;
		bRet = TRUE;
	    }
	    else
	    {
		bRet = GetOverlappedResult(hFile, over, pCount, TRUE);
		if (bRet == FALSE) {
		    dwResult = GetLastError();
		}
	    }
	} else if (dwResult == ERROR_HANDLE_EOF ||
		   dwResult == ERROR_BROKEN_PIPE) {
	    *pCount = 0;
	    bRet = TRUE;
	}
	*pError = dwResult;
    }
    return bRet;
}

/*
 *----------------------------------------------------------------------
 *
 * PassThroughThread --
 *
 *	Reads everything that is currently available from one pipe
 *	and sends it to the other pipe.  Since anonymous pipes are
 *	synchronous, we wait for a read on one pipe and then send
 *	to the next pipe.
 *
 * Results:
 *	This this exits before leaving.
 *
 * Notes:
 *	XXX: Should be using ExpReadMaster instead of ReadFile, but
 *	it is very sensitive to error conditions.
 *
 *----------------------------------------------------------------------
 */
static DWORD WINAPI
PassThroughThread(LPVOID *arg)
{
    PassThrough *thru = (PassThrough *) arg;
    HANDLE hIn = thru->in;
    HANDLE hMaster = thru->hMaster;
    int useSocket = thru->useSocket;
    OVERLAPPED over;
    DWORD nread;
    DWORD max;
    DWORD count, n;
    BOOL ret;
    UCHAR buf[BUFSIZE];
    DWORD exitVal;
    LONG err;

    n = 0;

    if (hMaster != NULL) {
	over.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    }

    while (1) {
	ret = PeekNamedPipe(hIn, NULL, 0, NULL, &nread, NULL);
	if (ret == FALSE) {
	    break;
	}
	if (nread == 0) {
	    nread = 1;
	}
	do {
	    max = sizeof(buf) - 1 - n;
	    nread = min(nread, max);
	    ret = ReadFile(hIn, &buf[n], nread, &count, NULL);
	    if (ret == FALSE) {
		err = GetLastError();
		goto done;
	    }
	    if (count > 0) {
		n += count;
		if (n - 1 >= sizeof(buf)) {
		    break;
		}
	    } else {
		break;
	    }
	    ret = PeekNamedPipe(hIn, NULL, 0, NULL, &nread, NULL);
	    if (ret == FALSE) {
		err = GetLastError();
		goto done;
	    }
	    /*
	     * To allow subprocess to do something without continuous
	     * process switching, give it a bit of processing time before
	     * we check for more data.
	     */
	    if (count == 1 && nread == 0) {
		Sleep(40);
		ret = PeekNamedPipe(hIn, NULL, 0, NULL, &nread, NULL);
		if (ret == FALSE) {
		    err = GetLastError();
		    goto done;
		}
	    }
	} while (nread > 0);

	if (WaitForSingleObject(hMutex, INFINITE) != WAIT_OBJECT_0) {
	    goto error;
	}
	WriteFile(ExpConsoleOut, buf, n, &count, NULL);
	ReleaseMutex(hMutex);
	ret = ExpWriteMaster(useSocket, hMaster, buf, n, &over);
	n = 0;
	if (ret == FALSE) {
	    break;
	}
    }

 done:
    if (n > 0) {
	if (WaitForSingleObject(hMutex, INFINITE) == WAIT_OBJECT_0) {
	    WriteFile(ExpConsoleOut, buf, n, &count, NULL);
	    ReleaseMutex(hMutex);
	    ret = ExpWriteMaster(useSocket, hMaster, buf, n, &over);
	}
    }
 error:
    CloseHandle(hIn);
    thru->running = 0;
    if (err == ERROR_HANDLE_EOF || err == ERROR_BROKEN_PIPE) {
	exitVal = 0;
    } else {
	exitVal = err;
    }
    ExitThread(exitVal);
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * ConvertAsciiToKeyEvents --
 *
 *	Converts an ASCII character to an KEY_EVENT_RECORD.
 *
 * Results:
 *	Number of input record that were filled in here.  Currently,
 *	this routine should never be called with less than 6 empty
 *	slots that could be filled.
 *
 *----------------------------------------------------------------------
 */
static DWORD
ConvertAsciiToKeyEvents(UCHAR c, KEY_EVENT_RECORD *keyRecord)
{
    UCHAR lc;
    DWORD mods;
    DWORD n;

    n = 0;
    lc = c < 128 ? c : c - 128;
    mods = ExpAsciiToKeyArray[lc].dwControlKeyState;

#if 0
    if (mods & RIGHT_CTRL_PRESSED) {
	/* First, generate a control key press */
	keyRecord->bKeyDown = TRUE;
	keyRecord->wRepeatCount = 1;
	keyRecord->wVirtualKeyCode =
	    ExpModifierKeyArray[EXP_KEY_CONTROL].wVirtualKeyCode;
	keyRecord->wVirtualScanCode =
	    ExpModifierKeyArray[EXP_KEY_CONTROL].wVirtualScanCode;
	keyRecord->uChar.AsciiChar = 0;
	keyRecord->dwControlKeyState = RIGHT_CTRL_PRESSED;
	keyRecord++; n++;
    }
    if (mods & SHIFT_PRESSED) {
	/* First, generate a control key press */
	keyRecord->bKeyDown = TRUE;
	keyRecord->wRepeatCount = 1;
	keyRecord->wVirtualKeyCode =
	    ExpModifierKeyArray[EXP_KEY_SHIFT].wVirtualKeyCode;
	keyRecord->wVirtualScanCode =
	    ExpModifierKeyArray[EXP_KEY_SHIFT].wVirtualScanCode;
	keyRecord->uChar.AsciiChar = 0;
	keyRecord->dwControlKeyState = mods;
	keyRecord++; n++;
    }
#endif

    keyRecord->bKeyDown = TRUE;
    keyRecord->wRepeatCount = 1;
    keyRecord->wVirtualKeyCode = ExpAsciiToKeyArray[lc].wVirtualKeyCode;
    keyRecord->wVirtualScanCode = ExpAsciiToKeyArray[lc].wVirtualScanCode;
    keyRecord->dwControlKeyState = ExpAsciiToKeyArray[lc].dwControlKeyState;
    keyRecord->uChar.AsciiChar = c;
    keyRecord++; n++;

    keyRecord->bKeyDown = FALSE;
    keyRecord->wRepeatCount = 1;
    keyRecord->wVirtualKeyCode = ExpAsciiToKeyArray[lc].wVirtualKeyCode;
    keyRecord->wVirtualScanCode = ExpAsciiToKeyArray[lc].wVirtualScanCode;
    keyRecord->dwControlKeyState = ExpAsciiToKeyArray[lc].dwControlKeyState;
    keyRecord->uChar.AsciiChar = c;
    keyRecord++; n++;

#if 0
    if (mods & SHIFT_PRESSED) {
	/* First, generate a control key press */
	keyRecord->bKeyDown = FALSE;
	keyRecord->wRepeatCount = 1;
	keyRecord->wVirtualKeyCode =
	    ExpModifierKeyArray[EXP_KEY_SHIFT].wVirtualKeyCode;
	keyRecord->wVirtualScanCode =
	    ExpModifierKeyArray[EXP_KEY_SHIFT].wVirtualScanCode;
	keyRecord->uChar.AsciiChar = 0;
	keyRecord->dwControlKeyState = mods & ~SHIFT_PRESSED;
	keyRecord++; n++;
    }
    if (mods & RIGHT_CTRL_PRESSED) {
	/* First, generate a control key press */
	keyRecord->bKeyDown = FALSE;
	keyRecord->wRepeatCount = 1;
	keyRecord->wVirtualKeyCode =
	    ExpModifierKeyArray[EXP_KEY_CONTROL].wVirtualKeyCode;
	keyRecord->wVirtualScanCode =
	    ExpModifierKeyArray[EXP_KEY_CONTROL].wVirtualScanCode;
	keyRecord->uChar.AsciiChar = 0;
	keyRecord->dwControlKeyState = 0;
	keyRecord++; n++;
    }
#endif
    return n;
}

/*
 *----------------------------------------------------------------------
 *
 * ConvertFKeyToKeyEvents --
 *
 *	Converts a function key to an KEY_EVENT_RECORD.
 *
 * Results:
 *	Number of input record that were filled in here.  Currently,
 *	this routine should never be called with less than 6 empty
 *	slots that could be filled.
 *
 *----------------------------------------------------------------------
 */
static DWORD
ConvertFKeyToKeyEvents(DWORD fk, KEY_EVENT_RECORD *keyRecord)
{
    DWORD n;

    n = 0;

    keyRecord->bKeyDown = TRUE;
    keyRecord->wRepeatCount = 1;
    keyRecord->wVirtualKeyCode = ExpFunctionToKeyArray[fk].wVirtualKeyCode;
    keyRecord->wVirtualScanCode = ExpFunctionToKeyArray[fk].wVirtualScanCode;
    keyRecord->dwControlKeyState = ExpFunctionToKeyArray[fk].dwControlKeyState;
    keyRecord->uChar.AsciiChar = 0;
    keyRecord++; n++;

    keyRecord->bKeyDown = FALSE;
    keyRecord->wRepeatCount = 1;
    keyRecord->wVirtualKeyCode = ExpFunctionToKeyArray[fk].wVirtualKeyCode;
    keyRecord->wVirtualScanCode = ExpFunctionToKeyArray[fk].wVirtualScanCode;
    keyRecord->dwControlKeyState = ExpFunctionToKeyArray[fk].dwControlKeyState;
    keyRecord->uChar.AsciiChar = 0;
    keyRecord++; n++;

    return n;
}

/*
 *----------------------------------------------------------------------
 *
 * FindEscapeKey --
 *
 *	Search for a matching escape key sequence
 *
 * Results:
 *	The matching key if found, -1 if not found, -2 if a partial match
 *
 *----------------------------------------------------------------------
 */
static int
FindEscapeKey(PUCHAR buf, DWORD buflen)
{
    DWORD len;
    int i;

    for (i = 0; VtFunctionKeys[i].sequence; i++) {
	len = strlen(VtFunctionKeys[i].sequence);
	if (len == buflen) {
	    if (strncmp(VtFunctionKeys[i].sequence, buf, buflen) == 0) {
		return VtFunctionKeys[i].keyval;
	    }
	} else {
	    if (strncmp(VtFunctionKeys[i].sequence, buf, buflen) == 0) {
		/* Partial match */
		return -2;
	    }
	}
    }
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * FlushInputRecords --
 *
 *	Takes a stack of input records and flushes them
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful
 *
 *----------------------------------------------------------------------
 */
static BOOL
FlushInputRecords(HANDLE hConsole, INPUT_RECORD *records, DWORD pos)
{
    DWORD j = 0;
    DWORD nWritten;

    while (j != pos) {
	if (! WriteConsoleInput(hConsole, &records[j], pos-j, &nWritten)) {
	    return FALSE;
	}
	j += nWritten;
    }
    return TRUE;
}

/*
 *----------------------------------------------------------------------
 *
 * WriteBufferToSlave --
 *
 *	Takes an input buffer, and it generates key commands to drive
 *	the slave program.
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful.
 *
 * Side Effects:
 *	Characters are entered into the console input buffer.
 *
 * Notes:
 *	XXX: We need to be able to timeout if an escape is in
 *	the buffer and no further control sequences come in within
 *	a reasonable amount of time, say a 1/4 second.
 *
 *----------------------------------------------------------------------
 */
static BOOL
WriteBufferToSlave(int sshd, int useSocket, int noEscapes, HANDLE hMaster,
		   HANDLE hConsoleInW, HANDLE hConsoleOut,
		   PUCHAR buf, DWORD n, LPOVERLAPPED over)
{
    INPUT_RECORD ibuf[1024];
    DWORD i;
    DWORD pos;
    UCHAR masterBuf[BUFSIZE];
    PUCHAR op, p;
    int key, cols, rows;
    static UCHAR saveBuf[10];
    static int savePos = 0;

#define MAX_RECORDS 1000
    for (pos = 0, i = 0, op = masterBuf; i < n; i++) {

	if (!noEscapes && buf[i] == '\033') {
	    if (FlushInputRecords(hConsoleInW, ibuf, pos) == FALSE) {
		return FALSE;
	    }
	    pos = 0;
	    if (savePos) {
		WriteBufferToSlave(sshd, useSocket, TRUE, hMaster,
				   hConsoleInW, hConsoleOut,
				   saveBuf, savePos, over);
		savePos = 0;
	    }
	    saveBuf[savePos++] = buf[i];
	    continue;
	}

	if (!noEscapes && savePos) {
	    saveBuf[savePos++] = buf[i];
	    key = FindEscapeKey(&saveBuf[1], savePos-1);
	    /* Check for partial match */
	    if (key == -2) {
		continue;
	    } else if (key == EXP_WIN_RESIZE) {
		p = &buf[i+1];
		cols = strtoul(p, &p, 10);
		if (! p) goto flush;
		if (*p++ != ';') goto flush;
		rows = strtoul(p, &p, 10);
		if (! p) goto flush;
		if (*p++ != 'G') goto flush;
		ExpSetConsoleSize(hConsoleInW, hConsoleOut, cols, rows,
				  useSocket, hMaster, over);
		i += p - &buf[i+1];
	    } else if (key >= 0) {
		ibuf[pos].EventType = KEY_EVENT;
		pos += ConvertFKeyToKeyEvents(key, &ibuf[pos].Event.KeyEvent);
	    } else {
	    flush:
		WriteBufferToSlave(sshd, useSocket, TRUE, hMaster,
				   hConsoleInW, hConsoleOut,
				   saveBuf, savePos, over);
	    }
	    savePos = 0;
	    continue;
	}

	/*
	 * Code to echo characters back.  When echoing, convert '\r'
	 * characters into '\n'.  This first determines what mode the
	 * slave process' console is in for echoing.  Still, it isn't
	 * perfect.  The mode can be changed between the time the
	 * characters come through here and the time the characters
	 * are actually read in by the process.
	 */

	if (ExpConsoleInputMode & ENABLE_ECHO_INPUT) {
	    if (buf[i] == '\r') {
		if (sshd) {
		    *op++ = '\r';
		}
		*op++ = '\n';
	    } else {
		*op++ = buf[i];
	    }
	}
	ibuf[pos].EventType = KEY_EVENT;
	pos += ConvertAsciiToKeyEvents(buf[i], &ibuf[pos].Event.KeyEvent);
	if (pos >= MAX_RECORDS - 6) {
	    if (FlushInputRecords(hConsoleInW, ibuf, pos) == FALSE) {
		return FALSE;
	    }
	    pos = 0;
	}
    }
    if (FlushInputRecords(hConsoleInW, ibuf, pos) == FALSE) {
	return FALSE;
    }
    ResetEvent(over->hEvent);
    if (op - masterBuf) {
	ExpWriteMaster(useSocket, hMaster, masterBuf, op - masterBuf, over);
    }
    return TRUE;
}

/*
 *----------------------------------------------------------------------
 *
 * WaitQueueThread --
 *
 *	Wait for all subprocesses to exit before exiting this process.
 *	Exit with the value of the primary child.
 *
 * Results:
 *	None really.  This exits the process.  A zero is return to make
 *	the compiler happy.
 *
 *----------------------------------------------------------------------
 */
static DWORD WINAPI
WaitQueueThread(LPVOID *arg)
{
    Tcl_Pid slavePid = *((Tcl_Pid *) arg);
    DWORD exitVal;
    HANDLE hEvents[EXP_MAX_QLEN+1];
    DWORD  posEvents[EXP_MAX_QLEN+1];
    DWORD n, val, err;
    int i;

    ResetEvent(ExpWaitEvent);
    hEvents[0] = ExpWaitEvent;
    while (ExpWaitCount > 0) {
	n = 1;
	WaitForSingleObject(ExpWaitMutex, INFINITE);
	for (i = 0; i < EXP_MAX_QLEN; i++) {
	    if (ExpWaitQueue[i] != INVALID_HANDLE_VALUE) {
		hEvents[n] = ExpWaitQueue[i];
		posEvents[n] = i;
		n++;
	    }
	}
	ReleaseMutex(ExpWaitMutex);
	val = WaitForMultipleObjects(n, hEvents, FALSE, INFINITE);
	if (val == WAIT_FAILED) {
	    err = GetLastError();
	    printf("WAIT_FAILED: 0x%x\n", err);
	} else if (val >= WAIT_ABANDONED_0 && val < WAIT_ABANDONED_0 + n) {
	    val -= WAIT_ABANDONED_0;
	    err = GetLastError();
	    printf("WAIT_ABANDONED %d: 0x%x\n", val, err);
	} else {
	    val -= WAIT_OBJECT_0;
	    if (val > 0) {
		if (hEvents[val] == (HANDLE) slavePid) {
		    Exp_WaitPid(slavePid, &exitVal, 0);
		} else {
		    CloseHandle(hEvents[val]);
		}
		ExpWaitCount--;
		WaitForSingleObject(ExpWaitMutex, INFINITE);
		ExpWaitQueue[posEvents[val]] = INVALID_HANDLE_VALUE;
		ReleaseMutex(ExpWaitMutex);
	    }
	}
    }

    CloseHandle(hMutex);
    CloseHandle(ExpWaitEvent);
    CloseHandle(ExpWaitMutex);

    /*
     * When this thread exits, the main thread will be free to return.  Just set
     * the event so that the main thread knows what's up.
     */
    SetEvent(hShutdown);

    return 0;
}

/*
 *-------------------------------------------------------------------------
 *
 * setargv --
 *
 *	Parse the Windows command line string into argc/argv.  Done here
 *	because we don't trust the builtin argument parser in crt0.  
 *	Windows applications are responsible for breaking their command
 *	line into arguments.
 *
 *	2N backslashes + quote -> N backslashes + begin quoted string
 *	2N + 1 backslashes + quote -> literal
 *	N backslashes + non-quote -> literal
 *	quote + quote in a quoted string -> single quote
 *	quote + quote not in quoted string -> empty string
 *	quote -> begin quoted string
 *
 * Results:
 *	Fills argcPtr with the number of arguments and argvPtr with the
 *	array of arguments.
 *
 * Side effects:
 *	Memory allocated.
 *
 *--------------------------------------------------------------------------
 */

static void
SetArgv(char *cmdLine, int *argcPtr, char ***argvPtr)
{
    char *p, *arg, *argSpace;
    char **argv;
    int argc, size, inquote, copy, slashes;
    
    /*
     * Precompute an overly pessimistic guess at the number of arguments
     * in the command line by counting non-space spans.
     */

    size = 2;
    for (p = cmdLine; *p != '\0'; p++) {
	if (isspace(*p)) {
	    size++;
	    while (isspace(*p)) {
		p++;
	    }
	    if (*p == '\0') {
		break;
	    }
	}
    }
    argSpace = (char *) ckalloc((unsigned) (size * sizeof(char *) 
	    + strlen(cmdLine) + 1));
    argv = (char **) argSpace;
    argSpace += size * sizeof(char *);
    size--;

    p = cmdLine;
    for (argc = 0; argc < size; argc++) {
	argv[argc] = arg = argSpace;
	while (isspace(*p)) {
	    p++;
	}
	if (*p == '\0') {
	    break;
	}

	inquote = 0;
	slashes = 0;
	while (1) {
	    copy = 1;
	    while (*p == '\\') {
		slashes++;
		p++;
	    }
	    if (*p == '"') {
		if ((slashes & 1) == 0) {
		    copy = 0;
		    if ((inquote) && (p[1] == '"')) {
			p++;
			copy = 1;
		    } else {
			inquote = !inquote;
		    }
                }
                slashes >>= 1;
            }

            while (slashes) {
		*arg = '\\';
		arg++;
		slashes--;
	    }

	    if ((*p == '\0') || (!inquote && isspace(*p))) {
		break;
	    }
	    if (copy != 0) {
		*arg = *p;
		arg++;
	    }
	    p++;
        }
	*arg = '\0';
	argSpace = arg + 1;
    }
    argv[argc] = NULL;

    *argcPtr = argc;
    *argvPtr = argv;
}
@


1.1.2.1.2.1
log
@A working set of code against Tcl8.4!
@
text
@a363 3

    DebugBreak();

a752 2
    //ResetEvent(over->hEvent);

d774 1
a774 1
	    if( bRet != WAIT_OBJECT_0 + 1 )
d777 1
a777 1
		 * We have been instructed to shut down or some other error.
d784 1
a784 1
		bRet = GetOverlappedResult(hFile, over, pCount, FALSE);
a1419 1

@


1.1.2.1.2.2
log
@Oopps..  left some bad debugging cruft around
@
text
@d365 1
a365 1
//    DebugBreak();
@


1.1.2.1.2.3
log
@Changed ExpWinCreateProcess() to support unicode (aka TCHAR at
run-time through Tcl_WinUtfToTchar())
@
text
@a222 2
    ExpWinProcessInit();

d364 3
a373 4
#ifdef _DEBUG
    DebugBreak();
#endif

d431 1
a431 1
			     /*dwNeeded-dwHave*/ BUFSIZE, &driverInCnt, &over, &dwResult);
d479 1
a479 1
	if (dwNeeded < dwHave) {
@


1.1.2.1.2.4
log
@OutputDebugString added to the winprocs for the Tchar thing that
Tcl_WinUtfToTChar() does.
@
text
@d223 1
a223 1
    ExpWinInit();
@


1.1.2.1.2.5
log
@Moved expWinProc initting to a new file.  Also realized COM control over the
slavedrv debugger is much more work than antisipated to get right.
@
text
@d58 1
a63 15
#ifdef _MSC_VER
    // Only do this when MSVC++ is compiling us.
#   ifdef USE_TCL_STUBS
#	pragma comment (lib, "tclstub" \
		STRINGIFY(JOIN(TCL_MAJOR_VERSION,TCL_MINOR_VERSION)) ".lib")
#	if !defined(_MT) || !defined(_DLL) || defined(_DEBUG)
	    // This fixes a bug with how the Stubs library was compiled.
	    // The requirement for msvcrt.lib from tclstubXX.lib must
	    // be removed.  This bug has been fixed since 8.4a3, I beleive.
#	    pragma comment(linker, "-nodefaultlib:msvcrt.lib")
#	endif
#   endif
#endif


d156 1
a156 1
static void		SetArgv(int *argcPtr, char ***argvPtr);
d194 1
a194 2
main(void)
{
d197 1
d204 1
d213 1
a223 1
    SetArgv(&argc, &argv);
d250 1
a250 1
	if (hMaster == INVALID_HANDLE_VALUE) {
a310 1
	/*
a319 1
	*/
d373 4
d1345 1
a1345 3
SetArgv(
    int *argcPtr,		/* Filled with number of argument strings. */
    char ***argvPtr)		/* Filled with argument strings in UTF (malloc'd). */
d1350 1
a1350 53
    Tcl_DString cmdLine;
    WCHAR *cmdLineUni;
    char buff[MAX_PATH];

    GetModuleFileName(GetModuleHandle(NULL), buff, MAX_PATH);
    Tcl_FindExecutable(buff);

    Tcl_DStringInit(&cmdLine);
    if (IsDebuggerPresent()) {
	/*
	 * There will be a unicode loss here.
	 */
	Tcl_DString cmdLineTChar;
	Tcl_DString enVar;
	DWORD needed;

	Tcl_DStringInit(&cmdLineTChar);
	Tcl_DStringInit(&enVar);
	Tcl_WinUtfToTChar("EXP_SPAWN_DEBUG_CMDLINE", -1, &enVar);
	/* Calc size needed */
	needed = (*expWinProcs->getEnvironmentVariableProc)(
		(LPCTSTR) Tcl_DStringValue(&enVar),
		(LPTSTR) Tcl_DStringValue(&cmdLineTChar),
		0);
	Tcl_DStringSetLength(&cmdLineTChar, (expWinProcs->useWide ?
		needed * sizeof(WCHAR) :
		needed * sizeof(CHAR)));
	/* get it */
	needed = (*expWinProcs->getEnvironmentVariableProc)(
		(LPCTSTR) Tcl_DStringValue(&enVar),
		(LPTSTR) Tcl_DStringValue(&cmdLineTChar),
		needed);
	/* truncate it again just to be sure it's null terminated */
	Tcl_DStringSetLength(&cmdLineTChar, (expWinProcs->useWide ?
		needed * sizeof(WCHAR) :
		needed * sizeof(CHAR)));
	/* convert it to UTF-8 */
	Tcl_WinTCharToUtf(Tcl_DStringValue(&cmdLineTChar),
		Tcl_DStringLength(&cmdLineTChar), &cmdLine);
	Tcl_DStringFree(&cmdLineTChar);
	Tcl_DStringFree(&enVar);
    } else {
	/*
	 * Always get the unicode commandline because *ALL* Win32 platforms
	 * support it.
	 */
	cmdLineUni = GetCommandLineW();
	size = WideCharToMultiByte(CP_UTF8, 0, cmdLineUni, -1, 0, 0, NULL, NULL);
	Tcl_DStringSetLength(&cmdLine, size);
	WideCharToMultiByte(CP_UTF8, 0, cmdLineUni, -1,
		Tcl_DStringValue(&cmdLine), size, NULL, NULL);
    }

d1357 2
a1358 2
    for (p = Tcl_DStringValue(&cmdLine); *p != '\0'; p++) {
	if ((*p == ' ') || (*p == '\t')) {	/* INTL: ISO space. */
d1360 1
a1360 1
	    while ((*p == ' ') || (*p == '\t')) { /* INTL: ISO space. */
d1368 2
a1369 2
    argSpace = (char *) ckalloc(
	    (unsigned) (size * sizeof(char *) + Tcl_DStringLength(&cmdLine) + 1));
d1374 1
a1374 1
    p = Tcl_DStringValue(&cmdLine);
d1377 1
a1377 1
	while ((*p == ' ') || (*p == '\t')) {	/* INTL: ISO space. */
d1411 1
a1411 2
	    if ((*p == '\0')
		    || (!inquote && ((*p == ' ') || (*p == '\t')))) { /* INTL: ISO space. */
d1427 1
a1428 2
    Tcl_DStringFree(&cmdLine);
}
@


1.1.2.1.2.6
log
@Second shot (and final) of automating VC++ for the debugger friendly
replacement to CreateProcess().  What a nightmare...
@
text
@a62 4
#ifdef _DEBUG
#include "MsvcDbgControl.h"
#endif

a154 1
int pid;			/* used by the debugger controler */
d231 4
a234 1
    pid = GetCurrentProcessId();
a1370 2

#ifdef _DEBUG
d1372 32
a1403 5
#   ifdef _MSC_VER
	cmdLineUni = MsvcDbg_GetCommandLine();
#   else
#   error "Need Debugger control for this IDE"
#   endif
d1405 4
a1408 2
#endif

d1410 4
a1413 2

#ifdef _DEBUG
a1414 9
#endif
    /*
     * Always get the unicode commandline because *ALL* Win32 platforms
     * support it.
     */
    size = WideCharToMultiByte(CP_UTF8, 0, cmdLineUni, -1, 0, 0, NULL, NULL);
    Tcl_DStringSetLength(&cmdLine, size);
    WideCharToMultiByte(CP_UTF8, 0, cmdLineUni, -1,
	    Tcl_DStringValue(&cmdLine), size, NULL, NULL);
@


1.1.2.1.2.7
log
@Got the spawndrv.exe using Stubs.  Tried to get the extension, but more work
needs to be done first.  Most Expect commands are now in the ::exp
namespace.
@
text
@d68 3
a70 1
#   pragma comment (lib, "tclstub" \
d72 6
a77 5
#   if !defined(_MT) || !defined(_DLL) || defined(_DEBUG)
	// This fixes a bug with how the Stubs library was compiled.
	// The requirement for msvcrt.lib from tclstubXX.lib must
	// be removed.  This bug has been fixed since 8.4a3, I beleive.
#	pragma comment(linker, "-nodefaultlib:msvcrt.lib")
d159 1
d236 1
a236 1
    ExpDynloadTclStubs();
d447 1
a447 1
			     dwNeeded-dwHave, &driverInCnt, &over, &dwResult);
d486 1
a486 1
	    /*ExpKillProcessList();*/
d1367 4
d1377 1
a1377 8

	/*
	 *  There will be a unicode loss here.  I don't feel it's a bad
	 *  trade-off when running in a debugger.
	 *  cp1251 != utf-8, though.
	 */
	Tcl_DStringAppend(&cmdLine, MsvcDbg_GetCommandLine(), -1);

a1383 4
	/*
	 * Always get the unicode commandline because *ALL* Win32 platforms
	 * support it.
	 */
a1384 4
	size = WideCharToMultiByte(CP_UTF8, 0, cmdLineUni, -1, 0, 0, NULL, NULL);
	Tcl_DStringSetLength(&cmdLine, size);
	WideCharToMultiByte(CP_UTF8, 0, cmdLineUni, -1,
		Tcl_DStringValue(&cmdLine), size, NULL, NULL);
d1389 8
@


1.1.2.1.2.8
log
@moved all header files over to a more core style with the beginnings of a
Stubs table.  This work is far from complete.
@
text
@d58 8
a65 1
#include "expWinInt.h"
@


1.1.2.1.2.9
log
@not needed anymore
@
text
@@


1.1.2.2
log
@slavedrv.exe is building..  need to add Stubs startup code.
@
text
@d53 6
a62 1
//#include <windows.h>
d153 1
a153 1
			    PUCHAR buf, DWORD n, LPWSAOVERLAPPED over);
d194 3
a196 1
main(int argc, char **argv)
d198 6
a203 6
    HANDLE hConsoleInW;	    /* Console, writeable input handle */
    HANDLE hConsoleOut;	    /* Console, readable output handle */
    HANDLE hMaster;	    /* Pipe between master and us */
    HANDLE hSlaveOut;	    /* Pipe from slave's STDOUT to us */
    HANDLE hSlaveOutW;	    /* Pipe from slave's STDOUT to us */
    HANDLE hProcess;	    /* Current process handle */
d255 1
a255 1
	dwResult = WSAStartup(WINSOCK_VERSION, &SockData);
d309 2
a310 2
	WSAOVERLAPPED over;
	ZeroMemory(&over, sizeof(WSAOVERLAPPED));
d410 1
a410 1
    WSAOVERLAPPED over;
d424 1
a424 1
    ZeroMemory(&over, sizeof(WSAOVERLAPPED));
d568 1
a568 1
    WSAOVERLAPPED over;
d570 1
a570 1
    ZeroMemory(&over, sizeof(WSAOVERLAPPED));
d694 1
a694 1
	       LPWSAOVERLAPPED over)
d743 1
a743 1
	      PDWORD pCount, LPWSAOVERLAPPED over, PDWORD pError)
d825 1
a825 1
    WSAOVERLAPPED over;
d1138 1
a1138 1
		   PUCHAR buf, DWORD n, LPWSAOVERLAPPED over)
@


1.1.2.3
log
@Added Stubs dynloading stuff.  slavedrv.exe appears to be working thus far,
@
text
@a52 5
/*
 * Even though we won't have access to most of the commands, use the
 * normal headers 
 */

d57 1
d148 1
a148 1
			    PUCHAR buf, DWORD n, LPOVERLAPPED over);
d189 1
a189 3
main(argc, argv)
    int argc;
    char **argv;
d191 6
a196 6
    HANDLE hConsoleInW;		/* Console, writeable input handle */
    HANDLE hConsoleOut;	/* Console, readable output handle */
    HANDLE hMaster;		/* Pipe between master and us */
    HANDLE hSlaveOut;		/* Pipe from slave's STDOUT to us */
    HANDLE hSlaveOutW;		/* Pipe from slave's STDOUT to us */
    HANDLE hProcess;		/* Current process handle */
a215 3
    ExpInitWinProcessAPI();
    ExpDynloadTclStubs();

d248 1
a248 1
	dwResult = WSAStartup(MAKEWORD(2, 0), &SockData);
d302 2
a303 2
	OVERLAPPED over;
	memset(&over, 0, sizeof(over));
d403 1
a403 1
    OVERLAPPED over;
d417 1
a417 1
    memset(&over, 0, sizeof(over));
d561 1
a561 1
    OVERLAPPED over;
d563 1
a563 1
    memset(&over, 0, sizeof(over));
d687 1
a687 1
	       LPOVERLAPPED over)
d736 1
a736 1
	      PDWORD pCount, LPOVERLAPPED over, PDWORD pError)
d818 1
a818 1
    OVERLAPPED over;
d1131 1
a1131 1
		   PUCHAR buf, DWORD n, LPOVERLAPPED over)
@


1.1.2.4
log
@ExpSyslog() is finally doing what I want.  More work to do, but the
groundwork is now set.
@
text
@d58 1
a61 1
#include "spawndrvmc.h"
d197 1
a197 1
    HANDLE hConsoleInW;	/* Console, writeable input handle */
d199 4
a202 4
    HANDLE hMaster;	/* Pipe between master and us */
    HANDLE hSlaveOut;	/* Pipe from slave's STDOUT to us */
    HANDLE hSlaveOutW;	/* Pipe from slave's STDOUT to us */
    HANDLE hProcess;	/* Current process handle */
a213 1
    int port = 0;
d226 1
a226 1
	EXP_LOG0(MSG_IO_ARGSWRONG);
d250 4
a253 2
	if (hMaster == INVALID_HANDLE_VALUE) {
	    EXP_LOG2(MSG_NP_CANTOPEN, argv[1], ExpSyslogGetSysMsg(GetLastError()));
d257 1
a257 1
	dwResult = WSAStartup(WINSOCK_VERSION, &SockData);
d259 4
a262 1
	    EXP_LOG2(MSG_WS_CANTSTART, "2.2", ExpSyslogGetSysMsg(dwResult));
a266 3
	if (fdmaster == INVALID_SOCKET) {
	    EXP_LOG1(MSG_WS_CANTCREATEMASTERSOCK, ExpSyslogGetSysMsg(WSAGetLastError()));
	}
d272 2
a273 9

	/* get the port */
	if (Tcl_GetInt(NULL, argv[1], &port) != TCL_OK || port < 0 || port > 65536) {
	    EXP_LOG1(MSG_WS_PORTOUTOFRANGE, argv[1]);
	}

	sin.sin_port = (short) port;
	sin.sin_addr.s_addr = INADDR_LOOPBACK;

d275 4
a278 1
	    EXP_LOG2(MSG_WS_CANTCONNECTMASTERSOCK, argv[1], ExpSyslogGetSysMsg(WSAGetLastError()));
d311 2
a312 2
	WSAOVERLAPPED over;
	ZeroMemory(&over, sizeof(WSAOVERLAPPED));
d333 2
a334 1
	EXP_LOG2(MSG_DT_CANTGETCONSOLEHANDLE, "CONIN$", ExpSyslogGetSysMsg(GetLastError()));
d340 2
a341 1
	EXP_LOG2(MSG_DT_CANTGETCONSOLEHANDLE, "CONOUT$", ExpSyslogGetSysMsg(GetLastError()));
d412 1
a412 1
    WSAOVERLAPPED over;
d426 1
a426 1
    ZeroMemory(&over, sizeof(WSAOVERLAPPED));
d466 1
a466 1
		    EXP_LOG1(MSG_IO_BADSHUTDOWN, ExpSyslogGetSysMsg(dwResult));
d472 1
d474 1
a474 1
	    EXP_LOG1(MSG_IO_UNEXPECTED, ExpSyslogGetSysMsg(dwResult));
d528 1
a528 1
		EXP_LOG1(MSG_MS_SLAVENOWRITABLE, ExpSyslogGetSysMsg(GetLastError()));
d545 1
a545 1
	    EXP_LOG0(MSG_MS_BADSTATE);
d570 1
a570 1
    WSAOVERLAPPED over;
d572 1
a572 1
    ZeroMemory(&over, sizeof(WSAOVERLAPPED));
d592 1
a592 1
	    EXP_LOG1(MSG_MS_SLAVENOWRITABLE, ExpSyslogGetSysMsg(GetLastError()));
d595 1
@


1.1.2.5
log
@adding more calls to ExpSyslog() where needed.
@
text
@a57 1
#define STRICT    /* ask windows.h to agressive about the HANDLE type */
a253 3
	if (GetFileType(hMaster) != FILE_TYPE_PIPE) {
	    EXP_LOG1(MSG_NP_BADTYPE, argv[1]);
	}
d443 2
a444 2
		    fd_set monitor;
		    int	sts;
@


1.1.2.6
log
@Numerous changes
@
text
@a51 3
#if !defined(BUILD_spawndrv) && !defined(STATIC_BUILD)
#   error "build instruction error"
#endif
d53 4
a56 3
#include "expWinInt.h"

#pragma comment (lib, "ws2_32.lib")
d58 5
d192 1
a192 1
#if 0
a223 1
    /* Select the unicode or ascii winprocs. */
a224 3

    /* We use a few APIs from Tcl, dynamically load it. */
    /* This exits on error. */
a229 6

    /* This exits on error. */
    ExpSpawnOpenClientMailbox(argv[1]);



d399 1
a399 1
#endif
d1312 112
@


