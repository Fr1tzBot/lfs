head	5.30;
access;
symbols
	expect_5_45:5.30
	expect_6_branch:5.29.0.8
	expect_5_44_1_15:5.29
	activestate_win32_port_start:5.29
	win32-jump-point-1:5.29
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.1
	scriptics-sc-2-0-b5:5.28.1.1.2.1
	scriptics-sc-2-0-fixed:5.28.1.1.2.1
	scriptics-sc-2-0-b2:5.28.1.1.2.1
	scriptics-sc-2-0-b1:5.28.1.1.2.1
	scriptics-sc-1-1:5.28.1.1.2.1
	scriptics-sc-1-1-b1:5.28.1.1.2.1
	scriptics-sc-1-1-branch:5.28.1.1.2.1.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.1
	scriptics-sc-1-0:5.28.1.1.2.1
	scriptics-sc-1-0-branch:5.28.1.1.2.1.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.1
	expect-5-31-3:5.28.1.1.2.1
	scriptics-bc-1-0-b1:5.28.1.1.2.1
	scriptics-tclpro-1-3-0:5.28.1.1.2.1
	scriptics-tclpro-1-3-b4:5.28.1.1.2.1
	scriptics-tclpro-1-3-b3:5.28.1.1.2.1
	expect-5-31:5.28.1.1.2.1
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.30
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.07;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.29.02.27.48;	author libes;	state Exp;
branches;
next	;


desc
@@


5.30
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# Name: cryptdir
# Author: Don Libes, NIST
#
# Synopsis:
#	  cryptdir [dir]
#	decryptdir [dir]
#
# Encrypt or decrypts the current directory or named directory if given.

if {[llength $argv] > 0} {
    cd $argv
}

# encrypt or decrypt?
set decrypt [regexp "decrypt" $argv0]

set timeout -1
stty -echo
send "Password:"
expect -re "(.*)\n"
send "\n"
set passwd $expect_out(1,string)

# Wouldn't want to encrypt/decrypt files with mistyped password!
send "Again:"
expect -re "(.*)\n"
send "\n"
if {![string match $passwd $expect_out(1,string)]} {
    send_user "mistyped password?\n"
    stty echo
    exit
}
stty echo

log_user 0
foreach f [glob *] {
    # strip shell metachars from filename to avoid problems
    if {[regsub -all {[]['`~<>:-]} $f "" newf]} {
	exec mv $f $newf
	set f $newf
    }

    set strcmp [string compare .crypt [file extension $f]]
    if {$decrypt} {
	# skip files that don't end with ".crypt"
	if {0!=$strcmp} continue
	spawn sh -c "exec crypt < $f > [file root $f]"
    } else {
	# skip files that already end with ".crypt"
	if {0==$strcmp} continue
	spawn sh -c "exec crypt < $f > $f.crypt"
    }
    expect "key:"
    send "$passwd\r"
    expect
    wait
    exec rm -f $f
    send_tty "."
}
send_tty "\n"
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d1 8
a8 1
#!../expect --
@


5.28
log
@Initial revision
@
text
@d12 1
a12 1
	cd $argv
d25 8
a32 10
# wouldn't want to encrypt files with mistyped password!
if !$decrypt {
	send "Again:"
	expect -re "(.*)\n"
	send "\n"
	if ![string match $passwd $expect_out(1,string)] {
		send_user "mistyped password?"
		stty echo
		exit
	}
d38 5
a42 5
	# strip shell metachars from filename to avoid problems
	if [regsub -all {[]['`~<>:-]} $f "" newf] {
		exec mv $f $newf
		set f $newf
	}
d44 16
a59 16
	set strcmp [string compare .crypt [file extension $f]]
	if $decrypt {
		# skip files that don't end with ".crypt"
		if 0!=$strcmp continue
		spawn sh -c "exec crypt < $f > [file root $f]"
	} else {
		# skip files that already end with ".crypt"
		if 0==$strcmp continue
		spawn sh -c "exec crypt < $f > $f.crypt"
	}
	expect "key:"
	send "$passwd\r"
	expect
	wait
	exec rm -f $f
	send_tty "."
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d12 1
a12 1
    cd $argv
d25 10
a34 8
# Wouldn't want to encrypt/decrypt files with mistyped password!
send "Again:"
expect -re "(.*)\n"
send "\n"
if {![string match $passwd $expect_out(1,string)]} {
    send_user "mistyped password?\n"
    stty echo
    exit
d40 5
a44 5
    # strip shell metachars from filename to avoid problems
    if {[regsub -all {[]['`~<>:-]} $f "" newf]} {
	exec mv $f $newf
	set f $newf
    }
d46 16
a61 16
    set strcmp [string compare .crypt [file extension $f]]
    if {$decrypt} {
	# skip files that don't end with ".crypt"
	if {0!=$strcmp} continue
	spawn sh -c "exec crypt < $f > [file root $f]"
    } else {
	# skip files that already end with ".crypt"
	if {0==$strcmp} continue
	spawn sh -c "exec crypt < $f > $f.crypt"
    }
    expect "key:"
    send "$passwd\r"
    expect
    wait
    exec rm -f $f
    send_tty "."
@

