head	5.31;
access;
symbols
	expect_5_45:5.31
	expect_6_branch:5.30.0.2
	expect_5_44_1_15:5.30
	activestate_win32_port_start:5.29
	win32-jump-point-1:5.29
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.2
	scriptics-sc-2-0-b5:5.28.1.1.2.2
	scriptics-sc-2-0-fixed:5.28.1.1.2.2
	scriptics-sc-2-0-b2:5.28.1.1.2.2
	scriptics-sc-2-0-b1:5.28.1.1.2.2
	scriptics-sc-1-1:5.28.1.1.2.2
	scriptics-sc-1-1-b1:5.28.1.1.2.2
	scriptics-sc-1-1-branch:5.28.1.1.2.2.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.2
	scriptics-sc-1-0:5.28.1.1.2.2
	scriptics-sc-1-0-branch:5.28.1.1.2.2.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.2
	expect-5-31-3:5.28.1.1.2.2
	scriptics-bc-1-0-b1:5.28.1.1.2.2
	scriptics-tclpro-1-3-0:5.28.1.1.2.2
	scriptics-tclpro-1-3-b4:5.28.1.1.2.1
	scriptics-tclpro-1-3-b3:5.28.1.1.2.1
	expect-5-31:5.28.1.1.2.1
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.31
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.30;

5.30
date	2007.06.28.19.23.40;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.07;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.29.02.27.49;	author libes;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.08.04.22.10.17;	author libes;	state Exp;
branches;
next	;


desc
@@


5.31
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# passmass: change password on many machines
# Synopsis: passmass host1 host2 host3 ....
# Don Libes - March 11, 1991

# Description: Change passwords on the named machines.
#
# See passmass.man for further info.

exp_version -exit 5.0

if {$argc==0} {
    send_user "usage: $argv0 host1 host2 host3 . . .\n"
    exit
}

expect_before -i $user_spawn_id \003 exit

proc badhost {host emsg} {
    global badhosts

    send_user "\r\n\007password not changed on $host - $emsg\n\n"
    if {0==[llength $badhosts]} {
	set badhosts $host
    } else {
	set badhosts [concat $badhosts $host]
    }
}

# set defaults
set login "rlogin"
set program "passwd"
set user [exec whoami]
set su 0

set timeout -1
stty -echo

if {!$su} {
    send_user "old password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(old) $expect_out(1,string)
    set password(login) $expect_out(1,string)
    send_user "new password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(new) $expect_out(1,string)
    send_user "retype new password: "
    expect_user -re "(.*)\n"
    set password(newcheck) $expect_out(1,string)
    send_user "\n"
} else {
    send_user "login password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(login) $expect_out(1,string)
    send_user "root password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(old) $expect_out(1,string)
    send_user "new password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(new) $expect_out(1,string)
    send_user "retype new password: "
    expect_user -re "(.*)\n"
    set password(newcheck) $expect_out(1,string)
    send_user "\n"
}

stty echo
trap exit SIGINT

if ![string match $password(new) $password(newcheck)] {
    send_user "mismatch - password unchanged\n"
    exit
}

set timeout -1

set badhosts {}
for {set i 0} {$i<$argc} {incr i} {
    set arg [lindex $argv $i]
    switch -- $arg "-user" {
	incr i
	set user [lindex $argv $i]
	continue
    } "-prompt" {
	incr i
	set prompt [lindex $argv $i]
	continue
    } "-rlogin" {
	set login "rlogin"
	continue
    } "-slogin" {
	set login "slogin"
	continue
    } "-ssh" {
	set login "ssh"
	continue
    } "-telnet" {
	set login "telnet"
	continue
    } "-program" {
	incr i
	set program [lindex $argv $i]
	continue
    } "-timeout" {
	incr i
	set timeout [lindex $argv $i]
	continue
    } "-su" {
	incr i
	set su [lindex $argv $i]
	continue
    }

    set host $arg
    if {[string match $login "rlogin"]} {
	set pid [spawn rlogin $host -l $user]
    } elseif {[string match $login "slogin"]} {
	set pid [spawn slogin $host -l $user]
    } elseif {[string match $login "ssh"]} {
	set pid [spawn ssh $host -l $user]
    } else {
	set pid [spawn telnet $host]
	expect -nocase -re "(login|username):.*" {
	    send "$user\r"
	}
    }

    if ![info exists prompt] {
	if {[string match $user "root"]} {
	    set prompt "# "
	} else {
	    set prompt "(%|\\\$|#) "
	}
    }

    set logged_in 0
    while {1} {
	expect -nocase "password*" {
	    send "$password(login)\r"
	} eof {
	    badhost $host "spawn failed"
	    break
	} timeout {
	    badhost $host "could not log in (or unrecognized prompt)"
	    exec kill $pid
	    expect eof
	    break
	} -re "incorrect|invalid" {
	    badhost $host "bad password or login"
	    exec kill $pid
	    expect eof
	    break
	} -re $prompt {
	    set logged_in 1
	    break
	}
    }

    if (!$logged_in) {
	wait
	continue
    }

    if ($su) {
	send "su -\r"
	expect -nocase "password:"
	send "$password(old)\r"
	expect "# "
	send "$program root\r"
    } else {
	send "$program\r"
    }

    expect -nocase -re "(old|existing login) password:.*" {
	send "$password(old)\r"
	expect -nocase "sorry*" {
	    badhost $host "old password is bad?"
	    continue
	} -nocase "password:"
    } -nocase -re "new password:" {
	# got prompt, fall through
    } timeout {
	badhost $host "could not recognize prompt for password"
	continue
    }
    send "$password(new)\r"
    expect -re "not changed|unchanged" {
	badhost $host "new password is bad?"
	continue
    } -nocase -re "(password|verification|verify|again):.*"
    send "$password(new)\r"
    expect -nocase -re "(not changed|incorrect|choose new).*" {
	badhost $host "password is bad?"
	continue
    } -re "$prompt"
    send_user "\n"

    close
    wait
}

if {[llength $badhosts]} {
    send_user "\nfailed to set password on $badhosts\n"
}
@


5.30
log
@
	* Merged changes from the official version 5.44.1 of expect into
	  the SF sources. See the details below.

	  --------------------
	  Marius Schamsula <marius173@@mchsi.xcom> reported tclconfig
	  missing, evidentally for new TEA.

	  Lots of massaging to fix TEAification of Makefile and configure
	  including that version numbers will now be full three part.

	  Daniel Wong <danielwong@@berkeley.xedu> noted the home page
	  should note that Wikipedia has a very readable entry for Expect.

	  Andre Alves <aalves@@escloyalty.xcom> noted passmass needed some
	  fixes to handle Solaris 9 passwd prompt changes.

	  Andreas fixed several things: changes to better support TEA, fix
	  debugger interaction with nonblocking mode, and probably other
	  things I'm overlooking.

	  Martin Dietze <di@@fh-wedel.xde> noted that autoconf 2.59 is
	  confused by C comment after undefs in expect_cf.h.in.

	  Added additional code to unbuffer -p so that if a process
	  earlier in the pipeline exits, unbuffer attempts to recover any
	  remaining output from the spawned proc before unbuffer itself
	  exits.

	  Jeffrey Hobbs noted that once stty was called, a bg'd script
	  would be suspended at exit.  Turned out to be overaggressive
	  code in stty that recorded what 'damage' the user might have
	  caused when calling stty in the first place.

	  Jens Petersen provided patch to make setpgrp configure better on
	  some Linux systems.

	  Added example/getpassck script to test for getpass bug.

	  multixterm had debugging stuff leftover ("hello").
	  --------------------
@
text
@d1 8
a8 1
#!../expect --
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d80 1
a81 10
#send_user "want to see new password you just typed? (y|n) "
#expect_user "*\n"
#
#if {[string match "y" [lindex $expect_match 0 c]]} {
#	send_user "password is <$password(new)>\nproceed? (y|n) "
#	expect_user "*\n"
#	if ![string match "y" [lindex $expect_match 0 c]] exit
#}

set timeout 30
d99 3
d128 1
a128 1
	expect -re "(login|Username):.*" {
d143 1
a143 1
	expect "Password*" {
d171 1
a171 1
	expect "Password:"
d179 1
a179 1
    expect "Old password*" {
d181 1
a181 1
	expect "Sorry*" {
d184 7
a190 2
	} "password:"
    } -re "(n|N)ew password:"
d195 1
a195 1
    } -re "(password|Verification|Verify|again):.*"
d197 1
a197 1
    expect -re "(not changed|incorrect|choose new).*" {
@


5.28
log
@Initial revision
@
text
@d8 1
a8 24
# You are prompted for old/new passwords.  (If you are changing root
# passwords and have equivalencing, the old password is not used and may be
# omitted.)
# 
# Additional arguments may be used for fine tuning.  They affect all hosts
# which follow until another argument overrides.
#
#   -user	User whose password will be changed.  By default, the current
#		user is used.
#   -rlogin	Use rlogin to access host.  (default)
#   -slogin	Use slogin to access host.
#   -telnet	Use telnet to access host.
#   -program	Next argument is taken as program to run to set password.
#		Default is "passwd".  Other common choices are "yppasswd" and
#		"set passwd" (e.g., VMS hosts).
#   -prompt	Next argument is taken as a prompt suffix pattern.  This allows
#		the script to know when the shell is prompting.  The default is
#		"# " for root and "% " for non-root accounts.
#   -timeout	Next argument is number of seconds to wait for responses.
#		Default is 30 but some systems can be much slower logging in.

# The best way to run this is to put the command in a one-line shell script
# or alias. (Presumably, the set of hosts and parameters will rarely change.)
# Then run it whenever you want to change your passwords on all the hosts.
d12 3
a14 3
if $argc==0 {
	send_user "usage: $argv0 host1 host2 host3 . . .\n"
	exit
d20 1
a20 1
	global badhosts
d22 6
a27 6
	send_user "\r\n\007password not changed on $host - $emsg\n\n"
	if 0==[llength $badhosts] {
		set badhosts $host
	} else {
		set badhosts [concat $badhosts $host]
	}
d34 1
d36 1
a36 1
set timeout 1000000
d38 34
a71 12
send_user "old password: "
expect_user -re "(.*)\n"
send_user "\n"
set password(old) $expect_out(1,string)
send_user "new password: "
expect_user -re "(.*)\n"
send_user "\n"
set password(new) $expect_out(1,string)
send_user "retype new password: "
expect_user -re "(.*)\n"
set password(newcheck) $expect_out(1,string)
send_user "\n"
d76 2
a77 2
	send_user "mismatch - password unchanged\n"
	exit
d84 1
a84 1
#if [string match "y" [lindex $expect_match 0 c]] {
d93 45
d139 3
a141 36
	set arg [lindex $argv $i]
	switch -- $arg \
		"-user" {
			incr i
			set user [lindex $argv $i]
			continue
		} "-prompt" {
			incr i
			set prompt [lindex $argv $i]
			continue
		} "-rlogin" {
			set login "rlogin"
			continue
		} "-slogin" {
			set login "slogin"
			continue
		} "-telnet" {
			set login "telnet"
			continue
		} "-program" {
			incr i
			set program [lindex $argv $i]
			continue
		} "-timeout" {
			incr i
			set timeout [lindex $argv $i]
			continue
		}

	set host $arg
	if [string match $login "rlogin"] {
		set pid [spawn rlogin $host -l $user]
	} elseif [string match $login "slogin"] {
		set pid [spawn slogin $host -l $user]
	} elseif [string match $login "ssh"] {
		set pid [spawn ssh $host -l $user]
d143 1
a143 4
		set pid [spawn telnet $host]
		expect -re "(login|Username):.*" {
			send "$user\r"
		}
d145 1
d147 20
a166 6
	if ![info exists prompt] {
		if [string match $user "root"] {
			set prompt "# "
		} else {
			set prompt "(%|\\\$) "
		}
d168 1
d170 4
a173 22
	set logged_in 0
	for {} 1 {} {
		expect "Password*" {
			send "$password(old)\r"
		} eof {
			badhost $host "spawn failed"
			break
		} timeout {
			badhost $host "could not log in (or unrecognized prompt)"
			exec kill $pid
			expect eof
			break
		} -re "incorrect|invalid" {
			badhost $host "bad password or login"
			exec kill $pid
			expect eof
			break
		} -re $prompt {
			set logged_in 1
			break
		}
	}
d175 9
a183 4
	if (!$logged_in) {
		wait
		continue
	}
d185 18
a202 19
	send "$program\r"
	expect "Old password*" {
		send "$password(old)\r"
		expect "Sorry*" {
			badhost $host "old password is bad?"
			continue
		} "password:"
	} -re "(n|N)ew password:"
	send "$password(new)\r"
	expect -re "not changed|unchanged" {
		badhost $host "new password is bad?"
		continue
	} -re "(password|Verification|Verify|again):.*"
	send "$password(new)\r"
	expect -re "(not changed|incorrect|choose new).*" {
		badhost $host "password is bad?"
		continue
	} -re "$prompt"
	send_user "\n"
d204 2
a205 2
	close
	wait
d208 3
a210 1
if [llength $badhosts] {send_user "\nfailed to set password on $badhosts\n"}
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d35 1
a35 1
if {$argc==0} {
d84 1
a84 1
#if {[string match "y" [lindex $expect_match 0 c]]} {
d124 1
a124 1
	if {[string match $login "rlogin"]} {
d126 1
a126 1
	} elseif {[string match $login "slogin"]} {
d128 1
a128 1
	} elseif {[string match $login "ssh"]} {
d138 1
a138 1
		if {[string match $user "root"]} {
d146 1
a146 1
	while {1} {
d197 1
a197 1
if {[llength $badhosts]} {send_user "\nfailed to set password on $badhosts\n"}
@


5.28.1.1.2.2
log
@fixed dup case in clib due to multiple defs of ENOTSUP/OPNOTSUP
added passmass -su
@
text
@d8 24
a31 1
# See passmass.man for further info.
d36 2
a37 2
    send_user "usage: $argv0 host1 host2 host3 . . .\n"
    exit
d43 1
a43 1
    global badhosts
d45 6
a50 6
    send_user "\r\n\007password not changed on $host - $emsg\n\n"
    if {0==[llength $badhosts]} {
	set badhosts $host
    } else {
	set badhosts [concat $badhosts $host]
    }
a56 1
set su 0
d58 1
a58 1
set timeout -1
d60 12
a71 34

if {!$su} {
    send_user "old password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(old) $expect_out(1,string)
    set password(login) $expect_out(1,string)
    send_user "new password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(new) $expect_out(1,string)
    send_user "retype new password: "
    expect_user -re "(.*)\n"
    set password(newcheck) $expect_out(1,string)
    send_user "\n"
} else {
    send_user "login password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(login) $expect_out(1,string)
    send_user "root password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(old) $expect_out(1,string)
    send_user "new password: "
    expect_user -re "(.*)\n"
    send_user "\n"
    set password(new) $expect_out(1,string)
    send_user "retype new password: "
    expect_user -re "(.*)\n"
    set password(newcheck) $expect_out(1,string)
    send_user "\n"
}

d76 2
a77 2
    send_user "mismatch - password unchanged\n"
    exit
d93 42
a134 43
    set arg [lindex $argv $i]
    switch -- $arg "-user" {
	incr i
	set user [lindex $argv $i]
	continue
    } "-prompt" {
	incr i
	set prompt [lindex $argv $i]
	continue
    } "-rlogin" {
	set login "rlogin"
	continue
    } "-slogin" {
	set login "slogin"
	continue
    } "-telnet" {
	set login "telnet"
	continue
    } "-program" {
	incr i
	set program [lindex $argv $i]
	continue
    } "-timeout" {
	incr i
	set timeout [lindex $argv $i]
	continue
    } "-su" {
	incr i
	set su [lindex $argv $i]
	continue
    }

    set host $arg
    if {[string match $login "rlogin"]} {
	set pid [spawn rlogin $host -l $user]
    } elseif {[string match $login "slogin"]} {
	set pid [spawn slogin $host -l $user]
    } elseif {[string match $login "ssh"]} {
	set pid [spawn ssh $host -l $user]
    } else {
	set pid [spawn telnet $host]
	expect -re "(login|Username):.*" {
	    send "$user\r"
a135 1
    }
d137 6
a142 5
    if ![info exists prompt] {
	if {[string match $user "root"]} {
	    set prompt "# "
	} else {
	    set prompt "(%|\\\$|#) "
a143 1
    }
d145 21
a165 20
    set logged_in 0
    while {1} {
	expect "Password*" {
	    send "$password(login)\r"
	} eof {
	    badhost $host "spawn failed"
	    break
	} timeout {
	    badhost $host "could not log in (or unrecognized prompt)"
	    exec kill $pid
	    expect eof
	    break
	} -re "incorrect|invalid" {
	    badhost $host "bad password or login"
	    exec kill $pid
	    expect eof
	    break
	} -re $prompt {
	    set logged_in 1
	    break
a166 1
    }
d168 4
a171 4
    if (!$logged_in) {
	wait
	continue
    }
a172 7
    if ($su) {
	send "su -\r"
	expect "Password:"
	send "$password(old)\r"
	expect "# "
	send "$program root\r"
    } else {
d174 18
a191 1
    }
d193 2
a194 21
    expect "Old password*" {
	send "$password(old)\r"
	expect "Sorry*" {
	    badhost $host "old password is bad?"
	    continue
	} "password:"
    } -re "(n|N)ew password:"
    send "$password(new)\r"
    expect -re "not changed|unchanged" {
	badhost $host "new password is bad?"
	continue
    } -re "(password|Verification|Verify|again):.*"
    send "$password(new)\r"
    expect -re "(not changed|incorrect|choose new).*" {
	badhost $host "password is bad?"
	continue
    } -re "$prompt"
    send_user "\n"

    close
    wait
d197 1
a197 3
if {[llength $badhosts]} {
    send_user "\nfailed to set password on $badhosts\n"
}
@


