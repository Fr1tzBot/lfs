head	5.21;
access;
symbols
	expect_5_45:5.20
	expect_6_branch:5.20.0.2
	expect_5_44_1_15:5.20
	activestate_win32_port_start:5.2
	telco-tec-win32-take2-branch:5.1.0.6
	telco-tec-win32-branch:5.1.0.4
	expect-sf418892-sf439042-branch:5.1.0.2
	tclpro-1-5-0:5.1
	tclpro-1-4-1:5.1
	tclpro-1-4-0:5.1
	expect-5-32-2:5.1
	expect-5-32-0:5.1
	ajuba-ajuba2-2-0:1.1.2.13
	scriptics-sc-2-0-b5:1.1.2.13
	scriptics-sc-2-0-fixed:1.1.2.13
	scriptics-sc-2-0-b2:1.1.2.13
	scriptics-sc-2-0-b1:1.1.2.13
	scriptics-sc-1-1:1.1.2.13
	scriptics-sc-1-1-b1:1.1.2.13
	scriptics-sc-1-1-branch:1.1.2.13.0.4
	scriptics-sc-1-1-base:1.1.2.13
	scriptics-sc-1-0:1.1.2.13
	scriptics-sc-1-0-branch:1.1.2.13.0.2
	scriptics-sc-1-0-base:1.1.2.13
	expect-5-31-3:1.1.2.13
	scriptics-bc-1-0-b1:1.1.2.13
	scriptics-tclpro-1-3-0:1.1.2.13
	scriptics-tclpro-1-3-b4:1.1.2.13
	scriptics-tclpro-1-3-b3:1.1.2.13
	expect-5-31:1.1.2.13
	expect-5-31-branch:1.1.0.2;
locks; strict;
comment	@ * @;


5.21
date	2012.08.15.22.25.31;	author andreas_kupries;	state Exp;
branches;
next	5.20;

5.20
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.19;

5.19
date	2010.04.15.14.58.38;	author eee;	state Exp;
branches;
next	5.18;

5.18
date	2010.03.11.21.55.19;	author eee;	state Exp;
branches;
next	5.17;

5.17
date	2010.03.11.21.47.33;	author eee;	state Exp;
branches;
next	5.16;

5.16
date	2007.07.11.21.35.08;	author andreas_kupries;	state Exp;
branches;
next	5.15;

5.15
date	2007.07.11.20.00.35;	author andreas_kupries;	state Exp;
branches;
next	5.14;

5.14
date	2006.03.01.17.21.45;	author andreas_kupries;	state Exp;
branches;
next	5.13;

5.13
date	2005.09.19.19.08.14;	author andreas_kupries;	state Exp;
branches;
next	5.12;

5.12
date	2005.09.09.18.02.59;	author andreas_kupries;	state Exp;
branches;
next	5.11;

5.11
date	2005.07.20.17.36.55;	author andreas_kupries;	state Exp;
branches;
next	5.10;

5.10
date	2005.06.22.17.03.38;	author andreas_kupries;	state Exp;
branches;
next	5.9;

5.9
date	2005.03.29.23.08.17;	author andreas_kupries;	state Exp;
branches;
next	5.8;

5.8
date	2005.02.15.22.39.44;	author andreas_kupries;	state Exp;
branches;
next	5.7;

5.7
date	2005.02.15.18.11.01;	author andreas_kupries;	state Exp;
branches;
next	5.6;

5.6
date	2005.01.21.23.17.01;	author andreas_kupries;	state Exp;
branches;
next	5.5;

5.5
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.4;

5.4
date	2004.06.14.20.56.07;	author andreas_kupries;	state Exp;
branches;
next	5.3;

5.3
date	2003.09.05.19.01.56;	author andreas_kupries;	state Exp;
branches;
next	5.2;

5.2
date	2003.02.14.23.42.05;	author andreas_kupries;	state Exp;
branches;
next	5.1;

5.1
date	2000.01.06.23.22.02;	author wart;	state Exp;
branches
	5.1.4.1
	5.1.6.1;
next	1.1;

1.1
date	99.06.10.22.02.32;	author don;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	99.06.10.22.02.33;	author don;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	99.06.11.20.11.48;	author don;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	99.06.14.20.36.46;	author don;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	99.06.14.23.54.03;	author don;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	99.06.15.10.02.34;	author don;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	99.06.16.03.02.32;	author don;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	99.06.16.08.15.58;	author don;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	99.06.20.06.32.18;	author libes;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	99.06.22.05.03.29;	author libes;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	99.06.22.19.50.52;	author libes;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	99.06.28.06.29.23;	author libes;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	99.06.29.02.27.45;	author libes;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	99.06.29.18.12.10;	author wart;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	99.12.04.06.18.23;	author libes;	state Exp;
branches;
next	;

5.1.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.1.6.1
date	2001.11.22.08.50.36;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.21
log
@
	* exp_main_sub.c: Updated EXP_VERSION to 5.45.1
	* configure, configure.in: Updated expect to version 5.45.1

	* exp_chan.c: Applied patch sent in by Ogawa Hirofumi
	  <hirofumi@@mail.parknet.co.jp>. The patch fixes a problem when
	  talking a tty where the writer has died. Some operating systems
	  report the condition as EIO with nothing read, while this
	  actually an EOF. Without the patch the returned data is
	  incomplete due to the error reported immediately and dropping
	  data in buffers.

	* exp_chan.c: [Bug 3526461]: Applied patch by Michael Cleverly
	  <cleverly@@users.sourceforge.net> fixing a problem with the
	  iteration over the expect channel list where the loop code may
	  modify the list, breaking the iterator.

	* exp_chan.c: [Bug 3526707]: Applied patch by Michael Cleverly
	* exp_command.h: <cleverly@@users.sourceforge.net> fixing problem
	* expect.c: with an insufficient test for a lost channel in
	  exp_background_channelhandler.
@
text
@/* 
 * exp_chan.c
 *
 *	Channel driver for Expect channels.
 *      Based on UNIX File channel from TclUnixChan.c
 *
 */

#include <sys/types.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>	/* for isspace */
#include <time.h>	/* for time(3) */

#include "expect_cf.h"

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#include <errno.h>

#include	"tclInt.h"	/* Internal definitions for Tcl. */

#include "tcl.h"

#include "string.h"

#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"
#include "exp_log.h"
#include "tcldbg.h" /* Dbg_StdinMode */

extern int		expSetBlockModeProc _ANSI_ARGS_((int fd, int mode));
static int		ExpBlockModeProc _ANSI_ARGS_((ClientData instanceData,
			    int mode));
static int		ExpCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
static int		ExpInputProc _ANSI_ARGS_((ClientData instanceData,
		            char *buf, int toRead, int *errorCode));
static int		ExpOutputProc _ANSI_ARGS_((
			    ClientData instanceData, char *buf, int toWrite,
                            int *errorCode));
static void		ExpWatchProc _ANSI_ARGS_((ClientData instanceData,
		            int mask));
static int		ExpGetHandleProc _ANSI_ARGS_((ClientData instanceData,
		            int direction, ClientData *handlePtr));

/*
 * This structure describes the channel type structure for Expect-based IO:
 */

Tcl_ChannelType expChannelType = {
    "exp",				/* Type name. */
    ExpBlockModeProc,			/* Set blocking/nonblocking mode.*/
    ExpCloseProc,			/* Close proc. */
    ExpInputProc,			/* Input proc. */
    ExpOutputProc,			/* Output proc. */
    NULL,				/* Seek proc. */
    NULL,				/* Set option proc. */
    NULL,				/* Get option proc. */
    ExpWatchProc,			/* Initialize notifier. */
    ExpGetHandleProc,			/* Get OS handles out of channel. */
    NULL,				/* Close2 proc */
};

typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    ExpState *firstExpPtr;
    int channelCount;	 /* this is process-wide as it is used to
			     give user some hint as to why a spawn has failed
			     by looking at process-wide resource usage */
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 *----------------------------------------------------------------------
 *
 * ExpBlockModeProc --
 *
 *	Helper procedure to set blocking and nonblocking modes on a
 *	file based channel. Invoked by generic IO level code.
 *
 * Results:
 *	0 if successful, errno when failed.
 *
 * Side effects:
 *	Sets the device into blocking or non-blocking mode.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
ExpBlockModeProc(instanceData, mode)
    ClientData instanceData;		/* Exp state. */
    int mode;				/* The mode to set. Can be one of
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
{
    ExpState *esPtr = (ExpState *) instanceData;

    if (esPtr->fdin == 0) {
        /* Forward status to debugger. Required for FIONBIO systems,
	 * which are unable to query the fd for its current state.
	 */
        Dbg_StdinMode (mode);
    }

    /* [Expect SF Bug 1108551] (July 7 2005)
     * Exclude manipulation of the blocking status for stdin/stderr.
     *
     * This is handled by the Tcl core itself and we must absolutely
     * not pull the rug out from under it. The standard setting to
     * non-blocking will mess with the core which had them set to
     * blocking, and makes all its decisions based on that assumption.
     * Setting to non-blocking can cause hangs and crashes.
     *
     * Stdin is ok however, apparently.
     * (Sep 9 2005) No, it is not.
     */

    if ((esPtr->fdin == 0) ||
	(esPtr->fdin == 1) ||
	(esPtr->fdin == 2)) {
      return 0;
    }

    return expSetBlockModeProc (esPtr->fdin, mode);
}

int
expSetBlockModeProc(fd, mode)
    int fd;
    int mode;				/* The mode to set. Can be one of
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
{
    int curStatus;
    /*printf("ExpBlockModeProc(%d)\n",mode);
      printf("fdin = %d\n",fd);*/

#ifndef USE_FIONBIO
    curStatus = fcntl(fd, F_GETFL);
    /*printf("curStatus = %d\n",curStatus);*/
    if (mode == TCL_MODE_BLOCKING) {
	curStatus &= (~(O_NONBLOCK));
    } else {
	curStatus |= O_NONBLOCK;
    }
    /*printf("new curStatus %d\n",curStatus);*/
    if (fcntl(fd, F_SETFL, curStatus) < 0) {
	return errno;
    }
    curStatus = fcntl(fd, F_GETFL);
#else /* USE_FIONBIO */
    if (mode == TCL_MODE_BLOCKING) {
	curStatus = 0;
    } else {
	curStatus = 1;
    }
    if (ioctl(fd, (int) FIONBIO, &curStatus) < 0) {
	return errno;
    }
#endif /* !USE_FIONBIO */
    return 0;
}
/*
 *----------------------------------------------------------------------
 *
 * ExpInputProc --
 *
 *	This procedure is invoked from the generic IO level to read
 *	input from an exp-based channel.
 *
 * Results:
 *	The number of bytes read is returned or -1 on error. An output
 *	argument contains a POSIX error code if an error occurs, or zero.
 *
 * Side effects:
 *	Reads input from the input device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
ExpInputProc(instanceData, buf, toRead, errorCodePtr)
    ClientData instanceData;		/* Exp state. */
    char *buf;				/* Where to store data read. */
    int toRead;				/* How much space is available
                                         * in the buffer? */
    int *errorCodePtr;			/* Where to store error code. */
{
    ExpState *esPtr = (ExpState *) instanceData;
    int bytesRead;			/* How many bytes were actually
                                         * read from the input device? */

    *errorCodePtr = 0;
    
    /*
     * Assume there is always enough input available. This will block
     * appropriately, and read will unblock as soon as a short read is
     * possible, if the channel is in blocking mode. If the channel is
     * nonblocking, the read will never block.
     */

    bytesRead = read(esPtr->fdin, buf, (size_t) toRead);
    /*printf("ExpInputProc: read(%d,,) = %d\r\n",esPtr->fdin,bytesRead);*/

    /* Emulate EOF on tty for tcl */
    if ((bytesRead == -1) && (errno == EIO) && isatty(esPtr->fdin)) {
	bytesRead = 0;
    }
    if (bytesRead > -1) {
	/* strip parity if requested */
	if (esPtr->parity == 0) {
	    char *end = buf+bytesRead;
	    for (;buf < end;buf++) {
		*buf &= 0x7f;
	    }
	}
        return bytesRead;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to an exp channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument	contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
ExpOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* Exp state. */
    char *buf;				/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    ExpState *esPtr = (ExpState *) instanceData;
    int written = 0;

    *errorCodePtr = 0;

    if (toWrite < 0) Tcl_Panic("ExpOutputProc: called with negative char count");
    if (toWrite ==0) {
        return 0;
    }

    written = write(esPtr->fdout, buf, (size_t) toWrite);
    if (written == 0) {
      /* This shouldn't happen but I'm told that it does
       * nonetheless (at least on SunOS 4.1.3).  Since this is
       * not a documented return value, the most reasonable
       * thing is to complain here and retry in the hopes that
       * it is some transient condition.  */
      sleep(1);
      expDiagLogU("write() failed to write anything - will sleep(1) and retry...\n");
      *errorCodePtr = EAGAIN;
      return -1;
    } else if (written < 0) {
      *errorCodePtr = errno;
      return -1;
    }
    return written;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpCloseProc --
 *
 *	This procedure is called from the generic IO level to perform
 *	channel-type-specific cleanup when an exp-based channel is closed.
 *
 * Results:
 *	0 if successful, errno if failed.
 *
 * Side effects:
 *	Closes the device of the channel.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
ExpCloseProc(instanceData, interp)
    ClientData instanceData;	/* Exp state. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
{
    ExpState *esPtr = (ExpState *) instanceData;
    ExpState **nextPtrPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    esPtr->registered = FALSE;

#if 0
    /*
      Really should check that we created one first.  Since we're sharing fds
      with Tcl, perhaps a filehandler was created with a plain tcl file - we
      wouldn't want to delete that.  Although if user really close Expect's
      user_spawn_id, it probably doesn't matter anyway.
    */

    Tcl_DeleteFileHandler(esPtr->fdin);
#endif /*0*/

    Tcl_Free((char*)esPtr->input.buffer);
    Tcl_DecrRefCount (esPtr->input.newchars);

    /* Actually file descriptor should have been closed earlier. */
    /* So do nothing here */

    /*
     * Conceivably, the process may not yet have been waited for.  If this
     * becomes a requirement, we'll have to revisit this code.  But for now, if
     * it's just Tcl exiting, the processes will exit on their own soon
     * anyway.
     */

    for (nextPtrPtr = &(tsdPtr->firstExpPtr); (*nextPtrPtr) != NULL;
	 nextPtrPtr = &((*nextPtrPtr)->nextPtr)) {
	if ((*nextPtrPtr) == esPtr) {
	    (*nextPtrPtr) = esPtr->nextPtr;
	    break;
	}
    }
    tsdPtr->channelCount--;

    if (esPtr->bg_status == blocked ||
	    esPtr->bg_status == disarm_req_while_blocked) {
	esPtr->freeWhenBgHandlerUnblocked = 1;
	/*
	 * If we're in the middle of a bg event handler, then the event
	 * handler will have to take care of freeing esPtr.
	 */
    } else {
	expStateFree(esPtr);
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpWatchProc --
 *
 *	Initialize the notifier to watch the fd from this channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets up the notifier so that a future event on the channel will
 *	be seen by Tcl.
 *
 *----------------------------------------------------------------------
 */

static void
ExpWatchProc(instanceData, mask)
    ClientData instanceData;		/* The exp state. */
    int mask;				/* Events of interest; an OR-ed
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
{
    ExpState *esPtr = (ExpState *) instanceData;

    /*
     * Make sure we only register for events that are valid on this exp.
     * Note that we are passing Tcl_NotifyChannel directly to
     * Tcl_CreateExpHandler with the channel pointer as the client data.
     */

    mask &= esPtr->validMask;
    if (mask) {
	/*printf("  CreateFileHandler: %d (mask = %d)\r\n",esPtr->fdin,mask);*/
	Tcl_CreateFileHandler(esPtr->fdin, mask,
		(Tcl_FileProc *) Tcl_NotifyChannel,
		(ClientData) esPtr->channel);
    } else {
	/*printf("  DeleteFileHandler: %d (mask = %d)\r\n",esPtr->fdin,mask);*/
	Tcl_DeleteFileHandler(esPtr->fdin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ExpGetHandleProc --
 *
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from
 *	an exp-based channel.
 *
 * Results:
 *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if
 *	there is no handle for the specified direction. 
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ExpGetHandleProc(instanceData, direction, handlePtr)
    ClientData instanceData;	/* The exp state. */
    int direction;		/* TCL_READABLE or TCL_WRITABLE */
    ClientData *handlePtr;	/* Where to store the handle.  */
{
    ExpState *esPtr = (ExpState *) instanceData;

    if (direction & TCL_WRITABLE) {
	*handlePtr = (ClientData) esPtr->fdin;
    }
    if (direction & TCL_READABLE) {
	*handlePtr = (ClientData) esPtr->fdin;
    } else {
	return TCL_ERROR;
    }
    return TCL_OK;
}

int
expChannelCountGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->channelCount;
}

int
expChannelStillAlive(esBackupPtr, backupName)
     ExpState *esBackupPtr;
     char *backupName;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;

    /* 
     * This utility function is called from 'exp_background_channelhandler'
     * and checks to make sure that backupName can still be found in the 
     * channels linked list at the same address as before.
     *
     * If it can't be (or if the memory address has changed) then it
     * means that it was lost in the background (and possibly another
     * channel was opened and reassigned the same name).
     */

    for (esPtr = tsdPtr->firstExpPtr; esPtr; esPtr = esPtr->nextPtr) {
        if (0 == strcmp(esPtr->name, backupName)) 
            return (esPtr == esBackupPtr);
    }
        
    /* not found; must have been lost in the background */
    return 0;
}

#if 0 /* Converted to macros */
int
expSizeGet(esPtr)
    ExpState *esPtr;
{
    return esPtr->input.use;
}

int
expSizeZero(esPtr)
    ExpState *esPtr;
{
    return (esPtr->input.use == 0);
}
#endif
/* return 0 for success or negative for failure */
int
expWriteChars(esPtr,buffer,lenBytes)
     ExpState *esPtr;
     char *buffer;
     int lenBytes;
{
  int rc;
 retry:
  rc = Tcl_WriteChars(esPtr->channel,buffer,lenBytes);
  if ((rc == -1) && (errno == EAGAIN)) goto retry;

  if (!exp_strict_write) {
    /*
     * 5.41 compatbility behaviour. Ignore any and all write errors
     * the OS may have thrown.
     */
    return 0;
  }

  /* just return 0 rather than positive byte counts */
  return ((rc > 0) ? 0 : rc);
}

int
expWriteCharsUni(esPtr,buffer,lenChars)
     ExpState *esPtr;
     Tcl_UniChar *buffer;
     int lenChars;
{
  int rc;
  Tcl_DString ds;

  Tcl_DStringInit (&ds);
  Tcl_UniCharToUtfDString (buffer,lenChars,&ds);

  rc = expWriteChars(esPtr,Tcl_DStringValue (&ds), Tcl_DStringLength (&ds));

  Tcl_DStringFree (&ds);

  return rc;
}

void
expStateFree(esPtr)
    ExpState *esPtr;
{
  if (esPtr->fdBusy) {
    close(esPtr->fdin);
  }

    esPtr->valid = FALSE;
    
    if (!esPtr->keepForever) {
	ckfree((char *)esPtr);
    }
}

/* close all connections
 * 
 * The kernel would actually do this by default, however Tcl is going to come
 * along later and try to reap its exec'd processes.  If we have inherited any
 * via spawn -open, Tcl can hang if we don't close the connections first.
 */
void
exp_close_all(interp)
Tcl_Interp *interp;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;
    ExpState *esNextPtr;

    /* Save the nextPtr in a local variable before calling 'exp_close'
       as 'expStateFree' can be called from it under some
       circumstances, possibly causing the memory allocator to smash
       the value in 'esPtr'. - Andreas Kupries
    */

    /* no need to keep things in sync (i.e., tsdPtr, count) since we could only
       be doing this if we're exiting.  Just close everything down. */

    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esNextPtr) {
        esNextPtr = esPtr->nextPtr;
	exp_close(interp,esPtr);
    }
}

/* wait for any of our own spawned processes we call waitpid rather
 * than wait to avoid running into someone else's processes.  Yes,
 * according to Ousterhout this is the best way to do it.
 * returns the ExpState or 0 if nothing to wait on */
ExpState *
expWaitOnAny()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int result;
    ExpState *esPtr;

    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
	if (esPtr->pid == exp_getpid) continue; /* skip ourself */
	if (esPtr->user_waited) continue;	/* one wait only! */
	if (esPtr->sys_waited) break;
      restart:
	result = waitpid(esPtr->pid,&esPtr->wait,WNOHANG);
	if (result == esPtr->pid) break;
	if (result == 0) continue;	/* busy, try next */
	if (result == -1) {
	    if (errno == EINTR) goto restart;
	    else break;
	}
    }
    return esPtr;
}

ExpState *
expWaitOnOne() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;
    int pid;
    /* should really be recoded using the common wait code in command.c */
    WAIT_STATUS_TYPE status;

    pid = wait(&status);
    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
	if (esPtr->pid == pid) {
	    esPtr->sys_waited = TRUE;
	    esPtr->wait = status;
	    return esPtr;
	}
    }
    /* Should not reach this location. If it happens return a value
     * causing an easy crash */
    return NULL;
}

void
exp_background_channelhandlers_run_all()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;
    ExpState *esNextPtr;
    ExpState *esPriorPtr = 0;

    /* kick off any that already have input waiting */
    for (esPtr = tsdPtr->firstExpPtr;esPtr; esPriorPtr = esPtr, esPtr = esPtr->nextPtr) {
	/* is bg_interp the best way to check if armed? */
	if (esPtr->bg_interp && !expSizeZero(esPtr)) {
            /* 
             * We save the nextPtr in a local variable before calling
             * 'exp_background_channelhandler' since in some cases
             * 'expStateFree' could end up getting called before it
             * returns, leading to a likely segfault on the next
             * interaction through the for loop.
             */
            esNextPtr = esPtr->nextPtr;
	    exp_background_channelhandler((ClientData)esPtr,0);
            if (esNextPtr != esPtr->nextPtr) {
                /* 
                 * 'expStateFree' must have been called from
                 * underneath us so we know that esPtr->nextPtr is
                 * invalid.  However, it is possible that either the
                 * original nextPtr and/or the priorPtr have been
                 * freed too.  If the esPriorPtr->nextPtr is now
                 * esNextPtr it seems safe to proceed.  Otherwise we
                 * break and end early for safety.
                 */
                if (esPriorPtr && esPriorPtr->nextPtr == esNextPtr) {
                    esPtr = esPriorPtr;
                } else {
                    break; /* maybe set esPtr = tsdPtr->firstExpPtr again? */
                }
            }
	}
    }
}

ExpState *
expCreateChannel(interp,fdin,fdout,pid)
    Tcl_Interp *interp;
    int fdin;
    int fdout;
    int pid;
{
    ExpState *esPtr;
    int mask;
    Tcl_ChannelType *channelTypePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    channelTypePtr = &expChannelType;

    esPtr = (ExpState *) ckalloc((unsigned) sizeof(ExpState));

    esPtr->nextPtr = tsdPtr->firstExpPtr;
    tsdPtr->firstExpPtr = esPtr;

    sprintf(esPtr->name,"exp%d",fdin);

    /*
     * For now, stupidly assume this.  We we will likely have to revisit this
     * later to prevent people from doing stupid things.
     */
    mask = TCL_READABLE | TCL_WRITABLE;

    /* not sure about this - what about adopted channels */
    esPtr->validMask = mask | TCL_EXCEPTION;
    esPtr->fdin = fdin;
    esPtr->fdout = fdout;

    /* set close-on-exec for everything but std channels */
    /* (system and stty commands need access to std channels) */
    if (fdin != 0 && fdin != 2) {
      expCloseOnExec(fdin);
      if (fdin != fdout) expCloseOnExec(fdout);
    }

    esPtr->fdBusy = FALSE;
    esPtr->channel = Tcl_CreateChannel(channelTypePtr, esPtr->name,
	    (ClientData) esPtr, mask);
    Tcl_RegisterChannel(interp,esPtr->channel);
    esPtr->registered = TRUE;
    Tcl_SetChannelOption(interp,esPtr->channel,"-buffering","none");
    Tcl_SetChannelOption(interp,esPtr->channel,"-blocking","0");
    Tcl_SetChannelOption(interp,esPtr->channel,"-translation","lf");

    esPtr->pid = pid;

    esPtr->input.max    = 1;
    esPtr->input.use    = 0;
    esPtr->input.buffer = (Tcl_UniChar*) Tcl_Alloc (sizeof (Tcl_UniChar));
    esPtr->input.newchars = Tcl_NewObj();
    Tcl_IncrRefCount (esPtr->input.newchars);

    esPtr->umsize = exp_default_match_max;
    /* this will reallocate object with an appropriate sized buffer */
    expAdjust(esPtr);

    esPtr->printed = 0;
    esPtr->echoed = 0;
    esPtr->rm_nulls = exp_default_rm_nulls;
    esPtr->parity = exp_default_parity;
    esPtr->close_on_eof = exp_default_close_on_eof;
    esPtr->key = expect_key++;
    esPtr->force_read = FALSE;
    esPtr->fg_armed = FALSE;
    esPtr->chan_orig = 0;
    esPtr->fd_slave = EXP_NOFD;
#ifdef HAVE_PTYTRAP
    esPtr->slave_name = 0;
#endif /* HAVE_PTYTRAP */
    esPtr->open = TRUE;
    esPtr->notified = FALSE;
    esPtr->user_waited = FALSE;
    esPtr->sys_waited = FALSE;
    esPtr->bg_interp = 0;
    esPtr->bg_status = unarmed;
    esPtr->bg_ecount = 0;
    esPtr->freeWhenBgHandlerUnblocked = FALSE;
    esPtr->keepForever = FALSE;
    esPtr->valid = TRUE;
    tsdPtr->channelCount++;

    return esPtr;
}

void
expChannelInit() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->channelCount = 0;
}
@


5.20
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@d220 5
d455 28
d638 2
d642 1
a642 1
    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
d645 8
d654 16
@


5.19
log
@ansification
@
text
@a37 1
#include "exp_event.h"
d40 14
a53 7
extern int		expSetBlockModeProc (int fd, int mode);
static int		ExpBlockModeProc (ClientData instanceData, int mode);
static int		ExpCloseProc (ClientData instanceData, Tcl_Interp *interp);
static int		ExpInputProc (ClientData instanceData, char *buf, int toRead, int *errorCode);
static int		ExpOutputProc ( ClientData instanceData, char *buf, int toWrite, int *errorCode);
static void		ExpWatchProc (ClientData instanceData, int mask);
static int		ExpGetHandleProc (ClientData instanceData, int direction, ClientData *handlePtr);
d87 1
a87 1
/*
a94 4
 *	The mode should be one of TCL_MODE_BLOCKING or
 *	                          TCL_MODE_NONBLOCKING.
 *	No validation is performed on the mode.
 *
d106 5
a110 1
ExpBlockModeProc(ClientData instanceData, int mode)
d144 5
a148 1
expSetBlockModeProc(int fd, int mode)
d185 1
a185 2
 *	input from an exp-based channel. The input is stored in the
 *	buffer pointed at by buf, which can store up to toRead bytes.
d188 2
a189 3
 *	The number of bytes read is returned or -1 on error. If there
 *	is an error, the error code is stored in *errorCodePtr, which
 *	is set to zero if no error occurs.
d198 6
a203 1
ExpInputProc(ClientData instanceData, char *buf, int toRead, int *errorCodePtr)
d233 1
a233 1

d240 1
a240 2
 *	output to an exp channel. The bytes to write are in the buffer
 *	pointer at by buf, which holds toWrite bytes.
d243 3
a245 3
 *	The number of bytes written is returned or -1 on error. If there
 *	is an error, the error code is stored in *errorCodePtr, which
 *	is set to zero if no error occurs.
d254 5
a258 1
ExpOutputProc(ClientData instanceData, char *buf, int toWrite, int *errorCodePtr)
d287 1
a287 1

d307 3
a309 1
ExpCloseProc(ClientData instanceData, Tcl_Interp *interp)
d362 1
a362 1

a368 4
 *	The mask can be any combination of:
 *		TCL_READABLE
 *		TCL_WRITABLE
 *		TCL_EXCEPTION
d381 5
a385 1
ExpWatchProc(ClientData instanceData, int mask)
d406 1
a406 1

a413 1
 *	Specify direction as TCL_READABLE or TCL_WRITABLE
d426 1
a426 1
ExpGetHandleProc(ClientData instanceData, int direction, ClientData *handlePtr)
d445 1
a445 1
expChannelCountGet(void)
d467 4
a470 1
expWriteChars(ExpState *esPtr, char *buffer, int lenBytes)
d475 1
a475 4
  if ((rc == -1) && (errno == EAGAIN)) 
  {
      goto retry;
  }
d478 5
a482 5
      /*
      * 5.41 compatbility behaviour. Ignore any and all write errors
      * the OS may have thrown.
      */
      return 0;
d490 4
a493 1
expWriteCharsUni(ExpState *esPtr, Tcl_UniChar *buffer, int lenChars)
d509 2
a510 1
expStateFree(ExpState *esPtr)
d530 2
a531 1
exp_close_all(Tcl_Interp *interp)
d557 1
a557 1
expWaitOnAny(void)
d580 1
a580 1
expWaitOnOne(void) {
d601 1
a601 1
exp_background_channelhandlers_run_all(void)
d616 5
a620 1
expCreateChannel(Tcl_Interp *interp, int fdin, int fdout, int pid)
d704 1
a704 1
expChannelInit(void) {
@


5.18
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d38 1
d41 7
a47 14
extern int		expSetBlockModeProc _ANSI_ARGS_((int fd, int mode));
static int		ExpBlockModeProc _ANSI_ARGS_((ClientData instanceData,
			    int mode));
static int		ExpCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
static int		ExpInputProc _ANSI_ARGS_((ClientData instanceData,
		            char *buf, int toRead, int *errorCode));
static int		ExpOutputProc _ANSI_ARGS_((
			    ClientData instanceData, char *buf, int toWrite,
                            int *errorCode));
static void		ExpWatchProc _ANSI_ARGS_((ClientData instanceData,
		            int mask));
static int		ExpGetHandleProc _ANSI_ARGS_((ClientData instanceData,
		            int direction, ClientData *handlePtr));
@


5.17
log
@Converting function declarations and definitions from K&R style
to ISO C style, along with occasional related comment changes.
@
text
@d87 1
a87 1
/*
d226 1
a226 1

d277 1
a277 1

d350 1
a350 1

d394 1
a394 1

@


5.16
log
@
	* exp_chan.c: Converted the buffering system from UTF-8 in Tcl_Obj
	* exp_command.h: to UTF-16 C-array, to avoid the repeated conversion
	* expect.c: of the input from utf-8 to utf-16. Updated the glob
	* exp_glob.c: matching code to use the same tricks for speed which
	* exp_inter.c: are used by the Tcl core. Extended the regexp
	* exp_log.c: matching path with a glob matcher which uses a gate
	* exp_log.h: keeper glob pattern to weed out most non-candidates
	* retoglob.c (New file): in a speedy manner. Regexp matching now
	  has to be done only for the small number of candidates
	  identified by the gate keeper. Overall speed improvement as glob
	  matching is faster than regexp matching. Added code translating
	  regular expressions into their gate keeper glob pattern.
@
text
@d95 4
d110 1
a110 5
ExpBlockModeProc(instanceData, mode)
    ClientData instanceData;		/* Exp state. */
    int mode;				/* The mode to set. Can be one of
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d144 1
a144 5
expSetBlockModeProc(fd, mode)
    int fd;
    int mode;				/* The mode to set. Can be one of
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d181 2
a182 1
 *	input from an exp-based channel.
d185 3
a187 2
 *	The number of bytes read is returned or -1 on error. An output
 *	argument contains a POSIX error code if an error occurs, or zero.
d196 1
a196 6
ExpInputProc(instanceData, buf, toRead, errorCodePtr)
    ClientData instanceData;		/* Exp state. */
    char *buf;				/* Where to store data read. */
    int toRead;				/* How much space is available
                                         * in the buffer? */
    int *errorCodePtr;			/* Where to store error code. */
d233 2
a234 1
 *	output to an exp channel.
d237 3
a239 3
 *	The number of bytes written is returned or -1 on error. An
 *	output argument	contains a POSIX error code if an error occurred,
 *	or zero.
d248 1
a248 5
ExpOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* Exp state. */
    char *buf;				/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
d297 1
a297 3
ExpCloseProc(instanceData, interp)
    ClientData instanceData;	/* Exp state. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
d357 4
d373 1
a373 5
ExpWatchProc(instanceData, mask)
    ClientData instanceData;		/* The exp state. */
    int mask;				/* Events of interest; an OR-ed
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
d402 1
d415 1
a415 1
ExpGetHandleProc(instanceData, direction, handlePtr)
d434 1
a434 1
expChannelCountGet()
d456 1
a456 4
expWriteChars(esPtr,buffer,lenBytes)
     ExpState *esPtr;
     char *buffer;
     int lenBytes;
d461 4
a464 1
  if ((rc == -1) && (errno == EAGAIN)) goto retry;
d467 5
a471 5
    /*
     * 5.41 compatbility behaviour. Ignore any and all write errors
     * the OS may have thrown.
     */
    return 0;
d479 1
a479 4
expWriteCharsUni(esPtr,buffer,lenChars)
     ExpState *esPtr;
     Tcl_UniChar *buffer;
     int lenChars;
d495 1
a495 2
expStateFree(esPtr)
    ExpState *esPtr;
d515 1
a515 2
exp_close_all(interp)
Tcl_Interp *interp;
d541 1
a541 1
expWaitOnAny()
d564 1
a564 1
expWaitOnOne() {
d585 1
a585 1
exp_background_channelhandlers_run_all()
d600 1
a600 5
expCreateChannel(interp,fdin,fdout,pid)
    Tcl_Interp *interp;
    int fdin;
    int fdout;
    int pid;
d684 1
a684 1
expChannelInit() {
@


5.15
log
@
	* Dbg.c: Added note about unhandled cases in a switch.
	* exp_chan.c: Added code to suppress unhandled warning for
	  unreachable code.
	* exp_command.c: Removed unused variable.
	* expect.c: Removed unused static function, added code to suppress
	  unhandled warning for unreachable code.
@
text
@d38 1
d328 2
a329 1
    Tcl_DecrRefCount(esPtr->buffer);
d450 1
a450 1

d455 1
a455 3
    int len;
    Tcl_GetStringFromObj(esPtr->buffer,&len);
    return len;
d462 1
a462 3
    int len;
    Tcl_GetStringFromObj(esPtr->buffer,&len);
    return (len == 0);
d464 1
a464 1

d489 19
a663 1
    esPtr->msize = 0;
d665 6
a670 3
    /* initialize a dummy buffer */
    esPtr->buffer = Tcl_NewStringObj("",0);
    Tcl_IncrRefCount(esPtr->buffer);
@


5.14
log
@
	* exp_main_sub.c: Added command 'exp_configure' for magic configuration.
	* exp_command.c:  Accepts option -strictwrite. Default is 0, ignoring
	* exp_chan.c:     write errors (compatible to 5.41). Setting to 1 re-
	* expect_tcl.h:   activates 5.42 behaviour.
@
text
@d578 3
@


5.13
log
@
	* exp_chan.c (ExpOutputProc): Added guard to intercept and ignore
	  empty write operations, i.e. operations trying to write zero
	  bytes.
@
text
@d479 8
@


5.12
log
@
	* exp_chan.c (ExpBlockModeProc): No, stdin is not ok (See last
	  entry). Fixed.
@
text
@d265 3
@


5.11
log
@
	* exp_chan.c (ExpBlockModeProc): [Expect SF Bug 1108551]. Excluded
	  manipulation of the blocking status for stdin/stderr. This is
	  handled by the Tcl core itself and we must absolutely not pull
	  the rug out from under it. The standard setting to non-blocking
	  will mess with the core which had them set to blocking, and
	  makes all its decisions based on that assumption. Setting to
	  non-blocking can cause hangs and crashes. Stdin is ok however,
	  apparently.

	  This problem was introduced at '2004-06-14'.
@
text
@d120 1
a120 1
    /* [Expect SF Bug 1108551]
d130 1
d133 2
a134 1
    if ((esPtr->fdin == 1) ||
@


5.10
log
@
	* exp_chan.c:    Fixed bug causing crash of expect on exit when a
	* exp_command.c: Tcl channel is used with -(leave)open more than
	* exp_command.h: once. It tried to close such channels multiple
	  times, going through already freed memory. Added data structures
	  to track and refcount all such channels, to close them only when
	  the last user goes away.
@
text
@d120 17
@


5.9
log
@
	* exp_chan.c: Fixed problem with debugger introduced at '2004-06-14'.
	* tcldbg.h:   For a nonblocking stdin the debugger blowed up on the
	* Dbg.c:      empty reads it could get, exiting the application. I
	              guess that this was an implicit 'panic'. Fix:

		      - Split ExpBlockmodeProc into high- and lowlevel
		        code, the latter for use by the debugger. The
		        high-level code tells the debugger which state
		        stdin is in (doing this explicitly because if
		        FIONBIO is used it is not possible to query the fd
		        directly, and I saw no reason to #ifdef for fcntl
		        which can).

		      - Debugger now exports a function for use by the
		        blockmode proc, and in each interaction it checks
		        for nonblocking input, forces blocking if
		        necessary. At the end of each interaction the true
		        mode is restored. Both operations use the
		        low-level blockmode code.
@
text
@d631 1
a631 1
    esPtr->channel_orig = 0;
@


5.8
log
@Merge goof fixed
@
text
@d39 1
d112 18
d132 1
a132 1
      printf("fdin = %d\n",esPtr->fdin);*/
d135 1
a135 1
    curStatus = fcntl(esPtr->fdin, F_GETFL);
d143 1
a143 1
    if (fcntl(esPtr->fdin, F_SETFL, curStatus) < 0) {
d146 1
a146 1
    curStatus = fcntl(esPtr->fdin, F_GETFL);
d153 1
a153 1
    if (ioctl(esPtr->fdin, (int) FIONBIO, &curStatus) < 0) {
@


5.7
log
@
	* Merged changes from the official versions 5.42.1 and 5.43.0 of
	  expect into the SF sources. See the details below.

	  --------------------
	  Martin Forssen <maf@@tkrat.xorg> fixed bug in ExpOutputProc
	  that caused misbehavior during partial writes.

	  Someone noted that gets stdin behaves differently (returns -1
	  immediately) from tclsh because with 5.42, stdin is unblocked by
	  defaults.

	  Robroy Gregg <robroy@@armory.xcom> noted that expect_background
	  ignores timeouts.  Added to documentation.

	  Jens Peterson <peterson@@redhat.xcom> provided patch for
	  "mkpasswd -vo".

	  Gary Bliesener <gary.bliesener@@nextel.xcom> noted that
	  multixterm failed on his system which had an old Tk that didn't
	  support the Tk package.

	  Removed beta designation.

	  Daniel A. Steffen <steffen@@ics.mq.edu.xau> provided patch for
	  MacOS to avoid panic-redefinition.
	  --------------------
@
text
@a68 1
#endif
@


5.6
log
@
	* exp_inter.c: Changed all uses of 'time(3)' to Tcl_GetTime. IOW
	* expect.c:    go through the abstract core API instead of
	               directly acessing OS time. This makes the code
	               dependent on Tcl 8.4, as Tcl_GetTime was not public
	               before. See TIP #73 for its introduction into the
	               public API. As for the reason behind _this_ change
	               see TIP #233. Our change here now causes Expect to
	               be automatically in sync with any virtualization
	               set up in the core.
@
text
@d69 1
d229 14
a242 17
    while (toWrite > 0) {
	written = write(esPtr->fdout, buf, (size_t) toWrite);
	if (written == 0) {
	    /* This shouldn't happen but I'm told that it does
	     * nonetheless (at least on SunOS 4.1.3).  Since this is
	     * not a documented return value, the most reasonable
	     * thing is to complain here and retry in the hopes that
	     * it is some transient condition.  */
	    sleep(1);
	    expDiagLogU("write() failed to write anything - will sleep(1) and retry...\n");
	} else if (written < 0) {
	    if (errno == EAGAIN) continue;
	    *errorCodePtr = errno;
	    return -1;
	}
	buf += written;
	toWrite -= written;
@


5.5
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@d239 1
@


5.4
log
@
	* exp_chan.c: Integrated the block mode proc I got by mail from
	  Don Libes into the channel driver. This fixes an error with
	  expect hanging on some input if the situation is just
	  right^Hwrong. Basically if the buffers in driver, Tcl IO core
	  and Expect itself are aligned just so it can cause Expect to
	  block in all call to the OS for more data even if all the data
	  it needs is in ts buffers. Because the driver is blocking and
	  the Tcl core was told that it can run in non-blocking mode. with
	  the block mode proc in place the driver knows that it should be
	  non-blocking and is able to tell this to the OS as well. The
	  call to the OS still happens, but is not blocking anymore, and
	  so the problem is gone.

	  A number of incompat changes in the Tcl IO core to work around
	  this problem in Expect will be removed now.
@
text
@d26 2
d85 1
a85 2

/*
d112 2
d117 1
d123 1
a139 1

d428 16
d610 1
@


5.3
log
@
	* Merged changes from the official version 5.39 of expect into the
	  SF sources. See details below. Partially already done.

	  --------------------
	  Poorva Gupta <poorva@@cup.hp.xcom> noted that grantpt/unlockpt
	  order was backward.  Strange that this was never a prob before!

	  Eric Raymond <esr@@snark.thyrsus.xcom> provided a troff-related
	  fix for the multixterm man page.

	  Nicolas Roeser <n-roeser@@gmx.xnet> noted confusion with md5 so I
	  made the Expect page more explicit about which file that hash
	  was based on.

	  Josh Purinton noted that earlier fix wasn't quite right.  Exit
	  on INT/TERM should cause Expect to exit with signal embedded in
	  status.  He also requested I obfuscate email addresses in this
	  file.

	  Guido Ostkamp <Guido.Ostkamp@@t-online.xde> and Igor Sobrado
	  <sobrado@@string1.ciencias.uniovi.xes> noted that fixline1
	  rewrote scripts to be expect scripts even if they were expectk
	  scripts.

	  Dirk Petera <dirkpetera@@yahoo.xcom> noted that any_spawn_id used
	  to work but did no longer.  Looks like a bug left over from the
	  the I18L conversion.  Fixed.

	  Steve Szabo noted exp_log_file -open channel failed.  Fixed.

	  Fixed bug from 5.31 that prevent stty from returning messages
	  from underlying program.

	  Thomas Dickey <dickey@@herndon4.his.xcom> noted that ncurses
	  ignores 2-char term names because of, well, poor assumptions and
	  coding.  Changed tkterm to use longer names.

	  Heath Moore <hmoore@@systran.xcom> noted that exp_clib could lock
	  up if remtime happened to be precisely 0.  Recoded to avoid.

	  At request of Per Otterholm <otterholm@@telia.xcom>, wrote script
	  to read from stdin and echo passwords (exercise 9 in Tk chapter
	  of Expect book).  Added to example directory as passwdprompt.

	  Josh Purinton <josh@@purinton.xorg> pointed out that by default,
	  SIGINT/TERM should cause expect's return status to be 1, not 0.

	  Paul Reithmuller <paul.reithmuller@@eng.sun.xcom> noted that
	  unbuffer shouldn't postprocess its output.  Added stty_init.

	  Mordechai T. Abzug <morty@@sanctuary.arbutus.md.xus> noted that
	  log_file wasn't recording -append status.

	  James Kelly <macubergeek@@comcast.xnet> noted weather example
	  needed new source.

	  Dimitar Haralanov <mitko@@tahoenetworks.xcom> noted that interact
	  dumped core with interact { timeout 1 }
	  --------------------
@
text
@d2 1
a2 1
 * tclUnixChan.c
d37 2
d57 1
a57 2
    /* Expect channels are always blocking */
    NULL,				/* Set blocking/nonblocking mode.*/
d87 52
@


5.2
log
@
	* exp_chan.c (exp_close_all): Save the nextPtr in a local variable
	  before calling 'exp_close' as 'expStateFree' can be called from
	  it under some circumstances, possibly causing the memory
	  allocator to smash the value in 'esPtr'.
@
text
@d400 6
@


5.1
log
@Merge of expect5-31-branch to mainline
@
text
@d398 1
d403 2
a404 1
    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
@


5.1.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.1.4.1
log
@Top-level source files removed.
@
text
@@


1.1
log
@file exp_chan.c was initially added on branch expect-5-31-branch.
@
text
@d1 557
@


1.1.2.1
log
@Expect channel driver
@
text
@a0 420
/* 
 * tclUnixChan.c
 *
 *	Channel driver for Expect channels.
 *      Based on UNIX File channel from TclUnixChan.c
 *
 */

#include	"tclInt.h"	/* Internal definitions for Tcl. */
#include	"tclPort.h"	/* Portability features for Tcl. */

#include "expChan.h"

/*
 * This structure describes the channel type structure for Expect-based IO:
 */

Tcl_ChannelType expChannelType = {
    "exp",				/* Type name. */
    /* Expect channels are always blocking */
    NULL,				/* Set blocking/nonblocking mode.*/
    ExpCloseProc,			/* Close proc. */
    ExpInputProc,			/* Input proc. */
    ExpOutputProc,			/* Output proc. */
    NULL,				/* Seek proc. */
    NULL,				/* Set option proc. */
    NULL,				/* Get option proc. */
    ExpWatchProc,			/* Initialize notifier. */
    ExpGetHandleProc,			/* Get OS handles out of channel. */
/* uncomment as necessary
/*  NULL,				/* Close2 proc */
};

typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    ExpState *firstExpPtr;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

int exp_ChannelCount = 0; /* this is process-wide as it is used to
			     give user some hint as to why a spawn has failed
			     by looking at process-wide resource usage */


/*
 *----------------------------------------------------------------------
 *
 * ExpInputProc --
 *
 *	This procedure is invoked from the generic IO level to read
 *	input from an exp-based channel.
 *
 * Results:
 *	The number of bytes read is returned or -1 on error. An output
 *	argument contains a POSIX error code if an error occurs, or zero.
 *
 * Side effects:
 *	Reads input from the input device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
ExpInputProc(instanceData, buf, toRead, errorCodePtr)
    ClientData instanceData;		/* Exp state. */
    char *buf;				/* Where to store data read. */
    int toRead;				/* How much space is available
                                         * in the buffer? */
    int *errorCodePtr;			/* Where to store error code. */
{
    ExpState *esPtr = (ExpState *) instanceData;
    int bytesRead;			/* How many bytes were actually
                                         * read from the input device? */

    *errorCodePtr = 0;
    
    /*
     * Assume there is always enough input available. This will block
     * appropriately, and read will unblock as soon as a short read is
     * possible, if the channel is in blocking mode. If the channel is
     * nonblocking, the read will never block.
     */

    bytesRead = read(esPtr->fdin, buf, (size_t) toRead);
    if (bytesRead > -1) {
        return bytesRead;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to an exp channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument	contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
ExpOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* Exp state. */
    char *buf;				/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    ExpState *esPtr = (ExpState *) instanceData;
    int written;

    *errorCodePtr = 0;

    written = write(esPtr->fdout, buf, (size_t) toWrite);
    if (written > -1) {
        return written;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpCloseProc --
 *
 *	This procedure is called from the generic IO level to perform
 *	channel-type-specific cleanup when an exp-based channel is closed.
 *
 * Results:
 *	0 if successful, errno if failed.
 *
 * Side effects:
 *	Closes the device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
ExpCloseProc(instanceData, interp)
    ClientData instanceData;	/* Exp state. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
{
    ExpState *esPtr = (ExpState *) instanceData;
    ExpState **nextPtrPtr;
    int errorCode = 0;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /*
      Really should check that we created one first.  Since we're sharing fds
      with Tcl, perhaps a filehandler was created with a plain tcl file - we
      wouldn't want to delete that.  Although if user really close Expect's
      user_spawn_id, it probably doesn't matter anyway.
    */

    Tcl_DeleteFileHandler(esPtr->fd);

    /*
     * Actually file descriptor should have been closed earlier.
     * But just in case, force it.
     */
    expSysClose(esPtr);

    /*
     * Conceivably, the process may not yet have been waited for.  If this
     * becomes a requirement, we'll have to revisit this code.  But for now, if
     * it's just Tcl exiting, * the processes will exit on their own soon
     * anyway.
     */
    
    for (nextPtrPtr = &(tsdPtr->firstExpPtr); (*nextPtrPtr) != NULL;
	 nextPtrPtr = &((*nextPtrPtr)->nextPtr)) {
	if ((*nextPtrPtr) == esPtr) {
	    (*nextPtrPtr) = esPtr->nextPtr;
	    break;
	}
    }
    exp_ChannelCount--;
    ckfree((char *) esPtr);
    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpWatchProc --
 *
 *	Initialize the notifier to watch the fd from this channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets up the notifier so that a future event on the channel will
 *	be seen by Tcl.
 *
 *----------------------------------------------------------------------
 */

static void
ExpWatchProc(instanceData, mask)
    ClientData instanceData;		/* The exp state. */
    int mask;				/* Events of interest; an OR-ed
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
{
    ExpState *esPtr = (ExpState *) instanceData;

    /*
     * Make sure we only register for events that are valid on this exp.
     * Note that we are passing Tcl_NotifyChannel directly to
     * Tcl_CreateExpHandler with the channel pointer as the client data.
     */

    mask &= esPtr->validMask;
    if (mask) {
	Tcl_CreateFileHandler(esPtr->fdin, mask,
		(Tcl_ExpProc *) Tcl_NotifyChannel,
		(ClientData) esPtr->channel);
    } else {
	Tcl_DeleteFileHandler(esPtr->fdin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ExpGetHandleProc --
 *
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from
 *	an exp-based channel.
 *
 * Results:
 *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if
 *	there is no handle for the specified direction. 
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ExpGetHandleProc(instanceData, direction, handlePtr)
    ClientData instanceData;	/* The exp state. */
    int direction;		/* TCL_READABLE or TCL_WRITABLE */
    ClientData *handlePtr;	/* Where to store the handle.  */
{
    ExpState *esPtr = (ExpState *) instanceData;

    if (direction & TCL_WRITABLE) {
	*handlePtr = (ClientData) esPtr->fdin;
    }
    if (direction & TCL_READABLE) {
	*handlePtr = (ClientData) esPtr->fd;
    } else {
	return TCL_ERROR;
    }
    return TCL_OK;
}

/* close all connections
The kernel would actually do this by default, however Tcl is going to
come along later and try to reap its exec'd processes.  If we have
inherited any via spawn -open, Tcl can hang if we don't close the
connections first.
*/

void
exp_close_all(interp)
Tcl_Interp *interp;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /* no need to keep things in sync (i.e., tsdPtr, count) since we could only
       be doing this if we're exiting.  Just close everything down. */

    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
	exp_close(interp,esPtr->channel);
    }
}

/* wait for any of our own spawned processes */
/* we call waitpid rather than wait to avoid running into */
/* someone else's processes.  Yes, according to Ousterhout */
/* this is the best way to do it. */
/* returns the ExpState or 0 if nothing to wait on */
ExpState *
expWaitOnAny(interp) {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int result;
    ExpState *esPtr;

    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
	if (esPtr->pid == exp_getpid) continue; /* skip ourself */
	if (esPtr->user_waited) continue;	/* one wait only! */
	if (esPtr->sys_waited) break;
      restart:
	result = waitpid(esPtr->pid,&esPtr->wait,WNOHANG);
	if (result == esPtr->pid) break;
	if (result == 0) continue;	/* busy, try next */
	if (result == -1) {
	    if (errno == EINTR) goto restart;
	    else break;
	}
    }
    return esPtr;
}

void
exp_background_channelhandlers_run_all()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int m;
    ExpState *f;

    /* kick off any that already have input waiting */
    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
	/* is bg_interp the best way to check if armed? */
	if (esPtr->bg_interp && (esPtr->size > 0)) {
	    exp_background_channelhandler((ClientData)esPtr);
	}
    }
}

#if NOTUSED
int
expIsExpChannelName(string)
    char *string;
{
    int rc;
    int fd;

    /* force assignment to something in order to get a useful return value */
    rc = scanf(string,"exp%d",&fd);

    return rc;
}
#endif

ExpState *
expCreateChannel(fdin,fdout,pid)
    int fdin;
    int fdout;
    int pid:
{
    ExpState *esPtr;
    char channelName[16 + TCL_INTEGER_SPACE];
    int mask;
    Tcl_ChannelType *channelTypePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    channelTypePtr = &expChannelType;

    esPtr = (ExpState *) ckalloc((unsigned) sizeof(ExpState));

    esPtr->nextPtr = tsdPtr->firstFilePtr;
    tsdPtr->firstFilePtr = esPtr;

    sprintf(esPtr->name,"exp%d",fdin);

    /*
     * For now, stupidly assume this.  We we will likely have to revisit this
     * later to prevent people from doing stupid things.
     */
    mask = TCL_READABLE | TCL_WRITABLE;

    /* not sure about this - what about adopted channels */
    esPtr->validMask = mask | TCL_EXCEPTION;
    esPtr->fdin = fdin;
    esPtr->fdout = fdout;
    esPtr->channel = Tcl_CreateChannel(channelTypePtr, esPtr->name,
	    (ClientData) esPtr, mask);
    Tcl_RegisterChannel(interp,esPtr->channel);

    esPtr->pid = pid;
    esPtr->msize = 0;

    /* should change this to just make a buffer! */
    esPtr->buffer = 0;
    
    esPtr->printed = 0;
    esPtr->echoed = 0;
    esPtr->rm_nulls = exp_default_rm_nulls;
    esPtr->parity = exp_default_parity;
    esPtr->key = expect_key++;
    esPtr->force_read = FALSE;
    esPtr->fg_armed = FALSE;
    esPtr->channel_orig = 0;
    esPtr->fd_slave = EXP_NOFD;
#ifdef HAVE_PTYTRAP
    esPtr->slave_name = 0;
#endif /* HAVE_PTYTRAP */
    esPtr->umsize = exp_default_match_max;
    esPtr->user_closed = FALSE;
    esPtr->sys_closed = FALSE;
    esPtr->user_waited = FALSE;
    esPtr->sys_waited = FALSE;
    esPtr->bg_interp = 0;
    esPtr->bg_status = unarmed;
    esPtr->bg_ecount = 0;

    exp_ChannelCount++;

    return esPtr->channel;
}
@


1.1.2.2
log
@got rid of remaining references to exp_fs and friends and exp_update_masters
@
text
@d170 1
a170 1
    Tcl_DeleteFileHandler(esPtr->fdin);
d269 1
a269 1
	*handlePtr = (ClientData) esPtr->fdin;
a321 18
}

ExpState *
expWaitOnOne() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int result;
    ExpState *esPtr;
    int pid;
    /* should really be recoded using the common wait code in command.c */
    int status;

    pid = wait(&status);
    for (esPtr = tsdPtr->firstExpPtr;esPtr;esPtr = esPtr->nextPtr) {
	if (esPtr->pid == pid) {
	    esPtr->sys_waited = TRUE;
	    esPtr->wait = status;
	}
    }
@


1.1.2.3
log
@fixed Log/Diag and ExpectCmd
@
text
@d172 5
a176 4
    Tcl_DecrRefCount(esPtr->buffer);

    /* Actually file descriptor should have been closed earlier. */
    /* So do nothing here */
a282 20
int
expSizeGet(esPtr)
    ExpState *esPtr;
{
    int len;
    Tcl_GetStringFromObj(esPtr->buffer,&len);
    return len;
}

int
expSizeZero(esPtr)
    ExpState *esPtr;
{
    int len;
    Tcl_GetStringFromObj(esPtr->buffer,&len);
    return (len == 0);
}



d347 1
a347 1
    ExpState *esPtr;
d352 1
a352 1
	if (esPtr->bg_interp && !expSizeZero(esPtr)) {
d358 15
a406 1
    esPtr->registered = 1;
d411 3
a413 7
    /* initialize a dummy buffer */
    esPtr->buffer = Tcl_NewStringObj("",0);
    Tcl_IncrRefCount(esPtr->buffer);
    esPtr->umsize = exp_default_match_max;
    /* this will reallocate object with an appropriate sized buffer */
    expAdjust(esPtr);

d426 3
a428 1
    esPtr->open = TRUE;
@


1.1.2.4
log
@made stuff compile
@
text
@a40 3
    int channelCount;	 /* this is process-wide as it is used to
			     give user some hint as to why a spawn has failed
			     by looking at process-wide resource usage */
d45 4
d191 1
a191 1
    tsdPtr->channelCount--;
d442 1
a442 8
    tsdPtr->channelCount++;

    return esPtr;
}

void
expChannelInit() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d444 1
a444 1
    tsdPtr->channelCount = 0;
@


1.1.2.5
log
@Checkpoint
@
text
@d159 1
a161 1
#if 0
a169 1
#endif /*0*/
d179 1
a179 1
     * it's just Tcl exiting, the processes will exit on their own soon
d182 1
a182 1

d191 2
a192 13

    if (esPtr->bg_status == blocked ||
	    esPtr->bg_status == disarm_req_while_blocked) {
	esPtr->freeWhenBgHandlerUnblocked = 1;
	/*
	 * If we're in the middle of a bg event handler, then the event
	 * handler will have to take care of freeing esPtr.
	 */
    } else {
	expStateFree(esPtr);
	ckfree((char *) esPtr);
    }
    return 0;
d274 7
a298 10
void
expStateFree(esPtr)
    ExpState *esPtr;
{
    esPtr->valid = FALSE;
    
    if (!esPtr->keepForever) {
	ckfree((char *)esPtr);
    }
}
d300 1
a300 6
/* close all connections
 * 
 * The kernel would actually do this by default, however Tcl is going to come
 * along later and try to reap its exec'd processes.  If we have inherited any
 * via spawn -open, Tcl can hang if we don't close the connections first.
 */
d440 1
a440 3
    esPtr->freeWhenBgHandlerUnblocked = FALSE;
    esPtr->keepForever = FALSE;
    esPtr->valid = TRUE;
@


1.1.2.6
log
@compiled!
@
text
@a8 17
#include <sys/types.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>	/* for isspace */
#include <time.h>	/* for time(3) */

#include "expect_cf.h"

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

d10 1
d12 1
a12 19
#include "tcl.h"

#include "string.h"

#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"

static int		ExpCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
static int		ExpInputProc _ANSI_ARGS_((ClientData instanceData,
		            char *buf, int toRead, int *errorCode));
static int		ExpOutputProc _ANSI_ARGS_((
			    ClientData instanceData, char *buf, int toWrite,
                            int *errorCode));
static void		ExpWatchProc _ANSI_ARGS_((ClientData instanceData,
		            int mask));
static int		ExpGetHandleProc _ANSI_ARGS_((ClientData instanceData,
		            int direction, ClientData *handlePtr));
a89 7
	/* strip parity if requested */
	if (esPtr->parity == 0) {
	    char *end = buf+bytesRead;
	    for (;buf < end;buf++) {
		*buf &= 0x7f;
	    }
	}
d242 1
a242 1
		(Tcl_FileProc *) Tcl_NotifyChannel,
a286 7
expChannelCountGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->channelCount;
}

int
a325 1
    ExpState *esPtr;
d331 1
a331 1
	exp_close(interp,esPtr);
d341 1
a341 3
expWaitOnAny(interp)
    Tcl_Interp *interp;
{
d397 1
a397 2
expCreateChannel(interp,fdin,fdout,pid)
    Tcl_Interp *interp;
d400 1
a400 1
    int pid;
d412 2
a413 2
    esPtr->nextPtr = tsdPtr->firstExpPtr;
    tsdPtr->firstExpPtr = esPtr;
@


1.1.2.7
log
@-gl now appears to work
@
text
@a482 3
    Tcl_SetChannelOption(interp,esPtr->channel,"-buffering","none");
    Tcl_SetChannelOption(interp,esPtr->channel,"-blocking","0");
    Tcl_SetChannelOption(interp,esPtr->channel,"-translation","binary");
@


1.1.2.8
log
@Fixed:
 expect command's arg handling to work (like interact)
 spawn -open
 expect eof
and various other bugs.
Expect now runs its minimal test suite (but not the examples).
@
text
@d243 1
a355 4
  if (esPtr->fdBusy) {
    close(esPtr->fdin);
  }

a478 5

    expCloseOnExec(fdin);
    if (fdin != fdout) expCloseOnExec(fdout);

    esPtr->fdBusy = FALSE;
@


1.1.2.9
log
@fixed examples
@
text
@d493 1
a493 1
    Tcl_SetChannelOption(interp,esPtr->channel,"-translation","lf");
@


1.1.2.10
log
@more mods
@
text
@a201 2
    esPtr->registered = FALSE;

d490 1
a490 1
    esPtr->registered = TRUE;
@


1.1.2.11
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@a34 1
#include "exp_log.h"
a122 1
    /*printf("ExpInputProc: read(%d,,) = %d\r\n",esPtr->fdin,bytesRead);*/
d164 1
a164 1
    int written = 0;
d168 3
a170 18
    if (toWrite < 0) Tcl_Panic("ExpOutputProc: called with negative char count");

    while (toWrite > 0) {
	written = write(esPtr->fdout, buf, (size_t) toWrite);
	if (written == 0) {
	    /* This shouldn't happen but I'm told that it does
	     * nonetheless (at least on SunOS 4.1.3).  Since this is
	     * not a documented return value, the most reasonable
	     * thing is to complain here and retry in the hopes that
	     * it is some transient condition.  */
	    sleep(1);
	    expDiagLogU("write() failed to write anything - will sleep(1) and retry...\n");
	} else if (written < 0) {
	    *errorCodePtr = errno;
	    return -1;
	}
	buf += written;
	toWrite -= written;
d172 2
a173 1
    return written;
a192 1
/*ARGSUSED*/
a282 1
	/*printf("  CreateFileHandler: %d (mask = %d)\r\n",esPtr->fdin,mask);*/
a286 1
	/*printf("  DeleteFileHandler: %d (mask = %d)\r\n",esPtr->fdin,mask);*/
d389 4
a392 3
/* wait for any of our own spawned processes we call waitpid rather
 * than wait to avoid running into someone else's processes.  Yes,
 * according to Ousterhout this is the best way to do it.
d395 2
a396 1
expWaitOnAny()
d421 1
a431 1
	    return esPtr;
d440 1
d447 1
a447 1
	    exp_background_channelhandler((ClientData)esPtr,0);
d460 1
a519 1
    esPtr->notified = FALSE;
@


1.1.2.12
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d65 2
a66 1
    NULL,				/* Close2 proc */
d411 1
a411 1
 * returns the ExpState or 0 if nothing to wait on */
@


1.1.2.13
log
@exp_chan.c:  Fixed incompatible type assignment in expWaitOnOne()
exp_command.h:  Now includes <tclPort.h> instead of ../unix/tclUnixPort.h

Other files touched but not changed.
@
text
@d440 1
a440 1
    WAIT_STATUS_TYPE status;
@


1.1.2.14
log
@Fixes to library.
Testing new fix to system command.
@
text
@d499 2
a500 6
    /* set close-on-exec for everything but std channels */
    /* (system and stty commands need access to std channels) */
    if (fdin != 0 && fdin != 2) {
      expCloseOnExec(fdin);
      if (fdin != fdout) expCloseOnExec(fdout);
    }
@


