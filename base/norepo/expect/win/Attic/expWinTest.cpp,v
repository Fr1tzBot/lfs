head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.2
	telco-tec-win32-take2-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2002.03.11.00.31.56;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.11.00.31.56;	author davygrvy;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.12.01.38.19;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.07.03.02.49.07;	author davygrvy;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.08.25.23.17.49;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expWinTest.cpp was initially added on branch telco-tec-win32-take2-branch.
@
text
@@


1.1.2.1
log
@Added a test for the BuildCommandLine function.
@
text
@a0 51
#include "TclAdapter.hpp"
#include "expWinUtils.hpp"

class Test1 : protected Tcl::Adapter<Test1>, ArgMaker
{
public:
    Test1(Tcl_Interp *_interp) : Tcl::Adapter<Test1>(_interp) {
	NewTclCmd(interp, "test_buildcmdline", TestCmdLineCmd);
    };
    virtual void DoCleanup () {
	// The adapter base class is telling us we are about to go away and it is
	// safe to use the interp pointer to do any needed cleanup.
    };
    ~Test1() {
	// can't use interp pointer in here.
    };
private:
    // Test the ArgMaker::BuildCommandLine() function.
    //
    int TestCmdLineCmd (int objc, struct Tcl_Obj * CONST objv[])
    {
	char **argv = new char * [objc-1];
	int i;
	char *line;

	for (i = objc-1; i > 0; i--) argv[i-1] = Tcl_GetString(objv[i]);
	line = BuildCommandLine(objc-1, argv);
	Tcl_SetObjResult(interp, Tcl_NewStringObj(line, -1));
	delete [] line;
	return TCL_OK;
    }
};

// tell the EXTERN macro we want to declare functions for export.
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT

EXTERN int
Slavedrv_test_Init (Tcl_Interp *interp)
{
#ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, "8.1", 0) == 0L) {
	return TCL_ERROR;
    }
#endif
    new Test1(interp);
    Tcl_PkgProvide(interp, "exptest", "1.0");
    return TCL_OK;
}


@


1.1.2.2
log
@Message class pulled-out to a seperate source file, due to expected growth in that area.
@
text
@a8 1
	NewTclCmd(interp, "test_passthru", TestPassThruCmd);
a29 20
	return TCL_OK;
    }
    // Test the full pass-thru
    //
    int TestPassThruCmd (int objc, struct Tcl_Obj * CONST objv[])
    {
	char **argvIn = new char * [objc-1];
	int i, argc;
	char *line, **argv;
	Tcl_Obj **oobjv;

	// Take the array and turn it into a string.
	for (i = objc-1; i > 0; i--) argvIn[i-1] = Tcl_GetString(objv[i]);
	line = BuildCommandLine(objc-1, argvIn);
	// Now take the string and turn it back into an array.
	SetArgv(line, &argc, &argv);
	delete [] line;
	oobjv = new Tcl_Obj * [argc];
	for (i = 0; i < argc; i++) oobjv[i] = Tcl_NewStringObj(argv[i], -1);
	Tcl_SetObjResult(interp, Tcl_NewListObj(argc, oobjv));
@


1.1.2.3
log
@minor lint.
@
text
@a5 2
    friend Tcl::Adapter<Test1>;

d7 1
a7 3
    Test1(Tcl_Interp *_interp)
	: Tcl::Adapter<Test1>(_interp)
    {
d10 5
a14 1
    }
d17 1
a17 2
    }

a32 1

a52 5

    virtual void DoCleanup () {
	// The adapter base class is telling us we are about to go away and it is
	// safe to use the interp pointer to do any needed cleanup.
    };
@


1.1.2.4
log
@these uncommitted edits have been sitting on my desktop for an eternity.

Adds some MS-DOS support but fails to deliver the required hooks to
succeed.
@
text
@d1 1
a1 1
#include "TclAdaptor.hpp"
d4 1
a4 1
class Test1 : protected Tcl::Adaptor<Test1>, ArgMaker
d6 1
a6 1
    friend Tcl::Adaptor<Test1>;
d10 1
a10 1
	: Tcl::Adaptor<Test1>(_interp)
d12 2
a13 2
	NewTclCmd("test_buildcmdline", TestCmdLineCmd);
	NewTclCmd("test_passthru", TestPassThruCmd);
@


