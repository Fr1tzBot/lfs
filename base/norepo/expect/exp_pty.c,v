head	5.38;
access;
symbols
	expect_5_45:5.38
	expect_6_branch:5.38.0.2
	expect_5_44_1_15:5.38
	activestate_win32_port_start:5.33
	telco-tec-win32-take2-branch:5.31.0.6
	telco-tec-win32-branch:5.31.0.4
	expect-sf418892-sf439042-branch:5.31.0.2
	tclpro-1-5-0:5.31
	tclpro-1-4-1:5.31
	tclpro-1-4-0:5.31
	expect-5-32-2:5.31
	expect-5-32-0:5.31
	ajuba-ajuba2-2-0:5.29.2.6
	scriptics-sc-2-0-b5:5.29.2.6
	scriptics-sc-2-0-fixed:5.29.2.6
	scriptics-sc-2-0-b2:5.29.2.6
	scriptics-sc-2-0-b1:5.29.2.6
	scriptics-sc-1-1:5.29.2.6
	scriptics-sc-1-1-b1:5.29.2.6
	scriptics-sc-1-1-branch:5.29.2.6.0.4
	scriptics-sc-1-1-base:5.29.2.6
	scriptics-sc-1-0:5.29.2.6
	scriptics-sc-1-0-branch:5.29.2.6.0.2
	scriptics-sc-1-0-base:5.29.2.6
	expect-5-31-3:5.29.2.6
	scriptics-bc-1-0-b1:5.29.2.5
	scriptics-tclpro-1-3-0:5.29.2.5
	scriptics-tclpro-1-3-b4:5.29.2.5
	scriptics-tclpro-1-3-b3:5.29.2.5
	expect-5-31:5.29.2.5
	expect-5-31-branch:5.29.0.2
	expect-5-31-base:5.29
	scriptics-tclpro-1-2:5.29
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.38
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.37;

5.37
date	2010.06.09.22.11.53;	author eee;	state Exp;
branches;
next	5.36;

5.36
date	2010.06.09.22.08.20;	author eee;	state Exp;
branches;
next	5.35;

5.35
date	2010.03.17.23.47.50;	author eee;	state Exp;
branches;
next	5.34;

5.34
date	2008.06.03.22.18.19;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2002.04.16.21.00.29;	author libes;	state Exp;
branches;
next	5.32;

5.32
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.31;

5.31
date	2000.02.19.21.29.43;	author libes;	state Exp;
branches
	5.31.4.1
	5.31.6.1;
next	5.30;

5.30
date	2000.01.06.23.22.04;	author wart;	state Exp;
branches;
next	5.29;

5.29
date	99.02.12.23.51.46;	author libes;	state Exp;
branches
	5.29.2.1;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches;
next	;

5.29.2.1
date	99.06.14.20.36.50;	author don;	state Exp;
branches;
next	5.29.2.2;

5.29.2.2
date	99.06.16.03.02.40;	author don;	state Exp;
branches;
next	5.29.2.3;

5.29.2.3
date	99.07.03.03.44.15;	author libes;	state Exp;
branches;
next	5.29.2.4;

5.29.2.4
date	99.07.07.19.49.30;	author libes;	state Exp;
branches;
next	5.29.2.5;

5.29.2.5
date	99.07.08.19.07.10;	author hershey;	state Exp;
branches;
next	5.29.2.6;

5.29.2.6
date	99.10.29.18.50.42;	author libes;	state Exp;
branches;
next	5.29.2.7;

5.29.2.7
date	99.12.04.06.18.24;	author libes;	state Exp;
branches;
next	;

5.31.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.31.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.38
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@/* exp_pty.c - generic routines to allocate and test ptys

Written by: Don Libes, NIST,  3/9/93

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include "expect_cf.h"
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_SYS_FCNTL_H
#  include <sys/fcntl.h>
#else
#  include <fcntl.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#include <signal.h>
#include <setjmp.h>
#include <sys/file.h>
#include "tcl.h"
#include "exp_int.h"
#include "expect_comm.h"
#include "exp_rename.h"
#include "exp_pty.h"

#include <errno.h>

#if 0
void expDiagLog();
void expDiagLogU();
void expDiagLogPtrSet();
#endif

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#ifdef O_NOCTTY
#define RDWR ((O_RDWR)|(O_NOCTTY))
#else
#define RDWR O_RDWR
#endif

static int locked = FALSE;
static char lock[] = "/tmp/ptylock.XXXX";	/* XX is replaced by pty id */
static char locksrc[50] = "/tmp/expect.pid"; /* pid is replaced by real pid */
	/* locksrc is used as the link source, i.e., something to link from */

static int i_read_errno;/* place to save errno, if i_read() == -1, so it
			   doesn't get overwritten before we get to read it */
#ifdef HAVE_SIGLONGJMP
static sigjmp_buf env;                /* for interruptable read() */
#else
static jmp_buf env;		/* for interruptable read() */
#endif  /* HAVE_SIGLONGJMP */

static int env_valid = FALSE;	/* whether we can longjmp or not */

/* sigalarm_handler and i_read are here just for supporting the sanity */
/* checking of pty slave devices.  I have only seen this happen on BSD */
/* systems, but it may need to be done to the other pty implementations */
/* as well. */

/* Note that this code is virtually replicated from other code in expect */
/* At some point, I'll dump one, but not until I'm satisfied no other */
/* changes are needed */

/*ARGSUSED*/
static RETSIGTYPE
sigalarm_handler(n)
int n;		/* unused, for compatibility with STDC */
{
#ifdef REARM_SIG
	signal(SIGALRM,sigalarm_handler);
#endif

	/* check env_valid first to protect us from the alarm occurring */
	/* in the window between i_read and alarm(0) */
#ifdef HAVE_SIGLONGJMP
	if (env_valid) siglongjmp(env,1);
#else
	if (env_valid) longjmp(env,1);
#endif  /* HAVE_SIGLONGJMP */
}

/* interruptable read */
static int
i_read(fd,buffer,length,timeout)
int fd;
char *buffer;
int length;
int timeout;
{
	int cc = -2;

	/* since setjmp insists on returning 1 upon longjmp(,0), */
	/* longjmp(,2) instead. */

	/* restart read if setjmp returns 0 (first time) or 2. */
	/* abort if setjmp returns 1. */

	alarm(timeout);

#ifdef HAVE_SIGLONGJMP
	if (1 != sigsetjmp(env,1)) {
#else
	if (1 != setjmp(env)) {
#endif  /* HAVE_SIGLONGJMP */
		env_valid = TRUE;
		cc = read(fd,buffer,length);
	}
	env_valid = FALSE;
	i_read_errno = errno;	/* errno can be overwritten by the */
				/* time we return */
	alarm(0);
	return(cc);
}

static RETSIGTYPE (*oldAlarmHandler)();
static RETSIGTYPE (*oldHupHandler)();
static time_t current_time;	/* time when testing began */

/* if TRUE, begin testing, else end testing */
/* returns -1 for failure, 0 for success */
int
exp_pty_test_start()
{
	int lfd;	/* locksrc file descriptor */

	oldAlarmHandler = signal(SIGALRM,sigalarm_handler);
#ifndef O_NOCTTY
	/* Ignore hangup signals generated by pty testing */
	/* when running in background with no control tty. */
	/* Very few systems don't define O_NOCTTY.  Only one */
	/* I know of is Next. */
	oldAlarmHandler = signal(SIGHUP,SIG_IGN);
#endif

	time(&current_time);

	/* recreate locksrc to prevent locks from 'looking old', so */
	/* that they are not deleted (later on in this code) */
	sprintf(locksrc,"/tmp/expect.%d",getpid());
	(void) unlink(locksrc);
	/* stanislav shalunov <shalunov@@mccme.ru> notes that creat allows */
	/* race - someone could link to important file which root could then */
	/* smash. */
/*	if (-1 == (lfd = creat(locksrc,0777))) { */
       if (-1 == (lfd = open(locksrc,O_RDWR|O_CREAT|O_EXCL,0777))) {
		static char buf[256];
		exp_pty_error = buf;
		sprintf(exp_pty_error,"can't create %s, errno = %d\n",locksrc, errno);
		return(-1);
	}
	close(lfd);
	return 0;
}

void
exp_pty_test_end()
{
	signal(SIGALRM,oldAlarmHandler);
#ifndef O_NOCTTY
	signal(SIGALRM,oldHupHandler);
#endif
	(void) unlink(locksrc);
}

/* returns non-negative if successful */
int
exp_pty_test(
     char *master_name,
     char *slave_name,
     char bank,
     char *num)	/* string representation of number */
{
	int master, slave;
	int cc;
	char c;

	/* make a lock file to prevent others (for now only */
	/* expects) from allocating pty while we are playing */
	/* with it.  This allows us to rigorously test the */
	/* pty is usable. */
	if (exp_pty_lock(bank,num) == 0) {
		expDiagLogPtrStr("pty master (%s) is locked...skipping\r\n",master_name);
		return(-1);
	}
	/* verify no one else is using slave by attempting */
	/* to read eof from master side */
	if (0 > (master = open(master_name,RDWR))) return(-1);

#ifdef __QNX__

	/* QNX ptys don't have a lot of the same properties such as
           read 0 at EOF, etc */
	/* if 1 should pacify C compiler without using nested ifdefs */
 	if (1) return master;
#endif

#ifdef HAVE_PTYTRAP
	if (access(slave_name, R_OK|W_OK) != 0) {
		expDiagLogPtrStr("could not open slave for pty master (%s)...skipping\r\n",
			master_name);
		(void) close(master);
		return -1;
	}
	return(master);
#else
	if (0 > (slave = open(slave_name,RDWR))) {
		(void) close(master);
		return -1;
	}
	(void) close(slave);
	cc = i_read(master,&c,1,10);
	(void) close(master);
	if (!(cc == 0 || cc == -1)) {
		expDiagLogPtrStr("%s slave open, skipping\r\n",slave_name);
		locked = FALSE;	/* leave lock file around so Expect's avoid */
				/* retrying this pty for near future */
		return -1;
	}

	/* verify no one else is using master by attempting */
	/* to read eof from slave side */
	if (0 > (master = open(master_name,RDWR))) return(-1);
	if (0 > (slave = open(slave_name,RDWR))) {
		(void) close(master);
		return -1;
	}
	(void) close(master);
	cc = i_read(slave,&c,1,10);
	(void) close(slave);
	if (!(cc == 0 || cc == -1)) {
		expDiagLogPtrStr("%s master open, skipping\r\n",master_name);
		return -1;
	}

	/* seems ok, let's use it */
	expDiagLogPtrStr("using master pty %s\n",master_name);
	return(open(master_name,RDWR));
#endif
}

void
exp_pty_unlock(void)
{
	if (locked) {
		(void) unlink(lock);
		locked = FALSE;
	}
}

/* returns 1 if successfully locked, 0 otherwise */
int
exp_pty_lock(
     char bank,
     char *num)	/* string representation of number */
{
	struct stat statbuf;

	if (locked) {
		unlink(lock);
		locked = FALSE;
	}

	sprintf(lock,"/tmp/ptylock.%c%s",bank,num);

	if ((0 == stat(lock,&statbuf)) &&
	    (statbuf.st_mtime+3600 < current_time)) {
		(void) unlink(lock);
	}

	if (-1 == (link(locksrc,lock))) locked = FALSE;
	else locked = TRUE;

	return locked;
}

/* 
 * expDiagLog needs a different definition, depending on whether its
 * called inside of Expect or the clib.  Allow it to be set using this
 * function.  It's done here because this file (and pty_XXX.c) are the 
 * ones that call expDiagLog from the two different environments.
 */

static void		(*expDiagLogPtrVal) _ANSI_ARGS_((char *));

void
expDiagLogPtrSet(fn)
     void (*fn) _ANSI_ARGS_((char *));
{
  expDiagLogPtrVal = fn;
}

void
expDiagLogPtr(str)
     char *str;
{
  (*expDiagLogPtrVal)(str);
}



void
expDiagLogPtrX(fmt,num)
     char *fmt;
     int num;
{
  static char buf[1000];
  sprintf(buf,fmt,num);
  (*expDiagLogPtrVal)(buf);
}


void
expDiagLogPtrStr(fmt,str1)
     char *fmt;
     char *str1;
{
  static char buf[1000];
  sprintf(buf,fmt,str1);
  (*expDiagLogPtrVal)(buf);
}

void
expDiagLogPtrStrStr(fmt,str1,str2)
     char *fmt;
     char *str1, *str2;
{
  static char buf[1000];
  sprintf(buf,fmt,str1,str2);
  (*expDiagLogPtrVal)(buf);
}

static char *		(*expErrnoMsgVal) _ANSI_ARGS_((int));

char *
expErrnoMsg(errorNo)
int errorNo;
{
  return (*expErrnoMsgVal)(errorNo);
}

void
expErrnoMsgSet(fn)
     char * (*fn) _ANSI_ARGS_((int));
{
  expErrnoMsgVal = fn;
}
@


5.37
log
@Change to how <fcntl.h> is included.
@
text
@d15 5
a21 1
#include <fcntl.h>
d88 2
a89 1
sigalarm_handler(int n)
d106 5
a110 1
i_read( int fd, char *buffer, int length, int timeout)
d144 1
a144 1
exp_pty_test_start(void)
d178 1
a178 1
exp_pty_test_end(void)
d305 1
a305 1
static void		(*expDiagLogPtrVal) (char *);
d308 2
a309 1
expDiagLogPtrSet( void (*fn) (char *))
d315 2
a316 1
expDiagLogPtr( char *str)
d321 2
d324 3
a326 1
expDiagLogPtrX( char *fmt, int num)
d335 3
a337 1
expDiagLogPtrStr( char *fmt, char *str1)
d345 3
a347 1
expDiagLogPtrStrStr( char *fmt, char *str1, char *str2)
d354 1
a354 1
static char *		(*expErrnoMsgVal) (int);
d357 2
a358 1
expErrnoMsg( int errorNo)
d364 2
a365 1
expErrnoMsgSet( char * (*fn) (int))
@


5.36
log
@ANSIfication changes.
@
text
@a14 4
#ifdef HAVE_SYS_FCNTL_H
#  include <sys/fcntl.h>
#else
#endif
@


5.35
log
@ANSIfication changes
@
text
@a17 1
#  include <fcntl.h>
d21 1
@


5.34
log
@
	* exp_pty.c: Minimal ansification of function definitions to match
	  them to their prototypes where promoted types are otherwise
	  causing a mismatch for some compilers, like AIX in 64bit mode.
	* configure.in: Bumped version to 5.44.1.8.
	* configure: Regen'd, autoconf 2.59.
@
text
@d88 1
a88 2
sigalarm_handler(n)
int n;		/* unused, for compatibility with STDC */
d105 1
a105 5
i_read(fd,buffer,length,timeout)
int fd;
char *buffer;
int length;
int timeout;
d139 1
a139 1
exp_pty_test_start()
d173 1
a173 1
exp_pty_test_end()
d300 1
a300 1
static void		(*expDiagLogPtrVal) _ANSI_ARGS_((char *));
d303 1
a303 2
expDiagLogPtrSet(fn)
     void (*fn) _ANSI_ARGS_((char *));
d309 1
a309 2
expDiagLogPtr(str)
     char *str;
a313 2


d315 1
a315 3
expDiagLogPtrX(fmt,num)
     char *fmt;
     int num;
d324 1
a324 3
expDiagLogPtrStr(fmt,str1)
     char *fmt;
     char *str1;
d332 1
a332 3
expDiagLogPtrStrStr(fmt,str1,str2)
     char *fmt;
     char *str1, *str2;
d339 1
a339 1
static char *		(*expErrnoMsgVal) _ANSI_ARGS_((int));
d342 1
a342 2
expErrnoMsg(errorNo)
int errorNo;
d348 1
a348 2
expErrnoMsgSet(fn)
     char * (*fn) _ANSI_ARGS_((int));
@


5.33
log
@misc updates
@
text
@d189 5
a193 5
exp_pty_test(master_name,slave_name,bank,num)
char *master_name;
char *slave_name;
char bank;
char *num;	/* string representation of number */
d264 1
a264 1
exp_pty_unlock()
d274 3
a276 3
exp_pty_lock(bank,num)
char bank;
char *num;	/* string representation of number */
@


5.32
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d305 1
a305 1
static void		(*expDiagLogPtrVal) _ANSI_ARGS_((CONST char *));
d309 1
a309 1
     void (*fn) _ANSI_ARGS_((CONST char *));
d354 1
a354 1
static CONST char *		(*expErrnoMsgVal) _ANSI_ARGS_((int));
d356 1
a356 1
CONST char *
d365 1
a365 1
     CONST char * (*fn) _ANSI_ARGS_((int));
@


5.31
log
@Fixed errors for SCO pty allocation.  Could also affect certain other
systems that make thousands of simultaneous pty allocations.

Fixed HP shared lib config prob.
@
text
@d305 1
a305 1
static void		(*expDiagLogPtrVal) _ANSI_ARGS_((char *));
d309 1
a309 1
     void (*fn) _ANSI_ARGS_((char *));
d354 1
a354 1
static char *		(*expErrnoMsgVal) _ANSI_ARGS_((int));
d356 1
a356 1
char *
d365 1
a365 1
     char * (*fn) _ANSI_ARGS_((int));
@


5.31.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.31.4.1
log
@Top-level source files removed.
@
text
@@


5.30
log
@Merge of expect5-31-branch to mainline
@
text
@d192 1
a192 1
int bank;
d275 1
a275 1
int bank;
@


5.29
log
@numerous edits - getting synchronized (first time I've used CVS), see
HISTORY file for more info
@
text
@d37 2
a38 1
#define EXP_AVOID_INCLUDING_TCL_H 1
d45 5
a49 1
void debuglog();
d69 3
d73 2
d97 3
d101 1
d122 3
d126 1
d204 1
a204 1
		debuglog("pty master (%s) is locked...skipping\r\n",master_name);
d221 1
a221 1
		debuglog("could not open slave for pty master (%s)...skipping\r\n",
d236 1
a236 1
		debuglog("%s slave open, skipping\r\n",slave_name);
d253 1
a253 1
		debuglog("%s master open, skipping\r\n",master_name);
d258 1
a258 1
	debuglog("using master pty %s\n",master_name);
d298 71
@


5.29.2.1
log
@fixed Log/Diag and ExpectCmd
@
text
@d44 1
a44 2
void expDiagLog();
void expDiagLogU();
d186 1
a186 1
		expDiagLog("pty master (%s) is locked...skipping\r\n",master_name);
d203 1
a203 1
		expDiagLog("could not open slave for pty master (%s)...skipping\r\n",
d218 1
a218 1
		expDiagLog("%s slave open, skipping\r\n",slave_name);
d235 1
a235 1
		expDiagLog("%s master open, skipping\r\n",master_name);
d240 1
a240 1
	expDiagLog("using master pty %s\n",master_name);
@


5.29.2.2
log
@compiled!
@
text
@d37 1
a37 1
#include "tcl.h"
@


5.29.2.3
log
@Fixed Expect's standalone C library and examples.  This required some
changes to Expect since it and the library share some things.
@
text
@a37 1
#include "exp_int.h"
a43 1
#if 0
a45 2
void expDiagLogPtrSet();
#endif
d187 1
a187 1
		expDiagLogPtrStr("pty master (%s) is locked...skipping\r\n",master_name);
d204 1
a204 1
		expDiagLogPtrStr("could not open slave for pty master (%s)...skipping\r\n",
d219 1
a219 1
		expDiagLogPtrStr("%s slave open, skipping\r\n",slave_name);
d236 1
a236 1
		expDiagLogPtrStr("%s master open, skipping\r\n",master_name);
d241 1
a241 1
	expDiagLogPtrStr("using master pty %s\n",master_name);
a280 55
/* 
 * expDiagLog needs a different definition, depending on whether its
 * called inside of Expect or the clib.  Allow it to be set using this
 * function.  It's done here because this file (and pty_XXX.c) are the 
 * ones that call expDiagLog from the two different environments.
 */

void		(*expDiagLogPtrVal) _ANSI_ARGS_((char *));

void
expDiagLogPtrSet(arg)
     void (*arg)(char *);
{
  expDiagLogPtrVal = arg;
}

void
expDiagLogPtr(str)
     char *str;
{
  (*expDiagLogPtrVal)(str);
}



void
expDiagLogPtrX(fmt,num)
     char *fmt;
     int num;
{
  static char buf[1000];
  sprintf(buf,fmt,num);
  (*expDiagLogPtrVal)(buf);
}


void
expDiagLogPtrStr(fmt,str1)
     char *fmt;
     char *str1;
{
  static char buf[1000];
  sprintf(buf,fmt,str1);
  (*expDiagLogPtrVal)(buf);
}

void
expDiagLogPtrStrStr(fmt,str1,str2)
     char *fmt;
     char *str1, *str2;
{
  static char buf[1000];
  sprintf(buf,fmt,str1,str2);
  (*expDiagLogPtrVal)(buf);
}
@


5.29.2.4
log
@Resolved link problem with Tcl_ErrnoMsg and TclRegError.

The problem was that exp_clib.c provides substitute definitions for
some of the Tcl functions when the Tcl library is absent.  (The
library is not used with exp_clib.)  In order for the other functions
in the Expect library (that work with either Tcl/Expect or exp_clib),
they had to be turned into function pointers.
@
text
@d292 1
a292 1
static void		(*expDiagLogPtrVal) _ANSI_ARGS_((char *));
d295 2
a296 2
expDiagLogPtrSet(fn)
     void (*fn)(char *);
d298 1
a298 1
  expDiagLogPtrVal = fn;
a338 16
}

static char *		(*expErrnoMsgVal) _ANSI_ARGS_((int));

char *
expErrnoMsg(errno)
int errno;
{
  return (*expErrnoMsgVal)(errno);
}

void
expErrnoMsgSet(fn)
     char * (*fn)(int);
{
  expErrnoMsgVal = fn;
@


5.29.2.5
log
@changed "errno" parameter to expErrnoMsg function to be called "errorNo".
This change was required on Linux because "errno" is #defined in the errno.h
library (included in the exp_pty.c file).
@
text
@d344 2
a345 2
expErrnoMsg(errorNo)
int errorNo;
d347 1
a347 1
  return (*expErrnoMsgVal)(errorNo);
@


5.29.2.6
log
@Fixes for picky HP compiler.
@
text
@d296 1
a296 1
     void (*fn) _ANSI_ARGS_((char *));
d352 1
a352 1
     char * (*fn) _ANSI_ARGS_((int));
@


5.29.2.7
log
@Fixes to library.
Testing new fix to system command.
@
text
@a68 3
#ifdef HAVE_SIGLONGJMP
static sigjmp_buf env;                /* for interruptable read() */
#else
a69 2
#endif  /* HAVE_SIGLONGJMP */

a91 3
#ifdef HAVE_SIGLONGJMP
	if (env_valid) siglongjmp(env,1);
#else
a92 1
#endif  /* HAVE_SIGLONGJMP */
a112 3
#ifdef HAVE_SIGLONGJMP
	if (1 != sigsetjmp(env,1)) {
#else
a113 1
#endif  /* HAVE_SIGLONGJMP */
@


5.28
log
@Initial revision
@
text
@d145 5
a149 1
	if (-1 == (lfd = creat(locksrc,0777))) {
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@
