head	1.1;
access;
symbols
	win32-jump-point-1:1.1.4.1
	telco-tec-win32-take2-branch:1.1.0.4
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2001.11.07.10.00.25;	author davygrvy;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2001.11.07.10.00.25;	author davygrvy;	state Exp;
branches;
next	;

1.1.4.1
date	2001.11.22.22.44.38;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file CMclKernel.cpp was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.4.1
log
@Merged Mcl into the take2 branch
@
text
@a0 60
//
// FILE: CMclKernel.cpp
//
// Copyright (c) 1997 by Aaron Michael Cohen
//
/////////////////////////////////////////////////////////////////////////

#include "CMclKernel.h"
#include "CMclAutoPtr.h"

CMclKernel::CMclKernel() {
    m_hHandle = NULL;
    m_dwStatus = ERROR_INVALID_HANDLE;
}

CMclKernel::~CMclKernel() {
    if (CMclIsValidHandle(m_hHandle)) {
        ::CloseHandle(m_hHandle);
        m_hHandle = NULL;
    }
}

void CMclKernel::ThrowError( DWORD dwStatus) {
    CMclThrowError(dwStatus);
}

DWORD CMclKernel::Status(void) const {
    return m_dwStatus;
}

DWORD CMclKernel::Wait( DWORD dwMilliseconds) {
    return ::WaitForSingleObject( m_hHandle, dwMilliseconds);
}

// wait on the current object and one other...    
DWORD CMclKernel::WaitForTwo( CMclWaitableObject &rCMclWaitableObject, BOOL bWaitAll, DWORD dwMilliseconds) {
    HANDLE handles[2];

    // the current object...
    handles[0] = m_hHandle;

    // the parameter object...
    handles[1] = rCMclWaitableObject.GetHandle();

    // wait for the objects...
    return ::WaitForMultipleObjects( 2, handles, bWaitAll, dwMilliseconds);
}

HANDLE CMclKernel::GetHandle(void) const {
    if (this != NULL)
        return m_hHandle;
    else
        return NULL;
}

CMclKernel::operator HANDLE() const {
    return GetHandle();
}


@


1.1.2.1
log
@"Mcl" multithreading C++ class library added
@
text
@a0 60
//
// FILE: CMclKernel.cpp
//
// Copyright (c) 1997 by Aaron Michael Cohen
//
/////////////////////////////////////////////////////////////////////////

#include "CMclKernel.h"
#include "CMclAutoPtr.h"

CMclKernel::CMclKernel() {
    m_hHandle = NULL;
    m_dwStatus = ERROR_INVALID_HANDLE;
}

CMclKernel::~CMclKernel() {
    if (CMclIsValidHandle(m_hHandle)) {
        ::CloseHandle(m_hHandle);
        m_hHandle = NULL;
    }
}

void CMclKernel::ThrowError( DWORD dwStatus) {
    CMclThrowError(dwStatus);
}

DWORD CMclKernel::Status(void) const {
    return m_dwStatus;
}

DWORD CMclKernel::Wait( DWORD dwMilliseconds) {
    return ::WaitForSingleObject( m_hHandle, dwMilliseconds);
}

// wait on the current object and one other...    
DWORD CMclKernel::WaitForTwo( CMclWaitableObject &rCMclWaitableObject, BOOL bWaitAll, DWORD dwMilliseconds) {
    HANDLE handles[2];

    // the current object...
    handles[0] = m_hHandle;

    // the parameter object...
    handles[1] = rCMclWaitableObject.GetHandle();

    // wait for the objects...
    return ::WaitForMultipleObjects( 2, handles, bWaitAll, dwMilliseconds);
}

HANDLE CMclKernel::GetHandle(void) const {
    if (this != NULL)
        return m_hHandle;
    else
        return NULL;
}

CMclKernel::operator HANDLE() const {
    return GetHandle();
}


@

