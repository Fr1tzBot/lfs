head	5.46;
access;
symbols
	expect_5_45:5.46
	expect_6_branch:5.45.0.2
	expect_5_44_1_15:5.45
	activestate_win32_port_start:5.33
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.19
	scriptics-sc-2-0-b5:5.28.1.1.2.19
	scriptics-sc-2-0-fixed:5.28.1.1.2.19
	scriptics-sc-2-0-b2:5.28.1.1.2.19
	scriptics-sc-2-0-b1:5.28.1.1.2.19
	scriptics-sc-1-1:5.28.1.1.2.19
	scriptics-sc-1-1-b1:5.28.1.1.2.19
	scriptics-sc-1-1-branch:5.28.1.1.2.19.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.19
	scriptics-sc-1-0:5.28.1.1.2.19
	scriptics-sc-1-0-branch:5.28.1.1.2.19.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.19
	expect-5-31-3:5.28.1.1.2.19
	scriptics-bc-1-0-b1:5.28.1.1.2.18
	scriptics-tclpro-1-3-0:5.28.1.1.2.18
	scriptics-tclpro-1-3-b4:5.28.1.1.2.18
	scriptics-tclpro-1-3-b3:5.28.1.1.2.18
	expect-5-31:5.28.1.1.2.18
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.46
date	2010.08.31.22.20.27;	author andreas_kupries;	state Exp;
branches;
next	5.45;

5.45
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.44;

5.44
date	2010.03.17.23.47.50;	author eee;	state Exp;
branches;
next	5.43;

5.43
date	2010.03.11.21.55.37;	author eee;	state Exp;
branches;
next	5.42;

5.42
date	2008.04.03.19.19.41;	author andreas_kupries;	state Exp;
branches;
next	5.41;

5.41
date	2008.04.03.19.07.14;	author andreas_kupries;	state Exp;
branches;
next	5.40;

5.40
date	2007.09.24.18.34.13;	author andreas_kupries;	state Exp;
branches;
next	5.39;

5.39
date	2007.07.11.21.35.08;	author andreas_kupries;	state Exp;
branches;
next	5.38;

5.38
date	2007.07.11.20.07.23;	author andreas_kupries;	state Exp;
branches;
next	5.37;

5.37
date	2005.01.21.23.17.12;	author andreas_kupries;	state Exp;
branches;
next	5.36;

5.36
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.35;

5.35
date	2004.05.19.17.33.36;	author andreas_kupries;	state Exp;
branches;
next	5.34;

5.34
date	2003.09.05.19.01.56;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2002.02.07.23.46.49;	author andreas_kupries;	state Exp;
branches;
next	5.32;

5.32
date	2002.01.16.18.14.04;	author andreas_kupries;	state Exp;
branches;
next	5.31;

5.31
date	2001.12.05.20.34.17;	author andreas_kupries;	state Exp;
branches;
next	5.30;

5.30
date	2001.11.09.19.36.18;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.03;	author wart;	state Exp;
branches
	5.29.2.1
	5.29.4.1
	5.29.6.1;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.10.22.01.43;	author don;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.11.02.10.19;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.11.20.11.49;	author don;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.06.12.01.44.17;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.5;

5.28.1.1.2.5
date	99.06.14.20.36.48;	author don;	state Exp;
branches;
next	5.28.1.1.2.6;

5.28.1.1.2.6
date	99.06.14.23.54.05;	author don;	state Exp;
branches;
next	5.28.1.1.2.7;

5.28.1.1.2.7
date	99.06.15.10.02.36;	author don;	state Exp;
branches;
next	5.28.1.1.2.8;

5.28.1.1.2.8
date	99.06.15.19.11.57;	author don;	state Exp;
branches;
next	5.28.1.1.2.9;

5.28.1.1.2.9
date	99.06.15.20.40.46;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.10;

5.28.1.1.2.10
date	99.06.15.21.09.57;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.11;

5.28.1.1.2.11
date	99.06.15.21.16.25;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.12;

5.28.1.1.2.12
date	99.06.16.03.02.37;	author don;	state Exp;
branches;
next	5.28.1.1.2.13;

5.28.1.1.2.13
date	99.06.16.08.15.59;	author don;	state Exp;
branches;
next	5.28.1.1.2.14;

5.28.1.1.2.14
date	99.06.18.01.41.50;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.15;

5.28.1.1.2.15
date	99.06.20.06.32.19;	author libes;	state Exp;
branches;
next	5.28.1.1.2.16;

5.28.1.1.2.16
date	99.06.22.05.03.30;	author libes;	state Exp;
branches;
next	5.28.1.1.2.17;

5.28.1.1.2.17
date	99.06.23.17.25.17;	author libes;	state Exp;
branches;
next	5.28.1.1.2.18;

5.28.1.1.2.18
date	99.06.28.06.29.25;	author libes;	state Exp;
branches;
next	5.28.1.1.2.19;

5.28.1.1.2.19
date	99.10.06.05.54.17;	author libes;	state Exp;
branches;
next	5.28.1.1.2.20;

5.28.1.1.2.20
date	99.12.04.06.18.24;	author libes;	state Exp;
branches;
next	;

5.29.2.1
date	2001.11.09.19.40.02;	author andreas_kupries;	state Exp;
branches;
next	5.29.2.2;

5.29.2.2
date	2001.12.05.20.36.50;	author andreas_kupries;	state Exp;
branches;
next	5.29.2.3;

5.29.2.3
date	2002.01.16.18.16.53;	author andreas_kupries;	state Exp;
branches;
next	5.29.2.4;

5.29.2.4
date	2002.02.07.23.46.00;	author andreas_kupries;	state Exp;
branches;
next	;

5.29.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.29.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.46
log
@
	* Various cleanups, local patches of ActiveState.
	* exp_clib.c: Remove local copy of Tcl_ErrnoMsg().
	* exp_inter.c: Hack access to TCL_REG_BOSONLY when not present,
	became private with Tcl 8.5 and higher.
	* expect.h: Remove the local fiddling with the memory allocation
	and panic macros.
@
text
@/* interact (using select) - give user keyboard control

Written by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include "expect_cf.h"
#include <stdio.h>
#ifdef HAVE_INTTYPES_H
#  include <inttypes.h>
#endif
#include <sys/types.h>
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
  
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#include <ctype.h>

#include "tclInt.h"
#include "string.h"

#include "exp_tty_in.h"
#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"
#include "exp_log.h"
#include "exp_event.h" /* exp_get_next_event decl */

/* Tcl 8.5+ moved this internal - needed for when I compile expect against 8.5. */
#ifndef TCL_REG_BOSONLY
#define TCL_REG_BOSONLY 002000
#endif

typedef struct ThreadSpecificData {
    Tcl_Obj *cmdObjReturn;
    Tcl_Obj *cmdObjInterpreter;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

#define INTER_OUT "interact_out"
#define out(var,val) \
 expDiagLog("interact: set %s(%s) ",INTER_OUT,var); \
 expDiagLogU(expPrintify(val)); \
 expDiagLogU("\"\r\n"); \
 Tcl_SetVar2(interp,INTER_OUT,var,val,0);

/*
 * tests if we are running this using a real tty
 *
 * these tests are currently only used to control what gets written to the
 * logfile.  Note that removal of the test of "..._is_tty" means that stdin
 * or stdout could be redirected and yet stdout would still be logged.
 * However, it's not clear why anyone would use log_file when these are
 * redirected in the first place.  On the other hand, it is reasonable to
 * run expect as a daemon in which case, stdin/out do not appear to be
 * ttys, yet it makes sense for them to be logged with log_file as if they
 * were.
 */
#if 0
#define real_tty_output(x) (exp_stdout_is_tty && (((x)==1) || ((x)==exp_dev_tty)))
#define real_tty_input(x) (exp_stdin_is_tty && (((x)==0) || ((x)==exp_dev_tty)))
#endif

#define real_tty_output(x) ((x->fdout == 1) || (expDevttyIs(x)))
#define real_tty_input(x) (exp_stdin_is_tty && ((x->fdin==0) || (expDevttyIs(x))))

#define new(x)	(x *)ckalloc(sizeof(x))

struct action {
	Tcl_Obj *statement;
	int tty_reset;		/* if true, reset tty mode upon action */
	int iread;		/* if true, reread indirects */
	int iwrite;		/* if true, write spawn_id element */
	struct action *next;	/* chain only for later for freeing */
};

struct keymap {
	Tcl_Obj *keys;	/* original pattern provided by user */
	int re;		/* true if looking to match a regexp. */
	int null;	/* true if looking to match 0 byte */
	int case_sensitive;
	int echo;	/* if keystrokes should be echoed */
	int writethru;	/* if keystrokes should go through to process */
	int indices;	/* true if should write indices */
	struct action action;
	struct keymap *next;
};

struct output {
	struct exp_i *i_list;
	struct action *action_eof;
	struct output *next;
};

struct input {
	struct exp_i *i_list;
	struct output *output;
	struct action *action_eof;
	struct action *action_timeout;
	struct keymap *keymap;
	int timeout_nominal;		/* timeout nominal */
	int timeout_remaining;		/* timeout remaining */
	struct input *next;
};

/*
 * Once we are handed an ExpState from the event handler, we can figure out
 * which "struct input *" it references by using expStateToInput.  This has is
 * populated by expCreateStateToInput.
 */

struct input *
expStateToInput(
    Tcl_HashTable *hash,
    ExpState *esPtr)
{
    Tcl_HashEntry *entry = Tcl_FindHashEntry(hash,(char *)esPtr);

    if (!entry) {
	/* should never happen */
	return 0;
    }
    return ((struct input *)Tcl_GetHashValue(entry));
}

void
expCreateStateToInput(
    Tcl_HashTable *hash,
    ExpState *esPtr,
    struct input *inp)
{
    Tcl_HashEntry *entry;
    int newPtr;

    entry = Tcl_CreateHashEntry(hash,(char *)esPtr,&newPtr);
    Tcl_SetHashValue(entry,(ClientData)inp);
}

static void free_input(Tcl_Interp *interp, struct input *i);
static void free_keymap(struct keymap *km);
static void free_output(Tcl_Interp *interp, struct output *o);
static void free_action(struct action *a);
static struct action *new_action(struct action **base);
static int inter_eval(
    Tcl_Interp *interp,
    struct action *action,
    ExpState *esPtr);

/* intMatch() accepts user keystrokes and returns one of MATCH,
CANMATCH, or CANTMATCH.  These describe whether the keystrokes match a
key sequence, and could or can't if more characters arrive.  The
function assigns a matching keymap if there is a match or can-match.
A matching keymap is assigned on can-match so we know whether to echo
or not.

intMatch is optimized (if you can call it that) towards a small
number of key mappings, but still works well for large maps, since no
function calls are made, and we stop as soon as there is a single-char
mismatch, and go on to the next one.  A hash table or compiled DFA
probably would not buy very much here for most maps.

The basic idea of how this works is it does a smart sequential search.
At each position of the input string, we attempt to match each of the
keymaps.  If at least one matches, the first match is returned.

If there is a CANMATCH and there are more keymaps to try, we continue
trying.  If there are no more keymaps to try, we stop trying and
return with an indication of the first keymap that can match.

Note that I've hacked up the regexp pattern matcher in two ways.  One
is to force the pattern to always be anchored at the front.  That way,
it doesn't waste time attempting to match later in the string (before
we're ready).  The other is to return can-match.

*/

static int
intMatch(
    ExpState *esPtr,
    struct keymap *keymap,	/* linked list of keymaps */
    struct keymap **km_match,	/* keymap that matches or can match */
    int *matchLen,		/* # of bytes that matched */
    int *skip,			/* # of chars to skip */
    Tcl_RegExpInfo *info)
{
    Tcl_UniChar *string;
    struct keymap *km;
    char *ks;		/* string from a keymap */

    Tcl_UniChar *start_search;	/* where in string to start searching */
    int offset;		/* # of chars from string to start searching */

    Tcl_UniChar *string_end;
    int numchars;
    int rm_nulls;		/* skip nulls if true */
    Tcl_UniChar ch;

    string   = esPtr->input.buffer;
    numchars = esPtr->input.use; /* Actually #chars */

    /* assert (*km == 0) */

    /* a shortcut that should help master output which typically */
    /* is lengthy and has no key maps.  Otherwise it would mindlessly */
    /* iterate on each character anyway. */
    if (!keymap) {
	*skip = numchars;
	return(EXP_CANTMATCH);
    }

    rm_nulls = esPtr->rm_nulls;

    string_end = string + numchars;

    /*
     * Maintain both a character index and a string pointer so we
     * can easily index into either the UTF or the Unicode representations.
     */

    for (start_search = string, offset = 0;
	 start_search < string_end;
	 start_search ++, offset++) {

	ch = *start_search;
	
	if (*km_match) break; /* if we've already found a CANMATCH */
			/* don't bother starting search from positions */
			/* further along the string */

	for (km=keymap;km;km=km->next) {
	    Tcl_UniChar *s;	/* current character being examined */

	    if (km->null) {
		if (ch == 0) {
		    *skip = start_search-string;
		    *matchLen = 1;	/* s - start_search == 1 */
		    *km_match = km;
		    return(EXP_MATCH);
	        }
	    } else if (!km->re) {
		int kslen;
		Tcl_UniChar sch, ksch;
		
		/* fixed string */

		ks = Tcl_GetString(km->keys);
		for (s = start_search;; s++, ks += kslen) {
		    /* if we hit the end of this map, must've matched! */
		    if (*ks == 0) {
			*skip = start_search-string;
			*matchLen = s-start_search;
			*km_match = km;
			return(EXP_MATCH);
		    }

		    /* if we ran out of user-supplied characters, and */
		    /* still haven't matched, it might match if the user */
		    /* supplies more characters next time */

		    if (s == string_end) {
			/* skip to next key entry, but remember */
			/* possibility that this entry might match */
			if (!*km_match) *km_match = km;
			break;
		    }

		    sch = *s;
		    kslen = Tcl_UtfToUniChar(ks, &ksch);
		    
		    if (sch == ksch) continue;
		    if ((sch == '\0') && rm_nulls) {
			kslen = 0;
			continue;
		    }
		    break;
		}
	    } else {
		/* regexp */
		Tcl_RegExp re;
		int flags;
		int result;
		Tcl_Obj* buf;

		re = Tcl_GetRegExpFromObj(NULL, km->keys,
			TCL_REG_ADVANCED|TCL_REG_BOSONLY|TCL_REG_CANMATCH);
		flags = (offset > 0) ? TCL_REG_NOTBOL : 0;

		/* ZZZ: Future optimization: Avoid copying */
		buf = Tcl_NewUnicodeObj (esPtr->input.buffer, esPtr->input.use);
		Tcl_IncrRefCount (buf);
		result = Tcl_RegExpExecObj(NULL, re, buf, offset,
			-1 /* nmatches */, flags);
		Tcl_DecrRefCount (buf);
		if (result > 0) {
		    *km_match = km;
		    *skip = start_search-string;
		    Tcl_RegExpGetInfo(re, info);
		    *matchLen = info->matches[0].end;
		    return EXP_MATCH;
		} else if (result == 0) {
		    Tcl_RegExpGetInfo(re, info);

		    /*
		     * Check to see if there was a partial match starting
		     * at the current character.
		     */
		    if (info->extendStart == 0) {
			if (!*km_match) *km_match = km;
		    }
		}		    
	    }
	}
    }

    if (*km_match) {
	/* report CANMATCH for -re and -ex */

	/*
	 * since canmatch is only detected after we've advanced too far,
	 * adjust start_search back to make other computations simpler
	 */
	start_search--;

	*skip = start_search - string;
	*matchLen = string_end - start_search;
	return(EXP_CANMATCH);
    }
    
    *skip = start_search-string;
    return(EXP_CANTMATCH);
}

/* put regexp result in variables */
static void
intRegExpMatchProcess(
    Tcl_Interp *interp,
    ExpState *esPtr,
    struct keymap *km,	/* ptr for above while parsing */
    Tcl_RegExpInfo *info,
    int offset)
{
    char name[20], value[20];
    int i;
    Tcl_Obj* buf = Tcl_NewUnicodeObj (esPtr->input.buffer,esPtr->input.use);

    for (i=0;i<=info->nsubs;i++) {
	int start, end;
	Tcl_Obj *val;

	start = info->matches[i].start + offset;
	if (start == -1) continue;
	end = (info->matches[i].end-1) + offset;

	if (km->indices) {
	    /* start index */
	    sprintf(name,"%d,start",i);
	    sprintf(value,"%d",start);
	    out(name,value);
		    
	    /* end index */
	    sprintf(name,"%d,end",i);
	    sprintf(value,"%d",end);
	    out(name,value);
	}

	/* string itself */
	sprintf(name,"%d,string",i);
	val = Tcl_GetRange(buf, start, end);
	expDiagLog("interact: set %s(%s) \"",INTER_OUT,name);
	expDiagLogU(expPrintifyObj(val));
	expDiagLogU("\"\r\n");
	Tcl_SetVar2Ex(interp,INTER_OUT,name,val,0);
    }
    Tcl_DecrRefCount (buf);
}

/*
 * echo chars
 */ 
static void
intEcho(
    ExpState *esPtr,
    int skipBytes,
    int matchBytes)
{
    int seenBytes;	/* either printed or echoed */
    int echoBytes;
    int offsetBytes;

    /* write is unlikely to fail, since we just read from same descriptor */
    seenBytes = esPtr->printed + esPtr->echoed;
    if (skipBytes >= seenBytes) {
	echoBytes = matchBytes;
	offsetBytes = skipBytes;
    } else if ((matchBytes + skipBytes - seenBytes) > 0) {
	echoBytes = matchBytes + skipBytes - seenBytes;
	offsetBytes = seenBytes;
    }

    (void) expWriteCharsUni(esPtr,
			    esPtr->input.buffer + offsetBytes,
		   echoBytes);

    esPtr->echoed = matchBytes + skipBytes - esPtr->printed;
}

/*
 * intRead() does the logical equivalent of a read() for the interact command.
 * Returns # of bytes read or negative number (EXP_XXX) indicating unusual event.
 */
static int
intRead(
    Tcl_Interp *interp,
    ExpState *esPtr,
    int warnOnBufferFull,
    int interruptible,
    int key)
{
    Tcl_UniChar *eobOld;  /* old end of buffer */
    int cc;
    int numchars;
    Tcl_UniChar *str;

    str      = esPtr->input.buffer;
    numchars = esPtr->input.use;
    eobOld   = str + numchars;

    /* We drop one third when are at least 2/3 full */
    /* condition is (size >= max*2/3) <=> (size*3 >= max*2) */
    if (numchars*3 >= esPtr->input.max*2) {
	/*
	 * In theory, interact could be invoked when this situation
	 * already exists, hence the "probably" in the warning below
	 */
	if (warnOnBufferFull) {
	    expDiagLogU("WARNING: interact buffer is full, probably because your\r\n");
	    expDiagLogU("patterns have matched all of it but require more chars\r\n");
	    expDiagLogU("in order to complete the match.\r\n");
	    expDiagLogU("Dumping first half of buffer in order to continue\r\n");
	    expDiagLogU("Recommend you enlarge the buffer or fix your patterns.\r\n");
	}
	exp_buffer_shuffle(interp,esPtr,0,INTER_OUT,"interact");
    }
    if (!interruptible) {
        cc = Tcl_ReadChars(esPtr->channel, esPtr->input.newchars,
			   esPtr->input.max - esPtr->input.use,
			   0 /* no append */);
    } else {
#ifdef SIMPLE_EVENT
        cc = intIRead(esPtr->channel, esPtr->input.newchars,
		      esPtr->input.max - esPtr->input.use,
		      0 /* no append */);
#endif
    }

    if (cc > 0) {
        memcpy (esPtr->input.buffer + esPtr->input.use,
		Tcl_GetUnicodeFromObj (esPtr->input.newchars, NULL),
		cc * sizeof (Tcl_UniChar));
	esPtr->input.use += cc;

	expDiagLog("spawn id %s sent <",esPtr->name);
	expDiagLogU(expPrintifyUni(eobOld,cc));
	expDiagLogU(">\r\n");

	esPtr->key = key;
    }
    return cc;
}



#ifdef SIMPLE_EVENT

/*

The way that the "simple" interact works is that the original Expect
process reads from the tty and writes to the spawned process.  A child
process is forked to read from the spawned process and write to the
tty.  It looks like this:

                        user
                    --> tty >--
                   /           \
                  ^             v
                child        original
               process        Expect
                  ^          process
                  |             v
                   \           /
                    < spawned <
                      process

*/



#ifndef WEXITSTATUS
#define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#include <setjmp.h>

#ifdef HAVE_SIGLONGJMP
static sigjmp_buf env;                /* for interruptable read() */
#else
static jmp_buf env;		/* for interruptable read() */
#endif  /* HAVE_SIGLONGJMP */

static int reading;		/* while we are reading */
				/* really, while "env" is valid */
static int deferred_interrupt = FALSE;	/* if signal is received, but not */
				/* in expIRead record this here, so it will */
				/* be handled next time through expIRead */

static void
sigchld_handler()
{
  if (reading) {
#ifdef HAVE_SIGLONGJMP
     siglongjmp(env,1);
#else
    longjmp(env,1);
#endif  /* HAVE_SIGLONGJMP */
  }
  deferred_interrupt = TRUE;
}

#define EXP_CHILD_EOF -100

/*
 * Name: expIRead, do an interruptable read
 *
 * intIRead() reads from chars from the user.
 *
 * It returns early if it detects the death of a proc (either the spawned
 * process or the child (surrogate).
 */
static int
intIRead(
    Tcl_Channel channel,
    Tcl_Obj *obj,
    int size,
    int flags)
{
    int cc = EXP_CHILD_EOF;

    if (deferred_interrupt) return(cc);

    if (
#ifdef HAVE_SIGLONGJMP
	0 == sigsetjmp(env,1)
#else
	0 == setjmp(env)
#endif  /* HAVE_SIGLONGJMP */
	) {
	reading = TRUE;
	cc = Tcl_ReadChars(channel,obj,size,flags);
    }
    reading = FALSE;
    return(cc);
}

/* exit status for the child process created by cmdInteract */
#define CHILD_DIED		-2
#define SPAWNED_PROCESS_DIED	-3

static void
clean_up_after_child(
    Tcl_Interp *interp,
    ExpState *esPtr)
{
    expWaitOnOne(); /* wait for slave */
    expWaitOnOne(); /* wait for child */

    deferred_interrupt = FALSE;
    if (esPtr->close_on_eof) {
    exp_close(interp,esPtr);
}
}
#endif /*SIMPLE_EVENT*/

static int
update_interact_fds(
    Tcl_Interp *interp,
    int *esPtrCount,
    Tcl_HashTable **esPtrToInput,	/* map from ExpStates to "struct inputs" */
    ExpState ***esPtrs,
    struct input *input_base,
    int do_indirect,		/* if true do indirects */
    int *config_count,
    int *real_tty_caller)
{
	struct input *inp;
	struct output *outp;
	struct exp_state_list *fdp;
	int count;

	int real_tty = FALSE;

	*config_count = exp_configure_count;

	count = 0;
	for (inp = input_base;inp;inp=inp->next) {

		if (do_indirect) {
			/* do not update "direct" entries (again) */
			/* they were updated upon creation */
			if (inp->i_list->direct == EXP_INDIRECT) {
				exp_i_update(interp,inp->i_list);
			}
			for (outp = inp->output;outp;outp=outp->next) {
				if (outp->i_list->direct == EXP_INDIRECT) {
					exp_i_update(interp,outp->i_list);
				}
			}
		}

		/* revalidate all input descriptors */
		for (fdp = inp->i_list->state_list;fdp;fdp=fdp->next) {
		    count++;
		    /* have to "adjust" just in case spawn id hasn't had */
		    /* a buffer sized yet */
		    if (!expStateCheck(interp,fdp->esPtr,1,1,"interact")) {
			return(TCL_ERROR);
		    }
		}

		/* revalidate all output descriptors */
		for (outp = inp->output;outp;outp=outp->next) {
			for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
				/* make user_spawn_id point to stdout */
			    if (!expStdinoutIs(fdp->esPtr)) {
				if (!expStateCheck(interp,fdp->esPtr,1,0,"interact"))
				    return(TCL_ERROR);
			    }
			}
		}
	}
	if (!do_indirect) return TCL_OK;

	if (*esPtrToInput == 0) {
	    *esPtrToInput = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	    *esPtrs = (ExpState **)ckalloc(count * sizeof(ExpState *));
	} else {
	    /* if hash table already exists, delete it and start over */
	    Tcl_DeleteHashTable(*esPtrToInput);
	    *esPtrs = (ExpState **)ckrealloc((char *)*esPtrs,count * sizeof(ExpState *));
	}
	Tcl_InitHashTable(*esPtrToInput,TCL_ONE_WORD_KEYS);

	count = 0;
	for (inp = input_base;inp;inp=inp->next) {
	    for (fdp = inp->i_list->state_list;fdp;fdp=fdp->next) {
		/* build map to translate from spawn_id to struct input */
		expCreateStateToInput(*esPtrToInput,fdp->esPtr,inp);

		/* build input to ready() */
		(*esPtrs)[count] = fdp->esPtr;

		if (real_tty_input(fdp->esPtr)) real_tty = TRUE;

		count++;
	    }
	}
	*esPtrCount = count;

	*real_tty_caller = real_tty; /* tell caller if we have found that */
					/* we are using real tty */

	return TCL_OK;
}

/*ARGSUSED*/
static char *
inter_updateproc(
    ClientData clientData,
    Tcl_Interp *interp,	/* Interpreter containing variable. */
    char *name1,	/* Name of variable. */
    char *name2,	/* Second part of variable name. */
    int flags)		/* Information about what happened. */
{
	exp_configure_count++;
	return 0;
}
			
#define finish(x)	{ status = x; goto done; }

static char return_cmd[] = "return";
static char interpreter_cmd[] = "interpreter";

/*ARGSUSED*/
int
Exp_InteractObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST initial_objv[])		/* Argument objects. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    Tcl_Obj *CONST *objv_copy;	/* original, for error messages */
    Tcl_Obj **objv = (Tcl_Obj **) initial_objv;
    char *string;
    Tcl_UniChar *ustring;

#ifdef SIMPLE_EVENT
    int pid;
#endif /*SIMPLE_EVENT*/

    /*declarations*/
    int input_count;	/* count of struct input descriptors */

    Tcl_HashTable *esPtrToInput = 0;	/* map from ExpState to "struct inputs" */
    ExpState **esPtrs;
    struct keymap *km;	/* ptr for above while parsing */
    Tcl_RegExpInfo reInfo;
    ExpState *u = 0;
    ExpState *esPtr = 0;
    Tcl_Obj *chanName = 0;
    int need_to_close_master = FALSE;	/* if an eof is received */
				/* we use this to defer close until later */

    int next_tty_reset = FALSE;	/* if we've seen a single -reset */
    int next_iread = FALSE;/* if we've seen a single -iread */
    int next_iwrite = FALSE;/* if we've seen a single -iread */
    int next_re = FALSE;	/* if we've seen a single -re */
    int next_null = FALSE;	/* if we've seen the null keyword */
    int next_writethru = FALSE;/*if macros should also go to proc output */
    int next_indices = FALSE;/* if we should write indices */
    int next_echo = FALSE;	/* if macros should be echoed */
    int status = TCL_OK;	/* final return value */
    int i;			/* misc temp */
    int size;			/* size temp */

    int timeout_simple = TRUE;	/* if no or global timeout */

    int real_tty;		/* TRUE if we are interacting with real tty */
    int tty_changed = FALSE;/* true if we had to change tty modes for */
				/* interact to work (i.e., to raw, noecho) */
    int was_raw;
    int was_echo;
    exp_tty tty_old;

    Tcl_Obj *replace_user_by_process = 0; /* for -u flag */

    struct input *input_base;
#define input_user input_base
    struct input *input_default;
    struct input *inp;	/* overused ptr to struct input */
    struct output *outp;	/* overused ptr to struct output */

    int dash_input_count = 0; /* # of "-input"s seen */
    int dash_o_count = 0; /* # of "-o"s seen */
    int arbitrary_timeout;
    int default_timeout;
    struct action action_timeout;	/* common to all */
    struct action action_eof;	/* common to all */
    struct action **action_eof_ptr;	/* allow -input/ouput to */
		/* leave their eof-action assignable by a later */
		/* -eof */
    struct action *action_base = 0;
    struct keymap **end_km;

    int key;
    int configure_count;	/* monitor reconfigure events */
    Tcl_Obj* new_cmd = NULL;

    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	/* expect {...} */

	new_cmd = exp_eval_with_one_arg(clientData,interp,objv);
	if (!new_cmd) return TCL_ERROR;

	/* Replace old arguments with result of reparse */
	Tcl_ListObjGetElements (interp, new_cmd, &objc, &objv);

    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	/* expect -brace {...} ... fake command line for reparsing */

	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];

	new_cmd = exp_eval_with_one_arg(clientData,interp,new_objv);
	if (!new_cmd) return TCL_ERROR;
	/* Replace old arguments with result of reparse */
	Tcl_ListObjGetElements (interp, new_cmd, &objc, &objv);
    }

    objv_copy = objv;

    objv++;
    objc--;

    default_timeout = EXP_TIME_INFINITY;
    arbitrary_timeout = EXP_TIME_INFINITY;	/* if user specifies */
		/* a bunch of timeouts with EXP_TIME_INFINITY, this will be */
		/* left around for us to find. */

    input_user = new(struct input);
    input_user->i_list = exp_new_i_simple(expStdinoutGet(),EXP_TEMPORARY); /* stdin by default */
    input_user->output = 0;
    input_user->action_eof = &action_eof;
    input_user->timeout_nominal = EXP_TIME_INFINITY;
    input_user->action_timeout = 0;
    input_user->keymap = 0;

    end_km = &input_user->keymap;
    inp = input_user;
    action_eof_ptr = &input_user->action_eof;

    input_default = new(struct input);
    input_default->i_list = exp_new_i_simple((ExpState *)0,EXP_TEMPORARY); /* fix up later */
    input_default->output = 0;
    input_default->action_eof = &action_eof;
    input_default->timeout_nominal = EXP_TIME_INFINITY;
    input_default->action_timeout = 0;
    input_default->keymap = 0;
    input_default->next = 0;		/* no one else */
    input_user->next = input_default;

    /* default and common -eof action */
    action_eof.statement = tsdPtr->cmdObjReturn;
    action_eof.tty_reset = FALSE;
    action_eof.iread = FALSE;
    action_eof.iwrite = FALSE;

    /*
     * Parse the command arguments.
     */
    for (;objc>0;objc--,objv++) {
	string = Tcl_GetString(*objv);
	if (string[0] == '-') {
	    static char *switches[] = {
		"--",		"-exact",	"-re",		"-input",
		"-output",	"-u",		"-o",		"-i",
		"-echo",	"-nobuffer",	"-indices",	"-f",
		"-reset",	"-F",		"-iread",	"-iwrite",
		"-eof",		"-timeout",	"-nobrace",	(char *)0
	    };
	    enum switches {
		EXP_SWITCH_DASH,	EXP_SWITCH_EXACT,
		EXP_SWITCH_REGEXP,	EXP_SWITCH_INPUT,
		EXP_SWITCH_OUTPUT,	EXP_SWITCH_USER,
		EXP_SWITCH_OPPOSITE,	EXP_SWITCH_SPAWN_ID,
		EXP_SWITCH_ECHO,	EXP_SWITCH_NOBUFFER,
		EXP_SWITCH_INDICES,	EXP_SWITCH_FAST,
		EXP_SWITCH_RESET,	EXP_SWITCH_CAPFAST,
		EXP_SWITCH_IREAD,	EXP_SWITCH_IWRITE,
		EXP_SWITCH_EOF,		EXP_SWITCH_TIMEOUT,
		EXP_SWITCH_NOBRACE
	    };
	    int index;

	    /*
	     * Allow abbreviations of switches and report an error if we
	     * get an invalid switch.
	     */

	    if (Tcl_GetIndexFromObj(interp, *objv, switches, "switch", 0,
		    &index) != TCL_OK) {
		goto error;
	    }
	    switch ((enum switches) index) {
		case EXP_SWITCH_DASH:
		case EXP_SWITCH_EXACT:
		    objc--;
		    objv++;
		    goto pattern;
		case EXP_SWITCH_REGEXP:
		    if (objc < 1) {
			Tcl_WrongNumArgs(interp,1,objv_copy,"-re pattern");
		    goto error;
		    }
		    next_re = TRUE;
		    objc--;
		    objv++;

		    /*
		     * Try compiling the expression so we can report
		     * any errors now rather then when we first try to
		     * use it.
		     */

		    if (!(Tcl_GetRegExpFromObj(interp, *objv,
			    TCL_REG_ADVANCED|TCL_REG_BOSONLY))) {
		    goto error;
		    }
		    goto pattern;
		case EXP_SWITCH_INPUT:
		    dash_input_count++;
		    if (dash_input_count == 2) {
			inp = input_default;
			input_user->next = input_default;
		    } else if (dash_input_count > 2) {
			struct input *previous_input = inp;
			inp = new(struct input);
			previous_input->next = inp;
		    }
		    inp->output = 0;
		    inp->action_eof = &action_eof;
		    action_eof_ptr = &inp->action_eof;
		    inp->timeout_nominal = default_timeout;
		    inp->action_timeout = &action_timeout;
		    inp->keymap = 0;
		    end_km = &inp->keymap;
		    inp->next = 0;
		    objc--;objv++;
		    if (objc < 1) {
			Tcl_WrongNumArgs(interp,1,objv_copy,"-input spawn_id");
		    goto error;
		    }
		    inp->i_list = exp_new_i_complex(interp,Tcl_GetString(*objv),
			    EXP_TEMPORARY,inter_updateproc);
		if (!inp->i_list) {
		    goto error;
		}
		    break;
		case EXP_SWITCH_OUTPUT: {
		    struct output *tmp;

		    /* imply a "-input" */
		    if (dash_input_count == 0) dash_input_count = 1;

		    outp = new(struct output);

				/* link new output in front of others */
		    tmp = inp->output;
		    inp->output = outp;
		    outp->next = tmp;

		    objc--;objv++;
		    if (objc < 1) {
			Tcl_WrongNumArgs(interp,1,objv_copy,"-output spawn_id");
		    goto error;
		    }
		    outp->i_list = exp_new_i_complex(interp,Tcl_GetString(*objv),
			    EXP_TEMPORARY,inter_updateproc);
		if (!outp->i_list) {
		    goto error;
		}
		    outp->action_eof = &action_eof;
		    action_eof_ptr = &outp->action_eof;
		    break;
		}
		case EXP_SWITCH_USER:
		    objc--;objv++;
		    if (objc < 1) {
			Tcl_WrongNumArgs(interp,1,objv_copy,"-u spawn_id");
		    goto error;
		    }
		    replace_user_by_process = *objv;

		    /* imply a "-input" */
		    if (dash_input_count == 0) dash_input_count = 1;
		    break;
		case EXP_SWITCH_OPPOSITE:
		    /* apply following patterns to opposite side */
		    /* of interaction */

		    end_km = &input_default->keymap;

		    if (dash_o_count > 0) {
			exp_error(interp,"cannot use -o more than once");
			goto error;
		    }
		    dash_o_count++;

		    /* imply two "-input" */
		    if (dash_input_count < 2) {
		      dash_input_count = 2;
		      inp = input_default;
		      action_eof_ptr = &inp->action_eof;
		    }
		    break;
		case EXP_SWITCH_SPAWN_ID:
		    /* substitute master */

		    objc--;objv++;
		    chanName = *objv;
		    /* will be used later on */

		    end_km = &input_default->keymap;

		    /* imply two "-input" */
		    if (dash_input_count < 2) {
			dash_input_count = 2;
			inp = input_default;
			action_eof_ptr = &inp->action_eof;
		    }
		    break;
		case EXP_SWITCH_ECHO:
		    next_echo = TRUE;
		    break;
		case EXP_SWITCH_NOBUFFER:
		    next_writethru = TRUE;
		    break;
		case EXP_SWITCH_INDICES:
		    next_indices = TRUE;
		    break;
		case EXP_SWITCH_RESET:
		    next_tty_reset = TRUE;
		    break;
		case EXP_SWITCH_IREAD:
		    next_iread = TRUE;
		    break;
		case EXP_SWITCH_IWRITE:
			next_iwrite= TRUE;
		    break;
		case EXP_SWITCH_EOF: {
		    struct action *action;

		    objc--;objv++;
		    expDiagLogU("-eof is deprecated, use eof\r\n");
		    *action_eof_ptr = action = new_action(&action_base);
		    action->statement = *objv;
		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    break;
		}
		case EXP_SWITCH_TIMEOUT: {
		    int t;
		    struct action *action;
		    expDiagLogU("-timeout is deprecated, use timeout\r\n");

		    objc--;objv++;
		    if (objc < 1) {
			Tcl_WrongNumArgs(interp,1,objv_copy,"-timeout time");
			goto error;
		    }

		    if (Tcl_GetIntFromObj(interp, *objv, &t) != TCL_OK) {
		    goto error;
		    }
		    objc--;objv++;
		    if (t != -1)
			arbitrary_timeout = t;
		    /* we need an arbitrary timeout to start */
		    /* search for lowest one later */

		    timeout_simple = FALSE;
		    action = inp->action_timeout = new_action(&action_base);
		    inp->timeout_nominal = t;

		    action->statement = *objv;
		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    break;
		}
		case EXP_SWITCH_FAST:
		case EXP_SWITCH_CAPFAST:
		    /* noop compatibility switches for fast mode */
		    break;
		case EXP_SWITCH_NOBRACE:
		    /* nobrace does nothing but take up space */
		    /* on the command line which prevents */
		    /* us from re-expanding any command lines */
		    /* of one argument that looks like it should */
		    /* be expanded to multiple arguments. */
		    break;
	    }
	    continue;
    	} else {
	    static char *options[] = {
		"eof", "timeout", "null", (char *)0
	    };
	    enum options {
		EXP_OPTION_EOF, EXP_OPTION_TIMEOUT, EXP_OPTION_NULL
	    };
	    int index;

	    /*
	     * Match keywords exactly, otherwise they are patterns.
	     */

	    if (Tcl_GetIndexFromObj(interp, *objv, options, "option",
		    1 /* exact */, &index) != TCL_OK) {
		Tcl_ResetResult(interp);
		goto pattern;
	    }
	    switch ((enum options) index) {
		case EXP_OPTION_EOF: {
		    struct action *action;

		    objc--;objv++;
		    *action_eof_ptr = action = new_action(&action_base);

		    action->statement = *objv;

		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    break;
		}
		case EXP_OPTION_TIMEOUT: {
		    int t;
		    struct action *action;

		    objc--;objv++;
		    if (objc < 1) {
			Tcl_WrongNumArgs(interp,1,objv_copy,"timeout time [action]");
		    goto error;
		    }
		    if (Tcl_GetIntFromObj(interp, *objv, &t) != TCL_OK) {
		    goto error;
		    }
		    objc--;objv++;

		    /* we need an arbitrary timeout to start */
		    /* search for lowest one later */
		    if (t != -1) arbitrary_timeout = t;

		    timeout_simple = FALSE;
		    action = inp->action_timeout = new_action(&action_base);
		    inp->timeout_nominal = t;

		    if (objc >= 1) {
		      action->statement = *objv;
		    } else {
		      action->statement = 0;
		    }

		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    break;
		}
		case EXP_OPTION_NULL:
		    next_null = TRUE;
		    goto pattern;
	    }
	    continue;
	}
    
	/*
	 * pick up the pattern
	 */

	pattern:
	km = new(struct keymap);

	/* so that we can match in order user specified */
	/* link to end of keymap list */
	*end_km = km;
	km->next = 0;
	end_km = &km->next;

	km->echo = next_echo;
	km->writethru = next_writethru;
	km->indices = next_indices;
	km->action.tty_reset = next_tty_reset;
	km->action.iwrite = next_iwrite;
	km->action.iread = next_iread;

	next_indices = next_echo = next_writethru = FALSE;
	next_tty_reset = FALSE;
	next_iwrite = next_iread = FALSE;

	km->keys = *objv;

	km->null = FALSE;
	km->re = 0;
	if (next_re) {
	    km->re = TRUE;
	    next_re = FALSE;
	}
	if (next_null) {
	    km->null = TRUE;
	    next_null = FALSE;
	}

	objc--;objv++;
	if (objc >= 1) {
	    km->action.statement = *objv;
	} else {
	    km->action.statement = 0;
	}

	expDiagLogU("defining key ");
	expDiagLogU(Tcl_GetString(km->keys));
	expDiagLogU(", action ");
	expDiagLogU(km->action.statement?expPrintify(Tcl_GetString(km->action.statement)):"interpreter");
	expDiagLogU("\r\n");

	/* imply a "-input" */
	if (dash_input_count == 0) dash_input_count = 1;
    }

    /* if the user has not supplied either "-output" for the */
    /* default two "-input"s, fix them up here */

    if (!input_user->output) {
	struct output *o = new(struct output);
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,1,1,0))) {
		goto error;
	    }
	    o->i_list = exp_new_i_simple(esPtr,EXP_TEMPORARY);
	} else {
	    o->i_list = exp_new_i_complex(interp,Tcl_GetString(chanName),
		    EXP_TEMPORARY,inter_updateproc);
	    if (!o->i_list) {
		goto error;
	    }
	}
	o->next = 0;	/* no one else */
	o->action_eof = &action_eof;
	input_user->output = o;
    }

    if (!input_default->output) {
	struct output *o = new(struct output);
	o->i_list = exp_new_i_simple(expStdinoutGet(),EXP_TEMPORARY);/* stdout by default */
	o->next = 0;	/* no one else */
	o->action_eof = &action_eof;
	input_default->output = o;
    }

    /* if user has given "-u" flag, substitute process for user */
    /* in first two -inputs */
    if (replace_user_by_process) {
	/* through away old ones */
	exp_free_i(interp,input_user->i_list,   inter_updateproc);
	exp_free_i(interp,input_default->output->i_list,inter_updateproc);

	/* replace with arg to -u */
	input_user->i_list = exp_new_i_complex(interp,
		Tcl_GetString(replace_user_by_process),
		EXP_TEMPORARY,inter_updateproc);
	if (!input_user->i_list) 
	    goto error;
	input_default->output->i_list = exp_new_i_complex(interp,
		Tcl_GetString(replace_user_by_process),
		EXP_TEMPORARY,inter_updateproc);
	if (!input_default->output->i_list) 
	    goto error;
    }

    /*
     * now fix up for default spawn id
     */

    /* user could have replaced it with an indirect, so force update */
    if (input_default->i_list->direct == EXP_INDIRECT) {
	exp_i_update(interp,input_default->i_list);
    }

    if (input_default->i_list->state_list
	    && (input_default->i_list->state_list->esPtr == EXP_SPAWN_ID_BAD)) {
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,1,1,0))) {
		goto error;
	    }
	    input_default->i_list->state_list->esPtr = esPtr;
	} else {
	    /* discard old one and install new one */
	    exp_free_i(interp,input_default->i_list,inter_updateproc);
	    input_default->i_list = exp_new_i_complex(interp,Tcl_GetString(chanName),
		    EXP_TEMPORARY,inter_updateproc);
	    if (!input_default->i_list)
		goto error;
	}
    }

    /*
     * check for user attempting to interact with self
     * they're almost certainly just fooling around
     */

    /* user could have replaced it with an indirect, so force update */
    if (input_user->i_list->direct == EXP_INDIRECT) {
	exp_i_update(interp,input_user->i_list);
    }

    if (input_user->i_list->state_list && input_default->i_list->state_list
	    && (input_user->i_list->state_list->esPtr == input_default->i_list->state_list->esPtr)) {
	exp_error(interp,"cannot interact with self - set spawn_id to a spawned process");
	goto error;
    }

    esPtrs = 0;

    /*
     * all data structures are sufficiently set up that we can now
     * "finish()" to terminate this procedure
     */

    status = update_interact_fds(interp,&input_count,&esPtrToInput,&esPtrs,input_base,1,&configure_count,&real_tty);
    if (status == TCL_ERROR) finish(TCL_ERROR);

    if (real_tty) {
	tty_changed = exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
    }

    for (inp = input_base,i=0;inp;inp=inp->next,i++) {
	/* start timers */
	inp->timeout_remaining = inp->timeout_nominal;
    }

    key = expect_key++;

    /* declare ourselves "in sync" with external view of close/indirect */
    configure_count = exp_configure_count;
    
#ifndef SIMPLE_EVENT
    /* loop waiting (in event handler) for input */
    for (;;) {
	int te;	/* result of Tcl_Eval */
	int rc;	/* return code from ready.  This is further refined by matcher. */
	int cc;			/* # of chars from read() */
	struct action *action = 0;
	time_t previous_time;
	time_t current_time;
	int matchLen;	/* # of chars matched */
	int skip;		/* # of chars not involved in match */
	int print;		/* # of chars to print */
	int oldprinted;		/* old version of u->printed */
	int change;		/* if action requires cooked mode */
	int attempt_match = TRUE;
	struct input *soonest_input;
	int timeout;	/* current as opposed to default_timeout */
	Tcl_Time temp_time;

	/* calculate how long to wait */
	/* by finding shortest remaining timeout */
	if (timeout_simple) {
	    timeout = default_timeout;
	} else {
	    timeout = arbitrary_timeout;

	    for (inp=input_base;inp;inp=inp->next) {
		if ((inp->timeout_remaining != EXP_TIME_INFINITY) &&
			(inp->timeout_remaining <= timeout)) {
		    soonest_input = inp;
		    timeout = inp->timeout_remaining;
		}
	    }

	    Tcl_GetTime (&temp_time);
	    previous_time = temp_time.sec;
	    /* timestamp here rather than simply saving old */
	    /* current time (after ready()) to account for */
	    /* possibility of slow actions */
	    
	    /* timeout can actually be EXP_TIME_INFINITY here if user */
	    /* explicitly supplied it in a few cases (or */
	    /* the count-down code is broken) */
	}

	/* update the world, if necessary */
	if (configure_count != exp_configure_count) {
	    status = update_interact_fds(interp,&input_count,
		    &esPtrToInput,&esPtrs,input_base,1,
		    &configure_count,&real_tty);
	    if (status) finish(status);
	}

	rc = exp_get_next_event(interp,esPtrs,input_count,&u,timeout,key);
	if (rc == EXP_TCLERROR)
	    goto error;
	if (rc == EXP_RECONFIGURE) continue;
	if (rc == EXP_TIMEOUT) {
	    if (timeout_simple) {
		action = &action_timeout;
		goto got_action;
	    } else {
		action = soonest_input->action_timeout;
		/* arbitrarily pick first fd out of list */
		u = soonest_input->i_list->state_list->esPtr;
	    }
	}
	if (!timeout_simple) {
	    int time_diff;

	    Tcl_GetTime (&temp_time);
	    current_time = temp_time.sec;
	    time_diff = current_time - previous_time;

	    /* update all timers */
	    for (inp=input_base;inp;inp=inp->next) {
		if (inp->timeout_remaining != EXP_TIME_INFINITY) {
		    inp->timeout_remaining -= time_diff;
		    if (inp->timeout_remaining < 0)
			inp->timeout_remaining = 0;
		}
	    }
	}

	/* at this point, we have some kind of event which can be */
	/* immediately processed - i.e. something that doesn't block */

	/* figure out who we are */
	inp = expStateToInput(esPtrToInput,u);

	/* reset timer */
	inp->timeout_remaining = inp->timeout_nominal;

	switch (rc) {
	    case EXP_DATA_NEW:
		cc = intRead(interp,u,1,0,key);
		if (cc > 0) break;

		rc = EXP_EOF;
		/*
		 * FALLTHRU
		 *
		 * Most systems have read() return 0, allowing
		 * control to fall thru and into this code.  On some
		 * systems (currently HP and new SGI), read() does
		 * see eof, and it must be detected earlier.  Then
		 * control jumps directly to this EXP_EOF label.
		 */
	    case EXP_EOF:
		action = inp->action_eof;
		attempt_match = FALSE;
		skip = expSizeGet(u);
		expDiagLog("interact: received eof from spawn_id %s\r\n",u->name);
		/* actual close is done later so that we have a */
		/* chance to flush out any remaining characters */
		need_to_close_master = TRUE;
		break;
	    case EXP_DATA_OLD:
		cc = 0;
		break;
	    case EXP_TIMEOUT:
		action = inp->action_timeout;
		attempt_match = FALSE;
		skip = expSizeGet(u);
		break;
	}

	km = 0;

	if (attempt_match) {
	    rc = intMatch(u,inp->keymap,&km,&matchLen,&skip,&reInfo);
	    if ((rc == EXP_MATCH) && km && km->re) {
		intRegExpMatchProcess(interp,u,km,&reInfo,skip);
	    }
	} else {
	    attempt_match = TRUE;
	}

	/*
	 * dispose of chars that should be skipped
	 * i.e., chars that cannot possibly be part of a match.
	 */
	if (km && km->writethru) {
	    print = skip + matchLen;
	} else print = skip;

	if (km && km->echo) {
	    intEcho(u,skip,matchLen);
	}
	oldprinted = u->printed;

	/*
	 * If expect has left characters in buffer, it has
	 * already echoed them to the screen, thus we must
	 * prevent them being rewritten.  Unfortunately this
	 * gives the possibility of matching chars that have
	 * already been output, but we do so since the user
	 * could have avoided it by flushing the output
	 * buffers directly.
	 */
	if (print > u->printed) {	/* usual case */
	    for (outp = inp->output;outp;outp=outp->next) {
		struct exp_state_list *fdp;
		for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
		    /* send to channel (and log if chan is stdout or devtty) */
		    /*
		     * Following should eventually be rewritten to ...WriteCharsAnd...
		     */
		    int wc = expWriteBytesAndLogIfTtyU(fdp->esPtr,
						       u->input.buffer + u->printed,
			    print - u->printed);
		    if (wc < 0) {
			expDiagLog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
			action = outp->action_eof;
			change = (action && action->tty_reset);
			
			if (change && tty_changed)
			    exp_tty_set(interp,&tty_old,was_raw,was_echo);
			te = inter_eval(interp,action,u);

			if (change && real_tty) tty_changed =
						    exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
			switch (te) {
			    case TCL_BREAK:
			    case TCL_CONTINUE:
				finish(te);
			    case EXP_TCL_RETURN:
				finish(TCL_RETURN);
			    case TCL_RETURN:
				finish(TCL_OK);
			    case TCL_OK:
				/* god knows what the user might */
				/* have done to us in the way of */
				/* closed fds, so .... */
				action = 0;	/* reset action */
				continue;
			    default:
				finish(te);
			}
		    }
		}
	    }
	    u->printed = print;
	}
	
	/* u->printed is now accurate with respect to the buffer */
	/* However, we're about to shift the old data out of the */
	/* buffer.  Thus size, printed, and echoed must be */
	/* updated */
	
	/* first update size based on skip information */
	/* then set skip to the total amount skipped */

	size = expSizeGet(u);
	if (rc == EXP_MATCH) {
	    action = &km->action;

	    skip += matchLen;
	    size -= skip;
	    if (size) {
		ustring = u->input.buffer;
		memmove(ustring, ustring + skip, size * sizeof(Tcl_UniChar));
	    }
	} else {
	    ustring = u->input.buffer;
	    if (skip) {
		size -= skip;
		memcpy(ustring, ustring + skip, size * sizeof(Tcl_UniChar));
	    }
	}
	u->input.use = size;

	/* now update printed based on total amount skipped */

	u->printed -= skip;
	/* if more skipped than printed (i.e., keymap encountered) */
	/* for printed positive */
	if (u->printed < 0) u->printed = 0;

	/* if we are in the middle of a match, force the next event */
	/* to wait for more data to arrive */
	u->force_read = (rc == EXP_CANMATCH);

	/* finally reset echoed if necessary */
	if (rc != EXP_CANMATCH) {
	    if (skip >= oldprinted + u->echoed) u->echoed = 0;
	}

	if (rc == EXP_EOF) {
	  if (u->close_on_eof) {
	    exp_close(interp,u);
	  }
	    need_to_close_master = FALSE;
	}

	if (action) {
got_action:
	    change = (action && action->tty_reset);
	    if (change && tty_changed)
		exp_tty_set(interp,&tty_old,was_raw,was_echo);

	    te = inter_eval(interp,action,u);

	    if (change && real_tty) tty_changed =
					exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
	    switch (te) {
		case TCL_BREAK:
		case TCL_CONTINUE:
		    finish(te);
		case EXP_TCL_RETURN:
		    finish(TCL_RETURN);
		case TCL_RETURN:
		    finish(TCL_OK);
		case TCL_OK:
		    /* god knows what the user might */
		    /* have done to us in the way of */
		    /* closed fds, so .... */
		    action = 0;	/* reset action */
		    continue;
		default:
		    finish(te);
	    }
	}
    }

#else /* SIMPLE_EVENT */
/*	deferred_interrupt = FALSE;*/
{
		int te;	/* result of Tcl_Eval */
		ExpState *u;    /*master*/
		int rc;	/* return code from ready.  This is further */
			/* refined by matcher. */
		int cc;	/* chars count from read() */
		struct action *action = 0;
		time_t previous_time;
		time_t current_time;
		int matchLen, skip;
		int change;	/* if action requires cooked mode */
		int attempt_match = TRUE;
		struct input *soonest_input;
		int print;		/* # of chars to print */
		int oldprinted;		/* old version of u->printed */

		int timeout;	/* current as opposed to default_timeout */

	if (-1 == (pid = fork())) {
		exp_error(interp,"fork: %s",Tcl_PosixError(interp));
		finish(TCL_ERROR);
	}
	if (pid == 0) {
	    /*
	     * This is a new child process.
	     * It exists only for this interact command and will go away when
	     * the interact returns.
	     *
	     * The purpose of this child process is to read output from the
	     * spawned process and send it to the user tty.
	     * (See diagram above.)
	     */

	    exp_close(interp,expStdinoutGet());

	    u = esPtrs[1];  /* get 2nd ExpState */
	    input_count = 1;

	    while (1) {

		/* calculate how long to wait */
		/* by finding shortest remaining timeout */
		if (timeout_simple) {
			timeout = default_timeout;
		} else {
			timeout = arbitrary_timeout;

			for (inp=input_base;inp;inp=inp->next) {
				if ((inp->timeout_remaining != EXP_TIME_INFINITY) &&
				    (inp->timeout_remaining < timeout))
					soonest_input = inp;
					timeout = inp->timeout_remaining;
			}

			Tcl_GetTime (&temp_time);
			previous_time = temp_time.sec;
			/* timestamp here rather than simply saving old */
			/* current time (after ready()) to account for */
			/* possibility of slow actions */

			/* timeout can actually be EXP_TIME_INFINITY here if user */
			/* explicitly supplied it in a few cases (or */
			/* the count-down code is broken) */
		}

		/* +1 so we can look at the "other" file descriptor */
		rc = exp_get_next_event(interp,esPtrs+1,input_count,&u,timeout,key);
		if (!timeout_simple) {
			int time_diff;

			Tcl_GetTime (&temp_time);
			current_time = temp_time.sec;
			time_diff = current_time - previous_time;

			/* update all timers */
			for (inp=input_base;inp;inp=inp->next) {
				if (inp->timeout_remaining != EXP_TIME_INFINITY) {
					inp->timeout_remaining -= time_diff;
					if (inp->timeout_remaining < 0)
						inp->timeout_remaining = 0;
				}
			}
		}

		/* at this point, we have some kind of event which can be */
		/* immediately processed - i.e. something that doesn't block */

		/* figure out who we are */
		inp = expStateToInput(esPtrToInput,u);

		switch (rc) {
		case EXP_DATA_NEW:
		    cc = intRead(interp,u,0,0,key);
		    if (cc > 0) break;
		    /*
		     * FALLTHRU
		     *
		     * Most systems have read() return 0, allowing
		     * control to fall thru and into this code.  On some
		     * systems (currently HP and new SGI), read() does
		     * see eof, and it must be detected earlier.  Then
		     * control jumps directly to this EXP_EOF label.
		     */
		case EXP_EOF:
			action = inp->action_eof;
			attempt_match = FALSE;
			skip = expSizeGet(u);
			rc = EXP_EOF;
			expDiagLog("interact: child received eof from spawn_id %s\r\n",u->name);
			exp_close(interp,u);
			break;
		case EXP_DATA_OLD:
			cc = 0;
			break;
		}

		km = 0;

		if (attempt_match) {
		    rc = intMatch(u,inp->keymap,&km,&matchLen,&skip,&reInfo);
		    if ((rc == EXP_MATCH) && km && km->re) {
			intRegExpMatchProcess(interp,u,km,&reInfo,skip);
		    }
		} else {
		    attempt_match = TRUE;
		}

		/* dispose of chars that should be skipped */
		
		/* skip is chars not involved in match */
		/* print is with chars involved in match */

		if (km && km->writethru) {
			print = skip + matchLen;
		} else print = skip;

		if (km && km->echo) {
		    intEcho(u,skip,matchLen);
		}
		oldprinted = u->printed;

		/* If expect has left characters in buffer, it has */
		/* already echoed them to the screen, thus we must */
		/* prevent them being rewritten.  Unfortunately this */
		/* gives the possibility of matching chars that have */
		/* already been output, but we do so since the user */
		/* could have avoided it by flushing the output */
		/* buffers directly. */
		if (print > u->printed) {	/* usual case */
		    for (outp = inp->output;outp;outp=outp->next) {
			struct exp_state_list *fdp;
			for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
			    /* send to channel (and log if chan is stdout or devtty) */
			    int wc = expWriteBytesAndLogIfTtyU(fdp->esPtr,
							       u->input.buffer + u->printed,
				    print - u->printed);
			    if (wc < 0) {
				expDiagLog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
				action = outp->action_eof;

				te = inter_eval(interp,action,u);

				switch (te) {
				    case TCL_BREAK:
				    case TCL_CONTINUE:
					finish(te);
				    case EXP_TCL_RETURN:
					finish(TCL_RETURN);
				    case TCL_RETURN:
					finish(TCL_OK);
				    case TCL_OK:
					/* god knows what the user might */
					/* have done to us in the way of */
					/* closed fds, so .... */
					action = 0;	/* reset action */
					continue;
				    default:
					finish(te);
				}
			    }
			}
		    }
		    u->printed = print;
		}

		/* u->printed is now accurate with respect to the buffer */
		/* However, we're about to shift the old data out of the */
		/* buffer.  Thus size, printed, and echoed must be */
		/* updated */

		/* first update size based on skip information */
		/* then set skip to the total amount skipped */

		size = expSizeGet(u);
		if (rc == EXP_MATCH) {
		    action = &km->action;

		    skip += matchLen;
		    size -= skip;
		    if (size) {
			memcpy(u->buffer, u->buffer + skip, size);
		    }
		} else {
		    if (skip) {
			size -= skip;
			memcpy(u->buffer, u->buffer + skip, size);
		    }
		}
		Tcl_SetObjLength(size);

		/* now update printed based on total amount skipped */

		u->printed -= skip;
		/* if more skipped than printed (i.e., keymap encountered) */
		/* for printed positive */
		if (u->printed < 0) u->printed = 0;

		/* if we are in the middle of a match, force the next event */
		/* to wait for more data to arrive */
		u->force_read = (rc == EXP_CANMATCH);

		/* finally reset echoed if necessary */
		if (rc != EXP_CANMATCH) {
			if (skip >= oldprinted + u->echoed) u->echoed = 0;
		}

		if (action) {
			te = inter_eval(interp,action,u);
			switch (te) {
			case TCL_BREAK:
			case TCL_CONTINUE:
				finish(te);
			case EXP_TCL_RETURN:
				finish(TCL_RETURN);
			case TCL_RETURN:
				finish(TCL_OK);
			case TCL_OK:
				/* god knows what the user might */
				/* have done to us in the way of */
				/* closed fds, so .... */
				action = 0;	/* reset action */
				continue;
			default:
				finish(te);
			}
		}
	    }
	} else {
	    /*
	     * This is the original Expect process.
	     *
	     * It now loops, reading keystrokes from the user tty
	     * and sending them to the spawned process.
	     * (See diagram above.)
	     */

#include <signal.h>

#if defined(SIGCLD) && !defined(SIGCHLD)
#define SIGCHLD SIGCLD
#endif
		expDiagLog("fork = %d\r\n",pid);
		signal(SIGCHLD,sigchld_handler);
/*	restart:*/
/*		tty_changed = exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);*/

	    u = esPtrs[0];  /* get 1st ExpState */
	    input_count = 1;

	    while (1) {
		/* calculate how long to wait */
		/* by finding shortest remaining timeout */
		if (timeout_simple) {
			timeout = default_timeout;
		} else {
			timeout = arbitrary_timeout;

			for (inp=input_base;inp;inp=inp->next) {
				if ((inp->timeout_remaining != EXP_TIME_INFINITY) &&
				    (inp->timeout_remaining < timeout))
					soonest_input = inp;
					timeout = inp->timeout_remaining;
			}

			Tcl_GetTime (&temp_time);
			previous_time = temp_time.sec;
			/* timestamp here rather than simply saving old */
			/* current time (after ready()) to account for */
			/* possibility of slow actions */

			/* timeout can actually be EXP_TIME_INFINITY here if user */
			/* explicitly supplied it in a few cases (or */
			/* the count-down code is broken) */
		}

		rc = exp_get_next_event(interp,esPtrs,input_count,&u,timeout,key);
		if (!timeout_simple) {
			int time_diff;

			Tcl_GetTime (&temp_time);
			current_time = temp_time.sec;
			time_diff = current_time - previous_time;

			/* update all timers */
			for (inp=input_base;inp;inp=inp->next) {
				if (inp->timeout_remaining != EXP_TIME_INFINITY) {
					inp->timeout_remaining -= time_diff;
					if (inp->timeout_remaining < 0)
						inp->timeout_remaining = 0;
				}
			}
		}

		/* at this point, we have some kind of event which can be */
		/* immediately processed - i.e. something that doesn't block */

		/* figure out who we are */
		inp = expStateToInput(esPtrToInput,u);

		switch (rc) {
		case EXP_DATA_NEW:
		        cc = intRead(interp,u,0,1,key);
		        if (cc > 0) {
				break;
			} else if (cc == EXP_CHILD_EOF) {
				/* user could potentially have two outputs in which */
				/* case we might be looking at the wrong one, but */
				/* the likelihood of this is nil */
				action = inp->output->action_eof;
				attempt_match = FALSE;
				skip = expSizeGet(u);
				rc = EXP_EOF;
				expDiagLogU("interact: process died/eof\r\n");
				clean_up_after_child(interp,esPtrs[1]);
				break;
			}
			/*
			 * FALLTHRU
			 *
			 * Most systems have read() return 0, allowing
			 * control to fall thru and into this code.  On some
			 * systems (currently HP and new SGI), read() does
			 * see eof, and it must be detected earlier.  Then
			 * control jumps directly to this EXP_EOF label.
			 */
		case EXP_EOF:
			action = inp->action_eof;
			attempt_match = FALSE;
			skip = expSizeGet(u);
			rc = EXP_EOF;
			expDiagLogU("user sent EOF or disappeared\n\n");
			break;
		case EXP_DATA_OLD:
			cc = 0;
			break;
		}

		km = 0;

		if (attempt_match) {
		    rc = intMatch(u,inp->keymap,&km,&matchLen,&skip,&reInfo);
		    if ((rc == EXP_MATCH) && km && km->re) {
			intRegExpMatchProcess(interp,u,km,&reInfo,skip);
		    }
		} else {
		    attempt_match = TRUE;
		}

		/* dispose of chars that should be skipped */
		
		/* skip is chars not involved in match */
		/* print is with chars involved in match */

		if (km && km->writethru) {
			print = skip + matchLen;
		} else print = skip;

		if (km && km->echo) {
		    intEcho(u,skip,matchLen);
		}
		oldprinted = u->printed;

		/* If expect has left characters in buffer, it has */
		/* already echoed them to the screen, thus we must */
		/* prevent them being rewritten.  Unfortunately this */
		/* gives the possibility of matching chars that have */
		/* already been output, but we do so since the user */
		/* could have avoided it by flushing the output */
		/* buffers directly. */
		if (print > u->printed) {	/* usual case */
		    for (outp = inp->output;outp;outp=outp->next) {
			struct exp_state_list *fdp;
			for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
			    /* send to channel (and log if chan is stdout or devtty) */
			    int wc = expWriteBytesAndLogIfTtyU(fdp->esPtr,
							       u->input.buffer + u->printed,
				    print - u->printed);
			    if (wc < 0) {
				expDiagLog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
				clean_up_after_child(interp,fdp->esPtr);
				action = outp->action_eof;
				change = (action && action->tty_reset);
				if (change && tty_changed)
				    exp_tty_set(interp,&tty_old,was_raw,was_echo);
				te = inter_eval(interp,action,u);

				if (change && real_tty) tty_changed =
							    exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
				switch (te) {
				    case TCL_BREAK:
				    case TCL_CONTINUE:
					finish(te);
				    case EXP_TCL_RETURN:
					finish(TCL_RETURN);
				    case TCL_RETURN:
					finish(TCL_OK);
				    case TCL_OK:
					/* god knows what the user might */
					/* have done to us in the way of */
					/* closed fds, so .... */
					action = 0;	/* reset action */
					continue;
				    default:
					finish(te);
				}
			    }
			}
		    }
		    u->printed = print;
		}

		/* u->printed is now accurate with respect to the buffer */
		/* However, we're about to shift the old data out of the */
		/* buffer.  Thus size, printed, and echoed must be */
		/* updated */

		/* first update size based on skip information */
		/* then set skip to the total amount skipped */

		size = expSizeGet(u);
		if (rc == EXP_MATCH) {
		    action = &km->action;

		    skip += matchLen;
		    size -= skip;
		    if (size) {
			memcpy(u->buffer, u->buffer + skip, size);
		    }
		} else {
		    if (skip) {
			size -= skip;
			memcpy(u->buffer, u->buffer + skip, size);
		    }
		}
		Tcl_SetObjLength(size);

		/* now update printed based on total amount skipped */

		u->printed -= skip;
		/* if more skipped than printed (i.e., keymap encountered) */
		/* for printed positive */
		if (u->printed < 0) u->printed = 0;

		/* if we are in the middle of a match, force the next event */
		/* to wait for more data to arrive */
		u->force_read = (rc == EXP_CANMATCH);

		/* finally reset echoed if necessary */
		if (rc != EXP_CANMATCH) {
			if (skip >= oldprinted + u->echoed) u->echoed = 0;
		}

		if (action) {
			change = (action && action->tty_reset);
			if (change && tty_changed)
				exp_tty_set(interp,&tty_old,was_raw,was_echo);

			te = inter_eval(interp,action,u);

			if (change && real_tty) tty_changed =
			   exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
			switch (te) {
			case TCL_BREAK:
			case TCL_CONTINUE:
				finish(te);
			case EXP_TCL_RETURN:
				finish(TCL_RETURN);
			case TCL_RETURN:
				finish(TCL_OK);
			case TCL_OK:
				/* god knows what the user might */
				/* have done to us in the way of */
				/* closed fds, so .... */
				action = 0;	/* reset action */
				continue;
			default:
				finish(te);
			}
		}
	    }
	}
}
#endif /* SIMPLE_EVENT */

 done:
#ifdef SIMPLE_EVENT
    /* force child to exit upon eof from master */
    if (pid == 0) {
	exit(SPAWNED_PROCESS_DIED);
    }
#endif /* SIMPLE_EVENT */

    if (need_to_close_master && u->close_on_eof) exp_close(interp,u);

    if (tty_changed) exp_tty_set(interp,&tty_old,was_raw,was_echo);
    if (esPtrs) ckfree((char *)esPtrs);
    if (esPtrToInput) Tcl_DeleteHashTable(esPtrToInput);
    free_input(interp,input_base);
    free_action(action_base);

    if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
    return(status);

 error:
    if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
    return TCL_ERROR;
}

/* version of Tcl_Eval for interact */ 
static int
inter_eval(
    Tcl_Interp *interp,
    struct action *action,
    ExpState *esPtr)
{
    int status;

    if (action->iwrite) {
	out("spawn_id",esPtr->name);
    }

    if (action->statement) {
	status = Tcl_EvalObjEx(interp,action->statement,0);
    } else {
	expStdoutLogU("\r\n",1);
	status = exp_interpreter(interp,(Tcl_Obj *)0);
    }

    return status;
}

static void
free_keymap(struct keymap *km)
{
	if (km == 0) return;
	free_keymap(km->next);

	ckfree((char *)km);
}

static void
free_action(struct action *a)
{
	struct action *next;

	while (a) {
		next = a->next;
		ckfree((char *)a);
		a = next;
	}
}

static void
free_input(
    Tcl_Interp *interp,
    struct input *i)
{
	if (i == 0) return;
	free_input(interp,i->next);

	exp_free_i(interp,i->i_list,inter_updateproc);
	free_output(interp,i->output);
	free_keymap(i->keymap);
	ckfree((char *)i);
}

static struct action *
new_action(struct action **base)
{
	struct action *o = new(struct action);

	/* stick new action into beginning of list of all actions */
	o->next = *base;
	*base = o;

	return o;
}

static void
free_output(
    Tcl_Interp *interp,
    struct output *o)
{
	if (o == 0) return;
	free_output(interp,o->next);
	exp_free_i(interp,o->i_list,inter_updateproc);

	ckfree((char *)o);
}


static struct exp_cmd_data cmd_data[]  = {
{"interact",	Exp_InteractObjCmd,	0,	0,	0},
{0}};

void
exp_init_interact_cmds(Tcl_Interp *interp)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    exp_create_commands(interp,cmd_data);

    tsdPtr->cmdObjReturn = Tcl_NewStringObj("return",6);
    Tcl_IncrRefCount(tsdPtr->cmdObjReturn);
#if 0
    tsdPtr->cmdObjInterpreter = Tcl_NewStringObj("interpreter",11);
    Tcl_IncrRefCount(tsdPtr->cmdObjInterpreter);
#endif
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.45
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@d48 5
@


5.44
log
@ANSIfication changes
@
text
@d532 1
a532 1
sigchld_handler(void)
d2251 1
a2251 1

@


5.43
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d532 1
a532 1
sigchld_handler()
@


5.42
log
@
	* configure.in: Bumped version to 5.44.1.7.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* exp_command.c: Fixed more compiler warnings, and started
	* exp_command.h: to ansify the code base, beginning with
	* exp_inter.c: the introduction of proper function prototypes.
	* exp_main_exp.c:
	* exp_pty.h:
	* exp_tty.c:
	* exp_tty.h:
	* exp_win.c:
	* expect.c:
	* pty_termios.c:
	* retoglob.c:
@
text
@d2251 1
a2251 1

@


5.41
log
@
	* configure.in: Bumped version to 5.44.1.6.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* configure.in: Fixed checking of stty on linux, do not restrict
	  to specific cpu's. Further try with stdin, and stdin redirected
	  to /dev/tty when determining if stdout is read.

	* testsuite/configure.in: Brought up to TEA 3.5.
	* testsuite/aclocal.m4: New file, to import the TEA definitions.

	* Dbg.c: Added missed CONST in declaration and definition of
	  'debugger_trap'.

	* exp_command.c: Fixed pointer aliasing trouble with
	  'Tcl_DetachPids', and added the missing initialization of the
	  command string in the 'overlay' command.

	* expect.c: Fixed missing initialization of 'simple_start' element
	  of 'ecase'.

	* exp_inter.c: Fixed bogus use of 'slen' in 'intMatch'. The
	  relevant string is Tcl_Unichar, not Utf.

	* Makefile.in: Replaced bogus INSTALL_ROOT with DESTDIR, and added
	  missing DESTDIR references to the target for the installation of
	  the manpages.
@
text
@d128 3
a130 3
expStateToInput(hash,esPtr)
    ExpState *esPtr;
    Tcl_HashTable *hash;
d142 4
a145 4
expCreateStateToInput(hash,esPtr,inp)
    ExpState *esPtr;
    Tcl_HashTable *hash;
    struct input *inp;
d154 9
a162 6
static void free_input();
static void free_keymap();
static void free_output();
static void free_action();
static struct action *new_action();
static int inter_eval();
d193 7
a199 7
intMatch(esPtr,keymap,km_match,matchLen,skip,info)
    ExpState *esPtr;
    struct keymap *keymap;	/* linked list of keymaps */
    struct keymap **km_match;	/* keymap that matches or can match */
    int *matchLen;		/* # of bytes that matched */
    int *skip;			/* # of chars to skip */
    Tcl_RegExpInfo *info;
d350 6
a355 6
intRegExpMatchProcess(interp,esPtr,km,info,offset)
     Tcl_Interp *interp;
     ExpState *esPtr;
     struct keymap *km;	/* ptr for above while parsing */
     Tcl_RegExpInfo *info;
     int offset;
d396 4
a399 4
intEcho(esPtr,skipBytes,matchBytes)
    ExpState *esPtr;
    int skipBytes;
    int matchBytes;
d427 6
a432 6
intRead(interp,esPtr,warnOnBufferFull,interruptible,key)
    Tcl_Interp *interp;
    ExpState *esPtr;
    int warnOnBufferFull;
    int interruptible;
    int key;
d555 5
a559 5
intIRead(channel,obj,size,flags);
Tcl_Channel channel;
Tcl_Obj *obj;
int size;
int flags;
d584 3
a586 3
clean_up_after_child(interp,esPtr)
Tcl_Interp *interp;
ExpState *esPtr;
d599 9
a607 10
update_interact_fds(interp,esPtrCount,esPtrToInput,esPtrs,input_base,
			do_indirect,config_count,real_tty_caller)
Tcl_Interp *interp;
int *esPtrCount;
Tcl_HashTable **esPtrToInput;	/* map from ExpStates to "struct inputs" */
ExpState ***esPtrs;
struct input *input_base;
int do_indirect;		/* if true do indirects */
int *config_count;
int *real_tty_caller;
d691 6
a696 6
inter_updateproc(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;	/* Interpreter containing variable. */
char *name1;		/* Name of variable. */
char *name2;		/* Second part of variable name. */
int flags;		/* Information about what happened. */
d709 5
a713 5
Exp_InteractObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d718 1
d2152 4
a2155 4
inter_eval(interp,action,esPtr)
Tcl_Interp *interp;
struct action *action;
ExpState *esPtr;
d2174 1
a2174 2
free_keymap(km)
struct keymap *km;
d2183 1
a2183 2
free_action(a)
struct action *a;
d2195 3
a2197 3
free_input(interp,i)
Tcl_Interp *interp;
struct input *i;
d2209 1
a2209 2
new_action(base)
struct action **base;
d2221 3
a2223 3
free_output(interp,o)
Tcl_Interp *interp;
struct output *o;
d2238 1
a2238 2
exp_init_interact_cmds(interp)
Tcl_Interp *interp;
@


5.40
log
@
	* exp_inter.c: Changed inclusion of tcl.h to tclInt.h to get the
	* expect.c: definition of TCL_REG_BOSONLY, which was moved to that
	  header in Tcl 8.5. Ditto for expect.c, for the macro
	  TclUtfToUniChar (was a function in 8.4). Expect now compiles
	  again for both Tcl 8.4 and 8.5.

	* configure.in: Bumped version to 5.44.1.4.
	* configure: Regenerated.
@
text
@d253 1
a253 1
		int slen, kslen;
d259 1
a259 1
		for (s = start_search;; s += slen, ks += kslen) {
@


5.39
log
@
	* exp_chan.c: Converted the buffering system from UTF-8 in Tcl_Obj
	* exp_command.h: to UTF-16 C-array, to avoid the repeated conversion
	* expect.c: of the input from utf-8 to utf-16. Updated the glob
	* exp_glob.c: matching code to use the same tricks for speed which
	* exp_inter.c: are used by the Tcl core. Extended the regexp
	* exp_log.c: matching path with a glob matcher which uses a gate
	* exp_log.h: keeper glob pattern to weed out most non-candidates
	* retoglob.c (New file): in a speedy manner. Regexp matching now
	  has to be done only for the small number of candidates
	  identified by the gate keeper. Overall speed improvement as glob
	  matching is faster than regexp matching. Added code translating
	  regular expressions into their gate keeper glob pattern.
@
text
@d38 1
a38 1
#include "tcl.h"
@


5.38
log
@
	* exp_command.c: Reformatted overlong lines, whitespace,
	* expect.c: comments. Added braces to some if-constructs.
	* exp_inter.c: Reworked if-constructs interleaved with
	* exp_tty.c: #if for better formatting in emacs.
@
text
@d46 1
d198 1
a198 1
    char *string;
d202 1
a202 1
    char *start_search;	/* where in string to start searching */
d205 2
a206 2
    char *string_end;
    int stringBytes, bytesThisChar;
d210 2
a211 1
    string = Tcl_GetStringFromObj(esPtr->buffer,&stringBytes);
d219 1
a219 1
	*skip = stringBytes;
d225 1
a225 1
    string_end = string + stringBytes;
d234 1
a234 1
	 start_search += bytesThisChar, offset++) {
d236 1
a236 1
	bytesThisChar = Tcl_UtfToUniChar(start_search, &ch);
d243 1
a243 1
	    char *s;	/* current character being examined */
d279 1
a279 1
		    slen = Tcl_UtfToUniChar(s, &sch);
d294 1
d300 4
a303 1
		result = Tcl_RegExpExecObj(NULL, re, esPtr->buffer, offset,
d305 1
d310 1
a310 1
		    *matchLen = Tcl_UtfAtIndex(start_search,info->matches[0].end) - start_search;
d356 1
d380 1
a380 1
	val = Tcl_GetRange(esPtr->buffer, start, end);
d386 1
d412 2
a413 2
    (void) expWriteChars(esPtr,
		   Tcl_GetString(esPtr->buffer) + offsetBytes,
d431 1
a431 1
    char *eobOld;  /* old end of buffer */
d433 2
a434 5
    int size;
    char *str;

    str = Tcl_GetStringFromObj(esPtr->buffer,&size);
    eobOld = str+size;
d436 7
a442 1
    if (size + TCL_UTF_MAX >= esPtr->msize) {
d457 3
a459 4
	cc = Tcl_ReadChars(esPtr->channel,
		esPtr->buffer,
		esPtr->msize - (size / TCL_UTF_MAX),
		1 /* append */);
d462 3
a464 4
	cc = intIRead(esPtr->channel,
		esPtr->buffer,
		esPtr->msize - (size / TCL_UTF_MAX),
		1 /* append */);
d469 5
d475 1
a475 1
	expDiagLogU(expPrintify(eobOld));
d717 2
d779 1
d782 8
a789 1
	return(exp_eval_with_one_arg(clientData,interp,objv));
d791 2
d796 5
a800 1
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d875 1
a875 1
		return TCL_ERROR;
d886 1
a886 1
			return(TCL_ERROR);
d900 1
a900 1
			return TCL_ERROR;
d924 1
a924 1
			return(TCL_ERROR);
d928 3
a930 1
		    if (!inp->i_list) return TCL_ERROR;
d948 1
a948 1
			return(TCL_ERROR);
d952 3
a954 1
		    if (!outp->i_list) return TCL_ERROR;
d963 1
a963 1
			return(TCL_ERROR);
d977 2
a978 2
		      exp_error(interp,"cannot use -o more than once");
		      return TCL_ERROR;
d1046 1
a1046 1
			return(TCL_ERROR);
d1050 1
a1050 1
			return TCL_ERROR;
d1126 1
a1126 1
			return(TCL_ERROR);
d1129 1
a1129 1
			return TCL_ERROR;
d1223 1
a1223 1
		return(TCL_ERROR);
d1229 3
a1231 1
	    if (!o->i_list) return TCL_ERROR;
d1257 2
a1258 1
	if (!input_user->i_list) return TCL_ERROR;
d1262 2
a1263 1
	if (!input_default->output->i_list) return TCL_ERROR;
d1279 1
a1279 1
		return(TCL_ERROR);
d1287 2
a1288 1
	    if (!input_default->i_list) return TCL_ERROR;
d1305 1
a1305 1
	return(TCL_ERROR);
d1386 2
a1387 1
	if (rc == EXP_TCLERROR) return(TCL_ERROR);
d1501 1
a1501 1
			    Tcl_GetString(u->buffer) + u->printed,
d1552 2
a1553 2
		string = Tcl_GetString(u->buffer);
		memmove(string, string + skip, size);
d1556 1
a1556 1
	    string = Tcl_GetString(u->buffer);
d1559 1
a1559 1
		memcpy(string, string + skip, size);
d1562 1
a1562 1
	Tcl_SetObjLength(u->buffer,size);
d1773 1
a1773 1
				    Tcl_GetString(u->buffer) + u->printed,
d2014 1
a2014 1
				    Tcl_GetString(u->buffer) + u->printed,
d2139 1
d2141 4
d2252 8
@


5.37
log
@
	* exp_inter.c: Changed all uses of 'time(3)' to Tcl_GetTime. IOW
	* expect.c:    go through the abstract core API instead of
	               directly acessing OS time. This makes the code
	               dependent on Tcl 8.4, as Tcl_GetTime was not public
	               before. See TIP #73 for its introduction into the
	               public API. As for the reason behind _this_ change
	               see TIP #233. Our change here now causes Expect to
	               be automatically in sync with any virtualization
	               set up in the core.
@
text
@d547 1
d549 1
a549 1
    if (0 == sigsetjmp(env,1)) {
d551 1
a551 1
    if (0 == setjmp(env)) {
d553 1
@


5.36
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@d1307 1
d1324 2
a1325 1
	    time(&previous_time);
d1359 2
a1360 1
	    time(&current_time);
d1630 2
a1631 1
			time(&previous_time);
d1646 2
a1647 1
			time(&current_time);
d1860 2
a1861 1
			time(&previous_time);
d1875 2
a1876 1
			time(&current_time);
@


5.35
log
@
	* Merged changes from the official version 5.41 of expect into the
	  SF sources. See details below.

	  --------------------
	  Simon Taylor <simon@@unisolve.com.xau> provided fix for interact
	  -o which was completely broken by 5.40.1.

	  Added scroll support to official tkterm.  Copied all fixes
	  from/to term_expect to/from tkterm.

	  Kiran Madabhushi <maskiran@@hotmail.xcom> encountered interact
	  diagnostics incorrectly pointing to expect_background.  Also,
	  found multiple -o flags behaving unexpectedly.  Added diag.

	  Kristoffer Eriksson <ske@@pkmab.xse> noted typo in SIMPLE code in
	  exp_inter.c.  However, this is extremely unlikely to affect any
	  machines.

	  Reinhard Max <max@@suse.xcom> noted that "make test" failed when
	  run in the background.  The log testcase was testing the
	  send_tty command.  Added code in both Expect and in the test to
	  handle this.
	  --------------------
@
text
@d403 1
a403 1
    Tcl_WriteChars(esPtr->channel,
d572 1
d575 1
d1457 1
a1457 1
		    if (wc <= 0) {
d1535 1
d1537 1
d1727 1
a1727 1
			    if (wc <= 0) {
d1966 1
a1966 1
			    if (wc <= 0) {
d2081 1
a2081 1
    if (need_to_close_master) exp_close(interp,u);
@


5.34
log
@
	* Merged changes from the official version 5.39 of expect into the
	  SF sources. See details below. Partially already done.

	  --------------------
	  Poorva Gupta <poorva@@cup.hp.xcom> noted that grantpt/unlockpt
	  order was backward.  Strange that this was never a prob before!

	  Eric Raymond <esr@@snark.thyrsus.xcom> provided a troff-related
	  fix for the multixterm man page.

	  Nicolas Roeser <n-roeser@@gmx.xnet> noted confusion with md5 so I
	  made the Expect page more explicit about which file that hash
	  was based on.

	  Josh Purinton noted that earlier fix wasn't quite right.  Exit
	  on INT/TERM should cause Expect to exit with signal embedded in
	  status.  He also requested I obfuscate email addresses in this
	  file.

	  Guido Ostkamp <Guido.Ostkamp@@t-online.xde> and Igor Sobrado
	  <sobrado@@string1.ciencias.uniovi.xes> noted that fixline1
	  rewrote scripts to be expect scripts even if they were expectk
	  scripts.

	  Dirk Petera <dirkpetera@@yahoo.xcom> noted that any_spawn_id used
	  to work but did no longer.  Looks like a bug left over from the
	  the I18L conversion.  Fixed.

	  Steve Szabo noted exp_log_file -open channel failed.  Fixed.

	  Fixed bug from 5.31 that prevent stty from returning messages
	  from underlying program.

	  Thomas Dickey <dickey@@herndon4.his.xcom> noted that ncurses
	  ignores 2-char term names because of, well, poor assumptions and
	  coding.  Changed tkterm to use longer names.

	  Heath Moore <hmoore@@systran.xcom> noted that exp_clib could lock
	  up if remtime happened to be precisely 0.  Recoded to avoid.

	  At request of Per Otterholm <otterholm@@telia.xcom>, wrote script
	  to read from stdin and echo passwords (exercise 9 in Tk chapter
	  of Expect book).  Added to example directory as passwdprompt.

	  Josh Purinton <josh@@purinton.xorg> pointed out that by default,
	  SIGINT/TERM should cause expect's return status to be 1, not 0.

	  Paul Reithmuller <paul.reithmuller@@eng.sun.xcom> noted that
	  unbuffer shouldn't postprocess its output.  Added stty_init.

	  Mordechai T. Abzug <morty@@sanctuary.arbutus.md.xus> noted that
	  log_file wasn't recording -append status.

	  James Kelly <macubergeek@@comcast.xnet> noted weather example
	  needed new source.

	  Dimitar Haralanov <mitko@@tahoenetworks.xcom> noted that interact
	  dumped core with interact { timeout 1 }
	  --------------------
@
text
@d373 1
a373 1
	expDiagLog("expect_background: set %s(%s) \"",INTER_OUT,name);
d745 1
d937 6
d945 3
a947 3
			dash_input_count = 2;
			inp = input_default;
			action_eof_ptr = &inp->action_eof;
d1761 1
a1761 1
		if (rc =n= EXP_MATCH) {
@


5.33
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@d1079 1
a1079 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"timeout time");
d1095 5
a1099 1
		    action->statement = *objv;
@


5.32
log
@
	* Resynchronization of SourceForge with Don's sources to Expect
	  version 5.34. The changes are

	  Don Porter <don.porter@@nist.gov> provided package-related fixes
	  for test suite.

	  Brian Theado <brian.theado@@usa.net> noted that interact's -re
	  support broke when offsets kicked in.  Turned out that the
	  regexp engine supports them during execution but the results are
	  delivered RELATIVE to the offset.  (I suspect this was done
	  due to expediency.)
@
text
@d892 1
d914 1
a914 1

d1179 1
d1205 1
d1209 1
d1233 1
@


5.31
log
@
	* exp_inter.c: Applied patch posted by Don libes to c.l.t. on his
	  behalf to keep the SF repository in sync with his changes. Don's
	  notes: I obviously missed the fact that although
	  "Tcl_RegExpExecObj" supports offsets, they aren't delivered to
	  "Tcl_RegExpGetInfo".
@
text
@d1672 1
a1672 1
			intRegExpMatchProcess(interp,u,km,&reInfo);
d1911 1
a1911 1
			intRegExpMatchProcess(interp,u,km,&reInfo);
@


5.30
log
@
Upgrading to 5.33.
@
text
@d340 1
a340 1
intRegExpMatchProcess(interp,esPtr,km,info)
d345 1
d354 1
a354 1
	start = info->matches[i].start;
d356 1
a356 1
	end = info->matches[i].end-1;
d1400 1
a1400 1
		intRegExpMatchProcess(interp,u,km,&reInfo);
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d294 1
a294 1
			TCL_REG_ADVANCED|TCL_REG_BOSONLY);
@


5.29.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.29.2.1
log
@Upgrading to 5.33.
@
text
@d294 1
a294 1
			TCL_REG_ADVANCED|TCL_REG_BOSONLY|TCL_REG_CANMATCH);
@


5.29.2.2
log
@
	* exp_inter.c: Applied patch posted by Don libes to c.l.t. on his
	  behalf to keep the SF repository in sync with his changes. Don's
	  notes: I obviously missed the fact that although
	  "Tcl_RegExpExecObj" supports offsets, they aren't delivered to
	  "Tcl_RegExpGetInfo".
@
text
@d340 1
a340 1
intRegExpMatchProcess(interp,esPtr,km,info,offset)
a344 1
     int offset;
d353 1
a353 1
	start = info->matches[i].start + offset;
d355 1
a355 1
	end = (info->matches[i].end-1) + offset;
d1399 1
a1399 1
		intRegExpMatchProcess(interp,u,km,&reInfo,skip);
@


5.29.2.3
log
@
	* Resynchronization of SourceForge with Don's sources to Expect
	  version 5.34. The changes are

	  Don Porter <don.porter@@nist.gov> provided package-related fixes
	  for test suite.

	  Brian Theado <brian.theado@@usa.net> noted that interact's -re
	  support broke when offsets kicked in.  Turned out that the
	  regexp engine supports them during execution but the results are
	  delivered RELATIVE to the offset.  (I suspect this was done
	  due to expediency.)
@
text
@d1672 1
a1672 1
			intRegExpMatchProcess(interp,u,km,&reInfo,skip);
d1911 1
a1911 1
			intRegExpMatchProcess(interp,u,km,&reInfo,skip);
@


5.29.2.4
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@a891 1
		    if (!inp->i_list) return TCL_ERROR;
d913 1
a913 1
		    if (!outp->i_list) return TCL_ERROR;
a1177 1
	    if (!o->i_list) return TCL_ERROR;
a1202 1
	if (!input_user->i_list) return TCL_ERROR;
a1205 1
	if (!input_default->output->i_list) return TCL_ERROR;
a1228 1
	    if (!input_default->i_list) return TCL_ERROR;
@


5.29.4.1
log
@Top-level source files removed.
@
text
@@


5.28
log
@Initial revision
@
text
@a45 1
#include "exp_tstamp.h"	/* remove when timestamp stuff is gone */
d47 4
a50 2
#include "tclRegexp.h"
#include "exp_regexp.h"
d52 1
a52 2
extern char *TclGetRegError();
extern void TclRegError();
d55 5
d78 2
a79 2
#define real_tty_output(x) (((x)==1) || ((x)==exp_dev_tty))
#define real_tty_input(x) (exp_stdin_is_tty && (((x)==0) || ((x)==exp_dev_tty)))
d84 1
a84 1
	char *statement;
a87 1
	int timestamp;		/* if true, generate timestamp */
d92 2
a93 2
	char *keys;	/* original pattern provided by user */
	regexp *re;
d120 33
d160 1
a160 1
/* in_keymap() accepts user keystrokes and returns one of MATCH,
d167 1
a167 1
in_keymap is optimized (if you can call it that) towards a small
d189 7
a195 8
in_keymap(string,stringlen,keymap,km_match,match_length,skip,rm_nulls)
char *string;
int stringlen;
struct keymap *keymap;		/* linked list of keymaps */
struct keymap **km_match;	/* keymap that matches or can match */
int *match_length;		/* # of chars that matched */
int *skip;			/* # of chars to skip */
int rm_nulls;			/* skip nulls if true */
d197 23
a219 4
	struct keymap *km;
	char *ks;		/* string from a keymap */
	char *start_search;	/* where in the string to start searching */
	char *string_end;
d221 1
a221 1
	/* assert (*km == 0) */
d223 1
a223 7
	/* a shortcut that should help master output which typically */
	/* is lengthy and has no key maps.  Otherwise it would mindlessly */
	/* iterate on each character anyway. */
	if (!keymap) {
		*skip = stringlen;
		return(EXP_CANTMATCH);
	}
d225 4
a228 1
	string_end = string + stringlen;
d230 3
a232 2
	/* Mark beginning of line for ^ . */
	regbol = string;
d234 2
a235 3
/* skip over nulls - Pascal Meheut, pascal@@cnam.cnam.fr 18-May-1993 */
/*    for (start_search = string;*start_search;start_search++) {*/
    for (start_search = string;start_search<string_end;start_search++) {
d244 1
a244 1
		if (*start_search == 0) {
d246 1
a246 1
		    *match_length = 1;	/* s - start_search == 1 */
d251 3
a254 8
		for (s = start_search,ks = km->keys ;;s++,ks++) {
			/* if we hit the end of this map, must've matched! */
			if (*ks == 0) {
				*skip = start_search-string;
				*match_length = s-start_search;
				*km_match = km;
				return(EXP_MATCH);
			}
d256 9
a264 10
			/* if we ran out of user-supplied characters, and */
			/* still haven't matched, it might match if the user */
			/* supplies more characters next time */

			if (s == string_end) {
				/* skip to next key entry, but remember */
				/* possibility that this entry might match */
				if (!*km_match) *km_match = km;
				break;
			}
d266 8
a273 7
			/* if this is a problem for you, use exp_parity command */
/*			if ((*s & 0x7f) == *ks) continue;*/
			if (*s == *ks) continue;
			if ((*s == '\0') && rm_nulls) {
				ks--;
				continue;
			}
d275 11
d289 24
a312 21
		int r;	/* regtry status */
		regexp *prog = km->re;

		/* if anchored, but we're not at beginning, skip pattern */
		if (prog->reganch) {
			if (string != start_search) continue;
		}

		/* known starting char - quick test 'fore lotta work */
		if (prog->regstart) {
			/* if this is a problem for you, use exp_parity command */
/*			/* if ((*start_search & 0x7f) != prog->regstart) continue; */
			if (*start_search != prog->regstart) continue;
		}
		r = exp_regtry(prog,start_search,match_length);
		if (r == EXP_MATCH) {
			*km_match = km;
			*skip = start_search-string;
			return(EXP_MATCH);
		}
		if (r == EXP_CANMATCH) {
d314 2
a315 1
		}
d320 2
a321 2
	if (*km_match) {
		/* report a can-match */
d323 85
a407 1
		char *p;
d409 45
a453 20
		*skip = (start_search-string)-1;
#if 0
		*match_length = stringlen - *skip;
#else
		/*
		 * there may be nulls in the string in which case
		 * the pattern matchers can report CANMATCH when
		 * the null is hit.  So find the null and compute
		 * the length of the possible match.
		 *
		 * Later, after we squeeze out the nulls, we will
		 * retry the match, but for now, go along with
		 * calling it a CANMATCH
		 */
		p = start_search;
		while (*p) {
			p++;
		}
		*match_length = (p - start_search) + 1;
		/*printf(" match_length = %d\n",*match_length);*/
d455 6
a460 2
		return(EXP_CANMATCH);
	}
d462 3
a464 2
	*skip = start_search-string;
	return(EXP_CANTMATCH);
d467 2
d500 3
d504 2
d509 2
a510 2
				/* in i_read record this here, so it will */
				/* be handled next time through i_read */
d512 2
a513 1
void sigchld_handler()
d515 8
a522 3
	if (reading) longjmp(env,1);

	deferred_interrupt = TRUE;
d527 8
a534 1
/* interruptable read */
d536 5
a540 4
i_read(fd,buffer,length)
int fd;
char *buffer;
int length;
d542 1
a542 1
	int cc = EXP_CHILD_EOF;
d544 1
a544 1
	if (deferred_interrupt) return(cc);
d546 10
a555 6
	if (0 == setjmp(env)) {
		reading = TRUE;
		cc = read(fd,buffer,length);
	}
	reading = FALSE;
	return(cc);
d563 1
a563 1
clean_up_after_child(interp,master)
d565 1
a565 1
int master;
d567 2
a568 4
/* should really be recoded using the common wait code in command.c */
	int status;
	int pid;
	int i;
d570 2
a571 18
	pid = wait(&status);	/* for slave */
	for (i=0;i<=exp_fd_max;i++) {
		if (exp_fs[i].pid == pid) {
			exp_fs[i].sys_waited = TRUE;
			exp_fs[i].wait = status;
		}
	}
	pid = wait(&status);	/* for child */
	for (i=0;i<=exp_fd_max;i++) {
		if (exp_fs[i].pid == pid) {
			exp_fs[i].sys_waited = TRUE;
			exp_fs[i].wait = status;
		}
	}

	deferred_interrupt = FALSE;
	exp_close(interp,master);
	master = -1;
d576 1
a576 1
update_interact_fds(interp,fd_count,fd_to_input,fd_list,input_base,
d579 3
a581 3
int *fd_count;
struct input ***fd_to_input;	/* map from fd's to "struct input"s */
int **fd_list;
d589 1
a589 1
	struct exp_fd_list *fdp;
d613 7
a619 6
		for (fdp = inp->i_list->fd_list;fdp;fdp=fdp->next) {
			count++;
			/* have to "adjust" just in case spawn id hasn't had */
			/* a buffer sized yet */
			if (!exp_fd2f(interp,fdp->fd,1,1,"interact"))
				return(TCL_ERROR);
d624 1
a624 1
			for (fdp = outp->i_list->fd_list;fdp;fdp=fdp->next) {
d626 4
a629 6
				if (fdp->fd == 0) {
					fdp->fd = 1;
				} else if (fdp->fd == 1) {
					/* do nothing */
				} else if (!exp_fd2f(interp,fdp->fd,1,0,"interact"))
					return(TCL_ERROR);
d635 3
a637 4
	if (*fd_to_input == 0) {
		*fd_to_input = (struct input **)ckalloc(
				(exp_fd_max+1) * sizeof(struct input *));
		*fd_list = (int *)ckalloc(count * sizeof(int));
d639 3
a641 3
		*fd_to_input = (struct input **)ckrealloc((char *)*fd_to_input,
				(exp_fd_max+1) * sizeof(struct input *));
		*fd_list = (int *)ckrealloc((char *)*fd_list,count * sizeof(int));
d643 1
d647 3
a649 3
		for (fdp = inp->i_list->fd_list;fdp;fdp=fdp->next) {
			/* build map to translate from spawn_id to struct input */
			(*fd_to_input)[fdp->fd] = inp;
d651 2
a652 2
			/* build input to ready() */
			(*fd_list)[count] = fdp->fd;
d654 1
a654 1
			if (real_tty_input(fdp->fd)) real_tty = TRUE;
d656 2
a657 2
			count++;
		}
d659 1
a659 1
	*fd_count = count;
d687 1
a687 1
Exp_InteractCmd(clientData, interp, argc, argv)
d690 2
a691 2
int argc;
char **argv;
d693 4
a696 1
	char *arg;	/* shorthand for current argv */
d698 1
a698 1
	int pid;
d701 11
a711 9
	/*declarations*/
	int input_count;	/* count of struct input descriptors */
	struct input **fd_to_input;	/* map from fd's to "struct input"s */
	int *fd_list;
	struct keymap *km;	/* ptr for above while parsing */
/* 	extern char *tclRegexpError;	/* declared in tclInt.h */
	int master = EXP_SPAWN_ID_BAD;
	char *master_string = 0;/* string representation of master */
	int need_to_close_master = FALSE;	/* if an eof is received */
d714 11
a724 13
	int next_tty_reset = FALSE;	/* if we've seen a single -reset */
	int next_iread = FALSE;/* if we've seen a single -iread */
	int next_iwrite = FALSE;/* if we've seen a single -iread */
	int next_re = FALSE;	/* if we've seen a single -re */
	int next_null = FALSE;	/* if we've seen the null keyword */
	int next_writethru = FALSE;/*if macros should also go to proc output */
	int next_indices = FALSE;/* if we should write indices */
	int next_echo = FALSE;	/* if macros should be echoed */
	int next_timestamp = FALSE; /* if we should generate a timestamp */
/*	int next_case_sensitive = TRUE;*/
	char **oldargv = 0;	/* save original argv here if we split it */
	int status = TCL_OK;	/* final return value */
	int i;			/* trusty temp */
d726 1
a726 1
	int timeout_simple = TRUE;	/* if no or global timeout */
d728 2
a729 2
	int real_tty;		/* TRUE if we are interacting with real tty */
	int tty_changed = FALSE;/* true if we had to change tty modes for */
d731 3
a733 3
	int was_raw;
	int was_echo;
	exp_tty tty_old;
d735 1
a735 1
	char *replace_user_by_process = 0; /* for -u flag */
d737 1
a737 1
	struct input *input_base;
d739 10
a748 10
	struct input *input_default;
	struct input *inp;	/* overused ptr to struct input */
	struct output *outp;	/* overused ptr to struct output */

	int dash_input_count = 0; /* # of "-input"s seen */
	int arbitrary_timeout;
	int default_timeout;
	struct action action_timeout;	/* common to all */
	struct action action_eof;	/* common to all */
	struct action **action_eof_ptr;	/* allow -input/ouput to */
d751 2
a752 2
	struct action *action_base = 0;
	struct keymap **end_km;
d754 2
a755 2
	int key;
	int configure_count;	/* monitor reconfigure events */
d757 10
a766 8
	if ((argc == 2) && exp_one_arg_braced(argv[1])) {
		return(exp_eval_with_one_arg(clientData,interp,argv));
	} else if ((argc == 3) && streq(argv[1],"-brace")) {
		char *new_argv[2];
		new_argv[0] = argv[0];
		new_argv[1] = argv[2];
		return(exp_eval_with_one_arg(clientData,interp,new_argv));
	}
d768 2
a769 2
	argv++;
	argc--;
d771 2
a772 2
	default_timeout = EXP_TIME_INFINITY;
	arbitrary_timeout = EXP_TIME_INFINITY;	/* if user specifies */
d776 118
a893 59
	input_user = new(struct input);
	input_user->i_list = exp_new_i_simple(0,EXP_TEMPORARY); /* stdin by default */
	input_user->output = 0;
	input_user->action_eof = &action_eof;
	input_user->timeout_nominal = EXP_TIME_INFINITY;
	input_user->action_timeout = 0;
	input_user->keymap = 0;

	end_km = &input_user->keymap;
	inp = input_user;
	action_eof_ptr = &input_user->action_eof;

	input_default = new(struct input);
	input_default->i_list = exp_new_i_simple(EXP_SPAWN_ID_BAD,EXP_TEMPORARY); /* fix up later */
	input_default->output = 0;
	input_default->action_eof = &action_eof;
	input_default->timeout_nominal = EXP_TIME_INFINITY;
	input_default->action_timeout = 0;
	input_default->keymap = 0;
	input_default->next = 0;		/* no one else */
	input_user->next = input_default;

	/* default and common -eof action */
	action_eof.statement = return_cmd;
	action_eof.tty_reset = FALSE;
	action_eof.iread = FALSE;
	action_eof.iwrite = FALSE;
	action_eof.timestamp = FALSE;

	for (;argc>0;argc--,argv++) {
		arg = *argv;
		if (exp_flageq("eof",arg,3)) {
			struct action *action;

			argc--;argv++;
			*action_eof_ptr = action = new_action(&action_base);

			action->statement = *argv;

			action->tty_reset = next_tty_reset;
			next_tty_reset = FALSE;
			action->iwrite = next_iwrite;
			next_iwrite = FALSE;
			action->iread = next_iread;
			next_iread = FALSE;
			action->timestamp = next_timestamp;
			next_timestamp = FALSE;
			continue;
		} else if (exp_flageq("timeout",arg,7)) {
			int t;
			struct action *action;

			argc--;argv++;
			if (argc < 1) {
				exp_error(interp,"timeout needs time");
				return(TCL_ERROR);
			}
			t = atoi(*argv);
			argc--;argv++;
d895 2
a896 63
			/* we need an arbitrary timeout to start */
			/* search for lowest one later */
			if (t != -1) arbitrary_timeout = t;

			timeout_simple = FALSE;
			action = inp->action_timeout = new_action(&action_base);
			inp->timeout_nominal = t;

			action->statement = *argv;

			action->tty_reset = next_tty_reset;
			next_tty_reset = FALSE;
			action->iwrite = next_iwrite;
			next_iwrite = FALSE;
			action->iread = next_iread;
			next_iread = FALSE;
			action->timestamp = next_timestamp;
			next_timestamp = FALSE;
			continue;
		} else if (exp_flageq("null",arg,4)) {
			next_null = TRUE;			
		} else if (arg[0] == '-') {
			arg++;
			if (exp_flageq1('-',arg)		/* "--" */
			 || (exp_flageq("exact",arg,3))) {
				argc--;argv++;
			} else if (exp_flageq("regexp",arg,2)) {
				if (argc < 1) {
					exp_error(interp,"-re needs pattern");
					return(TCL_ERROR);
				}
				next_re = TRUE;
				argc--;
				argv++;
			} else if (exp_flageq("input",arg,2)) {
				dash_input_count++;
				if (dash_input_count == 2) {
					inp = input_default;
					input_user->next = input_default;
				} else if (dash_input_count > 2) {
					struct input *previous_input = inp;
					inp = new(struct input);
					previous_input->next = inp;
				}
				inp->output = 0;
				inp->action_eof = &action_eof;
				action_eof_ptr = &inp->action_eof;
				inp->timeout_nominal = default_timeout;
				inp->action_timeout = &action_timeout;
				inp->keymap = 0;
				end_km = &inp->keymap;
				inp->next = 0;
				argc--;argv++;
				if (argc < 1) {
					exp_error(interp,"-input needs argument");
					return(TCL_ERROR);
				}
/*				inp->spawn_id = atoi(*argv);*/
				inp->i_list = exp_new_i_complex(interp,*argv,
						EXP_TEMPORARY,inter_updateproc);
				continue;
			} else if (exp_flageq("output",arg,3)) {
				struct output *tmp;
d898 1
a898 4
				/* imply a "-input" */
				if (dash_input_count == 0) dash_input_count = 1;

				outp = new(struct output);
d901 207
a1107 264
				tmp = inp->output;
				inp->output = outp;
				outp->next = tmp;

				argc--;argv++;
				if (argc < 1) {
					exp_error(interp,"-output needs argument");
					return(TCL_ERROR);
				}
				outp->i_list = exp_new_i_complex(interp,*argv,
					EXP_TEMPORARY,inter_updateproc);

				outp->action_eof = &action_eof;
				action_eof_ptr = &outp->action_eof;
				continue;
			} else if (exp_flageq1('u',arg)) {	/* treat process as user */
				argc--;argv++;
				if (argc < 1) {
					exp_error(interp,"-u needs argument");
					return(TCL_ERROR);
				}
				replace_user_by_process = *argv;

				/* imply a "-input" */
				if (dash_input_count == 0) dash_input_count = 1;

				continue;
			} else if (exp_flageq1('o',arg)) {
				/* apply following patterns to opposite side */
				/* of interaction */

				end_km = &input_default->keymap;

				/* imply two "-input" */
				if (dash_input_count < 2) {
					dash_input_count = 2;
					inp = input_default;
					action_eof_ptr = &inp->action_eof;
				}
				continue;
			} else if (exp_flageq1('i',arg)) {
				/* substitute master */

				argc--;argv++;
/*				master = atoi(*argv);*/
				master_string = *argv;
				/* will be used later on */

				end_km = &input_default->keymap;

				/* imply two "-input" */
				if (dash_input_count < 2) {
					dash_input_count = 2;
					inp = input_default;
					action_eof_ptr = &inp->action_eof;
				}
				continue;
/*			} else if (exp_flageq("nocase",arg,3)) {*/
/*				next_case_sensitive = FALSE;*/
/*				continue;*/
			} else if (exp_flageq("echo",arg,4)) {
				next_echo = TRUE;
				continue;
			} else if (exp_flageq("nobuffer",arg,3)) {
				next_writethru = TRUE;
				continue;
			} else if (exp_flageq("indices",arg,3)) {
				next_indices = TRUE;
				continue;
			} else if (exp_flageq1('f',arg)) {
				/* leftover from "fast" days */
				continue;
			} else if (exp_flageq("reset",arg,5)) {
				next_tty_reset = TRUE;
				continue;
			} else if (exp_flageq1('F',arg)) {
				/* leftover from "fast" days */
				continue;
			} else if (exp_flageq("iread",arg,2)) {
				next_iread = TRUE;
				continue;
			} else if (exp_flageq("iwrite",arg,2)) {
				next_iwrite = TRUE;
				continue;
			} else if (exp_flageq("eof",arg,3)) {
				struct action *action;

				argc--;argv++;
				debuglog("-eof is deprecated, use eof\r\n");
				*action_eof_ptr = action = new_action(&action_base);
				action->statement = *argv;
				action->tty_reset = next_tty_reset;
				next_tty_reset = FALSE;
				action->iwrite = next_iwrite;
				next_iwrite = FALSE;
				action->iread = next_iread;
				next_iread = FALSE;
				action->timestamp = next_timestamp;
				next_timestamp = FALSE;

				continue;
			} else if (exp_flageq("timeout",arg,7)) {
				int t;
				struct action *action;
				debuglog("-timeout is deprecated, use timeout\r\n");

				argc--;argv++;
				if (argc < 1) {
					exp_error(interp,"-timeout needs time");
					return(TCL_ERROR);
				}

				t = atoi(*argv);
				argc--;argv++;
				if (t != -1)
					arbitrary_timeout = t;
				/* we need an arbitrary timeout to start */
				/* search for lowest one later */

#if 0
				/* if -timeout comes before "-input", then applies */
				/* to all descriptors, else just the current one */
				if (dash_input_count > 0) {
					timeout_simple = FALSE;
					action = inp->action_timeout = 
						new_action(&action_base);
					inp->timeout_nominal = t;
				} else {
					action = &action_timeout;
					default_timeout = t;
				}
#endif
				timeout_simple = FALSE;
				action = inp->action_timeout = new_action(&action_base);
				inp->timeout_nominal = t;

				action->statement = *argv;
				action->tty_reset = next_tty_reset;
				next_tty_reset = FALSE;
				action->iwrite = next_iwrite;
				next_iwrite = FALSE;
				action->iread = next_iread;
				next_iread = FALSE;
				action->timestamp = next_timestamp;
				next_timestamp = FALSE;
				continue;
			} else if (exp_flageq("timestamp",arg,2)) {
				debuglog("-timestamp is deprecated, use exp_timestamp command\r\n");
				next_timestamp = TRUE;
				continue;
			} else if (exp_flageq("nobrace",arg,7)) {
				/* nobrace does nothing but take up space */
				/* on the command line which prevents */
				/* us from re-expanding any command lines */
				/* of one argument that looks like it should */
				/* be expanded to multiple arguments. */
				continue;
			}
		}

		/*
		 * pick up the pattern
		 */

		km = new(struct keymap);

		/* so that we can match in order user specified */
		/* link to end of keymap list */
		*end_km = km;
		km->next = 0;
		end_km = &km->next;

		km->echo = next_echo;
		km->writethru = next_writethru;
		km->indices = next_indices;
		km->action.tty_reset = next_tty_reset;
		km->action.iwrite = next_iwrite;
		km->action.iread = next_iread;
		km->action.timestamp = next_timestamp;
/*		km->case_sensitive = next_case_sensitive;*/

		next_indices = next_echo = next_writethru = FALSE;
		next_tty_reset = FALSE;
		next_iwrite = next_iread = FALSE;
/*		next_case_sensitive = TRUE;*/

		km->keys = *argv;

		km->null = FALSE;
		km->re = 0;
		if (next_re) {
			TclRegError((char *)0);
			if (0 == (km->re = TclRegComp(*argv))) {
				exp_error(interp,"bad regular expression: %s",
								TclGetRegError());
				return(TCL_ERROR);
			}
			next_re = FALSE;
		} if (next_null) {
			km->null = TRUE;
			next_null = FALSE;
		}

		argc--;argv++;

		km->action.statement = *argv;
		debuglog("defining key %s, action %s\r\n",
		 km->keys,
		 km->action.statement?(dprintify(km->action.statement))
				   :interpreter_cmd);

		/* imply a "-input" */
		if (dash_input_count == 0) dash_input_count = 1;
	}

	/* if the user has not supplied either "-output" for the */
	/* default two "-input"s, fix them up here */

	if (!input_user->output) {
		struct output *o = new(struct output);
		if (master_string == 0) {
			if (0 == exp_update_master(interp,&master,1,1)) {
				return(TCL_ERROR);
			}
			o->i_list = exp_new_i_simple(master,EXP_TEMPORARY);
		} else {
			o->i_list = exp_new_i_complex(interp,master_string,
					EXP_TEMPORARY,inter_updateproc);
		}
#if 0
		if (master == EXP_SPAWN_ID_BAD) {
			if (0 == exp_update_master(interp,&master,1,1)) {
				return(TCL_ERROR);
			}
		}
		o->i_list = exp_new_i_simple(master,EXP_TEMPORARY);
#endif
		o->next = 0;	/* no one else */
		o->action_eof = &action_eof;
		input_user->output = o;
	}

	if (!input_default->output) {
		struct output *o = new(struct output);
		o->i_list = exp_new_i_simple(1,EXP_TEMPORARY);/* stdout by default */
		o->next = 0;	/* no one else */
		o->action_eof = &action_eof;
		input_default->output = o;
	}

	/* if user has given "-u" flag, substitute process for user */
	/* in first two -inputs */
	if (replace_user_by_process) {
		/* through away old ones */
		exp_free_i(interp,input_user->i_list,   inter_updateproc);
		exp_free_i(interp,input_default->output->i_list,inter_updateproc);

		/* replace with arg to -u */
		input_user->i_list = exp_new_i_complex(interp,
				replace_user_by_process,
				EXP_TEMPORARY,inter_updateproc);
		input_default->output->i_list = exp_new_i_complex(interp,
				replace_user_by_process,
				EXP_TEMPORARY,inter_updateproc);
d1109 1
a1109 1

d1111 1
a1111 1
	 * now fix up for default spawn id
d1114 38
a1151 3
	/* user could have replaced it with an indirect, so force update */
	if (input_default->i_list->direct == EXP_INDIRECT) {
		exp_i_update(interp,input_default->i_list);
d1154 5
a1158 22
	if    (input_default->i_list->fd_list
	   && (input_default->i_list->fd_list->fd == EXP_SPAWN_ID_BAD)) {
		if (master_string == 0) {
			if (0 == exp_update_master(interp,&master,1,1)) {
				return(TCL_ERROR);
			}
			input_default->i_list->fd_list->fd = master;
		} else {
			/* discard old one and install new one */
			exp_free_i(interp,input_default->i_list,inter_updateproc);
			input_default->i_list = exp_new_i_complex(interp,master_string,
				EXP_TEMPORARY,inter_updateproc);
		}
#if 0
		if (master == EXP_SPAWN_ID_BAD) {
			if (0 == exp_update_master(interp,&master,1,1)) {
				return(TCL_ERROR);
			}
		}
		input_default->i_list->fd_list->fd = master;
#endif
	}
d1160 3
a1162 4
	/*
	 * check for user attempting to interact with self
	 * they're almost certainly just fooling around
	 */
d1164 2
a1165 4
	/* user could have replaced it with an indirect, so force update */
	if (input_user->i_list->direct == EXP_INDIRECT) {
		exp_i_update(interp,input_user->i_list);
	}
d1167 4
a1170 3
	if (input_user->i_list->fd_list && input_default->i_list->fd_list
	    && (input_user->i_list->fd_list->fd == input_default->i_list->fd_list->fd)) {
		exp_error(interp,"cannot interact with self - set spawn_id to a spawned process");
d1172 5
d1178 4
d1183 7
a1189 2
	fd_list = 0;
	fd_to_input = 0;
d1191 15
a1205 4
	/***************************************************************/
	/* all data structures are sufficiently set up that we can now */
	/* "finish()" to terminate this procedure                      */
	/***************************************************************/
d1207 8
a1214 2
	status = update_interact_fds(interp,&input_count,&fd_to_input,&fd_list,input_base,1,&configure_count,&real_tty);
	if (status == TCL_ERROR) finish(TCL_ERROR);
d1216 12
a1227 2
	if (real_tty) {
		tty_changed = exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
d1229 1
d1231 9
a1239 4
	for (inp = input_base,i=0;inp;inp=inp->next,i++) {
	    /* start timers */
	    inp->timeout_remaining = inp->timeout_nominal;
	}
d1241 5
a1245 1
	key = expect_key++;
d1247 1
a1247 2
	/* declare ourselves "in sync" with external view of close/indirect */
	configure_count = exp_configure_count;
d1249 4
a1252 19
#ifndef SIMPLE_EVENT
	/* loop waiting (in event handler) for input */
	for (;;) {
		int te;	/* result of Tcl_Eval */
		struct exp_f *u;
		int rc;	/* return code from ready.  This is further */
			/* refined by matcher. */
		int cc;	/* chars count from read() */
		int m;	/* master */
		int m_out; /* where master echoes to */
		struct action *action = 0;
		time_t previous_time;
		time_t current_time;
		int match_length, skip;
		int change;	/* if action requires cooked mode */
		int attempt_match = TRUE;
		struct input *soonest_input;
		int print;		/* # of chars to print */
		int oldprinted;		/* old version of u->printed */
d1254 2
a1255 1
		int timeout;	/* current as opposed to default_timeout */
d1257 3
a1259 6
		/* calculate how long to wait */
		/* by finding shortest remaining timeout */
		if (timeout_simple) {
			timeout = default_timeout;
		} else {
			timeout = arbitrary_timeout;
d1261 4
a1264 7
			for (inp=input_base;inp;inp=inp->next) {
				if ((inp->timeout_remaining != EXP_TIME_INFINITY) &&
				    (inp->timeout_remaining <= timeout)) {
					soonest_input = inp;
					timeout = inp->timeout_remaining;
				}
			}
d1266 1
a1266 4
			time(&previous_time);
			/* timestamp here rather than simply saving old */
			/* current time (after ready()) to account for */
			/* possibility of slow actions */
d1268 27
a1294 4
			/* timeout can actually be EXP_TIME_INFINITY here if user */
			/* explicitly supplied it in a few cases (or */
			/* the count-down code is broken) */
		}
d1296 5
a1300 22
		/* update the world, if necessary */
		if (configure_count != exp_configure_count) {
			status = update_interact_fds(interp,&input_count,
					&fd_to_input,&fd_list,input_base,1,
					&configure_count,&real_tty);
			if (status) finish(status);
		}

		rc = exp_get_next_event(interp,fd_list,input_count,&m,timeout,key);
		if (rc == EXP_TCLERROR) return(TCL_ERROR);

		if (rc == EXP_RECONFIGURE) continue;

		if (rc == EXP_TIMEOUT) {
			if (timeout_simple) {
				action = &action_timeout;
				goto got_action;
			} else {
				action = soonest_input->action_timeout;
				/* arbitrarily pick first fd out of list */
				m = soonest_input->i_list->fd_list->fd;
			}
d1302 1
a1302 2
		if (!timeout_simple) {
			int time_diff;
d1304 33
a1336 12
			time(&current_time);
			time_diff = current_time - previous_time;

			/* update all timers */
			for (inp=input_base;inp;inp=inp->next) {
				if (inp->timeout_remaining != EXP_TIME_INFINITY) {
					inp->timeout_remaining -= time_diff;
					if (inp->timeout_remaining < 0)
						inp->timeout_remaining = 0;
				}
			}
		}
d1338 2
a1339 55
		/* at this point, we have some kind of event which can be */
		/* immediately processed - i.e. something that doesn't block */

		/* figure out who we are */
		inp = fd_to_input[m];
/*		u = inp->f;*/
		u = exp_fs+m;

		/* reset timer */
		inp->timeout_remaining = inp->timeout_nominal;

		switch (rc) {
		case EXP_DATA_NEW:
			if (u->size == u->msize) {
			    /* In theory, interact could be invoked when this situation */
			    /* already exists, hence the "probably" in the warning below */

			    debuglog("WARNING: interact buffer is full, probably because your\r\n");
			    debuglog("patterns have matched all of it but require more chars\r\n");
			    debuglog("in order to complete the match.\r\n");
			    debuglog("Dumping first half of buffer in order to continue\r\n");
			    debuglog("Recommend you enlarge the buffer or fix your patterns.\r\n");
			    exp_buffer_shuffle(interp,u,0,INTER_OUT,"interact");
		        }
			cc = read(m,	u->buffer + u->size,
					u->msize - u->size);
			if (cc > 0) {
				u->key = key;
				u->size += cc;
				u->buffer[u->size] = '\0';

				/* strip parity if requested */
				if (u->parity == 0) {
					/* do it from end backwards */
					char *p = u->buffer + u->size - 1;
					int count = cc;
					while (count--) {
						*p-- &= 0x7f;
					}
				}

				/* avoid another function call if possible */
				if (debugfile || is_debugging) {
					debuglog("spawn id %d sent <%s>\r\n",m,
						exp_printify(u->buffer + u->size - cc));
				}
				break;
			}

			rc = EXP_EOF;
			/* Most systems have read() return 0, allowing */
			/* control to fall thru and into this code.  On some */
			/* systems (currently HP and new SGI), read() does */
			/* see eof, and it must be detected earlier.  Then */
			/* control jumps directly to this EXP_EOF label. */
d1341 6
a1346 28
			/*FALLTHRU*/
		case EXP_EOF:
			action = inp->action_eof;
			attempt_match = FALSE;
			skip = u->size;
			debuglog("interact: received eof from spawn_id %d\r\n",m);
			/* actual close is done later so that we have a */
			/* chance to flush out any remaining characters */
			need_to_close_master = TRUE;

#if EOF_SO
			/* should really check for remaining chars and */
			/* flush them but this will only happen in the */
			/* unlikely scenario that there are partially */
			/* matched buffered chars. */
			/* So for now, indicate no chars to skip. */
			skip = 0;
			exp_close(interp,m);
#endif
			break;
		case EXP_DATA_OLD:
			cc = 0;
			break;
		case EXP_TIMEOUT:
			action = inp->action_timeout;
			attempt_match = FALSE;
			skip = u->size;
			break;
d1348 2
d1351 2
a1352 1
		km = 0;
d1354 2
a1355 6
		if (attempt_match) {
			rc = in_keymap(u->buffer,u->size,inp->keymap,
				&km,&match_length,&skip,u->rm_nulls);
		} else {
			attempt_match = TRUE;
		}
d1357 2
a1358 28
		/* put regexp result in variables */
		if (km && km->re) {
#define out(var,val)  debuglog("expect: set %s(%s) \"%s\"\r\n",INTER_OUT,var, \
						dprintify(val)); \
		    Tcl_SetVar2(interp,INTER_OUT,var,val,0);

			char name[20], value[20];
			regexp *re = km->re;
			char match_char;/* place to hold char temporarily */
					/* uprooted by a NULL */

			for (i=0;i<NSUBEXP;i++) {
				int offset;

				if (re->startp[i] == 0) continue;

				if (km->indices) {
				  /* start index */
				  sprintf(name,"%d,start",i);
				  offset = re->startp[i]-u->buffer;
				  sprintf(value,"%d",offset);
				  out(name,value);

				  /* end index */
				  sprintf(name,"%d,end",i);
				  sprintf(value,"%d",re->endp[i]-u->buffer-1);
				  out(name,value);
				}
d1360 4
a1363 10
				/* string itself */
				sprintf(name,"%d,string",i);
				/* temporarily null-terminate in */
				/* middle */
				match_char = *re->endp[i];
				*re->endp[i] = 0;
				out(name,re->startp[i]);
				*re->endp[i] = match_char;
			}
		}
d1365 1
d1367 7
a1373 2
		 * dispose of chars that should be skipped
		 * i.e., chars that cannot possibly be part of a match.
d1375 29
a1403 3
		
		/* "skip" is count of chars not involved in match */
		/* "print" is count with chars involved in match */
d1405 7
a1411 3
		if (km && km->writethru) {
			print = skip + match_length;
		} else print = skip;
d1413 4
a1416 5
		/*
		 * echo chars if appropriate
		 */
		if (km && km->echo) {
			int seen;	/* either printed or echoed */
d1418 23
a1440 139
			/* echo to stdout rather than stdin */
			m_out = (m == 0)?1:m;

			/* write is unlikely to fail, since we just read */
			/* from same descriptor */
			seen = u->printed + u->echoed;
			if (skip >= seen) {
				write(m_out,u->buffer+skip,match_length);
			} else if ((match_length + skip - seen) > 0) {
				write(m_out,u->buffer+seen,match_length+skip-seen);
			}
			u->echoed = match_length + skip - u->printed;
		}

		oldprinted = u->printed;

		/* If expect has left characters in buffer, it has */
		/* already echoed them to the screen, thus we must */
		/* prevent them being rewritten.  Unfortunately this */
		/* gives the possibility of matching chars that have */
		/* already been output, but we do so since the user */
		/* could have avoided it by flushing the output */
		/* buffers directly. */
		if (print > u->printed) {	/* usual case */
			int wc;	/* return code from write() */
			for (outp = inp->output;outp;outp=outp->next) {
			    struct exp_fd_list *fdp;
			    for (fdp = outp->i_list->fd_list;fdp;fdp=fdp->next) {
				int od;	/* output descriptor */

				/* send to logfile if open */
				/* and user is seeing it */
				if (logfile && real_tty_output(fdp->fd)) {
					fwrite(u->buffer+u->printed,1,
					       print - u->printed,logfile);
				}

				/* send to each output descriptor */
				od = fdp->fd;
				/* if opened by Tcl, it may use a different */
				/* output descriptor */
				od = (exp_fs[od].tcl_handle?exp_fs[od].tcl_output:od);

				wc = write(od,u->buffer+u->printed,
					print - u->printed);
				if (wc <= 0) {
					debuglog("interact: write on spawn id %d failed (%s)\r\n",fdp->fd,Tcl_PosixError(interp));
					action = outp->action_eof;
					change = (action && action->tty_reset);

					if (change && tty_changed)
						exp_tty_set(interp,&tty_old,was_raw,was_echo);
					te = inter_eval(interp,action,m);

					if (change && real_tty) tty_changed =
					   exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
					switch (te) {
					case TCL_BREAK:
					case TCL_CONTINUE:
						finish(te);
					case EXP_TCL_RETURN:
						finish(TCL_RETURN);
					case TCL_RETURN:
						finish(TCL_OK);
					case TCL_OK:
						/* god knows what the user might */
						/* have done to us in the way of */
						/* closed fds, so .... */
						action = 0;	/* reset action */
						continue;
					default:
						finish(te);
					}
				}
			    }
			}
			u->printed = print;
		}

		/* u->printed is now accurate with respect to the buffer */
		/* However, we're about to shift the old data out of the */
		/* buffer.  Thus, u->size, printed, and echoed must be */
		/* updated */

		/* first update size based on skip information */
		/* then set skip to the total amount skipped */

		if (rc == EXP_MATCH) {
			action = &km->action;

			skip += match_length;
			u->size -= skip;

			if (u->size) {
				memcpy(u->buffer, u->buffer + skip, u->size);
				exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
			}
		} else {
			if (skip) {
				u->size -= skip;
				memcpy(u->buffer, u->buffer + skip, u->size);
				exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
			}
		}

#if EOF_SO
		/* as long as buffer is still around, null terminate it */
		if (rc != EXP_EOF) {
			u->buffer[u->size] = '\0';
			u->lower [u->size] = '\0';
		}
#else
		u->buffer[u->size] = '\0';
		u->lower [u->size] = '\0';
#endif

		/* now update printed based on total amount skipped */

		u->printed -= skip;
		/* if more skipped than printed (i.e., keymap encountered) */
		/* for printed positive */
		if (u->printed < 0) u->printed = 0;

		/* if we are in the middle of a match, force the next event */
		/* to wait for more data to arrive */
		u->force_read = (rc == EXP_CANMATCH);

		/* finally reset echoed if necessary */
		if (rc != EXP_CANMATCH) {
			if (skip >= oldprinted + u->echoed) u->echoed = 0;
		}

		if (rc == EXP_EOF) {
			exp_close(interp,m);
			need_to_close_master = FALSE;
		}

		if (action) {
got_action:
d1442 1
d1444 2
a1445 3
				exp_tty_set(interp,&tty_old,was_raw,was_echo);

			te = inter_eval(interp,action,m);
d1448 1
a1448 1
			   exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
d1450 2
a1451 2
			case TCL_BREAK:
			case TCL_CONTINUE:
d1453 1
a1453 1
			case EXP_TCL_RETURN:
d1455 1
a1455 1
			case TCL_RETURN:
d1457 1
a1457 1
			case TCL_OK:
d1463 1
a1463 1
			default:
d1466 1
d1468 79
d1548 1
d1554 1
a1554 1
		struct exp_f *u;
a1557 1
		int m;	/* master */
d1561 1
a1561 1
		int match_length, skip;
d1574 10
a1583 2
	if (pid == 0) { /* child - send process output to user */
	    exp_close(interp,0);
d1585 3
a1587 1
	    m = fd_list[1];	/* get 2nd fd */
d1617 1
a1617 1
		rc = exp_get_next_event(interp,fd_list+1,input_count,&m,timeout,key);
d1638 1
a1638 3
		inp = fd_to_input[m];
/*		u = inp->f;*/
		u = exp_fs+m;
d1642 11
a1652 31
			cc = read(m,	u->buffer + u->size,
					u->msize - u->size);
			if (cc > 0) {
				u->key = key;
				u->size += cc;
				u->buffer[u->size] = '\0';

				/* strip parity if requested */
				if (u->parity == 0) {
					/* do it from end backwards */
					char *p = u->buffer + u->size - 1;
					int count = cc;
					while (count--) {
						*p-- &= 0x7f;
					}
				}

				/* avoid another function call if possible */
				if (debugfile || is_debugging) {
					debuglog("spawn id %d sent <%s>\r\n",m,
						exp_printify(u->buffer + u->size - cc));
				}
				break;
			}
			/*FALLTHRU*/

			/* Most systems have read() return 0, allowing */
			/* control to fall thru and into this code.  On some */
			/* systems (currently HP and new SGI), read() does */
			/* see eof, and it must be detected earlier.  Then */
			/* control jumps directly to this EXP_EOF label. */
d1656 1
a1656 1
			skip = u->size;
d1658 2
a1659 2
			debuglog("interact: child received eof from spawn_id %d\r\n",m);
			exp_close(interp,m);
d1669 4
a1672 2
			rc = in_keymap(u->buffer,u->size,inp->keymap,
				&km,&match_length,&skip);
d1674 1
a1674 42
			attempt_match = TRUE;
		}

		/* put regexp result in variables */
		if (km && km->re) {
#define INTER_OUT "interact_out"
#define out(i,val)  debuglog("expect: set %s(%s) \"%s\"\r\n",INTER_OUT,i, \
						dprintify(val)); \
		    Tcl_SetVar2(interp,INTER_OUT,i,val,0);

			char name[20], value[20];
			regexp *re = km->re;
			char match_char;/* place to hold char temporarily */
					/* uprooted by a NULL */

			for (i=0;i<NSUBEXP;i++) {
				int offset;

				if (re->startp[i] == 0) continue;

				if (km->indices) {
				  /* start index */
				  sprintf(name,"%d,start",i);
				  offset = re->startp[i]-u->buffer;
				  sprintf(value,"%d",offset);
				  out(name,value);

				  /* end index */
				  sprintf(name,"%d,end",i);
				  sprintf(value,"%d",re->endp[i]-u->buffer-1);
				  out(name,value);
				}

				/* string itself */
				sprintf(name,"%d,string",i);
				/* temporarily null-terminate in */
				/* middle */
				match_char = *re->endp[i];
				*re->endp[i] = 0;
				out(name,re->startp[i]);
				*re->endp[i] = match_char;
			}
d1683 1
a1683 1
			print = skip + match_length;
a1685 1
		/* figure out if we should echo any chars */
d1687 1
a1687 14
			int seen;	/* either printed or echoed */

			/* echo to stdout rather than stdin */
			if (m == 0) m = 1;

			/* write is unlikely to fail, since we just read */
			/* from same descriptor */
			seen = u->printed + u->echoed;
			if (skip >= seen) {
				write(m,u->buffer+skip,match_length);
			} else if ((match_length + skip - seen) > 0) {
				write(m,u->buffer+seen,match_length+skip-seen);
			}
			u->echoed = match_length + skip - u->printed;
a1688 1

d1699 29
a1727 44
			int wc;	/* return code from write() */
			for (outp = inp->output;outp;outp=outp->next) {
			    struct exp_fd_list *fdp;
			    for (fdp = outp->i_list->fd_list;fdp;fdp=fdp->next) {
				int od;	/* output descriptor */

				/* send to logfile if open */
				/* and user is seeing it */
				if (logfile && real_tty_output(fdp->fd)) {
					fwrite(u->buffer+u->printed,1,
					       print - u->printed,logfile);
				}

				/* send to each output descriptor */
				od = fdp->fd;
				/* if opened by Tcl, it may use a different */
				/* output descriptor */
				od = (exp_fs[od].tcl_handle?exp_fs[od].tcl_output:od);

				wc = write(od,u->buffer+u->printed,
					print - u->printed);
				if (wc <= 0) {
					debuglog("interact: write on spawn id %d failed (%s)\r\n",fdp->fd,Tcl_PosixError(interp));
					action = outp->action_eof;

					te = inter_eval(interp,action,m);

					switch (te) {
					case TCL_BREAK:
					case TCL_CONTINUE:
						finish(te);
					case EXP_TCL_RETURN:
						finish(TCL_RETURN);
					case TCL_RETURN:
						finish(TCL_OK);
					case TCL_OK:
						/* god knows what the user might */
						/* have done to us in the way of */
						/* closed fds, so .... */
						action = 0;	/* reset action */
						continue;
					default:
						finish(te);
					}
d1731 2
a1732 1
			u->printed = print;
d1737 1
a1737 1
		/* buffer.  Thus, u->size, printed, and echoed must be */
d1743 9
a1751 9
		if (rc == EXP_MATCH) {
			action = &km->action;

			skip += match_length;
			u->size -= skip;

			if (u->size)
				memcpy(u->buffer, u->buffer + skip, u->size);
				exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
d1753 4
a1756 5
			if (skip) {
				u->size -= skip;
				memcpy(u->buffer, u->buffer + skip, u->size);
				exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
			}
d1758 1
a1759 5
		/* as long as buffer is still around, null terminate it */
		if (rc != EXP_EOF) {
			u->buffer[u->size] = '\0';
			u->lower [u->size] = '\0';
		}
d1777 1
a1777 1
			te = inter_eval(interp,action,m);
d1797 9
a1805 1
	} else { /* parent - send user keystrokes to process */
d1811 1
a1811 1
		debuglog("fork = %d\r\n",pid);
d1816 1
a1816 1
	    m = fd_list[0];	/* get 1st fd */
d1844 1
a1844 1
		rc = exp_get_next_event(interp,fd_list,input_count,&m,timeout,key);
d1865 1
a1865 3
		inp = fd_to_input[m];
/*		u = inp->f;*/
		u = exp_fs+m;
d1869 2
a1870 22
			cc = i_read(m,	u->buffer + u->size,
					u->msize - u->size);
			if (cc > 0) {
				u->key = key;
				u->size += cc;
				u->buffer[u->size] = '\0';

				/* strip parity if requested */
				if (u->parity == 0) {
					/* do it from end backwards */
					char *p = u->buffer + u->size - 1;
					int count = cc;
					while (count--) {
						*p-- &= 0x7f;
					}
				}

				/* avoid another function call if possible */
				if (debugfile || is_debugging) {
					debuglog("spawn id %d sent <%s>\r\n",m,
						exp_printify(u->buffer + u->size - cc));
				}
d1878 1
a1878 1
				skip = u->size;
d1880 2
a1881 2
				debuglog("interact: process died/eof\r\n");
				clean_up_after_child(interp,fd_list[1]);
d1884 9
a1892 7
			/*FALLTHRU*/

			/* Most systems have read() return 0, allowing */
			/* control to fall thru and into this code.  On some */
			/* systems (currently HP and new SGI), read() does */
			/* see eof, and it must be detected earlier.  Then */
			/* control jumps directly to this EXP_EOF label. */
d1896 1
a1896 1
			skip = u->size;
d1898 1
a1898 1
			debuglog("user sent EOF or disappeared\n\n");
d1908 4
a1911 2
			rc = in_keymap(u->buffer,u->size,inp->keymap,
				&km,&match_length,&skip);
d1913 1
a1913 37
			attempt_match = TRUE;
		}

		/* put regexp result in variables */
		if (km && km->re) {
			char name[20], value[20];
			regexp *re = km->re;
			char match_char;/* place to hold char temporarily */
					/* uprooted by a NULL */

			for (i=0;i<NSUBEXP;i++) {
				int offset;

				if (re->startp[i] == 0) continue;

				if (km->indices) {
				  /* start index */
				  sprintf(name,"%d,start",i);
				  offset = re->startp[i]-u->buffer;
				  sprintf(value,"%d",offset);
				  out(name,value);

				  /* end index */
				  sprintf(name,"%d,end",i);
				  sprintf(value,"%d",re->endp[i]-u->buffer-1);
				  out(name,value);
				}

				/* string itself */
				sprintf(name,"%d,string",i);
				/* temporarily null-terminate in */
				/* middle */
				match_char = *re->endp[i];
				*re->endp[i] = 0;
				out(name,re->startp[i]);
				*re->endp[i] = match_char;
			}
d1922 1
a1922 1
			print = skip + match_length;
a1924 1
		/* figure out if we should echo any chars */
d1926 1
a1926 14
			int seen;	/* either printed or echoed */

			/* echo to stdout rather than stdin */
			if (m == 0) m = 1;

			/* write is unlikely to fail, since we just read */
			/* from same descriptor */
			seen = u->printed + u->echoed;
			if (skip >= seen) {
				write(m,u->buffer+skip,match_length);
			} else if ((match_length + skip - seen) > 0) {
				write(m,u->buffer+seen,match_length+skip-seen);
			}
			u->echoed = match_length + skip - u->printed;
a1927 1

d1938 34
a1971 49
			int wc;	/* return code from write() */
			for (outp = inp->output;outp;outp=outp->next) {
			    struct exp_fd_list *fdp;
			    for (fdp = outp->i_list->fd_list;fdp;fdp=fdp->next) {
				int od;	/* output descriptor */

				/* send to logfile if open */
				/* and user is seeing it */
				if (logfile && real_tty_output(fdp->fd)) {
					fwrite(u->buffer+u->printed,1,
					       print - u->printed,logfile);
				}

				/* send to each output descriptor */
				od = fdp->fd;
				/* if opened by Tcl, it may use a different */
				/* output descriptor */
				od = (exp_fs[od].tcl_handle?exp_fs[od].tcl_output:od);

				wc = write(od,u->buffer+u->printed,
					print - u->printed);
				if (wc <= 0) {
					debuglog("interact: write on spawn id %d failed (%s)\r\n",fdp->fd,Tcl_PosixError(interp));
					clean_up_after_child(interp,fdp->fd);
					action = outp->action_eof;
					change = (action && action->tty_reset);
					if (change && tty_changed)
						exp_tty_set(interp,&tty_old,was_raw,was_echo);
					te = inter_eval(interp,action,m);

					if (change && real_tty) tty_changed =
					   exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
					switch (te) {
					case TCL_BREAK:
					case TCL_CONTINUE:
						finish(te);
					case EXP_TCL_RETURN:
						finish(TCL_RETURN);
					case TCL_RETURN:
						finish(TCL_OK);
					case TCL_OK:
						/* god knows what the user might */
						/* have done to us in the way of */
						/* closed fds, so .... */
						action = 0;	/* reset action */
						continue;
					default:
						finish(te);
					}
d1975 2
a1976 1
			u->printed = print;
d1981 1
a1981 1
		/* buffer.  Thus, u->size, printed, and echoed must be */
d1987 1
d1989 1
a1989 1
			action = &km->action;
d1991 5
a1995 6
			skip += match_length;
			u->size -= skip;

			if (u->size)
				memcpy(u->buffer, u->buffer + skip, u->size);
				exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
d1997 4
a2000 5
			if (skip) {
				u->size -= skip;
				memcpy(u->buffer, u->buffer + skip, u->size);
				exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
			}
d2002 1
a2003 5
		/* as long as buffer is still around, null terminate it */
		if (rc != EXP_EOF) {
			u->buffer[u->size] = '\0';
			u->lower [u->size] = '\0';
		}
d2025 1
a2025 1
			te = inter_eval(interp,action,m);
d2054 4
a2057 4
	/* force child to exit upon eof from master */
	if (pid == 0) {
		exit(SPAWNED_PROCESS_DIED);
	}
d2060 1
a2060 1
	if (need_to_close_master) exp_close(interp,master);
d2062 5
a2066 6
	if (tty_changed) exp_tty_set(interp,&tty_old,was_raw,was_echo);
	if (oldargv) ckfree((char *)argv);
	if (fd_list) ckfree((char *)fd_list);
	if (fd_to_input) ckfree((char *)fd_to_input);
	free_input(interp,input_base);
	free_action(action_base);
d2068 1
a2068 1
	return(status);
d2073 1
a2073 1
inter_eval(interp,action,spawn_id)
d2076 1
a2076 1
int spawn_id;
d2078 1
a2078 2
	int status;
	char value[20];
d2080 3
a2082 7
	/* deprecated */
	if (action->timestamp) {
		time_t current_time;
		time(&current_time);
		exp_timestamp(interp,&current_time,INTER_OUT);
	}
	/* deprecated */
d2084 6
a2089 11
	if (action->iwrite) {
		sprintf(value,"%d",spawn_id);
		out("spawn_id",value);
	}

	if (action->statement) {
		status = Tcl_Eval(interp,action->statement);
	} else {
		exp_nflog("\r\n",1);
		status = exp_interpreter(interp);
	}
d2091 1
a2091 1
	return status;
d2156 1
d2158 1
a2158 1
{"interact",	exp_proc(Exp_InteractCmd),	0,	0},
d2165 10
a2174 1
	exp_create_commands(interp,cmd_data);
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Added Exp channel driver and modified rest to support it.
@
text
@d73 2
a74 2
#define real_tty_output(x) ((esPtr->fdout == 1) || expIsDevtty(x))
#define real_tty_input(x) (exp_stdin_is_tty && ((x->fdin==0) || expIsDevtty(x)))
a115 33
/*
 * Once we are handed an ExpState from the event handler, we can figure out
 * which "struct input *" it references by using expStateToInput.  This has is
 * populated by expCreateStateToInput.
 */

struct input *
expStateToInput(hash,esPtr)
    ExpState *esPtr;
    Tcl_HashTable *hash;
{
    Tcl_HashEntry *entry = Tcl_FindHashEntry(hash,esPtr);

    if (!entry) {
	/* should never happen */
	return 0;
    }
    return ((struct input *)Tcl_GetHashValue(entry));
}

void
expCreateStateToInput(hash,esPtr,inp)
    ExpState *esPtr;
    Tcl_HashTable *hash;
    struct input *inp;
{
    Tcl_HashEntry *entry;
    int newptr;

    entry = Tcl_CreateHashEntry(hash,esPtr,&newPtr);
    Tcl_SetHashValue(entry,(ClientData)inp);
}

d161 14
a174 14
    struct keymap *km;
    char *ks;		/* string from a keymap */
    char *start_search;	/* where in the string to start searching */
    char *string_end;

    /* assert (*km == 0) */

    /* a shortcut that should help master output which typically */
    /* is lengthy and has no key maps.  Otherwise it would mindlessly */
    /* iterate on each character anyway. */
    if (!keymap) {
	*skip = stringlen;
	return(EXP_CANTMATCH);
    }
d176 1
a176 1
    string_end = string + stringlen;
d178 2
a179 2
    /* Mark beginning of line for ^ . */
    regbol = string;
d258 2
a259 2
    if (*km_match) {
	/* report a can-match */
d261 1
a261 1
	char *p;
d263 26
a288 22
	*skip = (start_search-string)-1;
	/*
	 * there may be nulls in the string in which case
	 * the pattern matchers can report CANMATCH when
	 * the null is hit.  So find the null and compute
	 * the length of the possible match.
	 *
	 * Later, after we squeeze out the nulls, we will
	 * retry the match, but for now, go along with
	 * calling it a CANMATCH
	 */
	p = start_search;
	while (*p) {
	    p++;
	}
	*match_length = (p - start_search) + 1;
	/*printf(" match_length = %d\n",*match_length);*/
	return(EXP_CANMATCH);
    }
    
    *skip = start_search-string;
    return(EXP_CANTMATCH);
d362 1
a362 1
clean_up_after_child(interp,esPtr)
d364 1
a364 1
ExpState *esPtr;
d387 2
a388 1
	exp_close(interp,esPtr);
d393 1
a393 1
update_interact_fds(interp,esPtrCount,esPtrToInput,esPtrs,input_base,
d396 3
a398 3
int *esPtrCount;
Tcl_InitHashTable **esPtrToInput;	/* map from ExpStates to "struct inputs" */
ExpState *((*esPtrs)[]);
d406 1
a406 1
	struct exp_state_list *fdp;
d430 6
a435 7
		for (fdp = inp->i_list->state_list;fdp;fdp=fdp->next) {
		    count++;
		    /* have to "adjust" just in case spawn id hasn't had */
		    /* a buffer sized yet */
		    if (!expCheckState(interp,fdp->esPtr,1,1,"interact")) {
			return(TCL_ERROR);
		    }
d440 1
a440 1
			for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
d442 6
a447 4
			    if (!expIsStdinout(fdp->esPtr)) {
				if (!expCheckState(interp,fdp->esPtr,1,0,"interact"))
				    return(TCL_ERROR);
			    }
d453 4
a456 3
	if (*esPtrToInput == 0) {
	    *esPtrToInput = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	    *esPtrs = (ExpState **)ckalloc(count * sizeof(ExpState *));
d458 3
a460 3
	    /* if hash table already exists, delete it and start over */
	    Tcl_DeleteHashTable(*esPtrToInput);
	    *esPtrs = (ExpState **)ckrealloc((char *)*fd_list,count * sizeof(ExpState *));
a461 1
	Tcl_InitHashTable(*esPtrToInput,TCL_ONE_WORD_KEYS);
d465 3
a467 3
	    for (fdp = inp->i_list->state_list;fdp;fdp=fdp->next) {
		/* build map to translate from spawn_id to struct input */
		expCreateStateToInput(*esPtrToInput,esPtr,inp);
d469 2
a470 2
		/* build input to ready() */
		(*esPtrs)[count] = fdp->esPtr;
d472 1
a472 1
		if (real_tty_input(fdp->esPtr)) real_tty = TRUE;
d474 2
a475 2
		count++;
	    }
d477 1
a477 1
	*esPtrCount = count;
d511 1
a511 1
    char *arg;	/* shorthand for current argv */
d513 1
a513 1
    int pid;
d516 9
a524 9
    /*declarations*/
    int input_count;	/* count of struct input descriptors */

    Tcl_HashTable *esPtrToInput = 0;	/* map from ExpState to "struct inputs" */
    ExpState **esPtrs;
    struct keymap *km;	/* ptr for above while parsing */
    ExpState *esPtr = 0;
    char *chanName = 0;
    int need_to_close_master = FALSE;	/* if an eof is received */
d527 13
a539 12
    int next_tty_reset = FALSE;	/* if we've seen a single -reset */
    int next_iread = FALSE;/* if we've seen a single -iread */
    int next_iwrite = FALSE;/* if we've seen a single -iread */
    int next_re = FALSE;	/* if we've seen a single -re */
    int next_null = FALSE;	/* if we've seen the null keyword */
    int next_writethru = FALSE;/*if macros should also go to proc output */
    int next_indices = FALSE;/* if we should write indices */
    int next_echo = FALSE;	/* if macros should be echoed */
    int next_timestamp = FALSE; /* if we should generate a timestamp */
    char **oldargv = 0;	/* save original argv here if we split it */
    int status = TCL_OK;	/* final return value */
    int i;			/* trusty temp */
d541 1
a541 1
    int timeout_simple = TRUE;	/* if no or global timeout */
d543 2
a544 2
    int real_tty;		/* TRUE if we are interacting with real tty */
    int tty_changed = FALSE;/* true if we had to change tty modes for */
d546 3
a548 3
    int was_raw;
    int was_echo;
    exp_tty tty_old;
d550 1
a550 1
    char *replace_user_by_process = 0; /* for -u flag */
d552 1
a552 1
    struct input *input_base;
d554 10
a563 10
    struct input *input_default;
    struct input *inp;	/* overused ptr to struct input */
    struct output *outp;	/* overused ptr to struct output */

    int dash_input_count = 0; /* # of "-input"s seen */
    int arbitrary_timeout;
    int default_timeout;
    struct action action_timeout;	/* common to all */
    struct action action_eof;	/* common to all */
    struct action **action_eof_ptr;	/* allow -input/ouput to */
d566 2
a567 2
    struct action *action_base = 0;
    struct keymap **end_km;
d569 2
a570 2
    int key;
    int configure_count;	/* monitor reconfigure events */
d572 8
a579 8
    if ((argc == 2) && exp_one_arg_braced(argv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,argv));
    } else if ((argc == 3) && streq(argv[1],"-brace")) {
	char *new_argv[2];
	new_argv[0] = argv[0];
	new_argv[1] = argv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_argv));
    }
d581 2
a582 2
    argv++;
    argc--;
d584 2
a585 2
    default_timeout = EXP_TIME_INFINITY;
    arbitrary_timeout = EXP_TIME_INFINITY;	/* if user specifies */
d589 28
a616 28
    input_user = new(struct input);
    input_user->i_list = exp_new_i_simple(expStdinout(),EXP_TEMPORARY); /* stdin by default */
    input_user->output = 0;
    input_user->action_eof = &action_eof;
    input_user->timeout_nominal = EXP_TIME_INFINITY;
    input_user->action_timeout = 0;
    input_user->keymap = 0;

    end_km = &input_user->keymap;
    inp = input_user;
    action_eof_ptr = &input_user->action_eof;

    input_default = new(struct input);
    input_default->i_list = exp_new_i_simple((ExpState *)0,EXP_TEMPORARY); /* fix up later */
    input_default->output = 0;
    input_default->action_eof = &action_eof;
    input_default->timeout_nominal = EXP_TIME_INFINITY;
    input_default->action_timeout = 0;
    input_default->keymap = 0;
    input_default->next = 0;		/* no one else */
    input_user->next = input_default;

    /* default and common -eof action */
    action_eof.statement = return_cmd;
    action_eof.tty_reset = FALSE;
    action_eof.iread = FALSE;
    action_eof.iwrite = FALSE;
    action_eof.timestamp = FALSE;
d763 2
a764 1
				chanName = *argv;
d939 5
a943 5
		if (!chanName) {
		    if (!(esPtr = expGetCurrentState(interp,1,1))) {
			return(TCL_ERROR);
		    }
		    o->i_list = exp_new_i_simple(esPtr,EXP_TEMPORARY);
d945 8
a952 2
		    o->i_list = exp_new_i_complex(interp,chanName,
			    EXP_TEMPORARY,inter_updateproc);
d954 2
d963 1
a963 1
		o->i_list = exp_new_i_simple(expStdinout,EXP_TEMPORARY);/* stdout by default */
d994 18
a1011 5
	if    (input_default->i_list->state_list
	   && (input_default->i_list->state_list->esPtr == EXP_SPAWN_ID_BAD)) {
	    if (!chanName) {
		if (!(esPtr = expGetCurrentState(interp,1,1)) {
		    return(TCL_ERROR);
d1013 2
a1014 7
		input_default->i_list->state_list->esPtr = esPtr;
	    } else {
		/* discard old one and install new one */
		exp_free_i(interp,input_default->i_list,inter_updateproc);
		input_default->i_list = exp_new_i_complex(interp,master_string,
			EXP_TEMPORARY,inter_updateproc);
	    }
d1027 2
a1028 2
	if (input_user->i_list->state_list && input_default->i_list->state_list
	    && (input_user->i_list->state_list->esPtr == input_default->i_list->state_list->esPtr)) {
d1033 2
a1034 2
	esPtrs = 0;
	/* Init esPtrToInput = 0;*/
d1041 1
a1041 1
	status = update_interact_fds(interp,&input_count,&esPtrToInput,&esPtrs,input_base,1,&configure_count,&real_tty);
d1062 1
a1062 1
		ExpState *u;
d1108 1
a1108 1
					&esPtrToInput,&esPtrs,input_base,1,
d1113 1
a1113 1
		rc = exp_get_next_event(interp,esPtrs,input_count,&u,timeout,key);
d1125 1
a1125 1
				m = soonest_input->i_list->state_list->esPtr;
d1148 3
a1150 1
		inp = expStateToInput(esPtrToInput,u);
d1209 10
d1323 4
a1326 2
			    struct exp_state_list *fdp;
			    for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
d1329 1
a1329 1
				if (logfile && real_tty_output(fdp->esPtr)) {
d1335 6
a1340 2
/*SCOTT*/
				wc = Tcl_Write(fdp->esPtr,u->buffer+u->printed,
d1343 1
a1343 1
					debuglog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
d1349 1
a1349 1
					te = inter_eval(interp,action,u);
d1401 8
d1411 1
d1440 1
a1440 1
			te = inter_eval(interp,action,u);
d1468 1
a1468 1
		ExpState *u;    /*master*/
d1472 1
a1472 1
/*		int m;	/* master */
d1492 1
a1492 1
	    u = esPtrs[1];  /* get 2nd ExpState */
d1522 1
a1522 1
		rc = exp_get_next_event(interp,esPtrs+1,input_count,&u,timeout,key);
d1543 3
a1545 1
		inp = expStateToInput(esPtrToInput,u);
d1682 4
a1685 2
			    struct exp_state_list *fdp;
			    for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
d1688 1
a1688 1
				if (logfile && real_tty_output(fdp->esPtr)) {
d1694 6
a1699 2
/*SCOTT*/
				wc = Tcl_Write(fdp->esPtr,u->buffer+u->printed,
d1702 1
a1702 1
					debuglog("interact: write on spawn id %d failed (%s)\r\n",Tcl_GetChannelName(fdp->esPtr->channel),Tcl_PosixError(interp));
d1705 1
a1705 1
					te = inter_eval(interp,action,u);
d1777 1
a1777 1
			te = inter_eval(interp,action,u);
d1808 1
a1808 1
	    u = esPtrs[0];  /* get 1st ExpState */
d1836 1
a1836 1
		rc = exp_get_next_event(interp,esPtrs,input_count,&u,timeout,key);
d1857 3
a1859 1
		inp = expStateToInput(esPtrToInput,u);
d1895 1
a1895 1
				clean_up_after_child(interp,esPtrs[1]);
d2001 4
a2004 2
			    struct exp_state_list *fdp;
			    for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
d2007 1
a2007 1
				if (logfile && real_tty_output(fdp->esPtr)) {
a2011 1
/*SCOTT*
d2013 6
a2018 1
				wc = Tcl_Write(fdp->esPtr,u->buffer+u->printed,
d2021 2
a2022 2
					debuglog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
					clean_up_after_child(interp,fdp->esPtr);
d2027 1
a2027 1
					te = inter_eval(interp,action,esPtr);
d2105 1
a2105 1
			te = inter_eval(interp,action,esPtr);
d2144 2
a2145 2
	if (esPtrs) ckfree((char *)esPtrs);
	if (esPtrToInput) Tcl_DeleteHashTable(esPtrToInput);
d2154 1
a2154 1
inter_eval(interp,action,esPtr)
d2157 1
a2157 1
ExpState *esPtr;
d2159 2
a2160 1
    int status;
d2162 7
a2168 7
    /* deprecated */
    if (action->timestamp) {
	time_t current_time;
	time(&current_time);
	exp_timestamp(interp,&current_time,INTER_OUT);
    }
    /* deprecated */
d2170 4
a2173 3
    if (action->iwrite) {
	out("spawn_id",esPtr->name);
    }
d2175 6
a2180 6
    if (action->statement) {
	status = Tcl_Eval(interp,action->statement);
    } else {
	exp_nflog("\r\n",1);
	status = exp_interpreter(interp);
    }
d2182 1
a2182 1
    return status;
a2245 1

@


5.28.1.1.2.2
log
@modified expect command to use new regexp interfaces, made various
I18N changes
@
text
@d1325 2
a1326 3
					Tcl_WriteChars(logfile,
						u->buffer+u->printed,
						print - u->printed);
d1331 1
a1331 2
				wc = Tcl_WriteChars(fdp->esPtr->channel,
					Tcl_GetString(u->buffer)+u->printed,
d1672 2
a1673 2
				wc = Tcl_WriteChars(fdp->esPtr->channel,
					Tcl_GetString(u->buffer) + u->printed,
d1982 1
d1984 1
a1984 2
				wc = Tcl_WriteChars(fdp->esPtr->channel,
					Tcl_GetString(u->buffer)+u->printed,
@


5.28.1.1.2.3
log
@got rid of remaining references to exp_fs and friends and exp_update_masters
@
text
@d395 4
a398 2
    expWaitOnOne(); /* wait for slave */
    expWaitOnOne(); /* wait for child */
d400 17
a416 2
    deferred_interrupt = FALSE;
    exp_close(interp,esPtr);
@


5.28.1.1.2.4
log
@more changes to objectify the interact command
@
text
@d79 1
a79 1
	Tcl_Obj *statement;
d88 1
a88 1
	Tcl_Obj *keys;	/* original pattern provided by user */
d518 2
a519 2
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d533 1
a533 1
    Tcl_Obj *chanName = 0;
d546 1
d559 1
a559 1
    Tcl_Obj *replace_user_by_process = 0; /* for -u flag */
d581 7
a587 7
    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(argv[1],"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d590 2
a591 2
    objv++;
    objc--;
d627 94
a720 80
    /*
     * Parse the command arguments.
     */

    for (;objc>0;objc--,objv++) {
	string = Tcl_GetString(objv);
	if (string[0] == '-') {
	    static char *switches[] = {
		"--",		"-exact",	"-re",		"-input",
		"-output",	"-u",		"-o",		"-i",
		"-echo",	"-nobuffer",	"-indices",	"-f",
		"-reset",	"-F",		"-iread",	"-iwrite",
		"-eof",		"-timeout",	"-timestamp",	"-nobrace"
	    };
	    enum switches {
		EXP_SWITCH_DASH,	EXP_SwITCH_EXACT,
		EXP_SWITCH_REGEXP,	EXP_SWITCH_INPUT,
		EXP_SWITCH_OUTPUT,	EXP_SWITCH_USER,
		EXP_SWITCH_OPPOSITE,	EXP_SWITCH_SPAWN_ID,
		EXP_SWITCH_ECHO,	EXP_SWITCH_NOBUFFER,
		EXP_SWITCH_INDICES,	EXP_SWITCH_FAST,
		EXP_SWITCH_RESET,	EXP_SWITCH_CAPFAST,
		EXP_SWITCH_IREAD,	EXP_SWITCH_IWRITE,
		EXP_SWITCH_EOF,		EXP_SWITCH_TIMEOUT,
		EXP_SWITCH_TIMESTAMP,	EXP_SWITCH_NOBRACE
	    };
	    int index;

	    /*
	     * Allow abbreviations of switches and report an error if we
	     * get an invalid switch.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv, switches, "switch", 0,
		    &index) != TCL_OK) {
		return TCL_ERROR;
	    }
	    switch ((enum switches) index) {
		case EXP_SWITCH_DASH:
		case EXP_SWITCH_EXACT:
		    objc--;
		    objv++;
		    goto pattern;
		case EXP_SWITCH_REGEXP:
		    if (objc < 1) {
			exp_error(interp,"-re needs pattern");
			return(TCL_ERROR);
		    }
		    next_re = TRUE;
		    objc--;
		    objv++;
		    goto pattern;
		case EXP_SWITCH_INPUT:
		    dash_input_count++;
		    if (dash_input_count == 2) {
			inp = input_default;
			input_user->next = input_default;
		    } else if (dash_input_count > 2) {
			struct input *previous_input = inp;
			inp = new(struct input);
			previous_input->next = inp;
		    }
		    inp->output = 0;
		    inp->action_eof = &action_eof;
		    action_eof_ptr = &inp->action_eof;
		    inp->timeout_nominal = default_timeout;
		    inp->action_timeout = &action_timeout;
		    inp->keymap = 0;
		    end_km = &inp->keymap;
		    inp->next = 0;
		    objc--;objv++;
		    if (objc < 1) {
			exp_error(interp,"-input needs argument");
			return(TCL_ERROR);
		    }
		    inp->i_list = exp_new_i_complex(interp,*objv,
			    EXP_TEMPORARY,inter_updateproc);
		    break;
		case EXP_SWITCH_OUTPUT: {
		    struct output *tmp;
d722 2
a723 2
		    /* imply a "-input" */
		    if (dash_input_count == 0) dash_input_count = 1;
d725 1
a725 1
		    outp = new(struct output);
d728 25
a752 11
		    tmp = inp->output;
		    inp->output = outp;
		    outp->next = tmp;

		    objc--;objv++;
		    if (objc < 1) {
			exp_error(interp,"-output needs argument");
			return(TCL_ERROR);
		    }
		    outp->i_list = exp_new_i_complex(interp,*objv,
			    EXP_TEMPORARY,inter_updateproc);
d754 16
a769 11
		    outp->action_eof = &action_eof;
		    action_eof_ptr = &outp->action_eof;
		    break;
		}
		case EXP_SWITCH_USER:
		    objc--;objv++;
		    if (objc < 1) {
			exp_error(interp,"-u needs argument");
			return(TCL_ERROR);
		    }
		    replace_user_by_process = *objv;
d771 42
a812 77
		    /* imply a "-input" */
		    if (dash_input_count == 0) dash_input_count = 1;
		    break;
		case EXP_SWITCH_OPPOSITE:
		    /* apply following patterns to opposite side */
		    /* of interaction */

		    end_km = &input_default->keymap;

		    /* imply two "-input" */
		    if (dash_input_count < 2) {
			dash_input_count = 2;
			inp = input_default;
			action_eof_ptr = &inp->action_eof;
		    }
		    break;
		case EXP_SWITCH_SPAWN_ID:
		    /* substitute master */

		    objc--;objv++;
		    chanName = *objv;
		    /* will be used later on */

		    end_km = &input_default->keymap;

		    /* imply two "-input" */
		    if (dash_input_count < 2) {
			dash_input_count = 2;
			inp = input_default;
			action_eof_ptr = &inp->action_eof;
		    }
		    break;
		case EXP_SWITCH_ECHO:
		    next_echo = TRUE;
		    break;
		case EXP_SWITCH_NOBUFFER:
		    next_writethru = TRUE;
		    break;
		case EXP_SWITCH_INDICES:
		    next_indices = TRUE;
		    break;
		case EXP_SWITCH_RESET:
		    next_tty_reset = TRUE;
		    break;
		case EXP_SWITCH_IREAD:
		    next_iread = TRUE;
		    break;
		    case EXP_SWITCH_IWRITE
			next_iwrite= TRUE;
		    break;
		case EXP_SWITCH_EOF: {
		    struct action *action;

		    objc--;objv++;
		    debuglog("-eof is deprecated, use eof\r\n");
		    *action_eof_ptr = action = new_action(&action_base);
		    action->statement = *objv;
		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    action->timestamp = next_timestamp;
		    next_timestamp = FALSE;
		    break;
		}
		case EXP_SWITCH_TIMEOUT: {
		    int t;
		    struct action *action;
		    debuglog("-timeout is deprecated, use timeout\r\n");

		    objc--;objv++;
		    if (objc < 1) {
			exp_error(interp,"-timeout needs time");
			return(TCL_ERROR);
		    }
d814 12
a825 90
		    if (Tcl_GetIntFromObj(interp, *objv, &t) != TCL_OK) {
			return TCL_ERROR;
		    }
		    objc--;objv++;
		    if (t != -1)
			arbitrary_timeout = t;
		    /* we need an arbitrary timeout to start */
		    /* search for lowest one later */

		    timeout_simple = FALSE;
		    action = inp->action_timeout = new_action(&action_base);
		    inp->timeout_nominal = t;

		    action->statement = *objv;
		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    action->timestamp = next_timestamp;
		    next_timestamp = FALSE;
		    break;
		}
		case EXP_SWITCH_TIMESTAMP:
		    debuglog("-timestamp is deprecated, use exp_timestamp command\r\n");
		    next_timestamp = TRUE;
		    break;
		case EXP_SWITCH_FAST:
		case EXP_SWITCH_CAPFAST:
		    /* noop compatibility switches for fast mode */
		    break;
		case EXP_SWITCH_NOBRACE:
		    /* nobrace does nothing but take up space */
		    /* on the command line which prevents */
		    /* us from re-expanding any command lines */
		    /* of one argument that looks like it should */
		    /* be expanded to multiple arguments. */
		    break;
	    }
	    continue;
    	} else {
	    static char *options[] = {
		"eof", "timeout", "null"
	    };
	    enum options {
		EXP_OPTION_EOF, EXP_OPTION_TIMEOUT, EXP_OPTION_NULL
	    };
	    int index;

	    /*
	     * Match keywords exactly, otherwise they are patterns.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv, options, "option",
		    1 /* exact */, &index) != TCL_OK) {
		goto pattern;
	    }
	    switch ((enum options) index) {
		case EXP_OPTION_EOF: {
		    struct action *action;

		    objc--;objv++;
		    *action_eof_ptr = action = new_action(&action_base);

		    action->statement = *objv;

		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    action->timestamp = next_timestamp;
		    next_timestamp = FALSE;
		    break;
		}
		case EXP_OPTION_TIMEOUT: {
		    int t;
		    struct action *action;

		    objc--;objv++;
		    if (objc < 1) {
			exp_error(interp,"timeout needs time");
			return(TCL_ERROR);
		    }
		    if (Tcl_GetIntFromObj(interp, *objv, &t) != TCL_OK) {
			return TCL_ERROR;
		    }
		    objc--;objv++;
d827 11
a837 30
		    /* we need an arbitrary timeout to start */
		    /* search for lowest one later */
		    if (t != -1) arbitrary_timeout = t;

		    timeout_simple = FALSE;
		    action = inp->action_timeout = new_action(&action_base);
		    inp->timeout_nominal = t;

		    action->statement = *objv;

		    action->tty_reset = next_tty_reset;
		    next_tty_reset = FALSE;
		    action->iwrite = next_iwrite;
		    next_iwrite = FALSE;
		    action->iread = next_iread;
		    next_iread = FALSE;
		    action->timestamp = next_timestamp;
		    next_timestamp = FALSE;
		    break;
		}
		case EXP_OPTION_NULL:
		    next_null = TRUE;
		    goto pattern;
	    }
	    continue;
	}
    
	/*
	 * pick up the pattern
	 */
d839 47
a885 2
	pattern:
	km = new(struct keymap);
d887 3
a889 34
	/* so that we can match in order user specified */
	/* link to end of keymap list */
	*end_km = km;
	km->next = 0;
	end_km = &km->next;

	km->echo = next_echo;
	km->writethru = next_writethru;
	km->indices = next_indices;
	km->action.tty_reset = next_tty_reset;
	km->action.iwrite = next_iwrite;
	km->action.iread = next_iread;
	km->action.timestamp = next_timestamp;

	next_indices = next_echo = next_writethru = FALSE;
	next_tty_reset = FALSE;
	next_iwrite = next_iread = FALSE;

	km->keys = *objv;

	km->null = FALSE;
	km->re = 0;
	if (next_re) {
	    TclRegError((char *)0);
	    if (0 == (km->re = TclRegComp(*objv))) {
		exp_error(interp,"bad regular expression: %s",
			TclGetRegError());
		return(TCL_ERROR);
	    }
	    next_re = FALSE;
	} if (next_null) {
	    km->null = TRUE;
	    next_null = FALSE;
	}
d891 1
a891 1
	objc--;objv++;
d893 44
a936 5
	km->action.statement = *objv;
	debuglog("defining key %s, action %s\r\n",
		km->keys,
		km->action.statement?(dprintify(km->action.statement))
		:interpreter_cmd);
d938 3
a940 3
	/* imply a "-input" */
	if (dash_input_count == 0) dash_input_count = 1;
    }
d942 2
a943 2
    /* if the user has not supplied either "-output" for the */
    /* default two "-input"s, fix them up here */
d945 14
a958 10
    if (!input_user->output) {
	struct output *o = new(struct output);
	if (!chanName) {
	    if (!(esPtr = expGetCurrentState(interp,1,1))) {
		return(TCL_ERROR);
	    }
	    o->i_list = exp_new_i_simple(esPtr,EXP_TEMPORARY);
	} else {
	    o->i_list = exp_new_i_complex(interp,chanName,
		    EXP_TEMPORARY,inter_updateproc);
a959 4
	o->next = 0;	/* no one else */
	o->action_eof = &action_eof;
	input_user->output = o;
    }
d961 7
a967 7
    if (!input_default->output) {
	struct output *o = new(struct output);
	o->i_list = exp_new_i_simple(expStdinout,EXP_TEMPORARY);/* stdout by default */
	o->next = 0;	/* no one else */
	o->action_eof = &action_eof;
	input_default->output = o;
    }
d969 15
a983 15
    /* if user has given "-u" flag, substitute process for user */
    /* in first two -inputs */
    if (replace_user_by_process) {
	/* through away old ones */
	exp_free_i(interp,input_user->i_list,   inter_updateproc);
	exp_free_i(interp,input_default->output->i_list,inter_updateproc);

	/* replace with arg to -u */
	input_user->i_list = exp_new_i_complex(interp,
		replace_user_by_process,
		EXP_TEMPORARY,inter_updateproc);
	input_default->output->i_list = exp_new_i_complex(interp,
		replace_user_by_process,
		EXP_TEMPORARY,inter_updateproc);
    }
d985 1
a985 1
    /*
d990 3
a992 3
    if (input_default->i_list->direct == EXP_INDIRECT) {
	exp_i_update(interp,input_default->i_list);
    }
d994 12
a1005 5
    if    (input_default->i_list->state_list
	    && (input_default->i_list->state_list->esPtr == EXP_SPAWN_ID_BAD)) {
	if (!chanName) {
	    if (!(esPtr = expGetCurrentState(interp,1,1)) {
		return(TCL_ERROR);
a1006 7
		input_default->i_list->state_list->esPtr = esPtr;
		} else {
		    /* discard old one and install new one */
		    exp_free_i(interp,input_default->i_list,inter_updateproc);
		    input_default->i_list = exp_new_i_complex(interp,master_string,
			    EXP_TEMPORARY,inter_updateproc);
		}
d1016 1
a1016 1
	    exp_i_update(interp,input_user->i_list);
d1020 3
a1022 3
		&& (input_user->i_list->state_list->esPtr == input_default->i_list->state_list->esPtr)) {
	    exp_error(interp,"cannot interact with self - set spawn_id to a spawned process");
	    return(TCL_ERROR);
d1037 1
a1037 1
	    tty_changed = exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
d1049 1
a1049 1
    
d2082 1
a2082 1
    }
d2094 1
@


5.28.1.1.2.5
log
@fixed Log/Diag and ExpectCmd
@
text
@a54 5
#define out(var,val) \
 expDiagLog("interact: set %s(%s) \",INTER_OUT,var); \
 expDiagLogU(expPrintify(val)); \
 expDiagLogU("\"\r\n"); \
 Tcl_SetVar2(interp,INTER_OUT,var,val,0);
d73 2
a74 2
#define real_tty_output(x) ((x->fdout == 1) || (expDevttyIs(x)))
#define real_tty_input(x) (exp_stdin_is_tty && ((x->fdin==0) || (expDevttyIs(x))))
a319 25
/*
 * echo chars
 */ 
static void
expEcho(esPtr,km,skipBytes,matchBytes)
    ExpState *esPtr;
    struct keymap *km;
    int skipBytes;
{
    int seenBytes;	/* either printed or echoed */
    ExpState *echo;

    if ((km == 0) || (km->echo == 0)) return;

    /* write is unlikely to fail, since we just read from same descriptor */
    seenBytes = esPtr->printed + esPtr->echoed;
    if (skipBytes >= seenBytes) {
	Tcl_Write(esPtr, Tcl_GetString(esPtr->buffer)+skipBytes, matchBytes);
    } else if ((match_length + skipBytes - seenBytes) > 0) {
	Tcl_Write(esPtr, Tcl_GetString(esPtr->buffer)+seenBytes,
		matchBytes+skipBytes-seenBytes);
    }
    esPtr->echoed = matchBytes + skipBytes - esPtr->printed;
}

d358 1
a358 2
static void
sigchld_handler()
d360 3
a362 2
    if (reading) longjmp(env,1);
    deferred_interrupt = TRUE;
d367 1
a367 8
/*
 * Name: i_read, do an interruptable read
 *
 * i_read() reads from chars from the user.
 *
 * It returns early if it detects the death of a proc (either the spawned
 * process or the child (surrogate).
 */
d369 2
a370 2
i_read(esPtr,buffer,length)
ExpState *esPtr;
d380 1
a380 1
		cc = Tcl_ReadChars(esPtr->channel,buffer,length);
d445 1
a445 1
		    if (!expStateCheck(interp,fdp->esPtr,1,1,"interact")) {
d454 2
a455 2
			    if (!expStdinoutIs(fdp->esPtr)) {
				if (!expStateCheck(interp,fdp->esPtr,1,0,"interact"))
d598 1
a598 1
    input_user->i_list = exp_new_i_simple(expStdinoutGet(),EXP_TEMPORARY); /* stdin by default */
d791 1
a791 1
		    expDiagLogU("-eof is deprecated, use eof\r\n");
d807 1
a807 1
		    expDiagLogU("-timeout is deprecated, use timeout\r\n");
d840 1
a840 1
		    expDiagLogU("-timestamp is deprecated, use exp_timestamp command\r\n");
d978 4
a981 5
	expDiagLogU("defining key ");
	expDiagLogU(km->keys);
	expDiagLogU(", action ");
	expDiagLogU(km->action.statement?expPrintify(km->action.statement):interpreter_cmd);
	expDiagLogU("\r\n");
d993 1
a993 1
	    if (!(esPtr = expStateCurrent(interp,1,1,0))) {
d1008 1
a1008 1
	o->i_list = exp_new_i_simple(expStdinoutGet,EXP_TEMPORARY);/* stdout by default */
d1031 2
a1032 2
     * now fix up for default spawn id
     */
d1034 1
a1034 1
    /* user could have replaced it with an indirect, so force update */
d1039 1
a1039 1
    if (input_default->i_list->state_list
d1042 1
a1042 1
	    if (!(esPtr = expStateCurrent(interp,1,1,0))) {
d1045 7
a1051 6
	    input_default->i_list->state_list->esPtr = esPtr;
	} else {
	    /* discard old one and install new one */
	    exp_free_i(interp,input_default->i_list,inter_updateproc);
	    input_default->i_list = exp_new_i_complex(interp,master_string,
		    EXP_TEMPORARY,inter_updateproc);
a1052 1
    }
d1054 4
a1057 4
    /*
     * check for user attempting to interact with self
     * they're almost certainly just fooling around
     */
d1059 4
a1062 4
    /* user could have replaced it with an indirect, so force update */
    if (input_user->i_list->direct == EXP_INDIRECT) {
	exp_i_update(interp,input_user->i_list);
    }
d1064 5
a1068 5
    if (input_user->i_list->state_list && input_default->i_list->state_list
	    && (input_user->i_list->state_list->esPtr == input_default->i_list->state_list->esPtr)) {
	exp_error(interp,"cannot interact with self - set spawn_id to a spawned process");
	return(TCL_ERROR);
    }
d1070 2
a1071 1
    esPtrs = 0;
d1073 4
a1076 4
    /*
     * all data structures are sufficiently set up that we can now
     * "finish()" to terminate this procedure
     */
d1078 2
a1079 2
    status = update_interact_fds(interp,&input_count,&esPtrToInput,&esPtrs,input_base,1,&configure_count,&real_tty);
    if (status == TCL_ERROR) finish(TCL_ERROR);
d1081 3
a1083 3
    if (real_tty) {
	tty_changed = exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
    }
d1085 4
a1088 4
    for (inp = input_base,i=0;inp;inp=inp->next,i++) {
	/* start timers */
	inp->timeout_remaining = inp->timeout_nominal;
    }
d1090 1
a1090 1
    key = expect_key++;
d1092 2
a1093 2
    /* declare ourselves "in sync" with external view of close/indirect */
    configure_count = exp_configure_count;
d1096 45
a1140 24
    /* loop waiting (in event handler) for input */
    for (;;) {
	int te;	/* result of Tcl_Eval */
	ExpState *u;
	int rc;	/* return code from ready.  This is further refined by matcher. */
	int cc;			/* # of chars from read() */
	struct action *action = 0;
	time_t previous_time;
	time_t current_time;
	int match_length;	/* # of chars matched */
	int skip;		/* # of chars not involved in match */
	int print;		/* # of chars to print */
	int oldprinted;		/* old version of u->printed */
	int change;		/* if action requires cooked mode */
	int attempt_match = TRUE;
	struct input *soonest_input;
	int timeout;	/* current as opposed to default_timeout */

	/* calculate how long to wait */
	/* by finding shortest remaining timeout */
	if (timeout_simple) {
	    timeout = default_timeout;
	} else {
	    timeout = arbitrary_timeout;
d1142 6
a1147 5
	    for (inp=input_base;inp;inp=inp->next) {
		if ((inp->timeout_remaining != EXP_TIME_INFINITY) &&
			(inp->timeout_remaining <= timeout)) {
		    soonest_input = inp;
		    timeout = inp->timeout_remaining;
a1148 1
	    }
d1150 2
a1151 9
	    time(&previous_time);
	    /* timestamp here rather than simply saving old */
	    /* current time (after ready()) to account for */
	    /* possibility of slow actions */
	    
	    /* timeout can actually be EXP_TIME_INFINITY here if user */
	    /* explicitly supplied it in a few cases (or */
	    /* the count-down code is broken) */
	}
d1153 1
a1153 7
	/* update the world, if necessary */
	if (configure_count != exp_configure_count) {
	    status = update_interact_fds(interp,&input_count,
		    &esPtrToInput,&esPtrs,input_base,1,
		    &configure_count,&real_tty);
	    if (status) finish(status);
	}
d1155 12
a1166 15
	rc = exp_get_next_event(interp,esPtrs,input_count,&u,timeout,key);
	if (rc == EXP_TCLERROR) return(TCL_ERROR);
	if (rc == EXP_RECONFIGURE) continue;
	if (rc == EXP_TIMEOUT) {
	    if (timeout_simple) {
		action = &action_timeout;
		goto got_action;
	    } else {
		action = soonest_input->action_timeout;
		/* arbitrarily pick first fd out of list */
		u = soonest_input->i_list->state_list->esPtr;
	    }
	}
	if (!timeout_simple) {
	    int time_diff;
d1168 2
a1169 2
	    time(&current_time);
	    time_diff = current_time - previous_time;
d1171 8
a1178 6
	    /* update all timers */
	    for (inp=input_base;inp;inp=inp->next) {
		if (inp->timeout_remaining != EXP_TIME_INFINITY) {
		    inp->timeout_remaining -= time_diff;
		    if (inp->timeout_remaining < 0)
			inp->timeout_remaining = 0;
a1179 2
	    }
	}
d1181 46
a1226 2
	/* at this point, we have some kind of event which can be */
	/* immediately processed - i.e. something that doesn't block */
d1228 6
a1233 2
	/* figure out who we are */
	inp = expStateToInput(esPtrToInput,u);
d1235 21
a1255 2
	/* reset timer */
	inp->timeout_remaining = inp->timeout_nominal;
d1257 5
a1261 12
	switch (rc) {
	    case EXP_DATA_NEW:
		if (u->size == u->msize) {
		    /* In theory, interact could be invoked when this situation */
		    /* already exists, hence the "probably" in the warning below */
		    
		    expDiagLogU("WARNING: interact buffer is full, probably because your\r\n");
		    expDiagLogU("patterns have matched all of it but require more chars\r\n");
		    expDiagLogU("in order to complete the match.\r\n");
		    expDiagLogU("Dumping first half of buffer in order to continue\r\n");
		    expDiagLogU("Recommend you enlarge the buffer or fix your patterns.\r\n");
		    exp_buffer_shuffle(interp,u,0,INTER_OUT,"interact");
d1263 38
a1300 15
/*SCOTT*/
		cc = Tcl_ReadChars(u, u->buffer + u->size,
				      u->msize - u->size);
		if (cc > 0) {
		    u->key = key;
		    u->size += cc;
		    u->buffer[u->size] = '\0';

		    /* strip parity if requested */
		    if (u->parity == 0) {
			/* do it from end backwards */
			char *p = u->buffer + u->size - 1;
			int count = cc;
			while (count--) {
			    *p-- &= 0x7f;
d1302 9
a1310 1
		    }
d1312 3
a1314 5
		    expDiagLog("spawn id %s send <",u->name);
		    expDiagLogU(expPrintify(u->buffer + u->size - cc));
		    expDiagLogU(">\r\n");
		    break;
		}
a1315 1
		rc = EXP_EOF;
d1317 1
a1317 5
		 * Most systems have read() return 0, allowing
		 * control to fall thru and into this code.  On some
		 * systems (currently HP and new SGI), read() does
		 * see eof, and it must be detected earlier.  Then
		 * control jumps directly to this EXP_EOF label.
d1319 2
d1322 82
a1403 19
		/*FALLTHRU*/
	    case EXP_EOF:
		action = inp->action_eof;
		attempt_match = FALSE;
		skip = u->size;
		expDiagLog("interact: received eof from spawn_id %d\r\n",u->name);
		/* actual close is done later so that we have a */
		/* chance to flush out any remaining characters */
		need_to_close_master = TRUE;
		break;
	    case EXP_DATA_OLD:
		cc = 0;
		break;
	    case EXP_TIMEOUT:
		action = inp->action_timeout;
		attempt_match = FALSE;
		skip = u->size;
		break;
	}
d1405 2
a1406 1
	km = 0;
d1408 2
a1409 6
	if (attempt_match) {
	    rc = in_keymap(u->buffer,u->size,inp->keymap,
		    &km,&match_length,&skip,u->rm_nulls);
	} else {
	    attempt_match = TRUE;
	}
d1411 13
a1423 6
	/* put regexp result in variables */
	if (km && km->re) {
	    char name[20], value[20];
	    regexp *re = km->re;
	    char match_char;/* place to hold char temporarily */
					/* uprooted by a NULL */
d1425 1
a1425 2
	    for (i=0;i<NSUBEXP;i++) {
		int offset;
d1427 4
a1430 1
		if (re->startp[i] == 0) continue;
d1432 3
a1434 22
		if (km->indices) {
		    /* start index */
		    sprintf(name,"%d,start",i);
		    offset = re->startp[i]-u->buffer;
		    sprintf(value,"%d",offset);
		    out(name,value);
		    
		    /* end index */
		    sprintf(name,"%d,end",i);
		    sprintf(value,"%d",re->endp[i]-u->buffer-1);
		    out(name,value);
		}

		/* string itself */
		sprintf(name,"%d,string",i);
		/* temporarily null-terminate in middle */
		match_char = *re->endp[i];
		*re->endp[i] = 0;
		out(name,re->startp[i]);
		*re->endp[i] = match_char;
	    }
	}
d1436 4
a1439 7
	/*
	 * dispose of chars that should be skipped
	 * i.e., chars that cannot possibly be part of a match.
	 */
	if (km && km->writethru) {
	    print = skip + match_length;
	} else print = skip;
d1441 4
a1444 2
	expEcho(u,km,skip,match);
	oldprinted = u->printed;
d1446 2
a1447 20
	/*
	 * If expect has left characters in buffer, it has
	 * already echoed them to the screen, thus we must
	 * prevent them being rewritten.  Unfortunately this
	 * gives the possibility of matching chars that have
	 * already been output, but we do so since the user
	 * could have avoided it by flushing the output
	 * buffers directly.
	 */
	if (print > u->printed) {	/* usual case */
	    for (outp = inp->output;outp;outp=outp->next) {
		struct exp_state_list *fdp;
		for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
		    /* send to channel (and log if chan is stdout or devtty) */
		    int wc = expWriteBytesAndLogIfTtyU(fdp->esPtr,
			    Tcl_GetString(u->buffer) + u->printed,
			    print - u->printed);
		    if (wc <= 0) {
			expDiagLog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
			action = outp->action_eof;
a1448 1
			
d1450 2
a1451 1
			    exp_tty_set(interp,&tty_old,was_raw,was_echo);
d1453 1
a1453 1
				
d1455 1
a1455 1
						    exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
d1457 2
a1458 2
			    case TCL_BREAK:
			    case TCL_CONTINUE:
d1460 1
a1460 1
			    case EXP_TCL_RETURN:
d1462 1
a1462 1
			    case TCL_RETURN:
d1464 1
a1464 1
			    case TCL_OK:
d1470 1
a1470 1
			    default:
a1472 1
		    }
a1473 2
	    }
	    u->printed = print;
a1474 8
	
	/* u->printed is now accurate with respect to the buffer */
	/* However, we're about to shift the old data out of the */
	/* buffer.  Thus, u->size, printed, and echoed must be */
	/* updated */
	
	/* first update size based on skip information */
	/* then set skip to the total amount skipped */
a1475 71
	if (rc == EXP_MATCH) {
	    action = &km->action;

	    skip += match_length;
	    u->size -= skip;

/*SCOTT*/
	    if (u->size) {
		memcpy(u->buffer, u->buffer + skip, u->size);
		exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
	    }
	} else {
	    if (skip) {
		u->size -= skip;
		memcpy(u->buffer, u->buffer + skip, u->size);
		exp_lowmemcpy(u->lower,u->buffer+ skip, u->size);
	    }
	}
	u->buffer[u->size] = '\0';
	u->lower [u->size] = '\0';

	/* now update printed based on total amount skipped */

	u->printed -= skip;
	/* if more skipped than printed (i.e., keymap encountered) */
	/* for printed positive */
	if (u->printed < 0) u->printed = 0;

	/* if we are in the middle of a match, force the next event */
	/* to wait for more data to arrive */
	u->force_read = (rc == EXP_CANMATCH);

	/* finally reset echoed if necessary */
	if (rc != EXP_CANMATCH) {
	    if (skip >= oldprinted + u->echoed) u->echoed = 0;
	}

	if (rc == EXP_EOF) {
	    exp_close(interp,u);
	    need_to_close_master = FALSE;
	}

	if (action) {
got_action:
	    change = (action && action->tty_reset);
	    if (change && tty_changed)
		exp_tty_set(interp,&tty_old,was_raw,was_echo);

	    te = inter_eval(interp,action,u);

	    if (change && real_tty) tty_changed =
					exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
	    switch (te) {
		case TCL_BREAK:
		case TCL_CONTINUE:
		    finish(te);
		case EXP_TCL_RETURN:
		    finish(TCL_RETURN);
		case TCL_RETURN:
		    finish(TCL_OK);
		case TCL_OK:
		    /* god knows what the user might */
		    /* have done to us in the way of */
		    /* closed fds, so .... */
		    action = 0;	/* reset action */
		    continue;
		default:
		    finish(te);
	    }
	}
    }
d1484 1
d1502 1
a1502 11
	    /*
	     * This is a new child process.
	     * It exists only for this interact command and will go away when
	     * the interact returns.
	     *
	     * The purpose of this child process is to read output from the
	     * spawned process and send it to the user tty.
	     * (See diagram above.)
	     */

	    exp_close(interp,expStdinoutGet());
d1559 2
a1560 2
			cc = Tcl_ReadChars(u,u->buffer + u->size,
					     u->msize - u->size);
d1576 5
a1580 3
				expDiagLog("spawn id %s send <",u->name);
				expDiagLogU(expPrintify(u->buffer + u->size - cc));
				expDiagLogU(">\r\n");
d1595 2
a1596 2
			expDiagLog("interact: child received eof from spawn_id %s\r\n",u->name);
			exp_close(interp,u);
d1614 5
d1662 18
a1679 1
		expEcho(u,km,skip,match);
d1690 38
a1727 29
		    for (outp = inp->output;outp;outp=outp->next) {
			struct exp_state_list *fdp;
			for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
			    /* send to channel (and log if chan is stdout or devtty) */
			    int wc = expWriteBytesAndLogIfTtyU(fdp->esPtr,
				    Tcl_GetString(u->buffer) + u->printed,
				    print - u->printed);
			    if (wc <= 0) {
				expDiagLog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
				action = outp->action_eof;

				te = inter_eval(interp,action,u);

				switch (te) {
				    case TCL_BREAK:
				    case TCL_CONTINUE:
					finish(te);
				    case EXP_TCL_RETURN:
					finish(TCL_RETURN);
				    case TCL_RETURN:
					finish(TCL_OK);
				    case TCL_OK:
					/* god knows what the user might */
					/* have done to us in the way of */
					/* closed fds, so .... */
					action = 0;	/* reset action */
					continue;
				    default:
					finish(te);
d1731 1
a1731 2
		    }
		    u->printed = print;
d1801 1
a1801 9
	} else {
	    /*
	     * This is the original Expect process.
	     *
	     * It now loops, reading keystrokes from the user tty
	     * and sending them to the spawned process.
	     * (See diagram above.)
	     */

d1807 1
a1807 1
		expDiagLog("fork = %d\r\n",pid);
d1865 1
a1865 1
			cc = i_read(u,	u->buffer + u->size,
d1882 5
a1886 3
				expDiagLog("spawn id %s send <",u->name);
				expDiagLogU(expPrintify(u->buffer + u->size - cc));
				expDiagLogU(">\r\n");
d1896 1
a1896 1
				expDiagLogU("interact: process died/eof\r\n");
d1912 1
a1912 1
			expDiagLogU("user sent EOF or disappeared\n\n");
d1973 18
a1990 1
		expEcho(u,km,skip,match);
d2001 43
a2043 34
		    for (outp = inp->output;outp;outp=outp->next) {
			struct exp_state_list *fdp;
			for (fdp = outp->i_list->state_list;fdp;fdp=fdp->next) {
			    /* send to channel (and log if chan is stdout or devtty) */
			    int wc = expWriteBytesAndLogIfTtyU(fdp->esPtr,
				    Tcl_GetString(u->buffer) + u->printed,
				    print - u->printed);
			    if (wc <= 0) {
				expDiagLog("interact: write on spawn id %s failed (%s)\r\n",fdp->esPtr->name,Tcl_PosixError(interp));
				clean_up_after_child(interp,fdp->esPtr);
				action = outp->action_eof;
				change = (action && action->tty_reset);
				if (change && tty_changed)
				    exp_tty_set(interp,&tty_old,was_raw,was_echo);
				te = inter_eval(interp,action,esPtr);

				if (change && real_tty) tty_changed =
							    exp_tty_raw_noecho(interp,&tty_old,&was_raw,&was_echo);
				switch (te) {
				    case TCL_BREAK:
				    case TCL_CONTINUE:
					finish(te);
				    case EXP_TCL_RETURN:
					finish(TCL_RETURN);
				    case TCL_RETURN:
					finish(TCL_OK);
				    case TCL_OK:
					/* god knows what the user might */
					/* have done to us in the way of */
					/* closed fds, so .... */
					action = 0;	/* reset action */
					continue;
				    default:
					finish(te);
d2047 1
a2047 2
		    }
		    u->printed = print;
d2136 1
a2136 1
	if (need_to_close_master) exp_close(interp,u);
d2171 1
a2171 1
	expStdoutLogU("\r\n",1);
@


5.28.1.1.2.6
log
@made stuff compile
@
text
@d190 8
a197 6
in_keymap(esPtr,keymap,km_match,match_length,skip)
    ExpState *esPtr;
    struct keymap *keymap;	/* linked list of keymaps */
    struct keymap **km_match;	/* keymap that matches or can match */
    int *match_length;		/* # of chars that matched */
    int *skip;			/* # of chars to skip */
a198 1
    char *string;
a202 5
    char *string;
    int stringLen;
    int rm_nulls;		/* skip nulls if true */

    string = Tcl_GetStringFromObj(esPtr->buffer,&stringLen);
d210 1
a210 1
	*skip = stringLen;
d214 1
a214 3
    rm_nulls = esPtr->rm_nulls;

    string_end = string + stringLen;
d385 2
a386 2
				/* in expIRead record this here, so it will */
				/* be handled next time through expIRead */
d398 1
a398 1
 * Name: expIRead, do an interruptable read
d400 1
a400 1
 * intIRead() reads from chars from the user.
d406 4
a409 27
intIRead(channel,obj,size,flags);
Tcl_Channel channel;
Tcl_Obj *obj;
int size;
int flags;
{
    int cc = EXP_CHILD_EOF;

    if (deferred_interrupt) return(cc);

    if (0 == setjmp(env)) {
	reading = TRUE;
	cc = Tcl_ReadChars(channel,obj,size,flags);
    }
    reading = FALSE;
    return(cc);
}

/*
 * intRead() does the logical equivalent of a read() for the interact command.
 * Returns # of bytes read or negative number (EXP_XXX) indicating unusual event.
 */
static int
intRead(esPtr,warnOnBufferFull,interruptible)
    ExpState *esPtr;
    int warnOnBufferFull;
    int interruptible;
d411 1
a411 4
    char *eobOld;  /* old end of buffer */
    int cc;
    int size = expSizeGet(esPtr);
    char *str;
d413 1
a413 2
    str = Tcl_GetString(esPtr->buffer,&size);
    eobOld = str+size;
d415 3
a417 11
    if (size + TCL_UTF_MAX >= esPtr->msize) {
	/*
	 * In theory, interact could be invoked when this situation
	 * already exists, hence the "probably" in the warning below
	 */
	if (warnOnBufferFull) {
	    expDiagLogU("WARNING: interact buffer is full, probably because your\r\n");
	    expDiagLogU("patterns have matched all of it but require more chars\r\n");
	    expDiagLogU("in order to complete the match.\r\n");
	    expDiagLogU("Dumping first half of buffer in order to continue\r\n");
	    expDiagLogU("Recommend you enlarge the buffer or fix your patterns.\r\n");
d419 2
a420 29
	exp_buffer_shuffle(interp,u,0,INTER_OUT,"interact");
    }
    if (!interruptible) {
	cc = Tcl_ReadChars(esPtr->channel,
		esPtr->buffer,
		esPtr->msize - (size / TCL_UTF_MAX),
		1 /* append */);
    } else {
#ifdef SIMPLE_EVENT
	cc = intIRead(esPtr->channel,
		esPtr->buffer,
		esPtr->msize - (size / TCL_UTF_MAX),
		1 /* append */);
#endif
    }

    if (cc > 0) {
	/* strip parity if requested */
	if (esPtr->parity == 0) {
	    expParityStrip(esPtr->buffer,size /* old size which is now offset */);
	}
	expDiagLog("spawn id %s send <",u->name);
	expDiagLogU(expPrintify(eobOld));
	expDiagLogU(">\r\n");

	u->key = key;
	cc = expSizeGet(esPtr);  /* generate true byte count */
    }
    return cc;
d552 1
a552 1
Exp_InteractCmd(clientData, interp, objc, objv)
d584 1
a584 2
    int i;			/* misc temp */
    int size;			/* size temp */
d1224 34
a1257 2
		cc = intRead(esPtr,1,0);
		if (cc > 0) break;
a1260 2
		 * FALLTHRU
		 *
d1267 2
d1272 2
a1273 2
		skip = expSizeGet(u);
		expDiagLog("interact: received eof from spawn_id %s\r\n",u->name);
d1284 1
a1284 1
		skip = expSizeGet(u);
d1291 2
a1292 1
	    rc = in_keymap(u,inp->keymap,&km,&match_length,&skip);
d1396 1
a1396 1
	/* buffer.  Thus size, printed, and echoed must be */
a1401 1
	size = expSizeGet(u);
d1406 6
a1411 3
	    size -= skip;
	    if (size) {
		memcpy(u->buffer, u->buffer + skip, size);
d1415 3
a1417 2
		size -= skip;
		memcpy(u->buffer, u->buffer + skip, size);
d1420 2
a1421 1
	Tcl_SetObjLength(size);
d1565 29
a1593 11
		    cc = intRead(esPtr,0,0);
		    if (cc > 0) break;
		    /*
		     * FALLTHRU
		     *
		     * Most systems have read() return 0, allowing
		     * control to fall thru and into this code.  On some
		     * systems (currently HP and new SGI), read() does
		     * see eof, and it must be detected earlier.  Then
		     * control jumps directly to this EXP_EOF label.
		     */
d1597 1
a1597 1
			skip = expSizeGet(u);
d1610 2
a1611 1
			rc = in_keymap(u,inp->keymap,&km,&match_length,&skip);
d1710 1
a1710 1
		/* buffer.  Thus size, printed, and echoed must be */
d1716 9
a1724 9
		size = expSizeGet(u);
		if (rc =n= EXP_MATCH) {
		    action = &km->action;

		    skip += match_length;
		    size -= skip;
		    if (size) {
			memcpy(u->buffer, u->buffer + skip, size);
		    }
d1726 5
a1730 4
		    if (skip) {
			size -= skip;
			memcpy(u->buffer, u->buffer + skip, size);
		    }
a1731 1
		Tcl_SetObjLength(size);
d1733 5
d1847 20
a1866 2
		        cc = intRead(esPtr,0,1);
		        if (cc > 0) {
d1874 1
a1874 1
				skip = expSizeGet(u);
d1880 7
a1886 9
			/*
			 * FALLTHRU
			 *
			 * Most systems have read() return 0, allowing
			 * control to fall thru and into this code.  On some
			 * systems (currently HP and new SGI), read() does
			 * see eof, and it must be detected earlier.  Then
			 * control jumps directly to this EXP_EOF label.
			 */
d1890 1
a1890 1
			skip = expSizeGet(u);
d1902 2
a1903 1
			rc = in_keymap(u,inp->keymap,&km,&match_length,&skip);
d2007 1
a2007 1
		/* buffer.  Thus size, printed, and echoed must be */
a2012 1
		size = expSizeGet(u);
d2014 4
a2017 1
		    action = &km->action;
d2019 3
a2021 5
		    skip += match_length;
		    size -= skip;
		    if (size) {
			memcpy(u->buffer, u->buffer + skip, size);
		    }
d2023 5
a2027 4
		    if (skip) {
			size -= skip;
			memcpy(u->buffer, u->buffer + skip, size);
		    }
a2028 1
		Tcl_SetObjLength(size);
d2030 5
@


5.28.1.1.2.7
log
@Checkpoint
@
text
@a47 1
#if OBSOLETE
a49 1
#endif /* OBSOLETE */
d94 1
a94 1
	Tcl_RegExp *re;
d132 1
a132 1
    Tcl_HashEntry *entry = Tcl_FindHashEntry(hash,(char *)esPtr);
d148 1
a148 1
    int newPtr;
d150 1
a150 1
    entry = Tcl_CreateHashEntry(hash,(char *)esPtr,&newPtr);
d197 1
d276 1
a276 1
		Tcl_RegExp *prog = km->re;
a341 4
    int echoBytes;
    int echoChars;
    char *string;
    char *p;
d348 4
a351 3
	echoBytes = matchBytes;
    } else if ((matchBytes + skipBytes - seenBytes) > 0) {
	echoBytes = matchBytes+skipBytes-seenBytes;
a352 9

    string = Tcl_GetString(esPtr->buffer)+skipBytes;
    echoChars = 0;
    for (p=string;*p;p=Tcl_UtfNext(p)) {
	if (p-string == echoBytes) break;
	echoChars++;
    }

    Tcl_WriteChars(esPtr->channel, Tcl_GetString(esPtr->buffer)+skipBytes, echoChars);
d513 1
a513 1
Tcl_HashTable **esPtrToInput;	/* map from ExpStates to "struct inputs" */
d574 1
a574 1
	    *esPtrs = (ExpState **)ckrealloc((char *)*esPtrs,count * sizeof(ExpState *));
d582 1
a582 1
		expCreateStateToInput(*esPtrToInput,fdp->esPtr,inp);
d688 1
a688 1
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
@


5.28.1.1.2.8
log
@Fixed interact of all but regexp probs.
@
text
@d51 1
a54 8
#endif /* OBSOLETE */

typedef struct ThreadSpecificData {
    Tcl_Obj *cmdObjReturn;
    Tcl_Obj *cmdObjInterpreter;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
d58 1
a58 1
 expDiagLog("interact: set %s(%s) \"",INTER_OUT,var); \
d527 1
a527 1
ExpState ***esPtrs;
a638 3
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    char *string;
a649 1
    ExpState *u = 0;
d739 1
a739 1
    action_eof.statement = tsdPtr->cmdObjReturn;
d750 1
a750 1
	string = Tcl_GetString(*objv);
d760 1
a760 1
		EXP_SWITCH_DASH,	EXP_SWITCH_EXACT,
d778 1
a778 1
	    if (Tcl_GetIndexFromObj(interp, *objv, switches, "switch", 0,
d820 1
a820 1
		    inp->i_list = exp_new_i_complex(interp,Tcl_GetString(*objv),
d841 1
a841 1
		    outp->i_list = exp_new_i_complex(interp,Tcl_GetString(*objv),
d903 1
a903 1
		case EXP_SWITCH_IWRITE:
d988 1
a988 1
	    if (Tcl_GetIndexFromObj(interp, *objv, options, "option",
d1098 1
a1098 1
	expDiagLogU(Tcl_GetString(km->keys));
d1100 1
a1100 1
	expDiagLogU(km->action.statement?expPrintify(Tcl_GetString(km->action.statement)):"interpreter");
d1118 1
a1118 1
	    o->i_list = exp_new_i_complex(interp,Tcl_GetString(chanName),
d1128 1
a1128 1
	o->i_list = exp_new_i_simple(expStdinoutGet(),EXP_TEMPORARY);/* stdout by default */
d1143 1
a1143 1
		Tcl_GetString(replace_user_by_process),
d1146 1
a1146 1
		Tcl_GetString(replace_user_by_process),
d1169 1
a1169 1
	    input_default->i_list = exp_new_i_complex(interp,Tcl_GetString(chanName),
d1218 1
d1349 1
a1349 1
	    Tcl_RegExp *re = km->re;
d1389 1
a1389 1
	expEcho(u,km,skip,match_length);
a1405 3
		    /*
		     * Following should eventually be rewritten to ...WriteCharsAnd...
		     */
d1458 1
a1458 2
		string = Tcl_GetString(u->buffer);
		memmove(string, string + skip, size);
a1460 1
	    string = Tcl_GetString(u->buffer);
d1463 1
a1463 1
		memcpy(string, string + skip, size);
d1466 1
a1466 1
	Tcl_SetObjLength(u->buffer,size);
d2081 1
d2084 4
a2087 4
    /* force child to exit upon eof from master */
    if (pid == 0) {
	exit(SPAWNED_PROCESS_DIED);
    }
d2090 1
a2090 1
    if (need_to_close_master) exp_close(interp,u);
d2092 5
a2096 5
    if (tty_changed) exp_tty_set(interp,&tty_old,was_raw,was_echo);
    if (esPtrs) ckfree((char *)esPtrs);
    if (esPtrToInput) Tcl_DeleteHashTable(esPtrToInput);
    free_input(interp,input_base);
    free_action(action_base);
d2098 1
a2098 1
    return(status);
d2123 1
a2123 1
	status = Tcl_EvalObjEx(interp,action->statement,0);
d2203 1
a2203 8
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    exp_create_commands(interp,cmd_data);

    tsdPtr->cmdObjReturn = Tcl_NewStringObj("return",6);
    Tcl_IncrRefCount(tsdPtr->cmdObjReturn);
    tsdPtr->cmdObjInterpreter = Tcl_NewStringObj("interpreter",11);
    Tcl_IncrRefCount(tsdPtr->cmdObjInterpreter);
@


5.28.1.1.2.9
log
@updated interact code to use new regexp interfaces
fixed bug in eval_case_string where non-matches were reported as matches
@
text
@d50 1
d65 1
a65 1
 expDiagLog("interact: set %s(%s) ",INTER_OUT,var); \
d103 1
a103 1
	int re;		/* true if looking to match a regexp. */
a205 2
    char *string;
    int offset;
d211 1
a211 1
    int stringLen, bytesThisChar;
d214 1
a214 1
    string = Tcl_GetStringFromObj(esPtr->buffer,&stringBytes);
d222 1
a222 1
	*skip = stringBytes;
d228 1
a228 1
    string_end = string + stringBytes;
a232 5
    /*
     * Maintain both a character index and a string pointer so we
     * can easily index into either the UTF or the Unicode representations.
     */

d235 1
a235 6
    for (start_search = string, offset = 0;
	 start_search < string_end;
	 start_search += bytesThisChar, offset++) {

	bytesThisChar = Tcl_UtfToUniChar(start_search, &ch);
	
d244 1
a244 1
		if (ch == 0) {
a250 3
		char *slen, *kslen;
		Tcl_UniChar sch, ksch;
		
d252 8
a259 9
		
		for (s = start_search,ks = km->keys ;;s+=slen,ks+=kslen) {
		    /* if we hit the end of this map, must've matched! */
		    if (*ks == 0) {
			*skip = start_search-string;
			*match_length = s-start_search;
			*km_match = km;
			return(EXP_MATCH);
		    }
d261 10
a270 10
		    /* if we ran out of user-supplied characters, and */
		    /* still haven't matched, it might match if the user */
		    /* supplies more characters next time */

		    if (s == string_end) {
			/* skip to next key entry, but remember */
			/* possibility that this entry might match */
			if (!*km_match) *km_match = km;
			break;
		    }
d272 1
a272 1
		    /* if this is a problem for you, use exp_parity command */
d274 6
a279 9
		    slen = Tcl_UtfToUniChar(s, &sch);
		    kslen = Tcl_UtfToUniChar(ks, &ksch);
		    
		    if (sch == ksch) continue;
		    if ((sch == '\0') && rm_nulls) {
			kslen = 0;
			continue;
		    }
		    break;
d283 2
a284 12
		Tcl_RegExp re;
		int flags;
		int result;

		re = Tcl_GetRegExpFromObj(NULL, km->keys, TCL_REG_ADVANCED);
		flags = (offset > 0) ? TCL_REG_NOTBOL : 0;

		result = Tcl_RegExpMatchObj(NULL, re, esPtr->buffer, offset,
			-1 /* nmatches */, flags);
		if (result > 0) {
		    Tcl_RegExpInfo info;
		    Tcl_RegExpGetInfo(re, &info);
d286 13
a298 7
		    /*
		     * Check to see that the match begins with the current
		     * character.  This is a hack until we get a fix from
		     * Henry to allow the TCL_REG_BOSONLY flag. 
		     */

		    if (info.matches[0].start == 0) {
d301 3
a303 12
			return EXP_MATCH;
		    }
		} else if (result == 0) {
		    Tcl_RegExpInfo info;
		    Tcl_RegExpGetInfo(re, &info);

		    /*
		     * Check to see if there was a partial match starting
		     * at the current character.
		     */
		    
		    if (info.extendStart == 0) {
d305 1
a305 2
		    }
		}		    
a806 10

		    /*
		     * Try compiling the expression so we can report
		     * any errors now rather then when we first try to
		     * use it.
		     */

		    if (!(Tcl_GetRegExpFromObj(interp, objv, REG_ADVANCED))) {
			return TCL_ERROR;
		    }
d1093 6
a1098 1
	    km->re = TRUE;
d1100 1
a1100 2
	}
	if (next_null) {
d1359 3
a1361 5
	    Tcl_RegExpInfo info;
	    Tcl_RegExp re;

	    re = Tcl_GetRegExpFromObj(interp, km->keys, TCL_REG_ADVANCED);
	    Tcl_RegExpGetInfo(re, &info);
d1363 2
a1364 2
	    for (i=0;i<info.nsubs;i++) {
		int start, end;
d1366 1
a1366 3
		start = info.matches[i].start;
		if (start == -1) continue;
		end = info.matches[i].end;
d1371 2
a1372 1
		    sprintf(value,"%d",start);
d1377 1
a1377 1
		    sprintf(value,"%d",end-1);
d1381 1
a1381 1
				/* string itself */
d1383 5
a1387 5
		val = Tcl_GetRange(buffer, start, end);
		expDiagLog("expect_background: set %s(%s) \"",INTER_OUT,name);
		expDiagLogU(expPrintifyObj(val));
		expDiagLogU("\"\r\n");
		Tcl_SetVar2Ex(interp,INTER_OUT,name,val,0);
a1532 1

a2095 1

@


5.28.1.1.2.10
log
@expect.c and exp_inter.c now compile cleanly
@
text
@d211 2
a212 1
    int stringBytes, bytesThisChar;
a213 1
    Tcl_UniChar ch;
d231 3
d262 1
a262 1
		int slen, kslen;
d266 2
a267 3

		ks = Tcl_GetString(km->keys);
		for (s = start_search;; s += slen, ks += kslen) {
d305 1
a305 2
		re = Tcl_GetRegExpFromObj(NULL, km->keys,
			TCL_REG_ADVANCED|TCL_REG_BOSONLY);
d846 1
a846 2
		    if (!(Tcl_GetRegExpFromObj(interp, *objv,
			    TCL_REG_ADVANCED|TCL_REG_BOSONLY))) {
d1400 1
a1400 2
	    re = Tcl_GetRegExpFromObj(interp, km->keys,
		    TCL_REG_ADVANCED|TCL_REG_BOSONLY);
a1404 1
		Tcl_Obj *val;
d1424 1
a1424 1
		val = Tcl_GetRange(esPtr->buffer, start, end);
@


5.28.1.1.2.11
log
@eliminated redundant test in regexp matching code
@
text
@d310 14
a323 3
		    *km_match = km;
		    *skip = start_search-string;
		    return EXP_MATCH;
@


5.28.1.1.2.12
log
@compiled!
@
text
@d46 1
d96 1
a395 61
/*
 * intRead() does the logical equivalent of a read() for the interact command.
 * Returns # of bytes read or negative number (EXP_XXX) indicating unusual event.
 */
static int
intRead(interp,esPtr,warnOnBufferFull,interruptible,key)
    Tcl_Interp *interp;
    ExpState *esPtr;
    int warnOnBufferFull;
    int interruptible;
    int key;
{
    char *eobOld;  /* old end of buffer */
    int cc;
    int size = expSizeGet(esPtr);
    char *str;

    str = Tcl_GetStringFromObj(esPtr->buffer,&size);
    eobOld = str+size;

    if (size + TCL_UTF_MAX >= esPtr->msize) {
	/*
	 * In theory, interact could be invoked when this situation
	 * already exists, hence the "probably" in the warning below
	 */
	if (warnOnBufferFull) {
	    expDiagLogU("WARNING: interact buffer is full, probably because your\r\n");
	    expDiagLogU("patterns have matched all of it but require more chars\r\n");
	    expDiagLogU("in order to complete the match.\r\n");
	    expDiagLogU("Dumping first half of buffer in order to continue\r\n");
	    expDiagLogU("Recommend you enlarge the buffer or fix your patterns.\r\n");
	}
	exp_buffer_shuffle(interp,esPtr,0,INTER_OUT,"interact");
    }
    if (!interruptible) {
	cc = Tcl_ReadChars(esPtr->channel,
		esPtr->buffer,
		esPtr->msize - (size / TCL_UTF_MAX),
		1 /* append */);
    } else {
#ifdef SIMPLE_EVENT
	cc = intIRead(esPtr->channel,
		esPtr->buffer,
		esPtr->msize - (size / TCL_UTF_MAX),
		1 /* append */);
#endif
    }

    if (cc > 0) {
	expDiagLog("spawn id %s sent <",esPtr->name);
	expDiagLogU(expPrintify(eobOld));
	expDiagLogU(">\r\n");

	esPtr->key = key;
	cc = expSizeGet(esPtr);  /* generate true byte count */
    }
    return cc;
}



d470 61
d660 1
a660 1
Exp_InteractObjCmd(clientData, interp, objc, objv)
d694 1
d774 1
d788 1
a788 1
		"-eof",		"-timeout",	"-nobrace"
d800 1
a800 1
		EXP_SWITCH_NOBRACE
d961 2
d996 2
d1000 4
d1049 2
d1083 2
d1113 1
d1343 1
a1343 1
		cc = intRead(u,esPtr,1,0,key);
d1658 1
a1658 1
		    cc = intRead(u,esPtr,0,0,key);
d1916 1
a1916 1
		        cc = intRead(u,esPtr,0,1,key);
d2158 8
d2244 1
a2244 1
{"interact",	Exp_InteractObjCmd,	0,	0,	0},
@


5.28.1.1.2.13
log
@-gl now appears to work
@
text
@d1376 1
a1376 1
	    for (i=0;i<=info.nsubs;i++) {
@


5.28.1.1.2.14
log
@Updated to reflect change of Tcl_RegExpMatchObj to Tcl_RegExpExecObj
moved compiler configure tests earlier in file so it works with gcc
@
text
@d305 1
a305 1
		result = Tcl_RegExpExecObj(NULL, re, esPtr->buffer, offset,
@


5.28.1.1.2.15
log
@Fixed:
 expect command's arg handling to work (like interact)
 spawn -open
 expect eof
and various other bugs.
Expect now runs its minimal test suite (but not the examples).
@
text
@d408 1
a408 1
    int size;
a1019 1
		Tcl_ResetResult(interp);
d1326 1
a1326 1
		cc = intRead(interp,u,1,0,key);
d1398 1
a1398 1
		val = Tcl_GetRange(u->buffer, start, end);
d1445 1
a1445 1

d1573 1
a1573 1
	if (pid == 0) {
d1641 1
a1641 1
		    cc = intRead(interp,u,0,0,key);
d1899 1
a1899 1
		        cc = intRead(interp,u,0,1,key);
d2013 1
a2013 1
				te = inter_eval(interp,action,u);
d2086 1
a2086 1
			te = inter_eval(interp,action,u);
@


5.28.1.1.2.16
log
@fixed examples
@
text
@d47 7
d167 1
a167 1
/* intMatch() accepts user keystrokes and returns one of MATCH,
d174 1
a174 1
intMatch is optimized (if you can call it that) towards a small
d196 1
a196 1
intMatch(esPtr,keymap,km_match,matchLen,skip,info)
d200 1
a200 1
    int *matchLen;		/* # of bytes that matched */
a201 1
    Tcl_RegExpInfo *info;
d204 1
d207 1
a207 4

    char *start_search;	/* where in string to start searching */
    int offset;		/* # of chars from string to start searching */

d234 2
d252 1
a252 1
		    *matchLen = 1;	/* s - start_search == 1 */
d267 1
a267 1
			*matchLen = s-start_search;
d283 2
a309 2
		    Tcl_RegExpGetInfo(re, info);
		    *matchLen = Tcl_UtfAtIndex(start_search,info->matches[0].end) - start_search;
d312 2
a313 1
		    Tcl_RegExpGetInfo(re, info);
d319 2
a320 1
		    if (info->extendStart == 0) {
d329 1
a329 1
	/* report CANMATCH for -re and -ex */
d331 3
d335 8
a342 2
	 * since canmatch is only detected after we've advanced too far,
	 * adjust start_search back to make other computations simpler
d344 6
a349 4
	start_search--;

	*skip = start_search - string;
	*matchLen = string_end - start_search;
a356 41
/* put regexp result in variables */
static void
intRegExpMatchProcess(interp,esPtr,km,info)
     Tcl_Interp *interp;
     ExpState *esPtr;
     struct keymap *km;	/* ptr for above while parsing */
     Tcl_RegExpInfo *info;
{
    char name[20], value[20];
    int i;

    for (i=0;i<=info->nsubs;i++) {
	int start, end;
	Tcl_Obj *val;

	start = info->matches[i].start;
	if (start == -1) continue;
	end = info->matches[i].end;

	if (km->indices) {
	    /* start index */
	    sprintf(name,"%d,start",i);
	    sprintf(value,"%d",start);
	    out(name,value);
		    
	    /* end index */
	    sprintf(name,"%d,end",i);
	    sprintf(value,"%d",end-1);
	    out(name,value);
	}

	/* string itself */
	sprintf(name,"%d,string",i);
	val = Tcl_GetRange(esPtr->buffer, start, end);
	expDiagLog("expect_background: set %s(%s) \"",INTER_OUT,name);
	expDiagLogU(expPrintifyObj(val));
	expDiagLogU("\"\r\n");
	Tcl_SetVar2Ex(interp,INTER_OUT,name,val,0);
    }
}

d361 1
a361 1
intEcho(esPtr,km,skipBytes,matchBytes)
a677 1
    Tcl_RegExpInfo reInfo;
d1245 1
a1245 1
	int matchLen;	/* # of chars matched */
d1362 1
a1362 4
	    rc = intMatch(u,inp->keymap,&km,&matchLen,&skip,&reInfo);
	    if ((rc == EXP_MATCH) && km && km->re) {
		intRegExpMatchProcess(interp,u,km,&reInfo);
	    }
d1367 40
d1412 1
a1412 1
	    print = skip + matchLen;
d1415 1
a1415 1
	intEcho(u,km,skip,matchLen);
d1484 1
a1484 1
	    skip += matchLen;
d1561 1
a1561 1
		int matchLen, skip;
d1669 1
a1669 4
		    rc = intMatch(u,inp->keymap,&km,&matchLen,&skip,&reInfo);
		    if ((rc == EXP_MATCH) && km && km->re) {
			intRegExpMatchProcess(interp,u,km,&reInfo);
		    }
d1671 37
a1707 1
		    attempt_match = TRUE;
d1716 1
a1716 1
			print = skip + matchLen;
d1719 1
a1719 1
		intEcho(u,km,skip,match);
d1778 1
a1778 1
		    skip += matchLen;
d1939 1
a1939 4
		    rc = intMatch(u,inp->keymap,&km,&matchLen,&skip,&reInfo);
		    if ((rc == EXP_MATCH) && km && km->re) {
			intRegExpMatchProcess(interp,u,km,&reInfo);
		    }
d1941 37
a1977 1
		    attempt_match = TRUE;
d1986 1
a1986 1
			print = skip + matchLen;
d1989 1
a1989 1
		intEcho(u,km,skip,match);
d2053 1
a2053 1
		    skip += matchLen;
@


5.28.1.1.2.17
log
@Fixed interact's -input/-output.
More fixes to exp_eval_with_one_arg.
Now runs dislocate.
@
text
@a687 1
    Tcl_Obj *CONST *objv_copy;	/* original, for error messages */
a758 2
    objv_copy = objv;

d798 1
d840 1
a840 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"-re pattern");
d878 1
a878 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"-input spawn_id");
d899 1
a899 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"-output spawn_id");
d912 1
a912 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"-u spawn_id");
d989 1
a989 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"-timeout time");
d1069 1
a1069 1
			Tcl_WrongNumArgs(interp,1,objv_copy,"timeout time");
a1139 5
	if (objc >= 1) {
	    km->action.statement = *objv;
	} else {
	    km->action.statement = 0;
	}
d1141 1
a2152 1
#if 0
a2154 1
#endif
@


5.28.1.1.2.18
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d355 1
a355 1
	end = info->matches[i].end-1;
d365 1
a365 1
	    sprintf(value,"%d",end);
d389 1
d395 2
d470 1
d690 1
d809 1
a809 1
		"-eof",		"-timeout",	"-nobrace",	(char *)0
d1032 1
a1032 1
		"eof", "timeout", "null", (char *)0
d1407 1
a1407 3
	if (km && km->echo) {
	    intEcho(u,km,skip,matchLen);
	}
d1678 1
a1678 3
		if (km && km->echo) {
		    intEcho(u,km,skip,matchLen);
		}
d1915 1
a1915 3
		if (km && km->echo) {
		    intEcho(u,km,skip,matchLen);
		}
d2076 1
a2076 1
	status = exp_interpreter(interp,(Tcl_Obj *)0);
@


5.28.1.1.2.19
log
@In interact, fixed encoding bug and -echo bug.
Made Makefile.in support CodeCenter better.
Fixed regexp bug in debugger.
@
text
@d383 1
a383 1
intEcho(esPtr,skipBytes,matchBytes)
d385 1
a386 1
    int matchBytes;
d390 3
a392 1
    int offsetBytes;
a397 1
	offsetBytes = skipBytes;
d399 1
a399 2
	echoBytes = matchBytes + skipBytes - seenBytes;
	offsetBytes = seenBytes;
d402 6
a407 3
    Tcl_WriteChars(esPtr->channel,
		   Tcl_GetString(esPtr->buffer) + offsetBytes,
		   echoBytes);
d409 1
d1403 1
a1403 1
	    intEcho(u,skip,matchLen);
d1676 1
a1676 1
		    intEcho(u,skip,matchLen);
d1915 1
a1915 1
		    intEcho(u,skip,matchLen);
@


5.28.1.1.2.20
log
@Fixes to library.
Testing new fix to system command.
@
text
@a499 3
#ifdef HAVE_SIGLONGJMP
static sigjmp_buf env;                /* for interruptable read() */
#else
a500 2
#endif  /* HAVE_SIGLONGJMP */

d510 2
a511 8
  if (reading) {
#ifdef HAVE_SIGLONGJMP
     siglongjmp(env,1);
#else
    longjmp(env,1);
#endif  /* HAVE_SIGLONGJMP */
  }
  deferred_interrupt = TRUE;
a534 3
#ifdef HAVE_SIGLONGJMP
    if (0 == sigsetjmp(env,1)) {
#else
a535 1
#endif  /* HAVE_SIGLONGJMP */
@


