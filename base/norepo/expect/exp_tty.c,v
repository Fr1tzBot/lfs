head	5.43;
access;
symbols
	expect_5_45:5.43
	expect_6_branch:5.43.0.2
	expect_5_44_1_15:5.43
	activestate_win32_port_start:5.32
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.4
	scriptics-sc-2-0-b5:5.28.1.1.2.4
	scriptics-sc-2-0-fixed:5.28.1.1.2.4
	scriptics-sc-2-0-b2:5.28.1.1.2.4
	scriptics-sc-2-0-b1:5.28.1.1.2.4
	scriptics-sc-1-1:5.28.1.1.2.4
	scriptics-sc-1-1-b1:5.28.1.1.2.4
	scriptics-sc-1-1-branch:5.28.1.1.2.4.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.4
	scriptics-sc-1-0:5.28.1.1.2.4
	scriptics-sc-1-0-branch:5.28.1.1.2.4.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.4
	expect-5-31-3:5.28.1.1.2.4
	scriptics-bc-1-0-b1:5.28.1.1.2.4
	scriptics-tclpro-1-3-0:5.28.1.1.2.4
	scriptics-tclpro-1-3-b4:5.28.1.1.2.4
	scriptics-tclpro-1-3-b3:5.28.1.1.2.4
	expect-5-31:5.28.1.1.2.4
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.43
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.42;

5.42
date	2010.03.19.16.53.03;	author eee;	state Exp;
branches;
next	5.41;

5.41
date	2010.03.11.21.55.45;	author eee;	state Exp;
branches;
next	5.40;

5.40
date	2010.03.11.21.47.37;	author eee;	state Exp;
branches;
next	5.39;

5.39
date	2009.05.27.16.52.36;	author andreas_kupries;	state Exp;
branches;
next	5.38;

5.38
date	2008.04.03.19.19.41;	author andreas_kupries;	state Exp;
branches;
next	5.37;

5.37
date	2007.07.11.20.22.10;	author andreas_kupries;	state Exp;
branches;
next	5.36;

5.36
date	2007.07.11.20.07.23;	author andreas_kupries;	state Exp;
branches;
next	5.35;

5.35
date	2005.03.07.21.49.22;	author hobbs;	state Exp;
branches;
next	5.34;

5.34
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2003.09.05.19.01.56;	author andreas_kupries;	state Exp;
branches;
next	5.32;

5.32
date	2002.04.16.21.00.29;	author libes;	state Exp;
branches;
next	5.31;

5.31
date	2002.03.25.20.46.20;	author andreas_kupries;	state Exp;
branches;
next	5.30;

5.30
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.05;	author wart;	state Exp;
branches
	5.29.2.1
	5.29.4.1
	5.29.6.1;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.14.20.36.51;	author don;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.15.19.11.58;	author don;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.16.03.02.40;	author don;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.06.28.06.29.26;	author libes;	state Exp;
branches;
next	5.28.1.1.2.5;

5.28.1.1.2.5
date	99.12.04.06.18.25;	author libes;	state Exp;
branches;
next	;

5.29.2.1
date	2001.07.06.23.15.47;	author andreas_kupries;	state Exp;
branches;
next	;

5.29.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.29.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.43
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@/* exp_tty.c - tty support routines */

#include "expect_cf.h"
#include <stdio.h>
#include <signal.h>
#include "string.h"

#ifdef HAVE_SYS_FCNTL_H
#  include <sys/fcntl.h>
#else
#  include <fcntl.h>
#endif

#include <sys/stat.h>

#ifdef HAVE_INTTYPES_H
#  include <inttypes.h>
#endif
#include <sys/types.h>

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#if defined(SIGCLD) && !defined(SIGCHLD)
#define SIGCHLD SIGCLD
#endif

#include "tcl.h"
#include "exp_prog.h"
#include "exp_rename.h"
#include "exp_tty_in.h"
#include "exp_command.h"
#include "exp_log.h"
#include "exp_win.h"

static int is_raw = FALSE;
static int is_noecho = FALSE;

int exp_ioctled_devtty = FALSE;
int exp_stdin_is_tty;
int exp_stdout_is_tty;

/*static*/ extern exp_tty exp_tty_current, exp_tty_cooked;
#define tty_current exp_tty_current
#define tty_cooked exp_tty_cooked

int
exp_israw(void)
{
	return is_raw;
}

int
exp_isecho(void)
{
	return !is_noecho;
}

/* if set == 1, set it to raw, else unset it */
void
exp_tty_raw(int set)
{
	if (set == 1) {
		is_raw = TRUE;
#if defined(HAVE_TERMIOS) || defined(HAVE_TERMIO) /* had POSIX too */
		tty_current.c_iflag = 0;
		tty_current.c_oflag = 0;
		tty_current.c_lflag &= ECHO;  /* disable everything but echo */
		tty_current.c_cc[VMIN] = 1;
		tty_current.c_cc[VTIME] = 0;
	} else {
		tty_current.c_iflag = tty_cooked.c_iflag;
		tty_current.c_oflag = tty_cooked.c_oflag;
/*		tty_current.c_lflag = tty_cooked.c_lflag;*/
/* attempt 2	tty_current.c_lflag = tty_cooked.c_lflag & ~ECHO;*/
		/* retain current echo setting */
		tty_current.c_lflag = (tty_cooked.c_lflag & ~ECHO) | (tty_current.c_lflag & ECHO);
		tty_current.c_cc[VMIN] = tty_cooked.c_cc[VMIN];
		tty_current.c_cc[VTIME] = tty_cooked.c_cc[VTIME];
#else
#  if defined(HAVE_SGTTYB)
		tty_current.sg_flags |= RAW;
	} else {
		tty_current.sg_flags = tty_cooked.sg_flags;
#  endif
#endif
		is_raw = FALSE;
	}
}
	
void
exp_tty_echo(int set)
{
	if (set == 1) {
		is_noecho = FALSE;
#if defined(HAVE_TERMIOS) || defined(HAVE_TERMIO) /* had POSIX too */
		tty_current.c_lflag |= ECHO;
	} else {
		tty_current.c_lflag &= ~ECHO;
#else
		tty_current.sg_flags |= ECHO;
	} else {
		tty_current.sg_flags &= ~ECHO;
#endif
		is_noecho = TRUE;
	}
}

int
exp_tty_set_simple(exp_tty *tty)
{
#ifdef HAVE_TCSETATTR
	return(tcsetattr(exp_dev_tty, TCSADRAIN,tty));
#else
	return(ioctl    (exp_dev_tty, TCSETSW  ,tty));
#endif
}

int
exp_tty_get_simple(exp_tty *tty)
{
#ifdef HAVE_TCSETATTR
	return(tcgetattr(exp_dev_tty,         tty));
#else
	return(ioctl    (exp_dev_tty, TCGETS, tty));
#endif
}

/* returns 0 if nothing changed */
/* if something changed, the out parameters are changed as well */
int
exp_tty_raw_noecho(
    Tcl_Interp *interp,
    exp_tty *tty_old,
    int *was_raw,
    int *was_echo)
{
	if (exp_disconnected) return(0);
	if (is_raw && is_noecho) return(0);
	if (exp_dev_tty == -1) return(0);

	*tty_old = tty_current;		/* save old parameters */
	*was_raw = is_raw;
	*was_echo = !is_noecho;
	expDiagLog("tty_raw_noecho: was raw = %d  echo = %d\r\n",is_raw,!is_noecho);

	exp_tty_raw(1);
	exp_tty_echo(-1);

	if (exp_tty_set_simple(&tty_current) == -1) {
		expErrorLog("ioctl(raw): %s\r\n",Tcl_PosixError(interp));

		/* SF #439042 -- Allow overide of "exit" by user / script
		 */
		{
		  char buffer [] = "exit 1";
		  Tcl_Eval(interp, buffer); 
		}
	}

	exp_ioctled_devtty = TRUE;
	return(1);
}

/* returns 0 if nothing changed */
/* if something changed, the out parameters are changed as well */
int
exp_tty_cooked_echo(
    Tcl_Interp *interp,
    exp_tty *tty_old,
    int *was_raw,
    int *was_echo)
{
	if (exp_disconnected) return(0);
	if (!is_raw && !is_noecho) return(0);
	if (exp_dev_tty == -1) return(0);

	*tty_old = tty_current;		/* save old parameters */
	*was_raw = is_raw;
	*was_echo = !is_noecho;
	expDiagLog("tty_cooked_echo: was raw = %d  echo = %d\r\n",is_raw,!is_noecho);

	exp_tty_raw(-1);
	exp_tty_echo(1);

	if (exp_tty_set_simple(&tty_current) == -1) {
		expErrorLog("ioctl(noraw): %s\r\n",Tcl_PosixError(interp));

		/* SF #439042 -- Allow overide of "exit" by user / script
		 */
		{
		  char buffer [] = "exit 1";
		  Tcl_Eval(interp, buffer); 
		}
	}
	exp_ioctled_devtty = TRUE;

	return(1);
}

void
exp_tty_set(
    Tcl_Interp *interp,
    exp_tty *tty,
    int raw,
    int echo)
{
	if (exp_tty_set_simple(tty) == -1) {
		expErrorLog("ioctl(set): %s\r\n",Tcl_PosixError(interp));

		/* SF #439042 -- Allow overide of "exit" by user / script
		 */
		{
		  char buffer [] = "exit 1";
		  Tcl_Eval(interp, buffer); 
		}
	}
	is_raw = raw;
	is_noecho = !echo;
	tty_current = *tty;
	expDiagLog("tty_set: raw = %d, echo = %d\r\n",is_raw,!is_noecho);
	exp_ioctled_devtty = TRUE;
}	

#if 0
/* avoids scoping problems */
void
exp_update_cooked_from_current() {
	tty_cooked = tty_current;
}

int
exp_update_real_tty_from_current() {
	return(exp_tty_set_simple(&tty_current));
}

int
exp_update_current_from_real_tty() {
	return(exp_tty_get_simple(&tty_current));
}
#endif

void
exp_init_stdio()
{
	exp_stdin_is_tty = isatty(0);
	exp_stdout_is_tty = isatty(1);

	setbuf(stdout,(char *)0);	/* unbuffer stdout */
}

/*ARGSUSED*/
void
exp_tty_break(
    Tcl_Interp *interp,
    int fd)
{
#ifdef POSIX
	tcsendbreak(fd,0);
#else
# ifdef TIOCSBRK
	ioctl(fd,TIOCSBRK,0);
	exp_dsleep(interp,0.25); /* sleep for at least a quarter of a second */
	ioctl(fd,TIOCCBRK,0);
# else
	/* dunno how to do this - ignore */
# endif
#endif
}

/* take strings with newlines and insert carriage-returns.  This allows user */
/* to write send_user strings without always putting in \r. */
/* If len == 0, use strlen to compute it */
/* NB: if terminal is not in raw mode, nothing is done. */
char *
exp_cook(
    char *s,
    int *len)	/* current and new length of s */
{
	static int destlen = 0;
	static char *dest = 0;
	char *d;		/* ptr into dest */
	unsigned int need;

	if (s == 0) return("<null>");

	if (!is_raw) return(s);

	/* worst case is every character takes 2 to represent */
	need = 1 + 2*(len?*len:strlen(s));
	if (need > destlen) {
		if (dest) ckfree(dest);
		dest = ckalloc(need);
		destlen = need;
	}

	for (d = dest;*s;s++) {
		if (*s == '\n') {
			*d++ = '\r';
			*d++ = '\n';
		} else {
			*d++ = *s;
		}
	}
	*d = '\0';
	if (len) *len = d-dest;
	return(dest);
}

static int		/* returns TCL_whatever */
exec_stty(
    Tcl_Interp *interp,
    int argc,
    char **argv,
    int devtty)		/* if true, redirect to /dev/tty */
{
	int i;
	int rc;

	Tcl_Obj *cmdObj = Tcl_NewStringObj("",0);
	Tcl_IncrRefCount(cmdObj);

	Tcl_AppendStringsToObj(cmdObj,"exec ",(char *)0);
	Tcl_AppendStringsToObj(cmdObj,STTY_BIN,(char *)0);
	for (i=1;i<argc;i++) {
	    Tcl_AppendStringsToObj(cmdObj," ",argv[i],(char *)0);
	}
	if (devtty) Tcl_AppendStringsToObj(cmdObj,
#ifdef STTY_READS_STDOUT
		" >/dev/tty",
#else
		" </dev/tty",
#endif
		(char *)0);

	Tcl_ResetResult(interp);

	/*
	 * normally, I wouldn't set one of Tcl's own variables, but in this
	 * case, I only want to see if Tcl resets it to non-NONE, and I don't
	 * know any other way of doing it
	 */

	Tcl_SetVar(interp,"errorCode","NONE",0);
	rc = Tcl_EvalObjEx(interp,cmdObj,TCL_EVAL_DIRECT);

	Tcl_DecrRefCount(cmdObj);

	/* if stty-reads-stdout, stty will fail since Exec */
	/* will detect the stderr.  Only by examining errorCode */
	/* can we tell if a real error occurred. */	

#ifdef STTY_READS_STDOUT
	if (rc == TCL_ERROR) {
		char *ec = Tcl_GetVar(interp,"errorCode",TCL_GLOBAL_ONLY);
		if (ec && !streq(ec,"NONE")) return TCL_ERROR;
	}
#endif
	return TCL_OK;
}

/*ARGSUSED*/
static int
Exp_SttyCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char **argv)
{
	/* redirection symbol is not counted as a stty arg in terms */
	/* of recognition. */
	int saw_unknown_stty_arg = FALSE;
	int saw_known_stty_arg = FALSE;
	int no_args = TRUE;

	int rc = TCL_OK;
	int cooked = FALSE;
	int was_raw, was_echo;

	char **redirect;	/* location of "<" */
	char *infile = 0;
	int fd;			/* (slave) fd of infile */
	int master = -1;	/* master fd of infile */
	char **argv0 = argv;

	for (argv=argv0+1;*argv;argv++) {
		if (argv[0][0] == '<') {
			redirect = argv;
			infile = *(argv+1);
			if (!infile) {
				expErrorLog("usage: < ttyname");
				return TCL_ERROR;
			}
			if (streq(infile,"/dev/tty")) {
				infile = 0;
				*argv = 0;
				*(argv+1) = 0;
				argc -= 2;
			} else {
				master = exp_trap_off(infile);
				if (-1 == (fd = open(infile,2))) {
					expErrorLog("couldn't open %s: %s",
					 infile,Tcl_PosixError(interp));
					return TCL_ERROR;
				}
			}
			break;
		}
	}

	if (!infile) {		/* work on /dev/tty */
		was_raw = exp_israw();
		was_echo = exp_isecho();

		for (argv=argv0+1;*argv;argv++) {
			if (streq(*argv,"raw") ||
			    streq(*argv,"-cooked")) {
				exp_tty_raw(1);
				saw_known_stty_arg = TRUE;
				no_args = FALSE;
				exp_ioctled_devtty = TRUE;
			} else if (streq(*argv,"-raw") ||
				   streq(*argv,"cooked")) {
				cooked = TRUE;
				exp_tty_raw(-1);
				saw_known_stty_arg = TRUE;
				no_args = FALSE;
				exp_ioctled_devtty = TRUE;
			} else if (streq(*argv,"echo")) {
				exp_tty_echo(1);
				saw_known_stty_arg = TRUE;
				no_args = FALSE;
				exp_ioctled_devtty = TRUE;
			} else if (streq(*argv,"-echo")) {
				exp_tty_echo(-1);
				saw_known_stty_arg = TRUE;
				no_args = FALSE;
				exp_ioctled_devtty = TRUE;
			} else if (streq(*argv,"rows")) {
				if (*(argv+1)) {
					exp_win_rows_set(*(argv+1));
					argv++;
					no_args = FALSE;
					exp_ioctled_devtty = TRUE;
				} else {
		    Tcl_SetResult (interp, exp_win_rows_get(), TCL_VOLATILE);
					return TCL_OK;
				}
			} else if (streq(*argv,"columns")) {
				if (*(argv+1)) {
					exp_win_columns_set(*(argv+1));
					argv++;
					no_args = FALSE;
					exp_ioctled_devtty = TRUE;
				} else {
		    Tcl_SetResult (interp, exp_win_columns_get(), TCL_VOLATILE);
					return TCL_OK;
				}
			} else {
				saw_unknown_stty_arg = TRUE;
			}
		}
		/* if any unknown args, let real stty try */
		if (saw_unknown_stty_arg || no_args) {
			if (saw_unknown_stty_arg) {
			    exp_ioctled_devtty = TRUE;
			}

			/* let real stty try */
			rc = exec_stty(interp,argc,argv0,1);

			/* find out what weird options user asked for */
			if (exp_tty_get_simple(&tty_current) == -1) {
				exp_error(interp,"stty: ioctl(get): %s\r\n",Tcl_PosixError(interp));
				rc = TCL_ERROR;
			}
			if (cooked) {
				/* find out user's new defn of 'cooked' */
				tty_cooked = tty_current;
			}
		} else if (saw_known_stty_arg) {
			if (exp_tty_set_simple(&tty_current) == -1) {
			    if (exp_disconnected || (exp_dev_tty == -1) || !isatty(exp_dev_tty)) {
				expErrorLog("stty: impossible in this context\n");
				expErrorLog("are you disconnected or in a batch, at, or cron script?");
				/* user could've conceivably closed /dev/tty as well */
			    }
			    exp_error(interp,"stty: ioctl(user): %s\r\n",Tcl_PosixError(interp));
			    rc = TCL_ERROR;
			}
		}

		/* if no result, make a crude one */
		if (0 == strcmp(Tcl_GetString(Tcl_GetObjResult(interp)),"")) {
		    char buf [11];
		    sprintf(buf,"%sraw %secho",
			    (was_raw?"":"-"),
			    (was_echo?"":"-"));
		    Tcl_SetResult (interp, buf, TCL_VOLATILE);
		}
	} else {
		/* a different tty */

		/* temporarily zap redirect */
		char *redirect_save = *redirect;
		*redirect = 0;

		for (argv=argv0+1;*argv;argv++) {
			if (streq(*argv,"rows")) {
				if (*(argv+1)) {
					exp_win2_rows_set(fd,*(argv+1));
					argv++;
					no_args = FALSE;
				} else {
		    Tcl_SetResult (interp, exp_win2_rows_get(fd), TCL_VOLATILE);
					goto done;
				}
			} else if (streq(*argv,"columns")) {
				if (*(argv+1)) {
					exp_win2_columns_set(fd,*(argv+1));
					argv++;
					no_args = FALSE;
				} else {
		    Tcl_SetResult (interp, exp_win2_columns_get(fd), TCL_VOLATILE);
					goto done;
				}
			} else if (streq(*argv,"<")) {
				break;
			} else {
				saw_unknown_stty_arg = TRUE;
				break;
			}
		}

		/* restore redirect */
		*redirect = redirect_save;

		close(fd);	/* no more use for this, from now on */
				/* pass by name */

		if (saw_unknown_stty_arg || no_args) {
#ifdef STTY_READS_STDOUT
			/* switch "<" to ">" */
			char original_redirect_char = (*redirect)[0];
			(*redirect)[0] = '>';
			/* stderr unredirected so we can get it directly! */
#endif
			rc = exec_stty(interp,argc,argv0,0);
#ifdef STTY_READS_STDOUT
			/* restore redirect - don't know if necessary */
			(*redirect)[0] = original_redirect_char;
#endif
		}
	}
 done:
	exp_trap_on(master);

	return rc;
}

/*ARGSUSED*/
static int
Exp_SystemCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char **argv)
{
	int result = TCL_OK;
	RETSIGTYPE (*old)();	/* save old sigalarm handler */
#define MAX_ARGLIST 10240
	int i;

	WAIT_STATUS_TYPE waitStatus;
	int systemStatus
;
	int abnormalExit = FALSE;
	char buf[MAX_ARGLIST];
	char *bufp = buf;
	int total_len = 0, arg_len;

	int stty_args_recognized = TRUE;
	int cmd_is_stty = FALSE;
	int cooked = FALSE;
	int was_raw, was_echo;

	if (argc == 1) return TCL_OK;

	if (streq(argv[1],"stty")) {
		expDiagLogU("system stty is deprecated, use stty\r\n");

		cmd_is_stty = TRUE;
		was_raw = exp_israw();
		was_echo = exp_isecho();
	}

	if (argc > 2 && cmd_is_stty) {
		exp_ioctled_devtty = TRUE;

		for (i=2;i<argc;i++) {
			if (streq(argv[i],"raw") ||
			    streq(argv[i],"-cooked")) {
				exp_tty_raw(1);
			} else if (streq(argv[i],"-raw") ||
				   streq(argv[i],"cooked")) {
				cooked = TRUE;
				exp_tty_raw(-1);
			} else if (streq(argv[i],"echo")) {
				exp_tty_echo(1);
			} else if (streq(argv[i],"-echo")) {
				exp_tty_echo(-1);
			} else stty_args_recognized = FALSE;
		}

		/* if unknown args, fall thru and let real stty have a go */
		if (stty_args_recognized) {
	    if (
#ifdef HAVE_TCSETATTR
		tcsetattr(exp_dev_tty,TCSADRAIN, &tty_current) == -1
#else
		ioctl(exp_dev_tty, TCSETSW, &tty_current) == -1
#endif
		) {
			    if (exp_disconnected || (exp_dev_tty == -1) || !isatty(exp_dev_tty)) {
				expErrorLog("system stty: impossible in this context\n");
				expErrorLog("are you disconnected or in a batch, at, or cron script?");
				/* user could've conceivably closed /dev/tty as well */
			    }
			    exp_error(interp,"system stty: ioctl(user): %s\r\n",Tcl_PosixError(interp));
			    return(TCL_ERROR);
			}
			if (cmd_is_stty) {
			    char buf [11];
			    sprintf(buf,"%sraw %secho",
				    (was_raw?"":"-"),
				    (was_echo?"":"-"));
			    Tcl_SetResult (interp, buf, TCL_VOLATILE);
			}
			return(TCL_OK);
		}
	}

	for (i = 1;i<argc;i++) {
		total_len += (1 + (arg_len = strlen(argv[i])));
		if (total_len > MAX_ARGLIST) {
			exp_error(interp,"args too long (>=%d chars)",
				total_len);
			return(TCL_ERROR);
		}
		memcpy(bufp,argv[i],arg_len);
		bufp += arg_len;
		/* no need to check bounds, we accted for it earlier */
		memcpy(bufp," ",1);
		bufp += 1;
	}

	*(bufp-1) = '\0';

	old = signal(SIGCHLD, SIG_DFL);
	systemStatus = system(buf);
	signal(SIGCHLD, old);	/* restore signal handler */
	expDiagLogU("system(");
	expDiagLogU(buf);
	expDiagLog(") = %d\r\n",i);

	if (systemStatus == -1) {
		exp_error(interp,Tcl_PosixError(interp));
		return TCL_ERROR;
	}
	*(int *)&waitStatus = systemStatus;

	if (!stty_args_recognized) {
		/* find out what weird options user asked for */
	if (
#ifdef HAVE_TCSETATTR
	    tcgetattr(exp_dev_tty, &tty_current) == -1
#else
	    ioctl(exp_dev_tty, TCGETS, &tty_current) == -1
#endif
	    ) {
			expErrorLog("ioctl(get): %s\r\n",Tcl_PosixError(interp));

			/* SF #439042 -- Allow overide of "exit" by user / script
			 */
			{
			  char buffer [] = "exit 1";
			  Tcl_Eval(interp, buffer); 
			}
		}
		if (cooked) {
			/* find out user's new defn of 'cooked' */
			tty_cooked = tty_current;
		}
	}

	if (cmd_is_stty) {
	    char buf [11];
	    sprintf(buf,"%sraw %secho",
		    (was_raw?"":"-"),
		    (was_echo?"":"-"));
	    Tcl_SetResult (interp, buf, TCL_VOLATILE);
	}

/* following macros stolen from Tcl's tclUnix.h file */
/* we can't include the whole thing because it depends on other macros */
/* that come out of Tcl's Makefile, sigh */

#if 0

#undef WIFEXITED
#ifndef WIFEXITED
#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xff) == 0)
#endif

#undef WEXITSTATUS
#ifndef WEXITSTATUS
#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#undef WIFSIGNALED
#ifndef WIFSIGNALED
#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
#endif

#undef WTERMSIG
#ifndef WTERMSIG
#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
#endif

#undef WIFSTOPPED
#ifndef WIFSTOPPED
#   define WIFSTOPPED(stat)  (((*((int *) &(stat))) & 0xff) == 0177)
#endif

#undef WSTOPSIG
#ifndef WSTOPSIG
#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#endif /* 0 */

/* stolen from Tcl.    Again, this is embedded in another routine */
/* (CleanupChildren in tclUnixAZ.c) that we can't use directly. */

	if (!WIFEXITED(waitStatus) || (WEXITSTATUS(waitStatus) != 0)) {
	    char msg1[20], msg2[20];
	    int pid = 0;	/* fake a pid, since system() won't tell us */ 

	    result = TCL_ERROR;
	    sprintf(msg1, "%d", pid);
	    if (WIFEXITED(waitStatus)) {
		sprintf(msg2, "%d", WEXITSTATUS(waitStatus));
		Tcl_SetErrorCode(interp, "CHILDSTATUS", msg1, msg2,
			(char *) NULL);
		abnormalExit = TRUE;
	    } else if (WIFSIGNALED(waitStatus)) {
		CONST char *p;
	
		p = Tcl_SignalMsg((int) (WTERMSIG(waitStatus)));
		Tcl_SetErrorCode(interp, "CHILDKILLED", msg1,
			Tcl_SignalId((int) (WTERMSIG(waitStatus))), p,
			(char *) NULL);
		Tcl_AppendResult(interp, "child killed: ", p, "\n",
			(char *) NULL);
	    } else if (WIFSTOPPED(waitStatus)) {
		CONST char *p;

		p = Tcl_SignalMsg((int) (WSTOPSIG(waitStatus)));
		Tcl_SetErrorCode(interp, "CHILDSUSP", msg1,
			Tcl_SignalId((int) (WSTOPSIG(waitStatus))), p, (char *) NULL);
		Tcl_AppendResult(interp, "child suspended: ", p, "\n",
			(char *) NULL);
	    } else {
		Tcl_AppendResult(interp,
			"child wait status didn't make sense\n",
			(char *) NULL);
	    }
	}

    if (abnormalExit && (Tcl_GetStringResult (interp)[0] == 0)) {
	Tcl_AppendResult(interp, "child process exited abnormally",
		(char *) NULL);
    }

    return result;
}

static struct exp_cmd_data
cmd_data[]  = {
{"stty",	exp_proc(Exp_SttyCmd),	0,	0},
{"system",	exp_proc(Exp_SystemCmd),	0,	0},
{0}};

void
exp_init_tty_cmds(struct Tcl_Interp *interp)
{
	exp_create_commands(interp,cmd_data);
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.42
log
@More ANSIfication
@
text
@d249 1
a249 1
exp_init_stdio(void)
d276 4
a279 9
/* take strings with newlines and insert carriage-returns. This allows user
 * to write send_user strings without always putting in \r.
 * If len == NULL, use strlen to compute length of the input string.
 * Otherwise, len points at an int that holds the length, which is
 * updated to the new length on the way out.
 *
 * NB: if terminal is not in raw mode, nothing is done.
 */

d804 1
a804 1

@


5.41
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d249 1
a249 1
exp_init_stdio()
@


5.40
log
@Converting function declarations and definitions from K&R style
to ISO C style, along with occasional related comment changes.
@
text
@d809 1
a809 1

@


5.39
log
@
	* exp_tty.c (Exp_SttyCmd, Exp_SystemCmd): Applied patch by
	  Reinhard Max (max@@suse.de) fixing buffer-overflows in the 'stty'
	  command due to an off-by-one error in the buffer size. See the
	  bugs https://bugzilla.novell.com/show_bug.cgi?id=506873
	  and  https://bugzilla.novell.com/show_bug.cgi?id=501291

	* configure.in: Bumped version to 5.44.1.13.
	* configure: Regen'd, autoconf 2.59.
@
text
@d276 9
a284 4
/* take strings with newlines and insert carriage-returns.  This allows user */
/* to write send_user strings without always putting in \r. */
/* If len == 0, use strlen to compute it */
/* NB: if terminal is not in raw mode, nothing is done. */
@


5.38
log
@
	* configure.in: Bumped version to 5.44.1.7.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* exp_command.c: Fixed more compiler warnings, and started
	* exp_command.h: to ansify the code base, beginning with
	* exp_inter.c: the introduction of proper function prototypes.
	* exp_main_exp.c:
	* exp_pty.h:
	* exp_tty.c:
	* exp_tty.h:
	* exp_win.c:
	* expect.c:
	* pty_termios.c:
	* retoglob.c:
@
text
@d500 5
a504 5
	    char buf [10];
	    sprintf(buf,"%sraw %secho",
				(was_raw?"":"-"),
				(was_echo?"":"-"));
	    Tcl_SetResult (interp, buf, TCL_VOLATILE);
d638 5
a642 5
		char buf [10];
		sprintf(buf,"%sraw %secho",
					(was_raw?"":"-"),
					(was_echo?"":"-"));
		Tcl_SetResult (interp, buf, TCL_VOLATILE);
d702 5
a706 5
	char buf [10];
	sprintf(buf,"%sraw %secho",
			(was_raw?"":"-"),
			(was_echo?"":"-"));
	Tcl_SetResult (interp, buf, TCL_VOLATILE);
@


5.37
log
@
	* Dbg.c: Cleaned up the direct access to interp->result,
	* exp_command.c: replaced with the proper functions and
	* expect.c: Tcl_Obj's.
	* exp_main_exp.c:
	* exp_main_sub.c:
	* exp_main_tk.c:
	* exp_prog.h:
	* exp_trap.c:
	* exp_tty.c:
	* exp_win.c:
	* exp_win.h:
@
text
@d53 1
a53 1
exp_israw()
d59 1
a59 1
exp_isecho()
d66 1
a66 2
exp_tty_raw(set)
int set;
d97 1
a97 2
exp_tty_echo(set)
int set;
d115 1
a115 2
exp_tty_set_simple(tty)
exp_tty *tty;
d125 1
a125 2
exp_tty_get_simple(tty)
exp_tty *tty;
d137 5
a141 4
exp_tty_raw_noecho(interp,tty_old,was_raw,was_echo)
Tcl_Interp *interp;
exp_tty *tty_old;
int *was_raw, *was_echo;
d173 5
a177 4
exp_tty_cooked_echo(interp,tty_old,was_raw,was_echo)
Tcl_Interp *interp;
exp_tty *tty_old;
int *was_raw, *was_echo;
d207 5
a211 5
exp_tty_set(interp,tty,raw,echo)
Tcl_Interp *interp;
exp_tty *tty;
int raw;
int echo;
d259 3
a261 3
exp_tty_break(interp,fd)
Tcl_Interp *interp;
int fd;
d281 3
a283 3
exp_cook(s,len)
char *s;
int *len;	/* current and new length of s */
d316 5
a320 5
exec_stty(interp,argc,argv,devtty)
Tcl_Interp *interp;
int argc;
char **argv;
int devtty;		/* if true, redirect to /dev/tty */
d369 5
a373 5
Exp_SttyCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d568 5
a572 5
Exp_SystemCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d800 1
a800 2
exp_init_tty_cmds(interp)
struct Tcl_Interp *interp;
@


5.36
log
@
	* exp_command.c: Reformatted overlong lines, whitespace,
	* expect.c: comments. Added braces to some if-constructs.
	* exp_inter.c: Reworked if-constructs interleaved with
	* exp_tty.c: #if for better formatting in emacs.
@
text
@d39 1
a316 3
/* this stupidity because Tcl needs commands in writable space */
static char exec_cmd[] = "exec";

a323 1
	char **new_argv;
d453 1
a453 1
					exp_win_rows_get(interp->result);
d463 1
a463 1
					exp_win_columns_get(interp->result);
d502 2
a503 1
			sprintf(interp->result,"%sraw %secho",
d506 1
d522 1
a522 1
					exp_win2_rows_get(fd,interp->result);
d531 1
a531 1
					exp_win2_columns_get(fd,interp->result);
d640 2
a641 1
				sprintf(interp->result,"%sraw %secho",
d644 1
d704 2
a705 1
		sprintf(interp->result,"%sraw %secho",
d708 1
d787 1
a787 1
    if (abnormalExit && (*interp->result == 0)) {
d807 8
@


5.35
log
@	* exp_tty.c (Exp_SttyCmd): fix from Libes that controlling
	terminal check example (book p372) by restricting set of
	exp_ioctled_devtty variable.
@
text
@d625 1
d627 1
a627 1
 			if (tcsetattr(exp_dev_tty,TCSADRAIN, &tty_current) == -1) {
d629 1
a629 1
		        if (ioctl(exp_dev_tty, TCSETSW, &tty_current) == -1) {
d631 1
d680 1
d682 1
a682 1
		if (tcgetattr(exp_dev_tty, &tty_current) == -1) {
d684 1
a684 1
	        if (ioctl(exp_dev_tty, TCGETS, &tty_current) == -1) {
d686 1
@


5.34
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@a389 1

a424 2
		exp_ioctled_devtty = TRUE;

d431 1
d438 1
d443 1
d448 1
d454 1
d464 1
d475 4
@


5.33
log
@
	* Merged changes from the official version 5.39 of expect into the
	  SF sources. See details below. Partially already done.

	  --------------------
	  Poorva Gupta <poorva@@cup.hp.xcom> noted that grantpt/unlockpt
	  order was backward.  Strange that this was never a prob before!

	  Eric Raymond <esr@@snark.thyrsus.xcom> provided a troff-related
	  fix for the multixterm man page.

	  Nicolas Roeser <n-roeser@@gmx.xnet> noted confusion with md5 so I
	  made the Expect page more explicit about which file that hash
	  was based on.

	  Josh Purinton noted that earlier fix wasn't quite right.  Exit
	  on INT/TERM should cause Expect to exit with signal embedded in
	  status.  He also requested I obfuscate email addresses in this
	  file.

	  Guido Ostkamp <Guido.Ostkamp@@t-online.xde> and Igor Sobrado
	  <sobrado@@string1.ciencias.uniovi.xes> noted that fixline1
	  rewrote scripts to be expect scripts even if they were expectk
	  scripts.

	  Dirk Petera <dirkpetera@@yahoo.xcom> noted that any_spawn_id used
	  to work but did no longer.  Looks like a bug left over from the
	  the I18L conversion.  Fixed.

	  Steve Szabo noted exp_log_file -open channel failed.  Fixed.

	  Fixed bug from 5.31 that prevent stty from returning messages
	  from underlying program.

	  Thomas Dickey <dickey@@herndon4.his.xcom> noted that ncurses
	  ignores 2-char term names because of, well, poor assumptions and
	  coding.  Changed tkterm to use longer names.

	  Heath Moore <hmoore@@systran.xcom> noted that exp_clib could lock
	  up if remtime happened to be precisely 0.  Recoded to avoid.

	  At request of Per Otterholm <otterholm@@telia.xcom>, wrote script
	  to read from stdin and echo passwords (exercise 9 in Tk chapter
	  of Expect book).  Added to example directory as passwdprompt.

	  Josh Purinton <josh@@purinton.xorg> pointed out that by default,
	  SIGINT/TERM should cause expect's return status to be 1, not 0.

	  Paul Reithmuller <paul.reithmuller@@eng.sun.xcom> noted that
	  unbuffer shouldn't postprocess its output.  Added stty_init.

	  Mordechai T. Abzug <morty@@sanctuary.arbutus.md.xus> noted that
	  log_file wasn't recording -append status.

	  James Kelly <macubergeek@@comcast.xnet> noted weather example
	  needed new source.

	  Dimitar Haralanov <mitko@@tahoenetworks.xcom> noted that interact
	  dumped core with interact { timeout 1 }
	  --------------------
@
text
@a317 1
static char stty_cmd[] = "/bin/stty";
d333 2
a334 1
	Tcl_AppendStringsToObj(cmdObj,"exec /bin/stty",(char *)0);
@


5.32
log
@misc updates
@
text
@d497 1
a497 1
		if (interp->result[0] == '\0') {
@


5.31
log
@
	* Merged fix for SF Bug #439042 into the HEAD (The source of the
	  patch is "expect-sf418892-sf439042-branch").
@
text
@d281 1
a281 1
CONST char *
d283 1
a283 1
CONST char *s;
@


5.30
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d159 7
a165 1
		Tcl_Exit(1);
d194 7
a200 1
		Tcl_Exit(1);
d216 7
a222 1
		Tcl_Exit(1);
d677 7
a683 1
			Tcl_Exit(1);
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d263 1
a263 1
char *
d265 1
a265 1
char *s;
d726 1
a726 1
		char *p;
d735 1
a735 1
		char *p;
@


5.29.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.29.4.1
log
@Top-level source files removed.
@
text
@@


5.29.2.1
log
@2001-07-06  Andreas Kupries <andreas_kupries@@users.sourceforge.net>

	* exp_main_exp.c:
	* exp_main_sub.c:
	* exp_main_tk.c:
	* exp_tty.c: Changed calls to 'Tcl_Exit' into calls to the command
	  [exit], to allow scripts and users to overide the functionality.
@
text
@d159 1
a159 7

		/* SF #439042 -- Allow overide of "exit" by user / script
		 */
		{
		  char buffer [] = "exit 1";
		  Tcl_Eval(interp, buffer); 
		}
d188 1
a188 7

		/* SF #439042 -- Allow overide of "exit" by user / script
		 */
		{
		  char buffer [] = "exit 1";
		  Tcl_Eval(interp, buffer); 
		}
d204 1
a204 7

		/* SF #439042 -- Allow overide of "exit" by user / script
		 */
		{
		  char buffer [] = "exit 1";
		  Tcl_Eval(interp, buffer); 
		}
d659 1
a659 7

			/* SF #439042 -- Allow overide of "exit" by user / script
			 */
			{
			  char buffer [] = "exit 1";
			  Tcl_Eval(interp, buffer); 
			}
@


5.28
log
@Initial revision
@
text
@d37 1
a38 1
#include "exp_command.h"
d152 1
a152 1
	debuglog("tty_raw_noecho: was raw = %d  echo = %d\r\n",is_raw,!is_noecho);
d158 2
a159 2
		errorlog("ioctl(raw): %s\r\n",Tcl_PosixError(interp));
		exp_exit(interp,1);
d181 1
a181 1
	debuglog("tty_cooked_echo: was raw = %d  echo = %d\r\n",is_raw,!is_noecho);
d187 2
a188 2
		errorlog("ioctl(noraw): %s\r\n",Tcl_PosixError(interp));
		exp_exit(interp,1);
d203 2
a204 2
		errorlog("ioctl(set): %s\r\n",Tcl_PosixError(interp));
		exp_exit(interp,1);
d209 1
a209 1
	debuglog("tty_set: raw = %d, echo = %d\r\n",is_raw,!is_noecho);
d313 4
a316 5
	/* insert "system" at front, null at end, */
	/* and optional redirect in middle, hence "+3" */
	new_argv = (char **)ckalloc((3+argc)*sizeof(char *));
	new_argv[0] = exec_cmd;
	new_argv[1] = stty_cmd;
d318 1
a318 1
		new_argv[i+1] = argv[i];
d320 1
a320 1
	if (devtty) new_argv[++i] =
d322 1
a322 1
		">/dev/tty";
d324 1
a324 1
		"</dev/tty";
d326 1
d328 1
a328 1
	new_argv[i+1] = (char *)0;
d330 5
a334 1
	Tcl_ResetResult(interp);
a335 3
	/* normally, I wouldn't set one of Tcl's own variables, but in this */
	/* case, I only only want to see if Tcl resets it to non-NONE, */
	/* and I don't know any other way of doing it */
d337 1
a337 1
	rc = Tcl_ExecCmd((ClientData)0,interp,argc+1+devtty,new_argv);
d339 1
a339 1
	ckfree((char *)new_argv);
d384 1
a384 1
				errorlog("usage: < ttyname");
d395 1
a395 1
					errorlog("couldn't open %s: %s",
d469 2
a470 2
				errorlog("stty: impossible in this context\n");
				errorlog("are you disconnected or in a batch, at, or cron script?");
d573 1
a573 1
		debuglog("system stty is deprecated, use stty\r\n");
d606 2
a607 2
				errorlog("system stty: impossible in this context\n");
				errorlog("are you disconnected or in a batch, at, or cron script?");
d637 1
d641 3
a643 1
	debuglog("system(%s) = %d\r\n",buf,i);
d658 2
a659 2
			errorlog("ioctl(get): %s\r\n",Tcl_PosixError(interp));
			exp_exit(interp,1);
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@fixed Log/Diag and ExpectCmd
@
text
@d152 1
a152 1
	expDiagLog("tty_raw_noecho: was raw = %d  echo = %d\r\n",is_raw,!is_noecho);
d158 1
a158 1
		expErrorLog("ioctl(raw): %s\r\n",Tcl_PosixError(interp));
d181 1
a181 1
	expDiagLog("tty_cooked_echo: was raw = %d  echo = %d\r\n",is_raw,!is_noecho);
d187 1
a187 1
		expErrorLog("ioctl(noraw): %s\r\n",Tcl_PosixError(interp));
d203 1
a203 1
		expErrorLog("ioctl(set): %s\r\n",Tcl_PosixError(interp));
d209 1
a209 1
	expDiagLog("tty_set: raw = %d, echo = %d\r\n",is_raw,!is_noecho);
d383 1
a383 1
				expErrorLog("usage: < ttyname");
d394 1
a394 1
					expErrorLog("couldn't open %s: %s",
d468 2
a469 2
				expErrorLog("stty: impossible in this context\n");
				expErrorLog("are you disconnected or in a batch, at, or cron script?");
d572 1
a572 1
		expDiagLogU("system stty is deprecated, use stty\r\n");
d605 2
a606 2
				expErrorLog("system stty: impossible in this context\n");
				expErrorLog("are you disconnected or in a batch, at, or cron script?");
d639 1
a639 3
	expDiagLogU("system(");
	expDiagLogU(buf)
	expDiagLog(") = %d\r\n",i);
d654 1
a654 1
			expErrorLog("ioctl(get): %s\r\n",Tcl_PosixError(interp));
@


5.28.1.1.2.2
log
@Fixed interact of all but regexp probs.
@
text
@d37 1
a38 1
#include "exp_log.h"
d640 1
a640 1
	expDiagLogU(buf);
@


5.28.1.1.2.3
log
@compiled!
@
text
@d313 5
a317 4
	Tcl_Obj *cmdObj = Tcl_NewStringObj("",0);
	Tcl_IncrRefCount(cmdObj);

	Tcl_AppendStringsToObj(cmdObj,"exec /bin/stty",(char *)0);
d319 1
a319 1
	    Tcl_AppendStringsToObj(cmdObj," ",argv[i],(char *)0);
d321 1
a321 1
	if (devtty) Tcl_AppendStringsToObj(cmdObj,
d323 1
a323 1
		" >/dev/tty",
d325 1
a325 1
		" </dev/tty",
d327 2
a328 1
		(char *)0);
d332 3
a334 6
	/*
	 * normally, I wouldn't set one of Tcl's own variables, but in this
	 * case, I only want to see if Tcl resets it to non-NONE, and I don't
	 * know any other way of doing it
	 */

d336 1
a336 1
	rc = Tcl_EvalObjEx(interp,cmdObj,TCL_EVAL_DIRECT);
d338 1
a338 1
	Tcl_DecrRefCount(cmdObj);
@


5.28.1.1.2.4
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d159 1
a159 1
		Tcl_Exit(1);
d188 1
a188 1
		Tcl_Exit(1);
d204 1
a204 1
		Tcl_Exit(1);
d658 1
a658 1
			Tcl_Exit(1);
@


5.28.1.1.2.5
log
@Fixes to library.
Testing new fix to system command.
@
text
@a636 1

@


