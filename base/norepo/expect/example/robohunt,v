head	5.30;
access;
symbols
	expect_5_45:5.30
	expect_6_branch:5.29.0.8
	expect_5_44_1_15:5.29
	activestate_win32_port_start:5.29
	win32-jump-point-1:5.29
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.1
	scriptics-sc-2-0-b5:5.28.1.1.2.1
	scriptics-sc-2-0-fixed:5.28.1.1.2.1
	scriptics-sc-2-0-b2:5.28.1.1.2.1
	scriptics-sc-2-0-b1:5.28.1.1.2.1
	scriptics-sc-1-1:5.28.1.1.2.1
	scriptics-sc-1-1-b1:5.28.1.1.2.1
	scriptics-sc-1-1-branch:5.28.1.1.2.1.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.1
	scriptics-sc-1-0:5.28.1.1.2.1
	scriptics-sc-1-0-branch:5.28.1.1.2.1.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.1
	expect-5-31-3:5.28.1.1.2.1
	scriptics-bc-1-0-b1:5.28.1.1.2.1
	scriptics-tclpro-1-3-0:5.28.1.1.2.1
	scriptics-tclpro-1-3-b4:5.28.1.1.2.1
	scriptics-tclpro-1-3-b3:5.28.1.1.2.1
	expect-5-31:5.28.1.1.2.1
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.30
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.08;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.29.02.27.50;	author libes;	state Exp;
branches;
next	;


desc
@@


5.30
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# Synopsis
#    robohunt player-name [-nodisplay]

# Plays hunt automatically.  Optional "-nodisplay" argument disables output.

# by Don Libes

expect_version -exit 5.0

set timeout 1

proc random {} {
    global ia ic im jran
    
    set jran [expr ($jran*$ia + $ic) % $im]
    return $jran
}

set ia 7141
set ic 54773
set im 259200
set jran [pid]

# given a direction and number, moves that many spaces in that direction
proc mv {dir num} {
    # first try firing a bullet (what the hell...open some walls to move!)
    send "f"
    for {set i 0} {$i<$num} {incr i} {
	send $dir
    }
}

# move a random distance/direction

# 31 is arbitrarily used as a max distance to move in any one direction
# this is a compromise between long horizontal and vertical moves
# but since excess movement is good for stabbing, this is reasonable
proc move {} {
    set num [random]
    set mask [expr $num&3]
    set num [expr $num&31]
    if $mask==0 {send "H"; mv "h" $num; return}
    if $mask==1 {send "L"; mv "l" $num; return}
    if $mask==2 {send "K"; mv "k" $num; return}
                 send "J"; mv "j" $num; return
}

if {2==$argc} { set output 0 } {set output 1}
if {1>$argc}  { send_user "usage: robohunt name \[-nodisplay\]\n"; exit}
spawn hunt -b -c -n [lindex $argv 0]
expect "team"
send "\r"

set several_moves 5

expect "Monitor:"
after 1000
expect ;# flush output
log_user 0
# output is turned off so that we can first strip out ^Gs before they
# are sent to the tty.  It seems to drive xterms crazy - because our
# rather stupid algorithm off not checking after every move can cause
# the game to send a lot of them.

for {} {1} {} {
    # make several moves at a time, before checking to see if we are dead
    # this is a compromise between just ignoring our status after each move
    # and looking at our status after each move
    for {set j $several_moves} {$j} {incr j -1} {
	move
    }

    expect {
	-re ^\007+ {exp_continue}
	-re "\\? " {send y}
	-re .+
    }	
    if $output {send_user -raw $expect_out(buffer)}
}
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d1 8
a8 1
#!../expect -f
@


5.28
log
@Initial revision
@
text
@d14 4
a17 4
	global ia ic im jran

	set jran [expr ($jran*$ia + $ic) % $im]
	return $jran
d27 5
a31 5
	# first try firing a bullet (what the hell...open some walls to move!)
	send "f"
	for {set i 0} {$i<$num} {incr i} {
		send $dir
	}
d40 7
a46 7
	set num [random]
	set mask [expr $num&3]
	set num [expr $num&31]
	if $mask==0 {send "H"; mv "h" $num; return}
	if $mask==1 {send "L"; mv "l" $num; return}
	if $mask==2 {send "K"; mv "k" $num; return}
		     send "J"; mv "j" $num; return
d49 2
a50 2
if 2==$argc { set output 0 } {set output 1}
if 1>$argc  { send_user "usage: robohunt name \[-nodisplay\]\n"; exit}
d58 1
a58 1
sleep 1
d66 14
a79 14
for {} 1 {} {
	# make several moves at a time, before checking to see if we are dead
	# this is a compromise between just ignoring our status after each move
	# and looking at our status after each move
	for {set j $several_moves} {$j} {incr j -1} {
		move
	}

	expect {
		-re ^\007+ {exp_continue}
		-re "\\? " {send y}
		-re .+
	}	
	if $output {send_user -raw $expect_out(buffer)}
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d14 4
a17 4
    global ia ic im jran
    
    set jran [expr ($jran*$ia + $ic) % $im]
    return $jran
d27 5
a31 5
    # first try firing a bullet (what the hell...open some walls to move!)
    send "f"
    for {set i 0} {$i<$num} {incr i} {
	send $dir
    }
d40 7
a46 7
    set num [random]
    set mask [expr $num&3]
    set num [expr $num&31]
    if $mask==0 {send "H"; mv "h" $num; return}
    if $mask==1 {send "L"; mv "l" $num; return}
    if $mask==2 {send "K"; mv "k" $num; return}
                 send "J"; mv "j" $num; return
d49 2
a50 2
if {2==$argc} { set output 0 } {set output 1}
if {1>$argc}  { send_user "usage: robohunt name \[-nodisplay\]\n"; exit}
d58 1
a58 1
after 1000
d66 14
a79 14
for {} {1} {} {
    # make several moves at a time, before checking to see if we are dead
    # this is a compromise between just ignoring our status after each move
    # and looking at our status after each move
    for {set j $several_moves} {$j} {incr j -1} {
	move
    }

    expect {
	-re ^\007+ {exp_continue}
	-re "\\? " {send y}
	-re .+
    }	
    if $output {send_user -raw $expect_out(buffer)}
@

