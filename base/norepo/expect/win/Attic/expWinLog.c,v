head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.1.2.3
	telco-tec-win32-take2-branch:1.1.2.1.0.2
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2001.09.13.02.01.49;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.13.02.01.49;	author davygrvy;	state Exp;
branches
	1.1.2.1.2.1;
next	1.1.2.2;

1.1.2.2
date	2001.10.26.09.34.34;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.26.11.49.18;	author davygrvy;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.28.09.07.50;	author davygrvy;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.11.07.10.04.57;	author davygrvy;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.11.07.22.10.39;	author davygrvy;	state Exp;
branches;
next	;

1.1.2.1.2.1
date	2002.02.10.02.59.46;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.2;

1.1.2.1.2.2
date	2002.02.10.12.03.30;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.3;

1.1.2.1.2.3
date	2002.03.09.05.48.51;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.4;

1.1.2.1.2.4
date	2003.08.26.20.46.52;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expWinLog.c was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.2.1
log
@snap29 "import"
@
text
@a0 56
/* 
 * expWinLog.c --
 *
 *	This file logs to the NT system log.  Use the Event Viewer to
 *	see these logs.  This was predominately used to debug the
 *	slavedrv.exe process.
 *
 * Copyright (c) 1997 Mitel Corporation
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "tcl.h"
#include "tclPort.h"
#include "expWin.h"

static HANDLE hSyslog = NULL;

/*
 *----------------------------------------------------------------------
 *
 * ExpSyslog --
 *
 *	Logs error messages to the system application event log.
 *	It is normally called through the macro EXP_LOG() when
 *	errors occur in the slave driver process, but it can be
 *	used elsewhere.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ExpSyslog TCL_VARARGS_DEF(char *,arg1)
{
    char *fmt;
    va_list args;
    char buf[16384];
    char *strings[1];

    fmt = TCL_VARARGS_START(char *,arg1,args);
    
    if (hSyslog == NULL) {
	hSyslog = OpenEventLog(NULL, "ExpectSlaveDrv");
    }
    vsprintf(buf, fmt, args);
    va_end(args);

    strings[0] = buf;
    ReportEvent(hSyslog, EVENTLOG_ERROR_TYPE, 0, 0, NULL, 1, 0,
		strings, NULL);
}
@


1.1.2.1.2.1
log
@moved all header files over to a more core style with the beginnings of a
Stubs table.  This work is far from complete.
@
text
@d15 3
a17 1
#include "expWinInt.h"
@


1.1.2.1.2.2
log
@All file comments have the same form.
@
text
@d1 1
a1 1
/* ----------------------------------------------------------------------------
a7 8
 * ----------------------------------------------------------------------------
 *
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 * 
a8 1
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
d10 2
a11 2
 * Copyright (c) 2001-2002 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
a12 7
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: exp.h,v 1.1.4.4 2002/02/10 10:17:04 davygrvy Exp $
 * ----------------------------------------------------------------------------
@


1.1.2.1.2.3
log
@Got error codes working.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinLog.c,v 1.1.2.1.2.2 2002/02/10 12:03:30 davygrvy Exp $
d33 1
a33 8
static char sysMsgSpace[1024];

/* local protos */
static TCHAR *Exp95Log (DWORD errCode, char *errData[], int cnt);

#define GETSEVERITY(code)   (UCHAR)((code >> 30) & 0x3) 
#define GETFACILITY(code)   (WORD)((code >> 16) & 0x0FFF)
#define GETCODE(code)	    (WORD)(code & 0xFFFF)
d38 1
a38 1
 * ExpWinSyslog --
d52 1
a52 1
ExpWinSyslog TCL_VARARGS_DEF(DWORD,arg1)
d54 1
a54 1
    DWORD errCode;
d56 2
a57 29
    char *errData[10];
    int cnt = 0;
    TCHAR *errMsg;
    static char codeBuf[33];
    DWORD dwWritten;
    char *file;
    int line;
    static char fileInfo[MAX_PATH];

    /* Get the error code */
    errCode = TCL_VARARGS_START(DWORD,arg1,args);

    /* Get the file info */
    file = va_arg(args, char *);
    line = va_arg(args, int);
    wsprintfA(fileInfo, "%s(%d)", file, line);
    errData[cnt++] = fileInfo;

    /* Set the textual severity */
    switch(GETSEVERITY(errCode)) {
	case STATUS_SEVERITY_WARNING:
	    errData[cnt++] = "Warning"; break;
	case STATUS_SEVERITY_SUCCESS:
	    errData[cnt++] = "Success"; break;
	case STATUS_SEVERITY_INFORMATIONAL:
	    errData[cnt++] = "Info"; break;
	case STATUS_SEVERITY_FATAL:
	    errData[cnt++] = "Fatal"; break;
    }
d59 4
a62 18
    /* Set the textual Facility */
    switch(GETFACILITY(errCode)) {
	case FACILITY_WINSOCK:
	    errData[cnt++] = "Winsock IPC"; break;
	case FACILITY_SYSTEM:
	    errData[cnt++] = "System"; break;
	case FACILITY_STUBS:
	    errData[cnt++] = "Stubs"; break;
	case FACILITY_NAMEDPIPE:
	    errData[cnt++] = "NamedPipe IPC"; break;
	case FACILITY_MSPROTO:
	    errData[cnt++] = "Master/Slave Protocol"; break;
	case FACILITY_MAILBOX:
	    errData[cnt++] = "MailBoxing IPC"; break;
	case FACILITY_IO:
	    errData[cnt++] = "I/O general"; break;
	case FACILITY_DBGTRAP:
	    errData[cnt++] = "Debug/Trap"; break;
d64 1
a64 6
    /* Set the textual Code */
    errData[cnt++] = codeBuf;
    wsprintfA(codeBuf, "0x%04X", GETCODE(errCode));

    /* set everyone else */
    while ((errData[cnt] = va_arg(args, char *)) != NULL) cnt++;
d67 3
a69 59
    /* format this error according to the message catalog contained in the exe. */
    errMsg = Exp95Log(errCode, errData, cnt);
    OutputDebugString(errMsg);

    /* If running under NT, also save this error in the event log. */
    /* TODO: add platform test */
//    ExpNTLog(errCode, errData, cnt);

    if (GETSEVERITY(errCode) & STATUS_SEVERITY_FATAL) {
	/* I could have used printf() and fflush(), but chose the direct
	 * route instead */
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), errMsg, _tcslen(errMsg),
		&dwWritten, NULL);

	/* Stop the world, I want to get off. */
	//DebugBreak();

	Sleep(5000);
	ExitProcess(255);
    }

    LocalFree(errMsg);
}

char *ExpSyslogGetSysMsg (DWORD id)
{
    int chars;

    chars = wsprintfA(sysMsgSpace, "[%d] ", id);

    FormatMessage(
	    FORMAT_MESSAGE_FROM_SYSTEM |
	    FORMAT_MESSAGE_MAX_WIDTH_MASK,
	    NULL,
	    id,
	    0,
	    (LPVOID) &sysMsgSpace[chars],
	    (1024-chars),
	    0);

    return sysMsgSpace;
}

TCHAR *Exp95Log(DWORD errCode, char *errData[], int cnt)
{
    TCHAR *msg;

    FormatMessage(
	    FORMAT_MESSAGE_FROM_HMODULE |
	    FORMAT_MESSAGE_ALLOCATE_BUFFER |
	    FORMAT_MESSAGE_ARGUMENT_ARRAY,
	    GetModuleHandle(NULL),
	    errCode,
	    0,
	    (LPVOID) &msg,
	    0,
	    errData);

    return msg;
@


1.1.2.1.2.4
log
@titleblock comment changes and removal of the Detours library usage.
@
text
@a19 1
 * Copyright (c) 2003 ActiveState Corporation
d27 1
a27 1
 * RCS: @@(#) $Id: expWinLog.c,v 1.1.2.1.2.3 2002/03/09 05:48:51 davygrvy Exp $
@


1.1.2.2
log
@ExpSyslog() is finally doing what I want.  More work to do, but the
groundwork is now set.
@
text
@a17 5
#include "spawndrvmc.h"

#ifdef _MSC_VER
#   pragma comment (lib, "advapi32.lib")
#endif
a19 12
static HANDLE hToken;
static TOKEN_USER *hUserTokPtr;
static TCHAR sysMsgSpace[1024];

/* local protos */
static void ExpNTLog (DWORD errCode, char *errData[], int cnt);
static TCHAR *Exp95Log (DWORD errCode, char *errData[], int cnt);
static void AddEventSource();

#define GETSEVERITY(code)   (UCHAR)((code >> 30) & 0x3) 
#define GETFACILITY(code)   (WORD)((code >> 16) & 0x0FFF)
#define GETCODE(code)	    (WORD)(code & 0xFFFF)
d38 1
a38 1
ExpSyslog TCL_VARARGS_DEF(DWORD,arg1)
d40 1
a40 1
    DWORD errCode;
d42 2
a43 11
    char *errData[10];
    int cnt = 0;
    TCHAR *errMsg;
    static TCHAR codeBuf[33];
    DWORD dwWritten;

    /* Get the error code */
    errCode = TCL_VARARGS_START(DWORD,arg1,args);

    /* Get the file info */
    errData[cnt++] = va_arg(args, char *);
d45 4
a48 10
    /* Set the textual severity */
    switch(GETSEVERITY(errCode)) {
	case STATUS_SEVERITY_WARNING:
	    errData[cnt++] = _T("Warning"); break;
	case STATUS_SEVERITY_SUCCESS:
	    errData[cnt++] = _T("Success"); break;
	case STATUS_SEVERITY_INFORMATIONAL:
	    errData[cnt++] = _T("Info"); break;
	case STATUS_SEVERITY_FATAL:
	    errData[cnt++] = _T("Fatal"); break;
d50 1
a50 26

    /* Set the textual Facility */
    switch(GETFACILITY(errCode)) {
	case FACILITY_WINSOCK:
	    errData[cnt++] = _T("Winsock IPC"); break;
	case FACILITY_SYSTEM:
	    errData[cnt++] = _T("System"); break;
	case FACILITY_STUBS:
	    errData[cnt++] = _T("Stubs"); break;
	case FACILITY_NAMEDPIPE:
	    errData[cnt++] = _T("NamedPipe IPC"); break;
	case FACILITY_MSPROTO:
	    errData[cnt++] = _T("Master/Slave Protocol"); break;
	case FACILITY_MAILBOX:
	    errData[cnt++] = _T("MailBoxing IPC"); break;
	case FACILITY_IO:
	    errData[cnt++] = _T("I/O [general]"); break;
	case FACILITY_DBGTRAP:
	    errData[cnt++] = _T("Debug/Trap"); break;
    }
    /* Set the textual Code */
    errData[cnt++] = codeBuf;
    wsprintf(codeBuf, "0x%04X", GETCODE(errCode));

    /* set everyone else */
    while ((errData[cnt] = va_arg(args, char *)) != NULL) cnt++;
d53 3
a55 152
    /* format this error according to the message catalog contained in the exe. */
    errMsg = Exp95Log(errCode, errData, cnt);
    OutputDebugString(errMsg);

    /* If running under NT, also save this error in the event log. */
    /* TODO: add platform test */
    ExpNTLog(errCode, errData, cnt);

    if (GETSEVERITY(errCode) & STATUS_SEVERITY_FATAL) {
	/* I could have used printf() and fflush(), but chose the direct
	 * route instead */
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), errMsg, _tcslen(errMsg),
		&dwWritten, NULL);
	/* Stop the world, I want to get off. */
	if (IsDebuggerPresent()) DebugBreak();

	Sleep(5000);
	ExitProcess(255);
    }

    LocalFree(errMsg);
}

TCHAR *ExpSyslogGetSysMsg (DWORD id)
{
    int chars;

    chars = wsprintf(sysMsgSpace, "[%d] ", id);

    FormatMessage(
	    FORMAT_MESSAGE_FROM_SYSTEM |
	    FORMAT_MESSAGE_MAX_WIDTH_MASK,
	    NULL,
	    id,
	    0,
	    (LPVOID) &sysMsgSpace[chars],
	    (1024-chars),
	    0);

    return sysMsgSpace;
}

TCHAR *Exp95Log(DWORD errCode, char *errData[], int cnt)
{
    TCHAR *msg;

    FormatMessage(
	    FORMAT_MESSAGE_FROM_HMODULE |
	    FORMAT_MESSAGE_ALLOCATE_BUFFER |
	    FORMAT_MESSAGE_ARGUMENT_ARRAY,
	    GetModuleHandle(NULL),
	    errCode,
	    0,
	    (LPVOID) &msg,
	    0,
	    errData);

    return msg;
}

void ExpNTLog (DWORD errCode, char *errData[], int cnt)
{
    DWORD dwSize = 0;
    WORD wSev;

    /* Write-out the registry data each time */
    AddEventSource();
    hSyslog = RegisterEventSource(NULL, _T("ExpectSlaveDrv"));

    /* aquire the user SID */
    OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
    GetTokenInformation(hToken, TokenUser, NULL, dwSize, &dwSize);
    hUserTokPtr = (PTOKEN_USER) GlobalAlloc(GPTR, dwSize);
    GetTokenInformation(hToken, TokenUser, hUserTokPtr, dwSize, &dwSize);

    switch(GETSEVERITY(errCode)) {
	case STATUS_SEVERITY_WARNING:
	    wSev = EVENTLOG_WARNING_TYPE; break;
	case STATUS_SEVERITY_SUCCESS:
	case STATUS_SEVERITY_INFORMATIONAL:
	    wSev = EVENTLOG_INFORMATION_TYPE; break;
	case STATUS_SEVERITY_FATAL:
	    wSev = EVENTLOG_ERROR_TYPE; break;
    }

    ReportEvent(hSyslog, wSev, GETFACILITY(errCode), errCode,
	    hUserTokPtr->User.Sid, cnt, 0, errData, NULL);
    GlobalFree(hUserTokPtr);
    DeregisterEventSource(hSyslog);
}

void AddEventSource()
{
    HKEY hk; 
    DWORD dwData; 
    TCHAR szBuf[MAX_PATH];
    int len;
 
    /*
     * Add your source name as a subkey under the Application 
     * key in the EventLog registry key. 
     */
    RegCreateKey(HKEY_LOCAL_MACHINE, 
	_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\ExpectSlaveDrv"),
	&hk); 

    /*
     * Set the name of the message file.  This is us, literally.
     */
    len = GetModuleFileName(GetModuleHandle(NULL), szBuf, MAX_PATH);

    /*
     * Add the name to the EventMessageFile subkey.
     */
    RegSetValueEx(hk,
            _T("EventMessageFile"),
            0,
            REG_EXPAND_SZ,
            (LPBYTE) szBuf,
            (len + 1));

    /* We also do catagories, too. */
    RegSetValueEx(hk,
            _T("CategoryMessageFile"),
            0,
            REG_EXPAND_SZ,
            (LPBYTE) szBuf,
            (len + 1));

    /* Last catagory (facility) */
    dwData = FACILITY_MSPROTO; 

    RegSetValueEx(hk,
            _T("CategoryCount"),
            0,
            REG_DWORD,
            (LPBYTE) &dwData,
            sizeof(DWORD));

    /* Set the supported event types in the TypesSupported subkey. */

    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 

    RegSetValueEx(hk,
            _T("TypesSupported"),
            0,
            REG_DWORD,
            (LPBYTE) &dwData,
            sizeof(DWORD));

    RegCloseKey(hk); 
@


1.1.2.3
log
@adding more calls to ExpSyslog() where needed.
@
text
@d15 1
a15 1
#define STRICT    /* ask windows.h to agressive about the HANDLE type */
d98 1
a98 1
	    errData[cnt++] = _T("I/O general"); break;
@


1.1.2.4
log
@removed the check to when not to call DebugBreak().  Always call it.
@
text
@d15 1
a15 1
#define STRICT    /* ask windows.h to be agressive about the HANDLE type */
a122 1

d124 1
a124 1
	DebugBreak();
@


1.1.2.5
log
@Numerous changes
@
text
@d1 1
a1 1
/* ----------------------------------------------------------------------------
a7 8
 * ----------------------------------------------------------------------------
 *
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 * 
a8 1
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
d10 2
a11 2
 * Copyright (c) 2001 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
a12 7
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: exp.h,v 1.1.2.5 2001/10/29 06:40:29 davygrvy Exp $
 * ----------------------------------------------------------------------------
d15 4
a18 2
#include "expWinInt.h"
#include <crtdbg.h>
d55 1
a55 1
ExpWinSyslog TCL_VARARGS_DEF(DWORD,arg1)
a63 3
    char *file;
    int line;
    static TCHAR fileInfo[MAX_PATH];
d69 1
a69 4
    file = va_arg(args, char *);
    line = va_arg(args, int);
    _stprintf(fileInfo, "%s(%d)", file, line);
    errData[cnt++] = fileInfo;
d125 1
a125 1
	//DebugBreak();
@


1.1.2.6
log
@More trims for unicode, but I'm dropping the attempt to build for unicode.
Too much wierd stuff to handle along with tchar.h having a C++ bug
that I don't understand why overloading is problematic.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinLog.c,v 1.1.2.5 2001/11/07 10:04:57 davygrvy Exp $
d41 1
a41 1
static char sysMsgSpace[1024];
d76 1
a76 1
    static char codeBuf[33];
d80 1
a80 1
    static char fileInfo[MAX_PATH];
d88 1
a88 1
    wsprintfA(fileInfo, "%s(%d)", file, line);
d94 1
a94 1
	    errData[cnt++] = "Warning"; break;
d96 1
a96 1
	    errData[cnt++] = "Success"; break;
d98 1
a98 1
	    errData[cnt++] = "Info"; break;
d100 1
a100 1
	    errData[cnt++] = "Fatal"; break;
d106 1
a106 1
	    errData[cnt++] = "Winsock IPC"; break;
d108 1
a108 1
	    errData[cnt++] = "System"; break;
d110 1
a110 1
	    errData[cnt++] = "Stubs"; break;
d112 1
a112 1
	    errData[cnt++] = "NamedPipe IPC"; break;
d114 1
a114 1
	    errData[cnt++] = "Master/Slave Protocol"; break;
d116 1
a116 1
	    errData[cnt++] = "MailBoxing IPC"; break;
d118 1
a118 1
	    errData[cnt++] = "I/O general"; break;
d120 1
a120 1
	    errData[cnt++] = "Debug/Trap"; break;
d124 1
a124 1
    wsprintfA(codeBuf, "0x%04X", GETCODE(errCode));
d154 1
a154 1
char *ExpSyslogGetSysMsg (DWORD id)
d158 1
a158 1
    chars = wsprintfA(sysMsgSpace, "[%d] ", id);
d216 1
a216 1
    ReportEventA(hSyslog, wSev, GETFACILITY(errCode), errCode,
@


