head	5.32;
access;
symbols
	expect_5_45:5.32
	expect_6_branch:5.31.0.2
	expect_5_44_1_15:5.31
	activestate_win32_port_start:5.30
	win32-jump-point-1:5.30
	telco-tec-win32-take2-branch:5.30.0.6
	telco-tec-win32-branch:5.30.0.4
	expect-sf418892-sf439042-branch:5.30.0.2
	tclpro-1-5-0:5.30
	tclpro-1-4-1:5.30
	tclpro-1-4-0:5.30
	expect-5-32-2:5.30
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.1
	scriptics-sc-2-0-b5:5.28.1.1.2.1
	scriptics-sc-2-0-fixed:5.28.1.1.2.1
	scriptics-sc-2-0-b2:5.28.1.1.2.1
	scriptics-sc-2-0-b1:5.28.1.1.2.1
	scriptics-sc-1-1:5.28.1.1.2.1
	scriptics-sc-1-1-b1:5.28.1.1.2.1
	scriptics-sc-1-1-branch:5.28.1.1.2.1.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.1
	scriptics-sc-1-0:5.28.1.1.2.1
	scriptics-sc-1-0-branch:5.28.1.1.2.1.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.1
	expect-5-31-3:5.28.1.1.2.1
	scriptics-bc-1-0-b1:5.28.1.1.2.1
	scriptics-tclpro-1-3-0:5.28.1.1.2.1
	scriptics-tclpro-1-3-b4:5.28.1.1.2.1
	scriptics-tclpro-1-3-b3:5.28.1.1.2.1
	expect-5-31:5.28.1.1.2.1
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.32
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.31;

5.31
date	2005.02.15.18.11.29;	author andreas_kupries;	state Exp;
branches;
next	5.30;

5.30
date	2000.08.04.18.01.56;	author libes;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.07;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.29.02.27.49;	author libes;	state Exp;
branches;
next	;


desc
@@


5.32
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# mkpasswd - make a password, if username given, set it.
# Author: Don Libes, NIST

# defaults
set length 9
set minnum 2
set minlower 2
set minupper 2
set minspecial 1
set verbose 0
set distribute 0

if {[file executable /bin/nispasswd]} {
	set defaultprog /bin/nispasswd
} elseif {[file executable /bin/yppasswd]} {
	set defaultprog /bin/yppasswd
} elseif {[file executable /bin/passwd]} {
	set defaultprog /bin/passwd
} else {
	set defaultprog passwd
}
set prog $defaultprog

while {[llength $argv]>0} {
	set flag [lindex $argv 0]
	switch -- $flag \
	"-l" {
		set length [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} "-d" {
		set minnum [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} "-c" {
		set minlower [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} "-C" {
		set minupper [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} "-s" {
		set minspecial [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} "-v" {
		set verbose 1
		set argv [lrange $argv 1 end]
	} "-p" {
		set prog [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} "-2" {
		set distribute 1
		set argv [lrange $argv 1 end]
	} default {
		set user [lindex $argv 0]
		set argv [lrange $argv 1 end]
		break
	}
}

if {[llength $argv]} {
	puts "usage: mkpasswd \[args] \[user]"
	puts "  where arguments are:"
	puts "    -l #      (length of password, default = $length)"
	puts "    -d #      (min # of digits, default = $minnum)"
	puts "    -c #      (min # of lowercase chars, default = $minlower)"
	puts "    -C #      (min # of uppercase chars, default = $minupper)"
	puts "    -s #      (min # of special chars, default = $minspecial)"
	puts "    -v        (verbose, show passwd interaction)"
	puts "    -p prog   (program to set password, default = $defaultprog)"
	exit 1
}

if {$minnum + $minlower + $minupper + $minspecial > $length} {
	puts "impossible to generate $length-character password\
		with $minnum numbers, $minlower lowercase letters,\
		$minupper uppercase letters and\
		$minspecial special characters."
	exit 1
}

# if there is any underspecification, use additional lowercase letters
set minlower [expr {$length - ($minnum + $minupper + $minspecial)}]

set lpass ""		;# password chars typed by left hand
set rpass ""		;# password chars typed by right hand

# insert char into password at a random position, thereby spreading
# the different kinds of characters throughout the password
proc insert {pvar char} {
    upvar $pvar p

    set p [linsert $p [rand [expr {(1+[llength $p])}]] $char]
}

proc rand {m} {
    expr {int($m*rand())}
}

# choose left or right starting hand
set initially_left [set isleft [rand 2]]

# given a size, distribute between left and right hands
# taking into account where we left off
proc psplit {max lvar rvar} {
	upvar $lvar left $rvar right
	global isleft

	if {$isleft} {
		set right [expr $max/2]
		set left [expr $max-$right]
		set isleft [expr !($max%2)]
	} else {
		set left [expr $max/2]
		set right [expr $max-$left]
		set isleft [expr $max%2]
	}
}

if {$distribute} {
	set lkeys {q w e r t a s d f g z x c v b}
	set rkeys {y u i o p h j k l n m}
	set lnums {1 2 3 4 5 6}
	set rnums {7 8 9 0}
	set lspec {! @@ # \$ %}
	set rspec {^ & * ( ) - = _ + [ ] "{" "}" \\ | ; : ' \" < > , . ? /}
} else {
	set lkeys {a b c d e f g h i j k l m n o p q r s t u v w x y z}
	set rkeys {a b c d e f g h i j k l m n o p q r s t u v w x y z}
	set lnums {0 1 2 3 4 5 6 7 8 9}
	set rnums {0 1 2 3 4 5 6 7 8 9}
	set lspec {! @@ # \$ % ~ ^ & * ( ) - = _ + [ ] "{" "}" \\ | ; : ' \" < > , . ? /}
	set rspec {! @@ # \$ % ~ ^ & * ( ) - = _ + [ ] "{" "}" \\ | ; : ' \" < > , . ? /}
}

set lkeys_length [llength $lkeys]
set rkeys_length [llength $rkeys]
set lnums_length [llength $lnums]
set rnums_length [llength $rnums]
set lspec_length [llength $lspec]
set rspec_length [llength $rspec]

psplit $minnum left right
for {set i 0} {$i<$left} {incr i} {
	insert lpass [lindex $lnums [rand $lnums_length]]
}
for {set i 0} {$i<$right} {incr i} {
	insert rpass [lindex $rnums [rand $rnums_length]]
}

psplit $minlower left right
for {set i 0} {$i<$left} {incr i} {
	insert lpass [lindex $lkeys [rand $lkeys_length]]
}
for {set i 0} {$i<$right} {incr i} {
	insert rpass [lindex $rkeys [rand $rkeys_length]]
}

psplit $minupper left right
for {set i 0} {$i<$left} {incr i} {
	insert lpass [string toupper [lindex $lkeys [rand $lkeys_length]]]
}
for {set i 0} {$i<$right} {incr i} {
	insert rpass [string toupper [lindex $rkeys [rand $rkeys_length]]]
}

psplit $minspecial left right
for {set i 0} {$i<$left} {incr i} {
	insert lpass [lindex $lspec [rand $lspec_length]]
}
for {set i 0} {$i<$right} {incr i} {
	insert rpass [lindex $rspec [rand $rspec_length]]
}

# merge results together
foreach l $lpass r $rpass {
    if {$initially_left} {
	append password $l $r
    } else {
	append password $r $l
    }
}

if {[info exists user]} {
	if {!$verbose} {
		log_user 0
	}

	spawn $prog $user
	expect {
		"assword*:" {
			# some systems say "Password (again):"
			send "$password\r"
			exp_continue
		}
	}

	# if user isn't watching, check status
	if {!$verbose} {
		if {[lindex [wait] 3]} {
			puts -nonewline "$expect_out(buffer)"
			exit 1
		}
	}

        if {$verbose} {
	    puts -nonewline "password for $user is "
        }
}

puts "$password"
@


5.31
log
@
	* Merged changes from the official versions 5.42.1 and 5.43.0 of
	  expect into the SF sources. See the details below.

	  --------------------
	  Martin Forssen <maf@@tkrat.xorg> fixed bug in ExpOutputProc
	  that caused misbehavior during partial writes.

	  Someone noted that gets stdin behaves differently (returns -1
	  immediately) from tclsh because with 5.42, stdin is unblocked by
	  defaults.

	  Robroy Gregg <robroy@@armory.xcom> noted that expect_background
	  ignores timeouts.  Added to documentation.

	  Jens Peterson <peterson@@redhat.xcom> provided patch for
	  "mkpasswd -vo".

	  Gary Bliesener <gary.bliesener@@nextel.xcom> noted that
	  multixterm failed on his system which had an old Tk that didn't
	  support the Tk package.

	  Removed beta designation.

	  Daniel A. Steffen <steffen@@ics.mq.edu.xau> provided patch for
	  MacOS to avoid panic-redefinition.
	  --------------------
@
text
@d1 8
a8 1
#!/depot/path/expect --
@


5.30
log
@Enhanced mkpasswd to support special chars.
@
text
@d203 4
a208 3
if {$verbose} {
	puts -nonewline "password for $user is "
}
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d10 1
d14 3
a16 1
if {[file executable /bin/yppasswd]} {
d40 3
d66 1
d72 1
a72 1
if {$minnum + $minlower + $minupper > $length} {
d75 2
a76 1
		and $minupper uppercase letters"
d81 1
a81 1
set minlower [expr $length - ($minnum + $minupper)]
d86 2
a87 1
# insert char into password at a random position
d89 1
a89 1
	upvar $pvar p
d91 1
a91 1
	set p [linsert $p [rand [expr 1+[llength $p]]] $char]
a93 2
set _ran [pid]

d95 1
a95 5
	global _ran

	set period 259200
	set _ran [expr ($_ran*7141 + 54773) % $period]
	expr int($m*($_ran/double($period)))
d123 2
d130 2
d138 2
d165 8
d174 6
a179 18
if {$initially_left} {
	regexp "(\[^ ]*) *(.*)" "$lpass" x password lpass
	while {[llength $lpass]} {
		regexp "(\[^ ]*) *(.*)" "$password$rpass" x password rpass
		regexp "(\[^ ]*) *(.*)" "$password$lpass" x password lpass
	}
	if {[llength $rpass]} {
		append password $rpass
	}		
} else {
	regexp "(\[^ ]*) *(.*)" "$rpass" x password rpass
	while {[llength $rpass]} {
		regexp "(\[^ ]*) *(.*)" "$password$lpass" x password lpass
		regexp "(\[^ ]*) *(.*)" "$password$rpass" x password rpass
	}
	if {[llength $lpass]} {
		append password $lpass
	}		
@


5.28
log
@Initial revision
@
text
@d13 1
a13 1
if [file executable /bin/yppasswd] {
d15 1
a15 1
} elseif [file executable /bin/passwd] {
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d13 1
a13 1
if {[file executable /bin/yppasswd]} {
d15 1
a15 1
} elseif {[file executable /bin/passwd]} {
@

