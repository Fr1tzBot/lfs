head	5.39;
access;
symbols
	expect_5_45:5.39
	expect_6_branch:5.39.0.2
	expect_5_44_1_15:5.39
	activestate_win32_port_start:5.31
	telco-tec-win32-take2-branch:5.30.0.6
	telco-tec-win32-branch:5.30.0.4
	expect-sf418892-sf439042-branch:5.30.0.2
	tclpro-1-5-0:5.30
	tclpro-1-4-1:5.30
	tclpro-1-4-0:5.30
	expect-5-32-2:5.30
	expect-5-32-0:5.30
	ajuba-ajuba2-2-0:5.28.1.1.2.3
	scriptics-sc-2-0-b5:5.28.1.1.2.3
	scriptics-sc-2-0-fixed:5.28.1.1.2.3
	scriptics-sc-2-0-b2:5.28.1.1.2.3
	scriptics-sc-2-0-b1:5.28.1.1.2.3
	scriptics-sc-1-1:5.28.1.1.2.3
	scriptics-sc-1-1-b1:5.28.1.1.2.3
	scriptics-sc-1-1-branch:5.28.1.1.2.3.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.3
	scriptics-sc-1-0:5.28.1.1.2.3
	scriptics-sc-1-0-branch:5.28.1.1.2.3.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.3
	expect-5-31-3:5.28.1.1.2.3
	scriptics-bc-1-0-b1:5.28.1.1.2.3
	scriptics-tclpro-1-3-0:5.28.1.1.2.3
	scriptics-tclpro-1-3-b4:5.28.1.1.2.3
	scriptics-tclpro-1-3-b3:5.28.1.1.2.3
	expect-5-31:5.28.1.1.2.3
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.39
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.38;

5.38
date	2010.03.24.19.28.18;	author eee;	state Exp;
branches;
next	5.37;

5.37
date	2010.03.17.23.47.50;	author eee;	state Exp;
branches;
next	5.36;

5.36
date	2010.03.11.21.55.37;	author eee;	state Exp;
branches;
next	5.35;

5.35
date	2008.06.03.22.25.03;	author andreas_kupries;	state Exp;
branches;
next	5.34;

5.34
date	2007.07.17.18.39.23;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2007.07.12.22.28.03;	author andreas_kupries;	state Exp;
branches;
next	5.32;

5.32
date	2007.07.11.21.35.08;	author andreas_kupries;	state Exp;
branches;
next	5.31;

5.31
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.30;

5.30
date	2000.01.21.02.57.40;	author libes;	state Exp;
branches
	5.30.4.1
	5.30.6.1;
next	5.29;

5.29
date	2000.01.06.23.22.03;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.10.22.01.42;	author don;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.15.22.52.57;	author don;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.22.05.03.30;	author libes;	state Exp;
branches;
next	;

5.30.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.30.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.39
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@/* exp_glob.c - expect functions for doing glob

Based on Tcl's glob functions but modified to support anchors and to
return information about the possibility of future matches

Modifications by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include "expect_cf.h"
#include "tcl.h"
#include "exp_int.h"

/* Proper forward declaration of internal function */
static int
Exp_StringCaseMatch2 _ANSI_ARGS_((CONST Tcl_UniChar *string, /* String. */
				  CONST Tcl_UniChar *stop,   /* First char _after_ string */
				  CONST Tcl_UniChar *pattern,	 /* Pattern, which may contain
								  * special characters. */
				  CONST Tcl_UniChar *pstop,   /* First char _after_ pattern */
				  int nocase));

/* The following functions implement expect's glob-style string matching */
/* Exp_StringMatch allow's implements the unanchored front (or conversely */
/* the '^') feature.  Exp_StringMatch2 does the rest of the work. */

int	/* returns # of CHARS that matched */
Exp_StringCaseMatch(string, strlen, pattern, plen, nocase, offset)		/* INTL */
     Tcl_UniChar *string;
     Tcl_UniChar *pattern;
     int strlen;
     int plen;
     int nocase;
     int *offset;	/* offset in chars from beginning of string where pattern matches */
{
    CONST Tcl_UniChar *s;
    CONST Tcl_UniChar *stop = string + strlen;
    CONST Tcl_UniChar *pstop = pattern + plen;
    int ssm, sm;	/* count of bytes matched or -1 */
    int caret = FALSE;
    int star = FALSE;

#ifdef EXP_INTERNAL_TRACE_GLOB
    expDiagLog("\nESCM pattern(%d)=\"",plen);
    expDiagLogU(expPrintifyUni(pattern,plen));
    expDiagLog("\"\n");
    expDiagLog("      string(%d)=\"",strlen);
    expDiagLogU(expPrintifyUni(string,strlen));
    expDiagLog("\"\n");
    expDiagLog("      nocase=%d\n",nocase);
#endif

    *offset = 0;

    if (pattern[0] == '^') {
	caret = TRUE;
	pattern++;
    } else if (pattern[0] == '*') {
	star = TRUE;
    }

    /*
     * test if pattern matches in initial position.
     * This handles front-anchor and 1st iteration of non-front-anchor.
     * Note that 1st iteration must be tried even if string is empty.
     */

    sm = Exp_StringCaseMatch2(string,stop,pattern,pstop,nocase);

#ifdef EXP_INTERNAL_TRACE_GLOB
    expDiagLog("@@0 => %d\n",sm);
#endif

    if (sm >= 0) return(sm);

    if (caret) return -1;
    if (star) return -1;

    if (*string == '\0') return -1;

    s = string + 1;
    sm = 0;
#if 0
    if ((*pattern != '[') && (*pattern != '?')
	&& (*pattern != '\\') && (*pattern != '$')
	&& (*pattern != '*')) {
	while (*s && (s < stop) && *pattern != *s) {
	    s++;
	    sm++;
	}
    }
    if (sm) {
	printf("skipped %d chars of %d\n", sm, strlen); fflush(stdout);
    }
#endif
    for (;s < stop; s++) {
	ssm = Exp_StringCaseMatch2(s,stop,pattern,pstop,nocase);

#ifdef EXP_INTERNAL_TRACE_GLOB
	expDiagLog("@@%d => %d\n",s-string,ssm);
#endif

	if (ssm != -1) {
	    *offset = s-string;
	    return(ssm+sm);
	}
    }
    return -1;
}

/* Exp_StringCaseMatch2 --
 *
 * Like Tcl_StringCaseMatch except that
 * 1: returns number of characters matched, -1 if failed.
 *    (Can return 0 on patterns like "" or "$")
 * 2: does not require pattern to match to end of string
 * 3: Much of code is stolen from Tcl_StringMatch
 * 4: front-anchor is assumed (Tcl_StringMatch retries for non-front-anchor)
*/

static int
Exp_StringCaseMatch2(string,stop,pattern,pstop,nocase)	/* INTL */
     register CONST Tcl_UniChar *string; /* String. */
     register CONST Tcl_UniChar *stop;   /* First char _after_ string */
     register CONST Tcl_UniChar *pattern;	 /* Pattern, which may contain
				 * special characters. */
     register CONST Tcl_UniChar *pstop;   /* First char _after_ pattern */
    int nocase;
{
    Tcl_UniChar ch1, ch2, p;
    int match = 0;	/* # of bytes matched */
    CONST Tcl_UniChar *oldString;

#ifdef EXP_INTERNAL_TRACE_GLOB
    expDiagLog("    ESCM2 pattern=\"");
    expDiagLogU(expPrintifyUni(pattern,pstop-pattern));
    expDiagLog("\"\n");
    expDiagLog("           string=\"");
    expDiagLogU(expPrintifyUni(string,stop-string));
    expDiagLog("\"\n");
    expDiagLog("           nocase=%d\n",nocase);
#endif

    while (1) {
#ifdef EXP_INTERNAL_TRACE_GLOB
	expDiagLog("          * ==========\n");
	expDiagLog("          * pattern=\"");
	expDiagLogU(expPrintifyUni(pattern,pstop-pattern));
	expDiagLog("\"\n");
	expDiagLog("          *  string=\"");
	expDiagLogU(expPrintifyUni(string,stop-string));
	expDiagLog("\"\n");
#endif
	/* If at end of pattern, success! */
	if (pattern >= pstop) {
		return match;
	}

	/* If last pattern character is '$', verify that entire
	 * string has been matched.
	 */
	if ((*pattern == '$') && ((pattern + 1) >= pstop)) {
		if (string == stop) return(match);
		else return(-1);		
	}

	/* Check for a "*" as the next pattern character.  It matches
	 * any substring.  We handle this by calling ourselves
	 * recursively for each postfix of string, until either we match
	 * or we reach the end of the string.
	 *
	 * ZZZ: Check against Tcl core, port optimizations found there over here.
	 */
	
	if (*pattern == '*') {
	    CONST Tcl_UniChar *tail;

	    /*
	     * Skip all successive *'s in the pattern
	     */
	    while ((pattern < pstop) && (*pattern == '*')) {
		++pattern;
	    }

	    if (pattern >= pstop) {
		return((stop-string)+match); /* DEL */
	    }

	    p = *pattern;
	    if (nocase) {
		p = Tcl_UniCharToLower(p);
	    }

	    /* find LONGEST match */

	    /*
	     * NOTES
	     *
	     * The original code used 'strlen' to find the end of the
	     * string. With the recursion coming this was done over and
	     * over again, making this an O(n**2) operation overall. Now
	     * the pointer to the end is passed in from the caller, and
	     * even the topmost context now computes it from start and
	     * length instead of seaching.
	     *
	     * The conversion to unicode also allow us to step back via
	     * decrement, in linear time overall. The previously used
	     * Tcl_UtfPrev crawled to the previous character from the
	     * beginning of the string, another O(n**2) operation.
	     */

	    tail = stop - 1;
	    while (1) {
		int rc;
#ifdef EXP_INTERNAL_TRACE_GLOB
		expDiagLog(" skip back '%c'\n",p);
#endif
		/*
		 * Optimization for matching - cruise through the string
		 * quickly if the next char in the pattern isn't a special
		 * character.
		 *
		 * NOTE: We cruise backwards to keep the semantics of
		 * finding the LONGEST match.
		 *
		 * XXX JH: should this add '&& (p != '$')' ???
		 */
		if ((p != '[') && (p != '?') && (p != '\\')) {
		    if (nocase) {
			while ((tail >= string) && (p != *tail)
			       && (p != Tcl_UniCharToLower(*tail))) {
			    tail--;;
			}
		    } else {
			/*
			 * XXX JH: Should this be (tail > string)?
			 * ZZZ AK: No. tail == string is perfectly acceptable,
			 *         if p == *tail. Backing before string is ok too,
			 *         that is the condition to break the outer loop.
			 */
			while ((tail >= string) && (p != *tail)) { tail --; }
		    }
		}

		/* if we've backed up to before the beginning of string, give up */
		if (tail < string) break;

		rc = Exp_StringCaseMatch2(tail, stop, pattern, pstop, nocase);
#ifdef EXP_INTERNAL_TRACE_GLOB
		expDiagLog(" (*) rc=%d\n",rc);
#endif
		if (rc != -1 ) {
		    return match + (tail - string) + rc;
		    /* match = # of bytes we've skipped before this */
		    /* (...) = # of bytes we've skipped due to "*" */
		    /* rc    = # of bytes we've matched after "*" */
		}

		/* if we've backed up to beginning of string, give up */
		if (tail == string) break;

		tail --;
		if (tail < string) tail = string;
	    }
	    return -1;					/* DEL */
	}
    
	/*
	 * after this point, all patterns must match at least one
	 * character, so check this
	 */

	if (string >= stop) return -1;

	/* Check for a "?" as the next pattern character.  It matches
	 * any single character.
	 */

	if (*pattern == '?') {
	    pattern++;
	    oldString = string;
	    string ++;
	    match ++; /* incr by # of matched chars */
	    continue;
	}

	/* Check for a "[" as the next pattern character.  It is
	 * followed by a list of characters that are acceptable, or by a
	 * range (two characters separated by "-").
	 */
	
	if (*pattern == '[') {
	    Tcl_UniChar ch, startChar, endChar;

#ifdef EXP_INTERNAL_TRACE_GLOB
	    expDiagLog("          class\n");
#endif
	    pattern++;
	    oldString = string;
	    ch = *string++;

	    while (1) {
		if ((pattern >= pstop) || (*pattern == ']')) {
#ifdef EXP_INTERNAL_TRACE_GLOB
		    expDiagLog("          end-of-pattern or class/1\n");
#endif
		    return -1;			/* was 0; DEL */
		}
		startChar = *pattern ++;
		if (nocase) {
		    startChar = Tcl_UniCharToLower(startChar);
		}
		if (*pattern == '-') {
		    pattern++;
		    if (pattern >= pstop) {
#ifdef EXP_INTERNAL_TRACE_GLOB
			expDiagLog("          end-of-pattern/2\n");
#endif
			return -1;		/* DEL */
		    }
		    endChar = *pattern ++;
		    if (nocase) {
			endChar = Tcl_UniCharToLower(endChar);
		    }
		    if (((startChar <= ch) && (ch <= endChar))
			    || ((endChar <= ch) && (ch <= startChar))) {
			/*
			 * Matches ranges of form [a-z] or [z-a].
			 */

#ifdef EXP_INTERNAL_TRACE_GLOB
			expDiagLog("          matched-range\n");
#endif
			break;
		    }
		} else if (startChar == ch) {
#ifdef EXP_INTERNAL_TRACE_GLOB
		    expDiagLog("          matched-char\n");
#endif
		    break;
		}
	    }
	    while ((pattern < pstop) && (*pattern != ']')) {
		pattern++;
	    }
	    if (pattern < pstop) {
		/*
		 * Skip closing bracket if there was any.
		 * Fixes SF Bug 1873404.
		 */
		pattern++;
	    }
#ifdef EXP_INTERNAL_TRACE_GLOB
	    expDiagLog("          skipped remainder of pattern\n");
#endif
	    match += (string - oldString); /* incr by # matched chars */
	    continue;
	}
 
	/* If the next pattern character is backslash, strip it off so
	 * we do exact matching on the character that follows.
	 */
	
	if (*pattern == '\\') {
	    pattern ++;
	    if (pattern >= pstop) {
		return -1;
	    }
	}

	/* There's no special character.  Just make sure that the next
	 * characters of each string match.
	 */
	
	oldString = string;
	ch1 = *string ++;
	ch2 = *pattern ++;
	if (nocase) {
	    if (Tcl_UniCharToLower(ch1) != Tcl_UniCharToLower(ch2)) {
		return -1;
	    }
	} else if (ch1 != ch2) {
	    return -1;
	}
	match += (string - oldString);  /* incr by # matched chars */
    }
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.38
log
@more ANSIfications
@
text
@d20 1
a20 1
Exp_StringCaseMatch2 (CONST Tcl_UniChar *string, /* String. */
d25 1
a25 1
				  int nocase);
d31 8
a38 8
int	/* returns # of chars that matched */
Exp_StringCaseMatch(		/* INTL */
     Tcl_UniChar *string,
     Tcl_UniChar *pattern,
     int strlen,
     int plen,
     int nocase,
     int *offset)	/* offset in chars from beginning of string where pattern matches */
d126 4
a129 4
Exp_StringCaseMatch2(	/* INTL */
     register CONST Tcl_UniChar *string, /* String. */
     register CONST Tcl_UniChar *stop,   /* First char _after_ string */
     register CONST Tcl_UniChar *pattern,	 /* Pattern, which may contain
d131 2
a132 2
     register CONST Tcl_UniChar *pstop,   /* First char _after_ pattern */
    int nocase)
d392 1
a392 1

@


5.37
log
@ANSIfication changes
@
text
@d31 1
a31 1
int	/* returns # of CHARS that matched */
@


5.36
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d20 1
a20 1
Exp_StringCaseMatch2 _ANSI_ARGS_((CONST Tcl_UniChar *string, /* String. */
d25 1
a25 1
				  int nocase));
d32 7
a38 7
Exp_StringCaseMatch(string, strlen, pattern, plen, nocase, offset)		/* INTL */
     Tcl_UniChar *string;
     Tcl_UniChar *pattern;
     int strlen;
     int plen;
     int nocase;
     int *offset;	/* offset in chars from beginning of string where pattern matches */
d126 4
a129 4
Exp_StringCaseMatch2(string,stop,pattern,pstop,nocase)	/* INTL */
     register CONST Tcl_UniChar *string; /* String. */
     register CONST Tcl_UniChar *stop;   /* First char _after_ string */
     register CONST Tcl_UniChar *pattern;	 /* Pattern, which may contain
d131 2
a132 2
     register CONST Tcl_UniChar *pstop;   /* First char _after_ pattern */
    int nocase;
@


5.35
log
@
	* exp_glob.c (Exp_StringCaseMatch2): Fixed bug in the handling of
	  glob classes, see [SF Bug 1873404]. The code tried to match the
	  closing bracket of a class in the input because it was not
	  properly skipped after the class was matched successfully.
	  Additional trace output added.
	* configure.in: Bumped version to 5.44.1.9.
	* configure: Regen'd, autoconf 2.59.
@
text
@d392 1
a392 1

@


5.34
log
@
	* expect.c: Circumvented problems with the C compiler by use of a
	  temporary variable to hold the unicode pointer of a glob
	  pattern. The computed pattern length given to
	  Exp_StringCaseMatch was bogus.

	* exp_glob.c: Added tracing of the glob matcher internals (Can be
	  enabled by define EXP_INTERNAL_TRACE_GLOB). Fixed bug in a guard
	  condition in the optimized handling of '*'. The bad condition
	  caused the code to miss possible matches at the beginning of the
	  input (first char).

	* tests/expect.test: Added tests which check the glob matcher and
	  RE gate keeping.

	* configure.in: Bumped to 5.44.1.1 to separate this from the
	  regular 5.44.1 sources.
	* configure: Regenerated.
@
text
@d150 1
d299 3
d308 3
d320 3
d335 3
d341 3
d350 10
@


5.33
log
@
	* expect.c: Found bugs mismanaging input and pattern in the
	* exp_glob.c: updated glob matcher. We cannot check for '\0'
	  anymore to find the end of the string, these are counted
	  arrays now. Rewritten to use sentinel pointers.
@
text
@d37 1
a37 1
int nocase;
d44 2
a45 2
	int caret = FALSE;
	int star = FALSE;
d47 11
a57 1
	*offset = 0;
d59 6
a64 6
	if (pattern[0] == '^') {
		caret = TRUE;
		pattern++;
	} else if (pattern[0] == '*') {
		star = TRUE;
	}
d66 5
a70 5
	/*
	 * test if pattern matches in initial position.
	 * This handles front-anchor and 1st iteration of non-front-anchor.
	 * Note that 1st iteration must be tried even if string is empty.
	 */
a72 1
	if (sm >= 0) return(sm);
d74 5
a78 2
	if (caret) return -1;
	if (star) return -1;
d80 4
a83 1
	if (*string == '\0') return -1;
d89 2
a90 2
	    && (*pattern != '\\') && (*pattern != '$')
	    && (*pattern != '*')) {
d102 5
d108 1
a108 1
			*offset = s-string;
a109 1
		}
d111 2
a112 1
	return -1;
d138 10
d149 8
d218 3
a220 1

d240 3
d248 2
a249 2
		/* if we've backed up to beginning of string, give up */
		if (tail <= string) break;
d252 3
@


5.32
log
@
	* exp_chan.c: Converted the buffering system from UTF-8 in Tcl_Obj
	* exp_command.h: to UTF-16 C-array, to avoid the repeated conversion
	* expect.c: of the input from utf-8 to utf-16. Updated the glob
	* exp_glob.c: matching code to use the same tricks for speed which
	* exp_inter.c: are used by the Tcl core. Extended the regexp
	* exp_log.c: matching path with a glob matcher which uses a gate
	* exp_log.h: keeper glob pattern to weed out most non-candidates
	* retoglob.c (New file): in a speedy manner. Regexp matching now
	  has to be done only for the small number of candidates
	  identified by the gate keeper. Overall speed improvement as glob
	  matching is faster than regexp matching. Added code translating
	  regular expressions into their gate keeper glob pattern.
@
text
@d24 1
d32 1
a32 1
Exp_StringCaseMatch(string, strlen, pattern, nocase, offset)		/* INTL */
d36 1
d42 1
d62 1
a62 1
    sm = Exp_StringCaseMatch2(string,stop,pattern, nocase);
d86 1
a86 1
	ssm = Exp_StringCaseMatch2(s,stop,pattern, nocase);
d106 1
a106 1
Exp_StringCaseMatch2(string,stop,pattern,nocase)	/* INTL */
d111 1
d120 1
a120 1
	if (*pattern == 0) {
d127 2
a128 2
	if ((*pattern == '$') && (pattern[1] == 0)) {
		if (*string == 0) return(match);
d146 3
a148 2
	    while (*(++pattern) == '*') {}
	    p = *pattern;
d150 1
a150 1
	    if (p == 0) {
d154 1
d208 1
a208 1
		rc = Exp_StringCaseMatch2(tail, stop, pattern, nocase);
d230 1
a230 1
	if (*string == 0) return -1;
d257 1
a257 1
		if ((*pattern == ']') || (*pattern == '\0')) {
d266 1
a266 1
		    if (*pattern == '\0') {
d285 1
a285 5
	    while (*pattern != ']') {
		if (*pattern == '\0') {
		    pattern--;
		    break;
		}
a287 1
	    pattern++;
d297 2
a298 2
	    pattern += 1;
	    if (*pattern == 0) {
@


5.31
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d18 8
d29 6
a34 4
int	/* returns # of BYTES that matched */
Exp_StringCaseMatch(string, pattern, nocase, offset)		/* INTL */
char *string;
char *pattern;
d36 1
a36 1
int *offset;	/* offset in bytes from beginning of string where pattern matches */
d38 3
a40 2
	CONST char *s;
	int sm;	/* count of bytes matched or -1 */
d59 1
a59 1
	sm = Exp_StringCaseMatch2(string,pattern, nocase);
d67 18
a84 3
	for (s = Tcl_UtfNext(string);*s;s = Tcl_UtfNext(s)) {
 		sm = Exp_StringCaseMatch2(s,pattern, nocase);
		if (sm != -1) {
d86 1
a86 1
			return(sm);
d93 7
a99 7

Like Tcl_StringCaseMatch except that
1) returns number of characters matched, -1 if failed.
	(Can return 0 on patterns like "" or "$")
2) does not require pattern to match to end of string
3) much of code is stolen from Tcl_StringMatch
4) front-anchor is assumed (Tcl_StringMatch retries for non-front-anchor)
d102 5
a106 3
int Exp_StringCaseMatch2(string,pattern, nocase)	/* INTL */
    register CONST char *string;	/* String. */
    register CONST char *pattern;	/* Pattern, which may contain
d110 1
a110 1
    Tcl_UniChar ch1, ch2;
d112 1
a112 3
    CONST char *oldString;

    CONST char *pstart = pattern;
d130 4
a133 2
	 * recursively for each postfix of string, until either we
	 * match or we reach the end of the string.
d137 11
a147 1
	    CONST char *tail;
d149 2
a150 3
	    pattern += 1;
	    if (*pattern == 0) {
		return(strlen(string)+match); /* DEL */
d154 18
a171 1
	    tail = string + strlen(string);
d175 29
a203 1
		if (-1 != (rc = Exp_StringCaseMatch2(tail, pattern, nocase))) {
d212 3
a214 1
		tail = Tcl_UtfPrev(tail,string);
d233 2
a234 2
	    string = Tcl_UtfNext(string);
	    match += (string - oldString); /* incr by # of bytes in char */
d238 3
a240 3
	/* Check for a "[" as the next pattern character.  It is followed
	 * by a list of characters that are acceptable, or by a range
	 * (two characters separated by "-").
d248 1
a248 1
	    string += Tcl_UtfToUniChar(string, &ch);
d254 1
a254 1
		pattern += Tcl_UtfToUniChar(pattern, &startChar);
d263 1
a263 1
		    pattern += Tcl_UtfToUniChar(pattern, &endChar);
d281 1
a281 1
		    pattern = Tcl_UtfPrev(pattern, pstart);
d284 1
a284 1
		pattern = Tcl_UtfNext(pattern);
d287 1
a287 1
	    match += (string - oldString); /* incr by # of bytes in char */
d291 2
a292 2
	/* If the next pattern character is backslash, strip it off
	 * so we do exact matching on the character that follows.
d307 2
a308 2
	string  += Tcl_UtfToUniChar(string, &ch1);
	pattern += Tcl_UtfToUniChar(pattern, &ch2);
d316 1
a316 1
	match += (string - oldString);  /* incr by # of bytes in char */
d319 8
@


5.30
log
@Fixed bug in expect's glob-range code.
@
text
@d28 1
a28 1
	char *s;
d77 2
a78 2
    register char *string;	/* String. */
    register char *pattern;	/* Pattern, which may contain
d84 1
a84 1
    char *oldString;
d86 1
a86 1
    char *pstart = pattern;
d109 1
a109 1
	    char *tail;
@


5.30.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.30.4.1
log
@Top-level source files removed.
@
text
@@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d163 1
d200 1
a200 1
		pattern++;
d203 1
@


5.28
log
@Initial revision
@
text
@a17 1
#if 0
d21 2
a22 2
int	/* returns # of chars that matched */
Exp_StringMatch(string, pattern,offset)
d25 2
a26 1
int *offset;	/* offset from beginning of string where pattern matches */
d29 1
a29 39
	int sm;	/* count of chars matched or -1 */
	int caret = FALSE;

	*offset = 0;

	if (pattern[0] == '^') {
		caret = TRUE;
		pattern++;
	}

	sm = Exp_StringMatch2(string,pattern);
	if (sm >= 0) return(sm);

	if (caret) return(-1);

	if (pattern[0] == '*') return(-1);

	for (s = string;*s;s++) {
 		sm = Exp_StringMatch2(s,pattern);
		if (sm != -1) {
			*offset = s-string;
			return(sm);
		}
	}
	return(-1);
}
#endif

/* The following functions implement expect's glob-style string matching */
/* Exp_StringMatch allow's implements the unanchored front (or conversely */
/* the '^') feature.  Exp_StringMatch2 does the rest of the work. */
int	/* returns # of chars that matched */
Exp_StringMatch(string, pattern,offset)
char *string;
char *pattern;
int *offset;	/* offset from beginning of string where pattern matches */
{
	char *s;
	int sm;	/* count of chars matched or -1 */
d48 1
a48 1
	sm = Exp_StringMatch2(string,pattern);
d56 2
a57 2
	for (s = string+1;*s;s++) {
 		sm = Exp_StringMatch2(s,pattern);
d66 1
a66 1
/* Exp_StringMatch2 --
d68 1
a68 1
Like Tcl_StringMatch except that
d76 1
a76 1
int Exp_StringMatch2(string,pattern)
d80 1
d82 5
a86 2
    char c2;
    int match = 0;	/* # of chars matched */
a108 2
#if 1
	    int head_len;
d110 1
a110 1
#endif
d115 4
a118 5
#if 1
	    /* find longest match - switched to this on 12/31/93 */
	    head_len = strlen(string);	/* length before tail */
	    tail = string + head_len;
	    while (head_len >= 0) {
d121 5
a125 2
		if (-1 != (rc = Exp_StringMatch2(tail, pattern))) {
		    return rc + match + head_len;	/* DEL */
a126 7
		tail--;
		head_len--;
	    }
#else
	    /* find shortest match */
	    while (*string != 0) {
		int rc;					/* DEL */
d128 3
a130 5
		if (-1 != (rc = Exp_StringMatch2(string, pattern))) {
		    return rc+match;		/* DEL */
		}
		string += 1;
		match++;				/* DEL */
a131 2
	    if (*pattern == '$') return 0;	/* handle *$ */
#endif
d147 5
a151 1
	    goto thisCharOK;
d160 5
a164 1
	    pattern += 1;
d166 1
a166 1
		if ((*pattern == ']') || (*pattern == 0)) {
d169 7
a175 6
		if (*pattern == *string) {
		    break;
		}
		if (pattern[1] == '-') {
		    c2 = pattern[2];
		    if (c2 == 0) {
d178 3
a180 2
		    if ((*pattern <= *string) && (c2 >= *string)) {
			break;
d182 6
a187 1
		    if ((*pattern >= *string) && (c2 <= *string)) {
d190 2
a191 1
		    pattern += 2;
a192 1
		pattern += 1;
a193 7

/* OOPS! Found a bug in vanilla Tcl - have sent back to Ousterhout */
/* but he hasn't integrated it yet. - DEL */

#if 0
	    while ((*pattern != ']') && (*pattern != 0)) {
#else
d195 2
a196 2
		if (*pattern == 0) {
		    pattern--;
d198 2
a199 3
	        }
#endif
		pattern += 1;
d201 2
a202 1
	    goto thisCharOK;
d204 1
a204 1
    
d220 8
a227 1
	if (*pattern != *string) {
d230 1
a230 4

	thisCharOK: pattern += 1;
	string += 1;
	match++;
a232 1

@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Added Exp channel driver and modified rest to support it.
@
text
@d18 1
d23 1
a23 1
Exp_StringCaseMatch(string, pattern, nocase, offset)		/* INTL */
d26 39
a64 2
int nocase;
int *offset;	/* offset in bytes from beginning of string where pattern matches */
d86 1
a86 1
	sm = Exp_StringCaseMatch2(string,pattern, nocase);
d94 2
a95 2
	for (s = Tcl_UtfNext(string);*s;s = Tcl_UtfNext(s)) {
 		sm = Exp_StringCaseMatch2(s,pattern, nocase);
d104 1
a104 1
/* Exp_StringCaseMatch2 --
d106 1
a106 1
Like Tcl_StringCaseMatch except that
d114 1
a114 1
int Exp_StringCaseMatch2(string,pattern, nocase)	/* INTL */
a117 1
    int nocase;
d158 1
a158 1
		if (-1 != (rc = Exp_StringCaseMatch2(tail, pattern, nocase))) {
d169 1
a169 1
		if (-1 != (rc = Exp_StringCaseMatch2(string, pattern, nocase))) {
d192 1
a192 4
	    pattern++;
	    string = Tcl_UtfNext(string);
	    match++;
	    continue;
d200 2
a201 6
	if (p == '[') {
	    Tcl_UniChar ch, startChar, endChar;

	    pattern++;
	    string += Tcl_UtfToUniChar(string, &ch);

d203 1
a203 1
		if ((*pattern == ']') || (*pattern == '\0')) {
d206 6
a211 7
		pattern += Tcl_UtfToUniChar(pattern, &startChar);
		if (nocase) {
		    startChar = Tcl_UniCharToLower(startChar);
		}
		if (*pattern == '-') {
		    pattern++;
		    if (*pattern == '\0') {
d214 2
a215 3
		    pattern += Tcl_UtfToUniChar(pattern, &endChar);
		    if (nocase) {
			endChar = Tcl_UniCharToLower(endChar);
d217 1
a217 6
		    if (((startChar <= ch) && (ch <= endChar))
			    || ((endChar <= ch) && (ch <= startChar))) {
			/*
			 * Matches ranges of form [a-z] or [z-a].
			 */

d220 1
a220 2
		} else if (startChar == ch) {
		    break;
d222 1
d224 7
d232 2
a233 2
		if (*pattern == '\0') {
		    pattern = Tcl_UtfPrev(pattern, pstart);
d235 3
a237 2
		}
		pattern++;
d239 1
a239 2
	    pattern++;
	    continue;
d241 1
a241 1
 
d257 1
a257 7
	string  += Tcl_UtfToUniChar(string, &ch1);
	pattern += Tcl_UtfToUniChar(pattern, &ch2);
	if (nocase) {
	    if (Tcl_UniCharToLower(ch1) != Tcl_UniCharToLower(ch2)) {
		return -1;
	    }
	} else if (ch1 != ch2) {
d260 3
d266 1
@


5.28.1.1.2.2
log
@Everything but Dbg.c
@
text
@d82 1
a82 1
    Tcl_UniChar ch1, ch2;
a84 2
    char *pstart = pattern;

d166 1
a166 1
	if (*pattern == '[') {
@


5.28.1.1.2.3
log
@fixed examples
@
text
@d21 1
a21 1
int	/* returns # of BYTES that matched */
d29 1
a29 1
	int sm;	/* count of bytes matched or -1 */
d83 1
a83 2
    int match = 0;	/* # of bytes matched */
    char *oldString;
d108 2
d111 1
a111 1

d116 5
a120 4

	    /* find LONGEST match */
	    tail = string + strlen(string);
	    while (1) {
d124 1
a124 4
		    return match + (tail - string) + rc;
		    /* match = # of bytes we've skipped before this */
		    /* (...) = # of bytes we've skipped due to "*" */
		    /* rc    = # of bytes we've matched after "*" */
d126 7
d134 5
a138 3
		/* if we've backed up to beginning of string, give up */
		if (tail == string) break;
		tail = Tcl_UtfPrev(tail,string);
d140 2
a157 1
	    oldString = string;
d159 1
a159 1
	    match += (string - oldString); /* incr by # of bytes in char */
a228 1
	oldString = string;
d238 1
a238 1
	match += (string - oldString);  /* incr by # of bytes in char */
@


