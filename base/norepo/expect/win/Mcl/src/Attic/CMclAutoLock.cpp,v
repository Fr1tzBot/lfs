head	1.1;
access;
symbols
	win32-jump-point-1:1.1.4.1
	telco-tec-win32-take2-branch:1.1.0.4
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2001.11.07.10.00.23;	author davygrvy;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2001.11.07.10.00.24;	author davygrvy;	state Exp;
branches;
next	;

1.1.4.1
date	2001.11.22.22.44.38;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file CMclAutoLock.cpp was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.4.1
log
@Merged Mcl into the take2 branch
@
text
@a0 65
//
// FILE: CMclAutoLock.cpp
//
// Copyright (c) 1997 by Aaron Michael Cohen
//
/////////////////////////////////////////////////////////////////////////

#include "CMclAutoLock.h"

// constructors...
CMclAutoLock::CMclAutoLock( HANDLE hMutexHandle) {
    m_pCritSec = NULL;
    m_pcCritSec = NULL;
    m_pcMutex = NULL;
    m_hMutexHandle = hMutexHandle;
    ::WaitForSingleObject( m_hMutexHandle, INFINITE);
}

CMclAutoLock::CMclAutoLock( CMclMutex & rCMclMutex) {
    m_pCritSec = NULL;
    m_pcCritSec = NULL;
    m_hMutexHandle = NULL;
    m_pcMutex = &rCMclMutex;
    m_pcMutex->Wait(INFINITE);
}

CMclAutoLock::CMclAutoLock( CRITICAL_SECTION * pCritSec) {
    m_hMutexHandle = NULL;
    m_pcMutex = NULL;
    m_pcCritSec = NULL;
    m_pCritSec = pCritSec;
    ::EnterCriticalSection(m_pCritSec);
}

CMclAutoLock::CMclAutoLock( CMclCritSec & rCMclCritSec) {
    m_hMutexHandle = NULL;
    m_pcMutex = NULL;
    m_pCritSec = NULL;
    m_pcCritSec = &rCMclCritSec;
    m_pcCritSec->Enter();
}

// destructor...
CMclAutoLock::~CMclAutoLock(void) {
    BOOL bStatus = TRUE;

    if (m_hMutexHandle) {
        bStatus = ::ReleaseMutex(m_hMutexHandle);
    }
    else if (m_pcMutex) {
        bStatus = m_pcMutex->Release();
    }
    else if (m_pCritSec) {
        ::LeaveCriticalSection(m_pCritSec);
    }
    else {
        m_pcCritSec->Leave();
    }

    if (!bStatus) {
        CMclThrowError( ::GetLastError());
    }
}


@


1.1.2.1
log
@"Mcl" multithreading C++ class library added
@
text
@a0 65
//
// FILE: CMclAutoLock.cpp
//
// Copyright (c) 1997 by Aaron Michael Cohen
//
/////////////////////////////////////////////////////////////////////////

#include "CMclAutoLock.h"

// constructors...
CMclAutoLock::CMclAutoLock( HANDLE hMutexHandle) {
    m_pCritSec = NULL;
    m_pcCritSec = NULL;
    m_pcMutex = NULL;
    m_hMutexHandle = hMutexHandle;
    ::WaitForSingleObject( m_hMutexHandle, INFINITE);
}

CMclAutoLock::CMclAutoLock( CMclMutex & rCMclMutex) {
    m_pCritSec = NULL;
    m_pcCritSec = NULL;
    m_hMutexHandle = NULL;
    m_pcMutex = &rCMclMutex;
    m_pcMutex->Wait(INFINITE);
}

CMclAutoLock::CMclAutoLock( CRITICAL_SECTION * pCritSec) {
    m_hMutexHandle = NULL;
    m_pcMutex = NULL;
    m_pcCritSec = NULL;
    m_pCritSec = pCritSec;
    ::EnterCriticalSection(m_pCritSec);
}

CMclAutoLock::CMclAutoLock( CMclCritSec & rCMclCritSec) {
    m_hMutexHandle = NULL;
    m_pcMutex = NULL;
    m_pCritSec = NULL;
    m_pcCritSec = &rCMclCritSec;
    m_pcCritSec->Enter();
}

// destructor...
CMclAutoLock::~CMclAutoLock(void) {
    BOOL bStatus = TRUE;

    if (m_hMutexHandle) {
        bStatus = ::ReleaseMutex(m_hMutexHandle);
    }
    else if (m_pcMutex) {
        bStatus = m_pcMutex->Release();
    }
    else if (m_pCritSec) {
        ::LeaveCriticalSection(m_pCritSec);
    }
    else {
        m_pcCritSec->Leave();
    }

    if (!bStatus) {
        CMclThrowError( ::GetLastError());
    }
}


@

