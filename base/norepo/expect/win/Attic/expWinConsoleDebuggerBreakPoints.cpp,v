head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.10
	telco-tec-win32-take2-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2002.03.07.02.41.46;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.07.02.41.46;	author davygrvy;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.07.03.25.43;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.08.23.20.49;	author davygrvy;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.09.01.17.29;	author davygrvy;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.03.09.01.51.29;	author davygrvy;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.03.09.03.10.31;	author davygrvy;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2002.03.09.05.48.50;	author davygrvy;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2002.03.12.07.09.36;	author davygrvy;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2002.03.13.03.52.57;	author davygrvy;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.03.15.07.41.45;	author davygrvy;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2002.06.18.22.51.31;	author davygrvy;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2002.06.21.03.01.51;	author davygrvy;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2002.06.22.14.02.03;	author davygrvy;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2002.06.29.00.44.36;	author davygrvy;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2002.06.29.02.11.06;	author davygrvy;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2003.08.25.23.17.49;	author davygrvy;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2003.08.26.20.46.52;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expWinConsoleDebuggerBreakPoints.cpp was initially added on branch telco-tec-win32-take2-branch.
@
text
@@


1.1.2.1
log
@breakpoints completed.  module compiles cleanly, but does not yet function.
The hook-in for posting work has not been established.
@
text
@a0 1082
/* ----------------------------------------------------------------------------
 * expWinConsoleDebuggerBreakPoints.cpp --
 *
 *	Breakpoints for the ConsoleDebugger class are in here.  These define
 *	the behavior of what to do when a breakpoint happens in the slave
 *	we are intercepting.  From here, we transfer the stream .... (TBD)
 *
 * ----------------------------------------------------------------------------
 *
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 * 
 * Copyright (c) 1997 Mitel Corporation
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
 *
 * Copyright (c) 2001-2002 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
 *
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: expWinSlaveTrapDbg.cpp,v 1.1.2.1 2001/11/15 07:25:19 davygrvy Exp $
 * ----------------------------------------------------------------------------
 */

#include "expWinConsoleDebugger.hpp"

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::CreateVtSequence --
 *
 *	When moving the cursor to a new location, this will create
 *	the appropriate VT100 type sequence to get the cursor there.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Characters are written to the pipe going to Expect
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::CreateVtSequence(Process *proc, COORD newPos, DWORD n)
{
    COORD oldPos;
    CHAR buf[2048];
    DWORD count;
//    BOOL b;

    if (n == 0) {
	return;
    }

    oldPos = CursorPosition;

    if (CursorKnown && (newPos.Y > oldPos.Y) && (newPos.X == 0)) {
	buf[0] = '\r';
	memset(&buf[1], '\n', newPos.Y - oldPos.Y);
	count = 1 + newPos.Y - oldPos.Y;
    } else {
	/* VT100 sequence */
	wsprintfA(buf, "\033[%d;%dH", newPos.Y+1, newPos.X+1);
	count = strlen(buf);
    }
    newPos.X += (SHORT) (n % ConsoleSize.X);
    newPos.Y += (SHORT) (n / ConsoleSize.X);
    CursorPosition = newPos;

//    b = ExpWriteMaster(UseSocket, HMaster, buf, count, &proc->overlapped);
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnBeep --
 *
 *	This routine gets called when Beep is called.  At least in sshd,
 *	we don't want a beep to show up on the local console.  Instead,
 *	direct it back to the master with a ASCII 7.
 *
 * Results:
 *	None
 *
 * Notes:
 *	XXX: Setting the duration to 0 doesn't seem to make the local
 *	beep go away.  It seems we need to stop the call at this point
 *	(or point it to some other call with the same number of arguments)
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnBeep(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    CHAR buf[50];

    //LOG_ENTRY("Beep");

    if (direction == BREAK_IN) {
	/* Modify the arguments so a beep doesn't sound on the server */
	threadInfo->args[1] = 0;
    } else if (direction == BREAK_OUT) {
	if (*returnValue == 0) {
	    buf[0] = 7; /* ASCII beep */
	    //ExpWriteMaster(UseSocket, HMaster, buf, 1, &proc->overlapped);
	}
    }
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnFillConsoleOutputCharacter --
 *
 *	This function gets called when an FillConsoleOutputCharacterA
 *	or FillConsoleOutputCharacterW breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnFillConsoleOutputCharacter(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    CHAR buf[4096];
    int bufpos;
    UCHAR c;
    PVOID ptr;
    DWORD i;
    DWORD len;
//    BOOL bRet;
    COORD coord;
    DWORD lines, preCols, postCols;
    BOOL eol, bol;		/* Needs clearing to end, beginning of line */
    CONSOLE_SCREEN_BUFFER_INFO info;

//    LOG_ENTRY("FillConsoleOutputCharacter");

    if (*returnValue == 0) {
	return;
    }

    c = (UCHAR) threadInfo->args[1];
    len = threadInfo->args[2];
    coord = *((PCOORD) &(threadInfo->args[3]));
    ptr = (PVOID) threadInfo->args[4];
    if (ptr) {
	ReadSubprocessMemory(proc, ptr, &len, sizeof(DWORD));
    }

    preCols = 0;
    bufpos = 0;
    eol = bol = FALSE;
    if (coord.X) {
	preCols = ConsoleSize.X - coord.X;
	if (len <= preCols) {
	    preCols = len;
	    len = 0;
	    if (len == preCols) {
		eol = TRUE;
	    }
	} else {
	    eol = TRUE;
	    len -= preCols;
	}
    } else if (len < (DWORD) ConsoleSize.X) {
	bol = TRUE;
	preCols = len;
	len = 0;
    }

    lines = len / ConsoleSize.X;
    postCols = len % ConsoleSize.X;

    if (preCols) {
	if (bol) {
	    /* Beginning of line to before end of line */
	    if (c == ' ') {
		wsprintfA(&buf[bufpos], "\033[%d;%dH\033[1K",
			  coord.Y+1, preCols+coord.X);
		bufpos += strlen(&buf[bufpos]);
	    } else {
		wsprintfA(&buf[bufpos], "\033[%d;%dH",
			  coord.Y+1, coord.X+1);
		bufpos += strlen(&buf[bufpos]);
		memset(&buf[bufpos], c, preCols);
		bufpos += preCols;
	    }
	} else {
	    /* After beginning of line to end of line */
	    wsprintfA(&buf[bufpos], "\033[%d;%dH", coord.Y+1, coord.X+1);
	    bufpos += strlen(&buf[bufpos]);
	    if (eol && c == ' ') {
		wsprintfA(&buf[bufpos], "\033[K");
		bufpos += strlen(&buf[bufpos]);
	    } else {
		memset(&buf[bufpos], c, preCols);
		bufpos += preCols;
	    }
	}
	coord.X = 0;
	coord.Y++;
    }
    if (lines) {
	if ((c == ' ') && ((lines + coord.Y) >= (DWORD) ConsoleSize.Y)) {
	    /* Clear to end of screen */
	    wsprintfA(&buf[bufpos], "\033[%d;%dH\033[J",
		      coord.Y+1, coord.X+1);
	    bufpos += strlen(&buf[bufpos]);
	} else if ((c == ' ') && (coord.Y == 0) && (lines > 0)) {
	    /* Clear to top of screen */
	    wsprintfA(&buf[bufpos], "\033[%d;%dH\033[1J", lines, 1);
	    bufpos += strlen(&buf[bufpos]);
	} else {
	    for (i = 0; i < lines; i++) {
		wsprintfA(&buf[bufpos], "\033[%d;%dH",
			  coord.Y+i+1, coord.X+1);
		bufpos += strlen(&buf[bufpos]);
		if (c == ' ') {
		    wsprintfA(&buf[bufpos], "\033[2K");
		    bufpos += strlen(&buf[bufpos]);
		} else {
		    memset(&buf[bufpos], c, ConsoleSize.X);
		    bufpos += ConsoleSize.X;
		}
	    }
	}
	coord.Y += (SHORT) lines;
    }
	
    if (postCols) {
	if (c == ' ') {
	    /* Clear to beginning of line */
	    wsprintfA(&buf[bufpos], "\033[%d;%dH\033[1K",
		      coord.Y+1, postCols+coord.X);
	    bufpos += strlen(&buf[bufpos]);
	} else {
	    wsprintfA(&buf[bufpos], "\033[%d;%dH", coord.X+1, coord.Y+1);
	    bufpos += strlen(&buf[bufpos]);
	    memset(&buf[bufpos], c, postCols);
	    bufpos += postCols;
	}
    }
    if (GetConsoleScreenBufferInfo(HConsole, &info) == FALSE) {
//	char errbuf[200];
//	wsprintfA(errbuf, "handle=0x%08x", HConsole);
//	EXP_LOG2(MSG_DT_SCREENBUF, errbuf, ExpSyslogGetSysMsg(GetLastError()));
	char errbuf[200];
	wsprintfA(errbuf, "Call to GetConsoleScreenBufferInfo failed: handle=0x%08x, err=0x%08x", HConsole, GetLastError());
//	EXP_LOG("%s", errbuf);
    } else {
	CursorPosition = info.dwCursorPosition;
	wsprintfA(&buf[bufpos], "\033[%d;%dH",
		  CursorPosition.Y+1, CursorPosition.X+1);
	bufpos += strlen(&buf[bufpos]);
	CursorKnown = TRUE;
    }

//    bRet = ExpWriteMaster(UseSocket, HMaster, buf, bufpos, &proc->overlapped);
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnGetStdHandle --
 *
 *	This function gets called when a GetStdHandle breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Sets some flags that are used in determining echoing
 *	characteristics of the slave driver.
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnGetStdHandle(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    DWORD i;
    BOOL found;

    if (*returnValue == (DWORD) INVALID_HANDLE_VALUE) {
	return;
    }
    if (threadInfo->args[0] != STD_INPUT_HANDLE) {
	return;
    }
    for (found = FALSE, i = 0; i < proc->consoleHandlesMax; i++) {
	if (proc->consoleHandles[i] == *returnValue) {
	    found = TRUE;
	    break;
	}
    }
    if (! found) {
	if (proc->consoleHandlesMax > 100) {
	    proc->consoleHandlesMax = 100;
	}
	proc->consoleHandles[proc->consoleHandlesMax++] = *returnValue;
    }
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnOpenConsoleW --
 *
 *	This function gets called when an OpenConsoleW breakpoint
 *	is hit.  There is one big problem with this function--it
 *	isn't documented.  However, we only really care about the
 *	return value which is a console handle.  I think this is
 *	what this function declaration should be:
 *
 *	HANDLE OpenConsoleW(LPWSTR lpFileName,
 *			    DWORD dwDesiredAccess,
 *			    DWORD dwShareMode,
 *			    LPSECURITY_ATTRIBUTES lpSecurityAttributes);
 *
 *	So why do we intercept an undocumented function while we
 *	could just intercept CreateFileW and CreateFileA?  Well,
 *	those functions are going to get called alot more than this
 *	one, so limiting the number of intercepted functions
 *	improves performance since fewer breakpoints will be hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Save the return value in an array of known console handles
 *	with their statuses.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnOpenConsoleW(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    WCHAR name[256];
    PVOID ptr;

//    LOG_ENTRY("OpenConsoleW");
    if (*returnValue == (DWORD) INVALID_HANDLE_VALUE) {
	return;
    }

    /*
     * Save any console input handle.  No SetConsoleMode() calls will
     * succeed unless they are really attached to a console input buffer.
     */

    ptr = (PVOID) threadInfo->args[0];
    ReadSubprocessStringW(proc, ptr, name, 256);

    if (wcsicmp(name, L"CONIN$") == 0) {
	if (proc->consoleHandlesMax > 100) {
	    proc->consoleHandlesMax = 100;
	}
	proc->consoleHandles[proc->consoleHandlesMax++] = *returnValue;
    }
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnReadConsoleInput --
 *
 *	This function gets called when a ReadConsoleInput breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Notes:
 *	If this is ever used for real, there need to be ASCII
 *	and UNICODE versions.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnReadConsoleInput(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnScrollConsoleScreenBuffer --
 *
 *	This funtions gets called when a ScrollConsoleScreenBuffer
 *	breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Generate some VT100 sequences to insert lines
 *
 * Notes:
 *	XXX: Ideally, we should check if the screen buffer is the one that
 *	is currently being displayed.  However, that means we have to
 *	track CONOUT$ handles, so we don't do it for now.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnScrollConsoleScreenBuffer(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
//    BOOL b;
    CHAR buf[100];
    DWORD count = 0;
    SMALL_RECT scroll, clip, *pClip;
    COORD dest;
    CHAR_INFO fill;
    CHAR c;
    PVOID ptr;
//    LOG_ENTRY("ScrollConsoleScreenBuffer");

    if (*returnValue == FALSE) {
	return;
    }
    ptr = (PVOID) threadInfo->args[1];
    ReadSubprocessMemory(proc, ptr, &scroll, sizeof(SMALL_RECT));
    ptr = (PVOID) threadInfo->args[2];
    pClip = 0L;
    if (ptr) {
	pClip = &clip;
	ReadSubprocessMemory(proc, ptr, &clip, sizeof(SMALL_RECT));
    }
    dest = *((PCOORD) &threadInfo->args[3]);
    ptr = (PVOID) threadInfo->args[4];
    ReadSubprocessMemory(proc, ptr, &fill, sizeof(CHAR_INFO));
    c = fill.Char.AsciiChar;

    /* Check for a full line scroll */
    if (c == ' ' && scroll.Left == dest.X &&
	scroll.Left == 0 && scroll.Right >= ConsoleSize.X-1)
    {
	if (dest.Y < scroll.Top) {
	    wsprintfA(&buf[count], "\033[%d;%dr\033[%d;%dH\033[%dM",
		      dest.Y+1,scroll.Bottom+1,dest.Y+1,1,
		      scroll.Top - dest.Y);
	} else {
	    wsprintfA(&buf[count], "\033[%d;%dr\033[%d;%dH\033[%dL",
		      scroll.Top+1,dest.Y+1+(scroll.Bottom - scroll.Top),
		      scroll.Top+1,1,
		      dest.Y - scroll.Top);
	}
	count = strlen(&buf[count]);
	wsprintf(&buf[count], "\033[%d;%dr", 1, ConsoleSize.Y);
	count += strlen(&buf[count]);
//	b = ExpWriteMaster(UseSocket, HMaster, buf, count, &proc->overlapped);
    } else {
//	RefreshScreen(&proc->overlapped);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleMode --
 *
 *	This function gets called when a SetConsoleMode breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Sets some flags that are used in determining echoing
 *	characteristics of the slave driver.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleMode(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    DWORD i;
    BOOL found;

//    LOG_ENTRY("SetConsoleMode");

    /* The console mode seems to get set even if the return value is FALSE */
    if (*returnValue == FALSE) {
	return;
    }
    for (found = FALSE, i = 0; i < proc->consoleHandlesMax; i++) {
	if (threadInfo->args[0] == proc->consoleHandles[i]) {
	    found = TRUE;
	    break;
	}
    }
    if (found) {
	ExpConsoleInputMode = threadInfo->args[1];
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleActiveScreenBuffer --
 *
 *	This function gets called when a SetConsoleActiveScreenBuffer
 *	breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	We reread the entire console and send it to the master.
 *	Updates the current console cursor position
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleActiveScreenBuffer(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
//    LOG_ENTRY("SetConsoleActiveScreenBuffer");

    if (*returnValue == FALSE) {
	return;
    }

//    RefreshScreen(&proc->overlapped);
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleCursorPosition --
 *
 *	This function gets called when a SetConsoleCursorPosition breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Updates the current console cursor position
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleCursorPosition(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
//    BOOL b;
    CHAR buf[50];
    DWORD count;

//    LOG_ENTRY("SetConsoleCursorPosition");

    if (*returnValue == FALSE) {
	return;
    }
    CursorPosition = *((PCOORD) &threadInfo->args[1]);

    wsprintfA(buf, "\033[%d;%dH", CursorPosition.Y+1, CursorPosition.X+1);
    count = strlen(buf);
//    b = ExpWriteMaster(UseSocket, HMaster, buf, count, &proc->overlapped);
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleWindowInfo --
 *
 *	This function gets called when a SetConsoleWindowInfo breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Updates the current console cursor position
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleWindowInfo(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteConsoleA --
 *
 *	This function gets called when an WriteConsoleA breakpoint
 *	is hit.  The data is also redirected to expect since expect
 *	normally couldn't see any output going through this interface.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteConsoleA(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    CHAR buf[1024];
    PVOID ptr;
    DWORD n;
    PCHAR p;
//    BOOL bRet;

//    LOG_ENTRY("WriteConsoleA");

    if (*returnValue == 0) {
	return;
    }
    /*
     * Get number of bytes written
     */
    ptr = (PVOID) threadInfo->args[3];
    if (ptr == 0L) {
	n = threadInfo->args[2];
    } else {
	ReadSubprocessMemory(proc, ptr, &n, sizeof(DWORD));
    }
    if (n > 1024) {
	p = new CHAR [n];
    } else {
	p = buf;
    }

    ptr = (PVOID) threadInfo->args[1];
    ReadSubprocessMemory(proc, ptr, p, n * sizeof(CHAR));
//    ResetEvent(proc->overlapped.hEvent);

//    bRet = ExpWriteMaster(UseSocket, HMaster, p, n, &proc->overlapped);

    if (p != buf) {
	delete [] p;
    }
    CursorKnown = FALSE;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteConsoleW --
 *
 *	This function gets called when an WriteConsoleW breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteConsoleW(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    static WCHAR buf[1024];
    static CHAR ansi[2048];
    PVOID ptr;
    DWORD n;
    PWCHAR p;
    PCHAR a;
    int asize;
//    BOOL bRet;
    int w;

//    LOG_ENTRY("WriteConsoleW");

    if (*returnValue == 0) {
	return;
    }

    ptr = (PVOID) threadInfo->args[1];
    n = threadInfo->args[2];

    if (n > 1024) {
	p = new WCHAR [n];
	a = new CHAR [n * 2];
    } else {
	p = buf;
	a = ansi;
	asize = sizeof(ansi);
    }
    ReadSubprocessMemory(proc, ptr, p, n * sizeof(WCHAR));
//    ResetEvent(proc->overlapped.hEvent);

    /*
     * Convert to ASCII and write the intercepted data to the pipe.
     */

    w = WideCharToMultiByte(CP_ACP, 0, p, n, a, asize, NULL, NULL);
//    bRet = ExpWriteMaster(UseSocket, HMaster, a, w, &proc->overlapped);

    if (p != buf) {
	delete [] p, a;
    }
    CursorKnown = FALSE;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteConsoleOutputA --
 *
 *	This function gets called when an WriteConsoleOutputA breakpoint
 *	is hit.  The data is also redirected to expect since expect
 *	normally couldn't see any output going through this interface.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteConsoleOutputA(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    CHAR buf[1024];
    PVOID ptr;
    DWORD n;
    CHAR *p, *end;
    int maxbuf;
//    BOOL b;
    COORD bufferSize;
    COORD bufferCoord;
    COORD curr;
    SMALL_RECT writeRegion;
    CHAR_INFO *charBuf, *pcb;
    SHORT x, y;

//    LOG_ENTRY("WriteConsoleOutputA");

    if (*returnValue == 0) {
	return;
    }

    bufferSize = *((PCOORD) &threadInfo->args[2]);
    bufferCoord = *((PCOORD) &threadInfo->args[3]);
    ptr = (PVOID) threadInfo->args[4]; /* Get the rectangle written */
    if (ptr == 0L) return;
    ReadSubprocessMemory(proc, ptr, &writeRegion,sizeof(SMALL_RECT));

    ptr = (PVOID) threadInfo->args[1]; /* Get character array */
    if (ptr == 0L) return;

    n = bufferSize.X * bufferSize.Y * sizeof(CHAR_INFO);
    charBuf = new CHAR_INFO [n];

#if 0
    wsprintfA((char *) charBuf, "writeRegion: (%d,%d) to (%d,%d)   bufferCoord: (%d,%d)   bufferSize: (%d,%d)", writeRegion.Left, writeRegion.Top, writeRegion.Right, writeRegion.Bottom, bufferCoord.X, bufferCoord.Y, bufferSize.X, bufferSize.Y);
    ExpSyslog("Debug 0: %s", charBuf);
#endif

    ReadSubprocessMemory(proc, ptr, charBuf, n);

    pcb = charBuf;
    for (y = 0; y <= writeRegion.Bottom - writeRegion.Top; y++) {
	pcb = charBuf;
	pcb += (y + bufferCoord.Y) * bufferSize.X;
	pcb += bufferCoord.X;
	p = buf;
	maxbuf = sizeof(buf);
	end = buf + maxbuf;
	for (x = 0; x <= writeRegion.Right - writeRegion.Left; x++, pcb++) {
	    *p++ = pcb->Char.AsciiChar;
	    if (p == end) {
//		ResetEvent(proc->overlapped.hEvent);
//		b = ExpWriteMaster(UseSocket, HMaster, buf, maxbuf, &proc->overlapped);
		p = buf;
	    }
	}
	curr.X = writeRegion.Left;
	curr.Y = writeRegion.Top + y;
	n = writeRegion.Right - writeRegion.Left;
	CreateVtSequence(proc, curr, n);
//	ResetEvent(proc->overlapped.hEvent);

	maxbuf = p - buf;
//	b = ExpWriteMaster(UseSocket, HMaster, buf, maxbuf, &proc->overlapped);
	buf[maxbuf] = 0;
#if 0
	ExpSyslog("Writing %s", buf);
#endif
    }

    delete [] charBuf;
//    LOG_EXIT("WriteConsoleOutputA");
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteConsoleOutputW --
 *
 *	This function gets called when an WriteConsoleOutputW breakpoint
 *	is hit.  The data is also redirected to expect since expect
 *	normally couldn't see any output going through this interface.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteConsoleOutputW(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    WCHAR buf[1024];
    PVOID ptr;
    DWORD n;
    WCHAR *p, *end;
    int maxbuf;
//    BOOL b;
    COORD bufferSize;
    COORD bufferCoord;
    COORD curr;
    SMALL_RECT writeRegion;
    CHAR_INFO *charBuf, *pcb;
    SHORT x, y;

//    LOG_ENTRY("WriteConsoleOutputW");

    if (*returnValue == 0) {
	return;
    }

    bufferSize = *((PCOORD) &threadInfo->args[2]);
    bufferCoord = *((PCOORD) &threadInfo->args[3]);
    ptr = (PVOID) threadInfo->args[4]; /* Get the rectangle written */
    if (ptr == 0L) return;
    ReadSubprocessMemory(proc, ptr, &writeRegion,sizeof(SMALL_RECT));

    ptr = (PVOID) threadInfo->args[1]; /* Get character array */
    if (ptr == 0L) return;

    n = bufferSize.X * bufferSize.Y * sizeof(CHAR_INFO);
    charBuf = new CHAR_INFO [n];

#if 0
    wsprintfA((char *) charBuf, "writeRegion: (%d,%d) to (%d,%d)   bufferCoord: (%d,%d)   bufferSize: (%d,%d)", writeRegion.Left, writeRegion.Top, writeRegion.Right, writeRegion.Bottom, bufferCoord.X, bufferCoord.Y, bufferSize.X, bufferSize.Y);
    ExpSyslog("Debug 0: %s", charBuf);
#endif

    ReadSubprocessMemory(proc, ptr, charBuf, n);

    pcb = charBuf;
    for (y = 0; y <= writeRegion.Bottom - writeRegion.Top; y++) {
	pcb = charBuf;
	pcb += (y + bufferCoord.Y) * bufferSize.X;
	pcb += bufferCoord.X;
	p = buf;
	maxbuf = sizeof(buf);
	end = buf + maxbuf;
	for (x = 0; x <= writeRegion.Right - writeRegion.Left; x++, pcb++) {
	    *p++ = (CHAR) (pcb->Char.UnicodeChar & 0xff);
	    if (p == end) {
//		ResetEvent(proc->overlapped.hEvent);
//		b = ExpWriteMaster(UseSocket, HMaster, buf, maxbuf, &proc->overlapped);
		p = buf;
	    }
	}
	curr.X = writeRegion.Left;
	curr.Y = writeRegion.Top + y;
	n = writeRegion.Right - writeRegion.Left;
	CreateVtSequence(proc, curr, n);
//	ResetEvent(proc->overlapped.hEvent);

	maxbuf = p - buf;
//	b = ExpWriteMaster(UseSocket, HMaster, buf, maxbuf, &proc->overlapped);
	buf[maxbuf] = 0;
#if 0
	ExpSyslog("Writing %s", buf);
#endif
    }

    delete [] charBuf;
//    LOG_EXIT("WriteConsoleOutputW");
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteConsoleOutputCharacterA --
 *
 *	This function gets called when an WriteConsoleOutputCharacterA breakpoint
 *	is hit.  The data is also redirected to expect since expect
 *	normally couldn't see any output going through this interface.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteConsoleOutputCharacterA(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    static CHAR buf[1024];
    PVOID ptr;
    DWORD n;
    PCHAR p;
//    BOOL b;

//    LOG_ENTRY("WriteConsoleOutputCharacterA");

    if (*returnValue == 0) {
	return;
    }
    /*
     * Get number of bytes written
     */
    ptr = (PVOID) threadInfo->args[4];
    if (ptr == 0L) {
	n = threadInfo->args[2];
    } else {
	ReadSubprocessMemory(proc, ptr, &n, sizeof(DWORD));
    }

    CreateVtSequence(proc, *((PCOORD) &threadInfo->args[3]), n);

    if (n > 1024) {
	p = new CHAR [n];
    } else {
	p = buf;
    }

    ptr = (PVOID) threadInfo->args[1];
    ReadSubprocessMemory(proc, ptr, p, n * sizeof(CHAR));
//    ResetEvent(proc->overlapped.hEvent);

//    b = ExpWriteMaster(UseSocket, HMaster, p, n, &proc->overlapped);

    if (p != buf) {
	delete p;
    }
    CursorKnown = FALSE;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteConsoleOutputCharacterW --
 *
 *	This function gets called when an WriteConsoleOutputCharacterW
 *	breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteConsoleOutputCharacterW(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    static WCHAR buf[1024];
    static CHAR ansi[2048];
    PVOID ptr;
    DWORD n;
    PWCHAR p;
    PCHAR a;
    int asize;
//    BOOL b;
    int w;

    if (direction == BREAK_IN) {
//	LOG_ENTRY("WriteConsoleOutputCharacterW (in)a");
	return;
//    } else {
//	LOG_ENTRY("WriteConsoleOutputCharacterW (out)");
    }

    if (*returnValue == 0) {
	return;
    }
    /*
     * Get number of bytes written
     */
    ptr = (PVOID) threadInfo->args[4];
    if (ptr == 0L) {
	n = threadInfo->args[2];
    } else {
	ReadSubprocessMemory(proc, ptr, &n, sizeof(DWORD));
    }

    CreateVtSequence(proc, *((PCOORD) &threadInfo->args[3]), n);

    if (n > 1024) {
	p = new WCHAR [n];
	asize = n * 2 * sizeof(CHAR);
	a = new CHAR [n * 2];
    } else {
	p = buf;
	a = ansi;
	asize = sizeof(ansi);
    }

    ptr = (PVOID) threadInfo->args[1];
    ReadSubprocessMemory(proc, ptr, p, n * sizeof(WCHAR));
//    ResetEvent(proc->overlapped.hEvent);

    /*
     * Convert to ASCI and Write the intercepted data to the pipe.
     */

    w = WideCharToMultiByte(CP_ACP, 0, p, n, a, asize, NULL, NULL);
//    b = ExpWriteMaster(UseSocket, HMaster, a, w, &proc->overlapped);

#if 0
    a[w] = 0;
    ExpSyslog("WCOCW: Writing %s", a);
#endif

    if (p != buf) {
	delete [] p, a;
    }
    CursorKnown = FALSE;
}
@


1.1.2.2
log
@C++ rewrite of the debugger code is coming along well.
@
text
@d6 1
a6 1
 *	we are intercepting.  From here, we transfer the stream .... (TBF)
d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.1 2002/03/07 02:41:46 davygrvy Exp $
a32 4

//  NOTE:  black magic abounds...  be warry young padwon...


d106 1
a106 1
//    LOG_ENTRY("Beep");
d114 1
a114 1
//	    ExpWriteMaster(UseSocket, HMaster, buf, 1, &proc->overlapped);
@


1.1.2.3
log
@more cleanup.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.2 2002/03/07 03:25:43 davygrvy Exp $
d33 3
a35 1
// NOTE:  black magic abounds...  be warry young padwon...
d73 1
a73 1
	// VT100 sequence
d108 3
a110 1
    CHAR buf[2];
d113 1
a113 1
	// Modify the arguments so a beep doesn't sound on the server
d154 1
a154 1
    BOOL eol, bol;		// Needs clearing to end, beginning of line
d157 2
d197 1
a197 1
	    // Beginning of line to before end of line
d210 1
a210 1
	    // After beginning of line to end of line
d226 1
a226 1
	    // Clear to end of screen
d231 1
a231 1
	    // Clear to top of screen
d253 1
a253 1
	    // Clear to beginning of line
d367 1
d372 5
a376 3
    // Save any console input handle.  No SetConsoleMode() calls will
    // succeed unless they are really attached to a console input buffer.
    //
d448 1
d466 1
a466 1
    // Check for a full line scroll
d514 3
a516 1
    // The console mode seems to get set even if the return value is FALSE
d554 2
d589 2
d653 2
d658 3
a660 1
    // Get number of bytes written
d716 2
a726 1
	asize = n * 2 * sizeof(CHAR);
d736 4
a739 2
    // Convert to ASCII and write the intercepted data to the pipe.
    //
d785 2
d793 1
a793 1
    ptr = (PVOID) threadInfo->args[4]; // Get the rectangle written
d797 1
a797 1
    ptr = (PVOID) threadInfo->args[1]; // Get character array
d835 3
d841 1
d880 2
d888 1
a888 1
    ptr = (PVOID) threadInfo->args[4]; // Get the rectangle written
d892 1
a892 1
    ptr = (PVOID) threadInfo->args[1]; // Get character array
d936 1
d967 2
d972 3
a974 1
    // Get number of bytes written
d997 1
a997 1
	delete [] p;
d1034 7
d1044 3
a1046 1
    // Get number of bytes written
d1070 4
a1073 1
    // Convert to ASCI and Write the intercepted data to the pipe.
d1076 5
@


1.1.2.4
log
@Almost linkable again.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.3 2002/03/08 23:20:49 davygrvy Exp $
a1032 26
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnIsWindowVisible --
 *
 *	This routine gets called when IsWindowVisible is called.
 *	The MKS Korn shell uses this as an indication of a window
 *	that can be seen by the user.  If the window can't be seen,
 *	it pops up a graphical error notification.  We really, really
 *	don't want those damn things popping up, so this helps avoid
 *	it.  And there really doesn't seem to be any good reason to
 *	return FALSE given that nobody is ever going to see anything.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnIsWindowVisible(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    *returnValue = TRUE;
@


1.1.2.5
log
@Changed all uses of NULL to the C++ 0L understanding.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.4 2002/03/09 01:17:29 davygrvy Exp $
d717 1
a717 1
    w = WideCharToMultiByte(CP_ACP, 0, p, n, a, asize, 0L, 0L);
d1026 1
a1026 1
    w = WideCharToMultiByte(CP_ACP, 0, p, n, a, asize, 0L, 0L);
@


1.1.2.6
log
@links once more, but isn't yet working again.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.5 2002/03/09 01:51:29 davygrvy Exp $
d258 1
a258 1
    if (GetConsoleScreenBufferInfo(MasterHConsole, &info) == FALSE) {
d263 1
a263 1
	wsprintfA(errbuf, "Call to GetConsoleScreenBufferInfo failed: handle=0x%08x, err=0x%08x", MasterHConsole, GetLastError());
d515 1
a515 1
	MasterConsoleInputMode = threadInfo->args[1];
@


1.1.2.7
log
@Got error codes working.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.6 2002/03/09 03:10:31 davygrvy Exp $
d259 3
d263 2
a264 2
	wsprintfA(errbuf, "handle=0x%08x", MasterHConsole);
	EXP_LOG2(MSG_DT_SCREENBUF, errbuf, ExpSyslogGetSysMsg(GetLastError()));
@


1.1.2.8
log
@removed all use of Tcl from the slavedrv.  It was only being used for hash tables.  replaced them with std::map.  It's a bit fatter now, but i'll live.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.7 2002/03/09 05:48:50 davygrvy Exp $
d109 1
a109 1
	// Modify the arguments so a beep doesn't sound in the slave.
@


1.1.2.9
log
@milestone!  It works.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.8 2002/03/12 07:09:36 davygrvy Exp $
d58 1
d79 1
a79 1
    WriteMaster(buf, count);
d113 2
a114 2
	    buf[0] = 7; // ASCII beep
	    WriteMaster(buf, 1);
d147 1
d269 2
a270 1
    WriteMaster(buf, bufpos);
d428 1
d470 1
a470 1
	WriteMaster(buf, count);
d568 1
d579 1
a579 1
    WriteMaster(buf, count);
d632 1
d653 2
a654 1
    WriteMaster(p, n);
d690 1
d715 1
a715 1
    WriteMaster(a, w);
d751 1
d794 1
a794 1
		WriteMaster(buf, maxbuf);
d805 1
a805 1
	WriteMaster(buf, maxbuf);
d840 1
d883 1
a883 1
		WriteMaster((char *)buf, maxbuf);
d894 1
a894 1
	WriteMaster((char *)buf, maxbuf);
d896 3
d930 1
d955 1
a955 1
    WriteMaster(p, n);
d992 1
d1024 1
a1024 1
    WriteMaster(a, w);
@


1.1.2.10
log
@final instalment.  tried to work on cleanup issues, but more testing needed.  Fixed a big bug in ConsoleDebugger::OnFillConsoleOutputCharacter() where the master console handle was null.  I successfully logged into panix.com with Win2k's telnet.exe and trapped it all!
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.9 2002/03/13 03:52:57 davygrvy Exp $
d105 1
a105 1
    CHAR buf[2] = {0,0};
d256 1
a256 1
    if (GetConsoleScreenBufferInfo(hMasterConsole, &info) == FALSE) {
d258 1
a258 1
	wsprintfA(errbuf, "handle=0x%08x", hMasterConsole);
@


1.1.2.11
log
@these changes perfect the debugger code under Win98 and have been sitting in my workspace for quite some time now.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.10 2002/03/15 07:41:45 davygrvy Exp $
a83 19
 * ConsoleDebugger::OnAllocConsole --
 *
 * Results:
 *	None
 *
 * Notes:
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnAllocConsole(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
}

/*
 *-----------------------------------------------------------------------------
 *
d259 1
a259 1
	EXP_LOG2(MSG_DT_SCREENBUF, errbuf, GetSysMsg(GetLastError()));
a272 19
 * ConsoleDebugger::OnFreeConsole --
 *
 * Results:
 *	None
 *
 * Notes:
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnFreeConsole(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
}

/*
 *-----------------------------------------------------------------------------
 *
d377 24
d475 1
a475 1
 * ConsoleDebugger::OnSetConsoleActiveScreenBuffer --
d477 2
a478 2
 *	This function gets called when a SetConsoleActiveScreenBuffer
 *	breakpoint is hit.
d484 2
a485 2
 *	We reread the entire console and send it to the master.
 *	Updates the current console cursor position
d491 2
a492 3
ConsoleDebugger::OnSetConsoleActiveScreenBuffer(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
d494 4
d501 9
a509 2

//    RefreshScreen(&proc->overlapped);
d513 1
a513 1
 *-----------------------------------------------------------------------------
d515 4
a518 1
 * ConsoleDebugger::OnSetConsoleCP --
d523 3
a525 1
 * Notes:
d527 1
a527 1
 *-----------------------------------------------------------------------------
d531 3
a533 2
ConsoleDebugger::OnSetConsoleCP(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
a537 2
    ConsoleCP = (UINT) threadInfo->args[0];
}
d539 1
a539 25
/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleCursorInfo --
 *
 * Results:
 *	None
 *
 * Notes:
 *	Updates the current console's cursor info.
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleCursorInfo(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    PVOID ptr;

    if (*returnValue == FALSE) {
	return;
    }
    ptr = (PVOID) threadInfo->args[1];
    ReadSubprocessMemory(proc, ptr, &CursorInfo, sizeof(CONSOLE_CURSOR_INFO));
d543 1
a543 1
 *-----------------------------------------------------------------------------
d554 1
a554 1
 *	Updates the current console's cursor position
d556 1
a556 1
 *-----------------------------------------------------------------------------
d564 1
a564 1
    static CHAR buf[50];
d572 2
a573 1
    count = wsprintf(buf, "\033[%d;%dH", CursorPosition.Y+1, CursorPosition.X+1);
d578 1
a578 64
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleMode --
 *
 *	This function gets called when a SetConsoleMode breakpoint
 *	is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Sets some flags that are used in determining echoing
 *	characteristics of the slave driver.
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleMode(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    DWORD i;
    BOOL found;

    // The console mode seems to get set even if the return value is FALSE
    if (*returnValue == FALSE) {
	return;
    }
    for (found = FALSE, i = 0; i < proc->consoleHandlesMax; i++) {
	if (threadInfo->args[0] == proc->consoleHandles[i]) {
	    found = TRUE;
	    break;
	}
    }
    if (found) {
	MasterConsoleInputMode = threadInfo->args[1];
    }
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleOutputCP --
 *
 * Results:
 *	None
 *
 * Notes:
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleOutputCP(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    if (*returnValue == FALSE) {
	return;
    }
    ConsoleOutputCP = (UINT) threadInfo->args[0];
}

/*
 *-----------------------------------------------------------------------------
d591 1
a591 1
 *-----------------------------------------------------------------------------
d602 1
a602 1
 *-----------------------------------------------------------------------------
d616 1
a616 1
 *-----------------------------------------------------------------------------
d646 1
d656 1
a656 1
 *-----------------------------------------------------------------------------
d669 1
a669 1
 *-----------------------------------------------------------------------------
d702 1
d716 1
a716 1
 *-----------------------------------------------------------------------------
d730 1
a730 1
 *-----------------------------------------------------------------------------
d784 1
d793 1
d804 1
a804 1
 *-----------------------------------------------------------------------------
d818 1
a818 1
 *-----------------------------------------------------------------------------
d872 1
d881 1
d892 1
a892 1
 *-----------------------------------------------------------------------------
d906 1
a906 1
 *-----------------------------------------------------------------------------
d939 2
d950 1
a950 1
 *-----------------------------------------------------------------------------
d963 1
a963 1
 *-----------------------------------------------------------------------------
d1005 1
d1018 1
a1018 1
 *-----------------------------------------------------------------------------
d1033 1
a1033 1
 *-----------------------------------------------------------------------------
@


1.1.2.12
log
@Injector code hook-in, but doesn't yet work.  I don't know why.
The opcodes for loading the DLL are correct.  The opcodes are
written to the sub process memory and run.  I just don't know.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.11 2002/06/18 22:51:31 davygrvy Exp $
d78 1
a78 1
    WriteMasterCopy(buf, count);
d132 1
a132 1
	    WriteMasterCopy(buf, 1);
d286 1
a286 1
    WriteMasterCopy(buf, bufpos);
d480 1
a480 1
	WriteMasterCopy(buf, count);
d597 1
a597 1
    WriteMasterCopy(buf, count);
d732 1
a732 1
    WriteMasterCopy(p, n);
d791 1
a791 1
    WriteMasterCopy(a, w);
d868 1
a868 1
		WriteMasterCopy(buf, maxbuf);
d878 1
a878 1
	WriteMasterCopy(buf, maxbuf);
d954 1
a954 1
		WriteMasterCopy((char *)buf, maxbuf);
d964 1
a964 1
	WriteMasterCopy((char *)buf, maxbuf);
d1019 1
a1019 1
    WriteMasterCopy(p, n);
d1086 1
a1086 1
    WriteMasterCopy(a, w);
@


1.1.2.13
log
@More new good stuff.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.12 2002/06/21 03:01:51 davygrvy Exp $
d31 1
a31 1
#include "expWinSlave.hpp"
@


1.1.2.14
log
@Started on adding the interact logic to the breakpoints.  This is sticky...
I don't know what to expect (pun intended).
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.13 2002/06/22 14:02:03 davygrvy Exp $
a32 1
//////////////////////////////////////////////////////////
a33 1
//////////////////////////////////////////////////////////
a97 1
    __asm nop;
a126 1
	lastBeepDuration = threadInfo->args[1];
a132 3
	    if (interacting) {
		Beep(threadInfo->args[0], lastBeepDuration);
	    }
d140 1
a140 1
 * ConsoleDebugger::OnFillConsoleOutputCharacterA --
d143 1
a143 1
 *	breakpoint is hit.
d155 1
a155 1
ConsoleDebugger::OnFillConsoleOutputCharacterA(Process *proc,
d159 3
a161 46
    CHAR cCharacter;
    DWORD nLength;
    COORD dwWriteCoord;
    PVOID ptr;

    if (*returnValue == 0) {
	return;
    }

    cCharacter = (CHAR) threadInfo->args[1];
    nLength = threadInfo->args[2];
    dwWriteCoord = *((PCOORD) &(threadInfo->args[3]));
    ptr = (PVOID) threadInfo->args[4];
    if (ptr) {
	ReadSubprocessMemory(proc, ptr, &nLength, sizeof(DWORD));
    }

    OnFillCOC_Finish(cCharacter, nLength, dwWriteCoord);
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnFillConsoleOutputCharacterW --
 *
 *	This function gets called when an FillConsoleOutputCharacterW
 *	breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Prints some output.
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnFillConsoleOutputCharacterW(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    CHAR cCharacter;
    WCHAR cWCharacter;
    DWORD nLength;
    COORD dwWriteCoord;
d163 6
d174 3
a176 3
    cWCharacter = (WCHAR) threadInfo->args[1];
    nLength = threadInfo->args[2];
    dwWriteCoord = *((PCOORD) &(threadInfo->args[3]));
d179 1
a179 24
	ReadSubprocessMemory(proc, ptr, &nLength, sizeof(DWORD));
    }

    // For now, just truncated it.
    // TODO: fix me!
    //
    cCharacter = (cWCharacter & 0xff);

    OnFillCOC_Finish(cCharacter, nLength, dwWriteCoord);
}

void
ConsoleDebugger::OnFillCOC_Finish(CHAR cCharacter, DWORD nLength, COORD dwWriteCoord)
{
    CHAR buf[4096];
    int bufpos;
    DWORD i;
    DWORD lines, preCols, postCols;
    BOOL eol, bol;		// Needs clearing to end, beginning of line
    CONSOLE_SCREEN_BUFFER_INFO info;

    if (interacting) {
	DWORD dwWritten;
	FillConsoleOutputCharacter(interactingConsole, cCharacter, nLength, dwWriteCoord, &dwWritten);
d185 6
a190 6
    if (dwWriteCoord.X) {
	preCols = ConsoleSize.X - dwWriteCoord.X;
	if (nLength <= preCols) {
	    preCols = nLength;
	    nLength = 0;
	    if (nLength == preCols) {
d195 1
a195 1
	    nLength -= preCols;
d197 1
a197 1
    } else if (nLength < (DWORD) ConsoleSize.X) {
d199 2
a200 2
	preCols = nLength;
	nLength = 0;
d203 2
a204 2
    lines = nLength / ConsoleSize.X;
    postCols = nLength % ConsoleSize.X;
d209 1
a209 1
	    if (cCharacter == ' ') {
d211 1
a211 1
			  dwWriteCoord.Y+1, preCols+dwWriteCoord.X);
d215 1
a215 1
			  dwWriteCoord.Y+1, dwWriteCoord.X+1);
d217 1
a217 1
		memset(&buf[bufpos], cCharacter, preCols);
d222 1
a222 1
	    wsprintfA(&buf[bufpos], "\033[%d;%dH", dwWriteCoord.Y+1, dwWriteCoord.X+1);
d224 1
a224 1
	    if (eol && cCharacter == ' ') {
d228 1
a228 1
		memset(&buf[bufpos], cCharacter, preCols);
d232 2
a233 2
	dwWriteCoord.X = 0;
	dwWriteCoord.Y++;
d236 1
a236 1
	if ((cCharacter == ' ') && ((lines + dwWriteCoord.Y) >= (DWORD) ConsoleSize.Y)) {
d239 1
a239 1
		      dwWriteCoord.Y+1, dwWriteCoord.X+1);
d241 1
a241 1
	} else if ((cCharacter == ' ') && (dwWriteCoord.Y == 0) && (lines > 0)) {
d248 1
a248 1
			  dwWriteCoord.Y+i+1, dwWriteCoord.X+1);
d250 1
a250 1
		if (cCharacter == ' ') {
d254 1
a254 1
		    memset(&buf[bufpos], cCharacter, ConsoleSize.X);
d259 1
a259 1
	dwWriteCoord.Y += (SHORT) lines;
d263 1
a263 1
	if (cCharacter == ' ') {
d266 1
a266 1
		      dwWriteCoord.Y+1, postCols+dwWriteCoord.X);
d269 1
a269 1
	    wsprintfA(&buf[bufpos], "\033[%d;%dH", dwWriteCoord.X+1, dwWriteCoord.Y+1);
d271 1
a271 1
	    memset(&buf[bufpos], cCharacter, postCols);
a305 1
    __asm nop;
a512 1
    __asm nop;
a536 4

    if (interacting) {
	SetConsoleCP(ConsoleCP);
    }
a563 4

    if (interacting) {
	SetConsoleCursorInfo(interactingConsole, &CursorInfo);
    }
a597 4

    if (interacting) {
	SetConsoleCursorPosition(interactingConsole, CursorPosition);
    }
d636 1
a636 5
	ConsoleInputMode = threadInfo->args[1];
    }

    if (interacting) {
	SetConsoleMode(interactingConsole, ConsoleInputMode);
a660 35

    if (interacting) {
	SetConsoleOutputCP(ConsoleOutputCP);
    }
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnSetConsoleTextAttribute --
 *
 * Results:
 *	None
 *
 * Notes:
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnSetConsoleTextAttribute(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    WORD wAttributes;

    wAttributes = (WORD) threadInfo->args[1];

    // TODO: fix me!
    //
    __asm nop;

    if (interacting) {
	SetConsoleTextAttribute(interactingConsole, wAttributes);
    }

a684 19
    HANDLE hConsoleOutput;
    BOOL bAbsolute;
    SMALL_RECT ConsoleWindowRect;
    PVOID ptr;

    if (*returnValue == FALSE) {
	return;
    }

    hConsoleOutput = (HANDLE) threadInfo->args[0];
    bAbsolute = threadInfo->args[1];
    ptr = (PVOID) threadInfo->args[2];
    if (ptr) {
	ReadSubprocessMemory(proc, ptr, &ConsoleWindowRect, sizeof(SMALL_RECT));
    }

    // TODO: fix me!  What do we do here?
    //
    __asm nop;
a733 5
    if (interacting) {
	DWORD x;
	WriteConsole(interactingConsole, p, n, &x, 0L);
    }

d788 1
a788 1
    // Convert to ASCII and write-out the intercepted data.
a792 5
    if (interacting) {
	DWORD x;
	WriteConsole(interactingConsole, a, w, &x, 0L);
    }

d842 1
a842 1
    ReadSubprocessMemory(proc, ptr, &writeRegion, sizeof(SMALL_RECT));
a881 4
    if (interacting) {
	WriteConsoleOutput(interactingConsole, charBuf, bufferSize, bufferCoord, &writeRegion);
    }

a967 4
    if (interacting) {
	WriteConsoleOutput(interactingConsole, charBuf, bufferSize, bufferCoord, &writeRegion);
    }

d995 2
a996 3
    DWORD nLength;
    PCHAR lpCharacter;
    COORD dwWriteCoord;
d1004 1
a1004 1
	nLength = threadInfo->args[2];
d1006 1
a1006 1
	ReadSubprocessMemory(proc, ptr, &nLength, sizeof(DWORD));
d1009 1
a1009 2
    dwWriteCoord = *((PCOORD) &threadInfo->args[3]);
    CreateVtSequence(proc, dwWriteCoord, nLength);
d1011 2
a1012 2
    if (nLength > 1024) {
	lpCharacter = new CHAR [nLength];
d1014 1
a1014 1
	lpCharacter = buf;
d1018 2
a1019 2
    ReadSubprocessMemory(proc, ptr, lpCharacter, nLength * sizeof(CHAR));
    WriteMasterCopy(lpCharacter, nLength);
d1021 2
a1022 7
    if (interacting) {
	DWORD dwWritten;
	WriteConsoleOutputCharacter(interactingConsole, lpCharacter, nLength, dwWriteCoord, &dwWritten);
    }

    if (lpCharacter != buf) {
	delete [] lpCharacter;
d1052 1
a1052 1
    DWORD nLength;
d1054 1
a1054 2
    PCHAR lpCharacter;
    COORD dwWriteCoord;
d1056 1
d1064 1
a1064 1
	nLength = threadInfo->args[2];
d1066 1
a1066 1
	ReadSubprocessMemory(proc, ptr, &nLength, sizeof(DWORD));
d1069 1
a1069 2
    dwWriteCoord = *((PCOORD) &threadInfo->args[3]);
    CreateVtSequence(proc, dwWriteCoord, nLength);
d1071 4
a1074 4
    if (nLength > 1024) {
	p = new WCHAR [nLength];
	asize = nLength * 2 * sizeof(CHAR);
	lpCharacter = new CHAR [nLength * 2];
d1077 1
a1077 1
	lpCharacter = ansi;
d1082 1
a1082 1
    ReadSubprocessMemory(proc, ptr, p, nLength * sizeof(WCHAR));
d1085 2
a1086 7
    nLength = WideCharToMultiByte(CP_ACP, 0, p, nLength, lpCharacter, asize, 0L, 0L);
    WriteMasterCopy(lpCharacter, nLength);

    if (interacting) {
	DWORD dwWritten;
	WriteConsoleOutputCharacter(interactingConsole, lpCharacter, nLength, dwWriteCoord, &dwWritten);
    }
d1089 1
a1089 1
	delete [] p, lpCharacter;
a1117 26
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnWriteFile --
 *
 *	This function gets called when a WriteFile
 *	breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	none yet..
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnWriteFile(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    // TODO: is this a console handle in the slave?
    __asm nop;
@


1.1.2.15
log
@Added some guts to OnWriteFile(), but I don't know where this is leading me to.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.14 2002/06/29 00:44:36 davygrvy Exp $
a1311 8
    HANDLE hFile;		    // handle to file
    PCHAR lpBuffer;		    // data buffer
    DWORD nNumberOfBytesToWrite;    // number of bytes to write
//    LPOVERLAPPED lpOverlapped;	    // overlapped buffer
    PVOID ptr;

    hFile = (HANDLE) threadInfo->args[0];

d1313 1
a1313 15
    return;

    // Get number of bytes written, if available.
    ptr = (PVOID) threadInfo->args[4];
    if (ptr == 0L) {
	nNumberOfBytesToWrite = threadInfo->args[2];
    } else {
	ReadSubprocessMemory(proc, ptr, &nNumberOfBytesToWrite, sizeof(DWORD));
    }

    ptr = (PVOID) threadInfo->args[1];
    lpBuffer = new CHAR [nNumberOfBytesToWrite];
    ReadSubprocessMemory(proc, ptr, lpBuffer, nNumberOfBytesToWrite);

    delete lpBuffer;
@


1.1.2.16
log
@these uncommitted edits have been sitting on my desktop for an eternity.

Adds some MS-DOS support but fails to deliver the required hooks to
succeed.
@
text
@d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.15 2002/06/29 02:11:06 davygrvy Exp $
d31 1
a31 1
#include "expWinConsoleDebugger.hpp"
d33 3
a35 3
/////////////////////////////////////////////////////////////
// NOTE:  black magic abounds...  be warry young padwon... //
/////////////////////////////////////////////////////////////
a99 3
    if (*returnValue == FALSE) {
	return;
    }
a146 52
 * ConsoleDebugger::OnCreateConsoleScreenBuffer --
 *
 *	This function gets called when a CreateConsoleScreenBuffer
 *	breakpoint is hit.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	unknown.
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnCreateConsoleScreenBuffer(Process *proc,
    ThreadInfo *threadInfo, Breakpoint *brkpt, PDWORD returnValue,
    DWORD direction)
{
    if (*returnValue == FALSE) {
	return;
    }
    // TODO: what to do here?
    __asm nop;
}

/*
 *-----------------------------------------------------------------------------
 *
 * ConsoleDebugger::OnFillConsoleOutputAttribute --
 *
 * Results:
 *	None
 *
 * Notes:
 *
 *-----------------------------------------------------------------------------
 */

void
ConsoleDebugger::OnFillConsoleOutputAttribute(Process *proc, ThreadInfo *threadInfo,
    Breakpoint *brkpt, PDWORD returnValue, DWORD direction)
{
    if (*returnValue == FALSE) {
	return;
    }
    __asm nop;
}

/*
 *-----------------------------------------------------------------------------
 *
a372 3
    if (*returnValue == FALSE) {
	return;
    }
@


1.1.2.17
log
@titleblock comment changes and removal of the Detours library usage.
@
text
@a19 1
 * Copyright (c) 2003 ActiveState Corporation
d27 1
a27 1
 * RCS: @@(#) $Id: expWinConsoleDebuggerBreakPoints.cpp,v 1.1.2.16 2003/08/25 23:17:49 davygrvy Exp $
@


