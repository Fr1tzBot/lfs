head	1.1;
access;
symbols
	telco-tec-win32-take2-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2001.12.18.04.26.02;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.12.18.04.26.02;	author davygrvy;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.12.19.01.00.34;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.12.21.12.17.22;	author davygrvy;	state dead;
branches;
next	;


desc
@@


1.1
log
@file ExpWinVCDbgLaunch.cpp was initially added on branch telco-tec-win32-take2-branch.
@
text
@@


1.1.2.1
log
@First shot at trying to automate VC++ so I can run slavedrv.exe and get
around the "can't debug child processes" issue.
@
text
@a0 99
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <initguid.h>
#include <comdef.h>

#include <ObjModel\appauto.h>
#include <ObjModel\appdefs.h>
#include <ObjModel\appguid.h>
#include <ObjModel\dbgauto.h>
#include <ObjModel\dbgguid.h>
#include <ObjModel\dbgdefs.h>

static IApplication *pApp = NULL;

//Uninitialize COM and VC++
void
UnInitializeCOMandVC()
{
    // Quit from Visual C++
    pApp->Quit();
    pApp = NULL;
    // Uninitialize COM libraries
    CoUninitialize();
}


void nameMangled (void)
{
    VARIANT_BOOL visibility=VARIANT_TRUE;
    HRESULT hr;

    if (pApp == NULL) {
	// Initialize COM libraries
	hr = CoInitialize(NULL);
	if(FAILED(hr)) {
	    OutputDebugString("Failed to initialize the COM libraries\n");
	    return;
	}
    
	// Obtain the IApplication pointer
	hr = CoCreateInstance(CLSID_Application, NULL, CLSCTX_LOCAL_SERVER,
		IID_IApplication, (void**)&pApp);
	if(FAILED(hr)) {
	    OutputDebugString("Failed to create an instance of MSDEV\n");
	    CoUninitialize();
	    return;
	}

	// Set the visibility of MSDEV to TRUE
	hr = pApp->put_Visible(visibility);
	if(FAILED(hr)) {
	    OutputDebugString("Failed to set visibility of MSDEV\n");
	    //Uninitialize COM libraries and quit from Visual C++
	    UnInitializeCOMandVC();
	    return;
	}

	// Set the current directory
	CComBSTR dir("D:\\expect_wslive\\expect_win32_take2\\win");
	hr = pApp->put_CurrentDirectory(dir);
	if(FAILED(hr)) {
	    OutputDebugString("Failed to set current directory\n");
	    //Uninitialize COM libraries and quit from Visual C++
	    UnInitializeCOMandVC();
	    return;
	}

	CComPtr<IDispatch> iDisp=NULL;
    
	// Obtain the IDocuments pointer using smart pointer classes
	pApp->get_Documents(&iDisp);
	CComQIPtr<IDocuments, &IID_IDocuments> pDocs(iDisp);
    
	// Open the slavedrv workspace
	CComBSTR fname("slavedrv.dsp");
	CComVariant type="Auto";
	CComVariant read="False";
	iDisp=NULL;
	hr = pDocs->Open(fname,type,read,&iDisp);
	if(FAILED(hr)) {
	    OutputDebugString("Failed to open the workspace slavedrv.dsp\n");
	    // Uninitialize COM libraries and quit from Visual C++
	    UnInitializeCOMandVC();
	    return;
	}
    }

}

extern "C" void
ExpWinDbgLaunch(void)
{
    __try {
	nameMangled();
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}
@


1.1.2.2
log
@Moved expWinProc initting to a new file.  Also realized COM control over the
slavedrv debugger is much more work than antisipated to get right.
@
text
@a13 1
/* local global */
d28 1
a28 1
void nameMangledAndTooCPlusPlusishToBeExternC (void)
d30 1
a30 1
    VARIANT_BOOL visibility = VARIANT_TRUE;
a31 1
    CComPtr<IDispatch> iDisp = NULL;
d69 2
a88 14
    // Obtain the IDebugger pointer using smart pointer classes
    pApp->get_Debugger(&iDisp);
    CComQIPtr<IDebugger, &IID_IDebugger> pDebug(iDisp);
    DsExecutionState state;

    pDebug->get_State(&state);
    if (state != dsNoDebugee) pDebug->Stop();
    hr = pDebug->Go();
    if(FAILED(hr)) {
	OutputDebugString("Failed to start the debugger\n");
	// Uninitialize COM libraries and quit from Visual C++
	UnInitializeCOMandVC();
	return;
    }
d95 1
a95 1
	nameMangledAndTooCPlusPlusishToBeExternC();
@


1.1.2.3
log
@Second shot (and final) of automating VC++ for the debugger friendly
replacement to CreateProcess().  What a nightmare...
@
text
@@


