head	5.30;
access;
symbols
	expect_5_45:5.30
	expect_6_branch:5.29.0.8
	expect_5_44_1_15:5.29
	activestate_win32_port_start:5.29
	win32-jump-point-1:5.29
	telco-tec-win32-take2-branch:5.29.0.6
	telco-tec-win32-branch:5.29.0.4
	expect-sf418892-sf439042-branch:5.29.0.2
	tclpro-1-5-0:5.29
	tclpro-1-4-1:5.29
	tclpro-1-4-0:5.29
	expect-5-32-2:5.29
	expect-5-32-0:5.29
	ajuba-ajuba2-2-0:5.28.1.1.2.1
	scriptics-sc-2-0-b5:5.28.1.1.2.1
	scriptics-sc-2-0-fixed:5.28.1.1.2.1
	scriptics-sc-2-0-b2:5.28.1.1.2.1
	scriptics-sc-2-0-b1:5.28.1.1.2.1
	scriptics-sc-1-1:5.28.1.1.2.1
	scriptics-sc-1-1-b1:5.28.1.1.2.1
	scriptics-sc-1-1-branch:5.28.1.1.2.1.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.1
	scriptics-sc-1-0:5.28.1.1.2.1
	scriptics-sc-1-0-branch:5.28.1.1.2.1.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.1
	expect-5-31-3:5.28.1.1.2.1
	scriptics-bc-1-0-b1:5.28.1.1.2.1
	scriptics-tclpro-1-3-0:5.28.1.1.2.1
	scriptics-tclpro-1-3-b4:5.28.1.1.2.1
	scriptics-tclpro-1-3-b3:5.28.1.1.2.1
	expect-5-31:5.28.1.1.2.1
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@# @;


5.30
date	2010.09.30.22.05.34;	author andreas_kupries;	state Exp;
branches;
next	5.29;

5.29
date	2000.01.06.23.22.07;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.23;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.29.02.27.49;	author libes;	state Exp;
branches;
next	;


desc
@@


5.30
log
@
	* example/autopasswd: Updated to use tclsh in PATH, and 'package
	* example/chess.exp: require Expect'. Obsoletes fixline1.
	* example/cryptdir:
	* example/decryptdir:
	* example/dislocate:
	* example/dvorak:
	* example/ftp-inband:
	* example/ftp-rfc:
	* example/gethostbyaddr:
	* example/kibitz:
	* example/lpunlock:
	* example/mkpasswd:
	* example/multixterm:
	* example/passmass:
	* example/read1char:
	* example/rftp:
	* example/rlogin-cwd:
	* example/robohunt:
	* example/rogue.exp:
	* example/telnet-cwd:
	* example/timed-read:
	* example/timed-run:
	* example/unbuffer:
	* example/virterm:
	* example/weather:
	* example/xkibitz:
	* example/xpstat:
@
text
@#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@@"}

package require Expect


# This script unhangs a printer which claims it is "waiting for lock".
# Written by Don Libes.  Based on English instructions from Scott Paisley.

# lpunlock figures out if the printer is on a server, and if so which,
# by looking in the local printcap file.  (You can override this by
# supplying a server name as an additional argument.)  It then rlogins
# to the server, recreates the device and resets the queue via lpc.

# assumes user has root privs on remote host via /.rhosts

# assumes printer is name of device on remote system

proc usage {} {
	send_user "usage: lpunlock <printer> \[<server>\]\n"
	send_user "example: lpunlock lw-isg durer\n"
	exit
}

if {$argc==0} usage
set printer [lindex $argv 0]

set client [exec hostname]

if {$argc == 1} {
	# if no arg2, look in local printcap for info
	spawn ed /etc/printcap
	expect "\n"			;# discard character count
	send "/$printer/\r"
	for {} {1} {} {
		expect -re ".*:rm=(\[^:]*):.*\r\n" {
			set server $expect_out(1,string)
			break
		} "\r\n*\\\r\n" {	;# look at next line of entry
			send "\r"
		} "\r\n*\n" {		;# no more lines of entry - give up
			set server $client
			break
		}
	}
} else {
	if {$argc == 2} {
		set server [lindex $argv 1]
	} else usage
}

set whoami [exec whoami]
if {[string match $server $client] && [string match $whoami "root"]} {
	spawn csh
	expect "# "
} else {
	# login to the print server as root.
	# Set timeout high because login is slow.
	set timeout 60
	spawn rlogin $server -l root
	expect	timeout	exit \
		eof exit \
		"Password*" {
			send_user "\ncouldn't login to $server as root\n"
			exit
		} "1#*"
	set timeout 10
}

# run lpc and 'stop printer'
send lpc\r				; expect "lpc>*"
send stop $printer\r			; expect "unknown*" exit \
						"disabled*lpc>*"

# exit lpc and cd /dev
send quit\r				; expect "#*"
send cd /dev\r				; expect "#*"

# figure out major/minor device numbers
send ls -l /dev/$printer\r		; expect timeout {
	send_user "\nbad device - couldn't get major/minor numbers\n"; exit
						} "crw*#*"
scan $expect_out(buffer) "ls -l %*s %*s 1 root %d, %d" major minor

# delete the lock and the printer device itself
send rm /var/spool/$printer/lock /dev/$printer\r	; expect #*

# recreate the printer device
send mknod $printer c $major $minor\r	; expect #*

# run lpc and 'start printer'
send lpc\r				; expect lpc>*
send start $printer\r			; expect started*lpc>*
send quit\r				; expect #*

# logout
send exit\r				; expect eof

send_user Printer unlocked and restarted.\n
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d1 7
a7 1
#!../expect -f
@


5.28
log
@Initial revision
@
text
@d21 1
a21 1
if $argc==0 usage
d31 1
a31 1
	for {} 1 {} {
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d21 1
a21 1
if {$argc==0} usage
d31 1
a31 1
	for {} {1} {} {
@

