head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.1.2.5
	telco-tec-win32-take2-branch:1.1.2.1.0.2
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2001.09.13.01.08.46;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.13.01.08.46;	author davygrvy;	state Exp;
branches
	1.1.2.1.2.1;
next	1.1.2.2;

1.1.2.2
date	2001.10.28.07.34.15;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.28.08.58.21;	author davygrvy;	state Exp;
branches;
next	;

1.1.2.1.2.1
date	2001.11.22.08.50.38;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.2;

1.1.2.1.2.2
date	2002.02.10.02.58.52;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.3;

1.1.2.1.2.3
date	2002.02.10.10.17.04;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.4;

1.1.2.1.2.4
date	2002.02.10.12.04.22;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.5;

1.1.2.1.2.5
date	2002.02.13.02.39.41;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expCommand.c was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.2.1
log
@snap29 "import"
@
text
@a0 2828
/*
 * expCommand.c --
 *
 *	The bulk of the Expect commands, platform generic
 *
 * Unix version written by: Don Libes, NIST, 2/6/90
 *
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 *
 *
 * Windows NT port by Gordon Chaffee
 * Copyright (c) 1997 by Mitel Corporation
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include <math.h>
#include "exp_port.h"
#include "tclInt.h"
#include "tclPort.h"
#include "expect_tcl.h"
#include "exp_command.h"
#include "exp_rename.h"
#include "exp_log.h"
#include "exp_event.h"
#include "exp_prog.h"
#include "exp_tty.h"

/* Tcl needs commands in writable space (or at least used to) */
static char close_cmd[] = "close";

/*
 * exp_configure_count is incremented whenever a spawned process is closed
 * or an indirect list is modified.  This forces any (stack of) expect or
 * interact commands to reexamine the state of the world and adjust
 * accordingly.
 */
int exp_configure_count = 0;

/* this message is required because fopen sometimes fails to set errno */
/* Apparently, it "does the user a favor" and doesn't even call open */
/* if the file name is bizarre enough.  This means we can't handle fopen */
/* with the obvious trivial logic. */
static char *open_failed = "could not open - odd file name?";

/*
 * expect_key is just a source for generating a unique stamp.  As each
 * expect/interact command begins, it generates a new key and marks all
 * the spawn ids of interest with it.  Then, if someone comes along and
 * marks them with yet a newer key, the old command will recognize this
 * reexamine the state of the spawned process.
 */
int expect_key = 0;

/*
 * The table is used to map channels to exp_f structures.
 */
Tcl_HashTable *exp_f_table = NULL;

/*
 * The 'exp_any' spawn identifier
 */
struct exp_f *exp_f_any = NULL;

static void		tcl_tracer _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int level, char *command,
			    Tcl_CmdProc *cmdProc, ClientData cmdClientData,
			    int argc, char *argv[]));
static void		exp_i_add_f _ANSI_ARGS_((struct exp_i *,
			    struct exp_f *fs));
static void		exp_f_closed _ANSI_ARGS_((struct exp_f *));


/*
 *----------------------------------------------------------------------
 *
 * exp_error --
 *
 *	Formats an error message into the interp.  Do not terminate
 *	format strings with \n!!!.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	An error message is written into interp->result
 *
 *----------------------------------------------------------------------
 */

void
exp_error TCL_VARARGS_DEF(Tcl_Interp *,arg1)
{
    Tcl_Interp *interp;
    char *fmt;
    va_list args;

    interp = TCL_VARARGS_START(Tcl_Interp *,arg1,args);
    fmt = va_arg(args,char *);
    vsprintf(interp->result,fmt,args);
    va_end(args);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_wait_zero --
 *
 *	Zero out the wait status field
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */
static void
exp_wait_zero(status)
    WAIT_STATUS_TYPE *status;
{
    int i;

    for (i=0;i<sizeof(WAIT_STATUS_TYPE);i++) {
	((char *)status)[i] = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * exp_fcheck --
 *
 *	Check and possibly adjust the status of the exp_f.
 *
 * Results:
 *	0 if not valid, 1 if good.
 *
 * Side Effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

int
exp_fcheck(interp,f,opened,adjust,msg)
    Tcl_Interp *interp;
    struct exp_f *f;
    int opened;		/* check not closed */
    int adjust;		/* adjust buffer sizes */
    char *msg;
{
    if ((!opened) || (!f->user_closed)) {
	if (adjust) {
	    exp_adjust(f);
	}
	return 1;
    }

    exp_error(interp,"%s: invalid spawn id (%s)", msg, f->spawnId);
    return(0);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_chan2f --
 *
 *	For a given channel name, returns the exp_f structure
 *	for that channel.
 *
 * Results:
 *	An exp_f structure if found and usable, NULL if not.
 *
 * Side Effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

struct exp_f *
exp_chan2f(interp,chan,opened,adjust,msg)
    Tcl_Interp *interp;
    char *chan;			/* Channel name */
    int opened;			/* check not closed */
    int adjust;			/* adjust buffer sizes */
    char *msg;
{
    Tcl_HashEntry *hPtr;
    struct exp_f *f;

    hPtr = Tcl_FindHashEntry(exp_f_table, chan);
    if (hPtr != NULL) {
	f = (struct exp_f *) Tcl_GetHashValue(hPtr);
	if ((!opened) || !f->user_closed) {
	    if (adjust) {
		exp_adjust(f);
	    }
	    return f;
	}
    }
    exp_error(interp,"%s: invalid spawn id (%s)",msg,chan);
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_close --
 *
 *	Close a connection.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	A native file handle is closed
 *
 *----------------------------------------------------------------------
 */

int
exp_close(interp, f)
    Tcl_Interp *interp;
    struct exp_f *f;
{
    /*
     * Check if this is an id that should never be deleted
     */
    if (f->alwaysopen) {
	exp_error(interp, "cannot close permanent id %s", f->spawnId);
	return TCL_ERROR;
    }

    f->user_closed = TRUE;

    if (! f->leaveopen) {
	/*
	 * Tcl_UnregisterChannel() will call Tcl_Close() if needed
	 */
	if (f->channel) {
	    return Tcl_UnregisterChannel(interp, f->channel);
	}
	return TCL_OK;
    } else {
	if (--f->leaveopen >= 0) {
	    return TCL_OK;
	}
	if (f->channel) {
	    Tcl_DeleteCloseHandler(f->channel, (Tcl_CloseProc *) exp_f_closed,
				   (ClientData) f);
	}
	exp_f_closed(f);
    }

    return(TCL_OK);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_f_find --
 *
 *	Try to find an existing exp_f structure in the spawn id table.
 *
 * Results:
 *	The structure if found, NULL if not.
 *
 *----------------------------------------------------------------------
 */

struct exp_f *
exp_f_find(interp,spawnId)
    Tcl_Interp *interp;
    char *spawnId;
{
    Tcl_HashEntry *hPtr;

    hPtr = Tcl_FindHashEntry(exp_f_table, spawnId);
    if (! hPtr) {
	return NULL;
    }
    return (struct exp_f *) Tcl_GetHashValue(hPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_f_new --
 *
 *	Create a new exp_f structure for a given channel and enter
 *	it into the spawn id hash table.  If spawnId is given, it
 *	is entered under that name.  If not, it is entered under
 *	the channel identifier.  This means that either a channel
 *	and/or a spawnId must be passed in.
 *
 * Results:
 *	The new structure if successful, NULL if not.
 *
 *----------------------------------------------------------------------
 */

struct exp_f *
exp_f_new(interp,chan,spawnId,pid)
    Tcl_Interp *interp;
    Tcl_Channel chan;
    char *spawnId;
    int pid;
{
    struct exp_f *f;
    Tcl_HashEntry *hPtr;
    int new;

    if (!chan && !spawnId) {
	return NULL;
    }

    spawnId = spawnId ? spawnId : Tcl_GetChannelName(chan);
    hPtr = Tcl_CreateHashEntry(exp_f_table, spawnId, &new);
    if (!new) {
	panic("Exp_SpawnCmd: old entry found in table");
	f = (struct exp_f *) Tcl_GetHashValue(hPtr);
	return f;
    }

    f = (struct exp_f *) ckalloc(sizeof(struct exp_f));
    f->interp = interp;
    f->pid = pid;
    f->size = 0;
    f->msize = 0;
    f->buffer = 0;
    f->printed = 0;
    f->echoed = 0;
    f->rm_nulls = exp_default_rm_nulls;
    f->parity = exp_default_parity;
    f->key = expect_key++;
    f->force_read = FALSE;
    f->fg_armed = FALSE;
    f->umsize = exp_default_match_max;
    f->valid = TRUE;
    f->user_closed = FALSE;
    f->user_waited = (EXP_NOPID == pid) ? TRUE : FALSE;
    f->sys_waited = (EXP_NOPID == pid) ? TRUE : FALSE;
    if (f->sys_waited) {
	exp_wait_zero(&f->wait);
    }
    f->bg_interp = 0;
    f->bg_status = unarmed;
    f->bg_ecount = 0;
    f->channel = chan;
    f->leaveopen = 0;
    f->alwaysopen = 0;
    f->matched = 0;		/* Used only by expectlib */
    f->Master = NULL;
    f->event_proc = NULL;
    f->event_data = 0;
    exp_f_new_platform(f);

    Tcl_SetHashValue(hPtr, f);
    f->hashPtr = hPtr;
    f->spawnId = ckalloc(strlen(spawnId) + 1);
    strcpy(f->spawnId, spawnId);

    if (chan) {
	Tcl_CreateCloseHandler(chan, (Tcl_CloseProc *) exp_f_closed,
			       (ClientData) f);
    }

    return f;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_f_free --
 *
 *	Frees an exp_f structure.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
exp_f_free(f)
    struct exp_f *f;
{
    if (f->buffer) {
	ckfree(f->buffer);
	f->buffer = 0;
	f->msize = 0;
	f->size = 0;
	f->printed = 0;
	f->echoed = 0;
	if (f->fg_armed) {
	    exp_event_disarm(f);
	    f->fg_armed = FALSE;
	}
	ckfree(f->lower);
    }
    ckfree(f->spawnId);
    f->fg_armed = FALSE;
    Tcl_DeleteHashEntry(f->hashPtr);

    exp_f_free_platform(f);
    ckfree((char *) f);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_f_closed --
 *
 *	A channel was closed, so we need to make it unavailable
 *	for anything except the wait command.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

static void
exp_f_closed(f)
    struct exp_f *f;
{
    exp_ecmd_remove_f_direct_and_indirect(f->interp,f);

    exp_configure_count++;

    f->fg_armed = FALSE;
    f->valid = FALSE;

    if (f->user_waited) {
	exp_f_free(f);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_ExpPidCmd --
 *
 *	Implements the "exp_pid" command
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	None
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_ExpPidCmd(clientData,interp,argc,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    struct exp_f *f;
    char *chanId = NULL;
    char *argv0 = argv[0];
    
    argc--; argv++;
    
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) goto usage;
	    chanId = *argv;
	} else goto usage;
    }
    
    if (chanId == NULL) {
	f = exp_update_master(interp,0,0);
    } else {
	f = exp_chan2f(interp, chanId, 1, 0, argv0);
    }
    if (f == NULL) {
	return(TCL_ERROR);
    }

    sprintf(interp->result,"%d",f->pid);
    return TCL_OK;
 usage:
    exp_error(interp,"usage: -i spawn_id");
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_GetpidDeprecatedCmd --
 *
 *	Implements the old 'getpid' command.  This command is has
 *	been deprecated and may not be supported in the future
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	None
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_GetpidDeprecatedCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    debuglog("getpid is deprecated, use pid\r\n");
    sprintf(interp->result,"%d",exp_getpidproc());
    return(TCL_OK);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_update_master --
 *
 *	Get the current master (via out-parameter)
 *
 * Results:
 *	An exp_f structure or NULL if not found
 *	
 * Note: Since exp_chan2f calls tcl_error, this may be
 *	immediately followed by a "return(TCL_ERROR)"!!!
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

struct exp_f *
exp_update_master(interp,opened,adjust)
    Tcl_Interp *interp;
    int opened;
    int adjust;
{
    char *s = exp_get_var(interp,EXP_SPAWN_ID_VARNAME);
    if (s == NULL) {
	s = EXP_SPAWN_ID_USER;
    }
    return exp_chan2f(interp,s,opened,adjust,s);
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_SleepCmd --
 *
 *	Implements the 'sleep' (alias 'exp_sleep') command.
 *	Can sleep for fractional seconds.
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	May not return immediately, and it may service other
 *	events during the sleep period
 *	
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_SleepCmd(clientData,interp,argc,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    argc--; argv++;

    if (argc != 1) {
	exp_error(interp,"must have one arg: seconds");
	return TCL_ERROR;
    }

    return(exp_dsleep(interp,(double)atof(*argv)));
}

struct slow_arg {
    int size;
    double time;
};

/*
 *----------------------------------------------------------------------
 *
 * get_slow_args --
 *
 *	Get the arguments the the 'send -s' command
 *
 * Results:
 *	0 on success, -1 on failure
 *	
 * Side Effects:
 *	The slow_arg structure is filled in
 *
 *----------------------------------------------------------------------
 */

/* returns 0 for success, -1 for failure */
static int
get_slow_args(interp,x)
    Tcl_Interp *interp;
    struct slow_arg *x;
{
    int sc;			/* return from scanf */
    char *s = exp_get_var(interp,"send_slow");
    if (!s) {
	exp_error(interp,"send -s: send_slow has no value");
	return(-1);
    }
    if (2 != (sc = sscanf(s,"%d %lf",&x->size,&x->time))) {
	exp_error(interp,"send -s: found %d value(s) in send_slow but need 2",sc);
	return(-1);
    }
    if (x->size <= 0) {
	exp_error(interp,"send -s: size (%d) in send_slow must be positive", x->size);
	return(-1);
    }
    if (x->time <= 0) {
	exp_error(interp,"send -s: time (%f) in send_slow must be larger",x->time);
	return(-1);
    }
    return(0);
}

/*
 *----------------------------------------------------------------------
 *
 * slow_write --
 *
 *	Write some bytes   s  l  o  w  l  y
 *
 * Results:
 *	0 on success, -1 on failure, positive for standard Tcl result
 *	
 * Side Effects:
 *	Data is written to an output object
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

static int
slow_write(interp,f,buffer,rembytes,arg)
    Tcl_Interp *interp;
    struct exp_f *f;
    char *buffer;
    int rembytes;
    struct slow_arg *arg;
{
    int rc;

    while (rembytes > 0) {
	int len;

	len = (arg->size<rembytes?arg->size:rembytes);
	if (0 > exp_exact_write(f,buffer,len)) return(-1);
	rembytes -= arg->size;
	buffer += arg->size;

	/* skip sleep after last write */
	if (rembytes > 0) {
	    rc = exp_dsleep(interp,arg->time);
	    if (rc>0) return rc;
	}
    }
    return(0);
}

struct human_arg {
    float alpha;		/* average interarrival time in seconds */
    float alpha_eow;		/* as above but for eow transitions */
    float c;			/* shape */
    float min, max;
};


/*
 *----------------------------------------------------------------------
 *
 * get_human_args --
 *
 *	Get the arguments the the 'send -h' command
 *
 * Results:
 *	0 on success, -1 on failure
 *	
 * Side Effects:
 *	The human_arg structure is filled in
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

static int
get_human_args(interp,x)
    Tcl_Interp *interp;
    struct human_arg *x;
{
    int sc;			/* return from scanf */
    char *s = exp_get_var(interp,"send_human");

    if (!s) {
	exp_error(interp,"send -h: send_human has no value");
	return(-1);
    }
    if (5 != (sc = sscanf(s,"%f %f %f %f %f",
			  &x->alpha,&x->alpha_eow,&x->c,&x->min,&x->max))) {
	if (sc == EOF) sc = 0;	/* make up for overloaded return */
	exp_error(interp,"send -h: found %d value(s) in send_human but need 5",sc);
	return(-1);
    }
    if (x->alpha < 0 || x->alpha_eow < 0) {
	exp_error(interp,"send -h: average interarrival times (%f %f) must be non-negative in send_human", x->alpha,x->alpha_eow);
	return(-1);
    }
    if (x->c <= 0) {
	exp_error(interp,"send -h: variability (%f) in send_human must be positive",x->c);
	return(-1);
    }
    x->c = 1/x->c;

    if (x->min < 0) {
	exp_error(interp,"send -h: minimum (%f) in send_human must be non-negative",x->min);
	return(-1);
    }
    if (x->max < 0) {
	exp_error(interp,"send -h: maximum (%f) in send_human must be non-negative",x->max);
	return(-1);
    }
    if (x->max < x->min) {
	exp_error(interp,"send -h: maximum (%f) must be >= minimum (%f) in send_human",x->max,x->min);
	return(-1);
    }
    return(0);
}

/*
 *----------------------------------------------------------------------
 *
 * unit_random --
 *
 *	Compute random numbers from 0 to 1, for expect's send -h
 *	This implementation sacrifices beauty for portability.
 *	Current implementation is pathetic but works
 *
 * Results:
 *	A floating point number between 0 and 1
 *
 * Side Effects:
 *	None
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

static float
unit_random()
{
    /* 99991 is largest prime in my CRC - can't hurt, eh? */
    return((float)(1+(rand()%99991))/(float) 99991.0);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_init_unit_random --
 *
 *	Initialize the random number generator
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	None
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

void
exp_init_unit_random()
{
    srand(exp_getpidproc());
}

/*
 *----------------------------------------------------------------------
 *
 * exp_init_unit_random --
 *
 *	This function is my implementation of the Weibull distribution.
 *	I've added a max time and an "alpha_eow" that captures the slight
 *	but noticable change in human typists when hitting end-of-word
 *	transitions.
 *
 * Results:
 *	0 for success, -1 for failure, positive for standard Tcl result
 *
 * Side Effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

static int
human_write(interp,f,buffer,arg)
    Tcl_Interp *interp;
    struct exp_f *f;
    char *buffer;
    struct human_arg *arg;
{
    char *sp;
    float t;
    float alpha;
    int in_word = TRUE;
    int wc;

    debuglog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
	     arg->alpha,arg->alpha_eow,arg->c,arg->min,arg->max);

    for (sp = buffer;*sp;sp++) {
	/* use the end-of-word alpha at eow transitions */
	if (in_word && (ispunct(*sp) || isspace(*sp)))
	    alpha = arg->alpha_eow;
	else alpha = arg->alpha;
	in_word = !(ispunct(*sp) || isspace(*sp));

	t = alpha * (float) pow(-log((double)unit_random()),arg->c);

	/* enforce min and max times */
	if (t<arg->min) t = arg->min;
	else if (t>arg->max) t = arg->max;

	/*fprintf(stderr,"\nwriting <%c> but first sleep %f seconds\n",*sp,t);*/
	/* skip sleep before writing first character */
	if (sp != buffer) {
	    wc = exp_dsleep(interp,(double)t);
	    if (wc > 0) return wc;
	}

	wc = exp_exact_write(f, sp, 1);
	if (wc == -1) {
	    return -1;
	}
    }
    return(0);
}

struct exp_i *exp_i_pool = 0;
struct exp_fs_list *exp_fs_list_pool = 0;

#define EXP_I_INIT_COUNT	10
#define EXP_FS_INIT_COUNT	10

struct exp_i *
exp_new_i()
{
    int n;
    struct exp_i *i;

    if (!exp_i_pool) {
	/* none avail, generate some new ones */
	exp_i_pool = i = (struct exp_i *)ckalloc(
						 EXP_I_INIT_COUNT * sizeof(struct exp_i));
	for (n=0;n<EXP_I_INIT_COUNT-1;n++,i++) {
	    i->next = i+1;
	}
	i->next = 0;
    }

    /* now that we've made some, unlink one and give to user */

    i = exp_i_pool;
    exp_i_pool = exp_i_pool->next;
    i->value = 0;
    i->variable = 0;
    i->fs_list = 0;
    i->ecount = 0;
    i->next = 0;
    return i;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_new_fs --
 *
 *	Get a new exp_f structure.
 *
 * Results:
 *	A structure pointer if successful.
 *
 * Side Effects:
 *	Removes one from the pool if there are any in the pool.
 *	If none are in pool, more are allocated for the pool.
 *
 *----------------------------------------------------------------------
 */

struct exp_fs_list *
exp_new_fs(f)
    struct exp_f *f;
{
    int n;
    struct exp_fs_list *fs;

    if (!exp_fs_list_pool) {
	exp_fs_list_pool = fs = (struct exp_fs_list *)
	    ckalloc(EXP_FS_INIT_COUNT * sizeof(struct exp_fs_list));
	for (n=0;n<EXP_FS_INIT_COUNT-1;n++,fs++) {
	    fs->next = fs+1;
	}
	fs->next = 0;
    }

    fs = exp_fs_list_pool;
    exp_fs_list_pool = exp_fs_list_pool->next;
    fs->f = f;
    return fs;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_free_fs --
 *
 *	Add an exp_f structure list to the free pool.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
exp_free_fs(fs_first)
    struct exp_fs_list *fs_first;
{
    struct exp_fs_list *fs, *penultimate;

    if (!fs_first) return;

    /*
     * link entire chain back in at once by first finding last pointer
     * making that point back to pool, and then resetting pool to this
     */

    /* run to end */
    for (fs = fs_first;fs;fs=fs->next) {
	penultimate = fs;
    }
    penultimate->next = exp_fs_list_pool;
    exp_fs_list_pool = fs_first;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_free_fs_single --
 *
 *	Remove an exp_f structure from the list and put it back
 *	in the free pool
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
exp_free_fs_single(fs)
    struct exp_fs_list *fs;
{
    fs->next = exp_fs_list_pool;
    exp_fs_list_pool = fs;
}

void
exp_free_i(interp,i,updateproc)
    Tcl_Interp *interp;
    struct exp_i *i;
    Tcl_VarTraceProc *updateproc; /* proc to invoke if indirect is written */
{
    if (i->next) exp_free_i(interp,i->next,updateproc);

    exp_free_fs(i->fs_list);

    if (i->direct == EXP_INDIRECT) {
	Tcl_UntraceVar(interp,i->variable,
		       TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
		       updateproc,(ClientData)i);
    }

    /*
     * here's the long form
     * if duration & direct	free(var)  free(val)
     * PERM	  DIR	    		1
     * PERM	  INDIR	    1		1
     * TMP	  DIR
     * TMP	  INDIR			1
     * Also if i->variable was a bogus variable name, i->value might not be
     * set, so test i->value to protect this
     * TMP in this case does NOT mean from the "expect" command.  Rather
     * it means "an implicit spawn id from any expect or expect_XXX
     *  command".  In other words, there was no variable name provided.
     */
    if (i->value
	&& (((i->direct == EXP_DIRECT) && (i->duration == EXP_PERMANENT))
	    || ((i->direct == EXP_INDIRECT) && (i->duration == EXP_TEMPORARY))))
    {
	ckfree(i->value);
    } else if (i->duration == EXP_PERMANENT) {
	if (i->value) ckfree(i->value);
	if (i->variable) ckfree(i->variable);
    }

    i->next = exp_i_pool;
    exp_i_pool = i;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_new_i_complex --
 *
 *	Generate a descriptor for a "-i" flag.  This tries to
 *	be backward compatible, but it can't be perfect.  If
 *	a channel exists, it assumes that the channel is what
 *	was intended.  If it doesn't, it checks the identifier
 *	as a variable.  If the variable exists, the it uses
 *	the variable name as an indirect pointer to the channel
 *	to use.  If the variable doesn't exist, it falls back
 *	to assuming the identifier is a channel identifier.
 *
 * Results:
 *	A new descriptor structure.  Cannot fail currently.
 *
 * Side Effects:
 *	Memory is allocated and a Tcl variable trace may be setup
 *
 *----------------------------------------------------------------------
 */
 
struct exp_i *
exp_new_i_complex(interp,arg,duration,updateproc,msg)
    Tcl_Interp *interp;
    char *arg;		/* spawn id list or a variable containing a list */
    int duration;	/* if we have to copy the args */
    /* should only need do this in expect_before/after */
    Tcl_VarTraceProc *updateproc;	/* proc to invoke if indirect is written */
    char *msg;		/* Error message identifier */
{
    struct exp_i *i;
    char **stringp;
    Tcl_DString dString;
    
    if (!exp_chan2f(interp, arg, 1, 0, msg)) {
	Tcl_DStringInit(&dString);
	Tcl_DStringGetResult(interp, &dString);
	if (Tcl_GetVar(interp, arg, 0)) {
	    Tcl_DStringFree(&dString);
	    i = exp_new_i();
	    i->direct = EXP_INDIRECT;
	    stringp = &i->variable;
	} else {
	    Tcl_DStringResult(interp, &dString);
	    Tcl_DStringFree(&dString);
	    return NULL;
	}
    } else {
	i = exp_new_i();
	i->direct = EXP_DIRECT;
	stringp = &i->value;
    }

    i->duration = duration;
    if (duration == EXP_PERMANENT) {
	*stringp = ckalloc(strlen(arg)+1);
	strcpy(*stringp,arg);
    } else {
	*stringp = arg;
    }
    
    i->fs_list = 0;
    exp_i_update(interp,i);
    
    /* if indirect, ask Tcl to tell us when variable is modified */
    
    if (i->direct == EXP_INDIRECT) {
	Tcl_TraceVar(interp, i->variable, TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
		     updateproc, (ClientData) i);
    }
    
    return i;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_i_add_f --
 *
 *	Add to a list of descriptors
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	A list grows
 *
 *----------------------------------------------------------------------
 */

static void
exp_i_add_f(i,f)
    struct exp_i *i;
    struct exp_f *f;
{
    struct exp_fs_list *new_fs;

    new_fs = exp_new_fs(f);
    new_fs->next = i->fs_list;
    i->fs_list = new_fs;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_i_parse_channels
 *
 *	Parses a string containing a list of channel identifiers and
 *	adds the resulting exp_f structures to a list.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	A list grows
 *
 *----------------------------------------------------------------------
 */
 
void
exp_i_parse_channels(interp, i)
    Tcl_Interp *interp;
    struct exp_i *i;
{
    char *p = i->value;
    char *b;
    char s;
    struct exp_f *f;

    while (1) {
	while (isspace(*p)) {
	    p++;
	}
	if (*p == 0) break;
	b = p;
	while (*p && !isspace(*p)) {
	    p++;
	}
	s = *p;
	*p = 0;

	f = exp_chan2f(interp, b, 1, 0, "");
	if (f) {
	    exp_i_add_f(i,f);
	}

	*p = s;
    }
}
	
/*
 *----------------------------------------------------------------------
 *
 * exp_i_update --
 *
 *	updates a single exp_i struct
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
exp_i_update(interp,i)
    Tcl_Interp *interp;
    struct exp_i *i;
{
    char *p;			/* string representation of list of spawn ids*/

    if (i->direct == EXP_INDIRECT) {
	p = Tcl_GetVar(interp,i->variable,TCL_GLOBAL_ONLY);
	if (!p) {
	    p = "";
	    exp_debuglog("warning: indirect variable %s undefined",i->variable);
	}

	if (i->value) {
	    if (streq(p,i->value)) return;

	    /* replace new value with old */
	    ckfree(i->value);
	}
	i->value = ckalloc(strlen(p)+1);
	strcpy(i->value,p);

	exp_free_fs(i->fs_list);
	i->fs_list = 0;
    } else {
	/* no free, because this should only be called on */
	/* "direct" i's once */
	i->fs_list = 0;
    }
    exp_i_parse_channels(interp, i);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_new_i_simple --
 *
 *	Not quite sure what this does (GCC)
 *
 * Results:
 *	An exp_i structure
 *
 *----------------------------------------------------------------------
 */

struct exp_i *
exp_new_i_simple(f,duration)
    struct exp_f *f;
    int duration;		/* if we have to copy the args */
    /* should only need do this in expect_before/after */
{
    struct exp_i *i;

    i = exp_new_i();

    i->direct = EXP_DIRECT;
    i->duration = duration;

    exp_i_add_f(i,f);

    return i;
}

/*
 *----------------------------------------------------------------------
 *
 * exp_exact_write --
 *
 *	Write exactly this many bytes, i.e. retry partial writes.
 *
 * Results:
 *	0 on success, -1 on failure
 *	
 * Side Effects:
 *	Data is written to an output object
 *
 *----------------------------------------------------------------------
 */

int
exp_exact_write(f,buffer,rembytes)
    struct exp_f *f;
    char *buffer;
    int rembytes;
{
    int n;
    while (rembytes) {
	n = Tcl_Write(f->channel, buffer, rembytes);
	if (-1 == n) {
	    return -1;
	}
	if (0 == n) {
	    Tcl_Sleep(1000);
	    exp_debuglog("write() failed to write anything but returned - sleeping and retrying...\n");
	}
	buffer += n;
	rembytes -= n;
    }
    return(0);
}

/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnOpen --
 *
 *	Handle the 'spawn -open' command.  Called from Exp_SpawnCmd.
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

int
ExpSpawnOpen(interp, chanId, leaveopen)
    Tcl_Interp *interp;
    char *chanId;
    int leaveopen;
{
    Tcl_Channel chan;
    int mode;
    struct exp_f *f;
    
    if (!(chan = Tcl_GetChannel(interp, chanId, &mode))) {
	return TCL_ERROR;
    }
    if (!mode) {
	exp_error(interp,"%s: channel is neither readable nor writable",
		  chanId);
	return TCL_ERROR;
    }

    f = exp_f_find(interp, chanId);
    if (! f) {
	f = exp_f_new(interp, chan, NULL, EXP_NOPID);
	f->leaveopen = leaveopen;

	exp_wait_zero(&f->wait);
    } else {
	/*
	 * Reference count this thing
	 */

	f->leaveopen += leaveopen;
    }

    /* tell user id of new process */
    Tcl_SetVar(interp,EXP_SPAWN_ID_VARNAME,chanId,0);

    sprintf(interp->result,"%d",EXP_NOPID);
    debuglog("spawn: returns {%s}\r\n",interp->result);

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_SendLogCmd --
 *
 *	Implements the send_log command.
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	Messages are written to a log file
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_SendLogCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    char *string;
    int len;

    argv++;
    argc--;

    if (argc) {
	if (streq(*argv,"--")) {
	    argc--; argv++;
	}
    }

    if (argc != 1) {
	exp_error(interp,"usage: send [args] string");
	return TCL_ERROR;
    }

    string = *argv;

    len = strlen(string);

    if (debugfile) Tcl_Write(debugfile, string, len);
    if (logfile) Tcl_Write(logfile, string, len);

    return(TCL_OK);
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_SendCmd --
 *
 *	Sends data to a subprocess or over some channel
 *
 * Results:
 *	Standard Tcl result
 *
 * Notes:
 *	(Don) I've rewritten this to be unbuffered.  I did this so you
 *	could shove large files through "send".  If you are concerned
 *	about efficiency, you should quote all your send args to make
 *	them one single argument.
 *
 *	(GCC) This uses Tcl channels.  By default, the channel
 *	translation will be binary for channels created with
 *	spawn <program>.  The clientData argument, if non-NULL,
 *	holds the name of the channel to use.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_SendCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int rc;			/* final result of this procedure */
    struct human_arg human_args;
    struct slow_arg slow_args;
#define SEND_STYLE_STRING_MASK	0x07 /* mask to detect a real string arg */
#define SEND_STYLE_PLAIN	0x01
#define SEND_STYLE_HUMAN	0x02
#define SEND_STYLE_SLOW		0x04
#define SEND_STYLE_ZERO		0x10
#define SEND_STYLE_BREAK	0x20
    int send_style = SEND_STYLE_PLAIN;
    int want_cooked = TRUE;
    char *string;		/* string to send */
    int len;			/* length of string to send */
    int zeros;			/* count of how many ascii zeros to send */
    
    char *i_masters = 0;
    struct exp_fs_list *fs;
    struct exp_i *i;
    char *arg;
    struct exp_f *f = NULL;
    char *argv0 = argv[0];
    
    argv++;
    argc--;
    while (argc) {
	arg = *argv;
	if (arg[0] != '-') break;
	arg++;
	if (exp_flageq1('-',arg)) { /* "--" */
	    argc--; argv++;
	    break;
	} else if (exp_flageq1('i',arg)) { /* "-i" */
	    argc--; argv++;
	    if (argc==0) {
		exp_error(interp,"usage: %s -i spawn_id", argv0);
		return(TCL_ERROR);
	    }
	    i_masters = *argv;
	    argc--; argv++;
	    continue;
	} else if (exp_flageq1('h',arg)) { /* "-h" */
	    argc--; argv++;
	    if (-1 == get_human_args(interp,&human_args))
		return(TCL_ERROR);
	    send_style = SEND_STYLE_HUMAN;
	    continue;
	} else if (exp_flageq1('s',arg)) { /* "-s" */
	    argc--; argv++;
	    if (-1 == get_slow_args(interp,&slow_args))
		return(TCL_ERROR);
	    send_style = SEND_STYLE_SLOW;
	    continue;
	} else if (exp_flageq("null",arg,1) || exp_flageq1('0',arg)) {
	    argc--; argv++;	/* "-null" */
	    if (!*argv) zeros = 1;
	    else {
		zeros = atoi(*argv);
		argc--; argv++;
		if (zeros < 1) return TCL_OK;
	    }
	    send_style = SEND_STYLE_ZERO;
	    string = "<zero(s)>";
	    continue;
	} else if (exp_flageq("raw",arg,1)) { /* "-raw" */
	    argc--; argv++;
	    want_cooked = FALSE;
	    continue;
	} else if (exp_flageq("break",arg,1)) {	/* "-break" */
	    argc--; argv++;
	    send_style = SEND_STYLE_BREAK;
	    string = "<break>";
	    continue;
	} else {
	    exp_error(interp,"usage: unrecognized flag <-%.80s>",arg);
	    return TCL_ERROR;
	}
    }
    
    if (send_style & SEND_STYLE_STRING_MASK) {
	if (argc != 1) {
	    exp_error(interp,"usage: %s [args] string", argv0);
	    return TCL_ERROR;
	}
	string = *argv;
    }
    len = strlen(string);
    
    if (clientData != NULL) {
	f = exp_chan2f(interp, (char *) clientData, 1, 0, argv0);
    } else if (!i_masters) {
	/*
	 * we really do want to check if it is open
	 * but since stdin could be closed, we have to first
	 * get the fs and then convert it from 0 to 1 if necessary
	 */
	f = exp_update_master(interp,0,0);
	if (f == NULL) {
	    return(TCL_ERROR);
	}
    }
    
    /*
     * if f != NULL, then it holds desired master, else i_masters does
     */
    
    if (f) {
	i = exp_new_i_simple(f,EXP_TEMPORARY);
    } else {
	i = exp_new_i_complex(interp,i_masters,FALSE,
			      (Tcl_VarTraceProc *)NULL,argv0);
	if (i == NULL) {
	    return TCL_ERROR;
	}
    }
    
    if (clientData == NULL) {
	/* This seems to be the standard send call (send_to_proc) */
	want_cooked = FALSE;
	debuglog("send: sending \"%s\" to {",dprintify(string));
	/* if closing brace doesn't appear, that's because an error */
	/* was encountered before we could send it */
    } else {
	if (debugfile) {
	    Tcl_Write(debugfile, string, len);
	}
	/* send_to_user ? */
	if (((strcmp((char *) clientData, "exp_user") == 0 ||
	      strcmp((char *) clientData, exp_dev_tty_id) == 0 ||
	      strcmp((char *) clientData, "exp_tty") == 0) && logfile_all) ||
	    logfile) {
	    if (logfile) {
		Tcl_Write(logfile, string, len);
	    }
	}
    }
    
    for (fs=i->fs_list;fs;fs=fs->next) {
	f = fs->f;

	if (clientData == NULL) {
	    /* send_to_proc */
	    debuglog(" %s ", f->spawnId);
	}

	/* check validity of each - i.e., are they open */
	if (! exp_fcheck(interp, f, 1, 0, "send")) {
	    rc = TCL_ERROR;
	    goto finish;
	}

	if (want_cooked) string = exp_cook(string,&len);

	switch (send_style) {
	case SEND_STYLE_PLAIN:
	    rc = exp_exact_write(f,string,len);
	    break;
	case SEND_STYLE_SLOW:
	    rc = slow_write(interp,f,string,len,&slow_args);
	    break;
	case SEND_STYLE_HUMAN:
	    rc = human_write(interp,f,string,&human_args);
	    break;
	case SEND_STYLE_ZERO:
	    for (;zeros>0;zeros--)
		rc = exp_exact_write(f, "", 1);
	    /* catching error on last write is sufficient */
	    break;
	case SEND_STYLE_BREAK:
	    exp_tty_break(interp,f);
	    rc = 0;
	    break;
	}

	if (rc != 0) {
	    if (rc == -1) {
		exp_error(interp,"write(spawn_id=%s): %s", f->spawnId,
			  Tcl_PosixError(interp));
		rc = TCL_ERROR;
	    }
	    goto finish;
	}
    }
    if (clientData == NULL) {
	/* send_to_proc */
	debuglog("}\r\n");
    }
    
    rc = TCL_OK;
 finish:
    exp_free_i(interp,i,(Tcl_VarTraceProc *)0);
    return rc;
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_LogFileCmd --
 *
 *	Implements the 'log_file' and 'exp_log_file' commands.
 *	Opens a logfile.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side Effects:
 *	A file may be opened, or a currently open file may be
 *	changed to unbuffered
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_LogFileCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    static Tcl_DString dstring;
    static int first_time = TRUE;
    static int current_append;	/* true if currently appending */
    static char *openarg = 0;	/* Tcl file identifier from -open */
    static int leaveopen = FALSE;	/* true if -leaveopen was used */
    
    int old_logfile_all = logfile_all;
    Tcl_Channel old_logfile = logfile;
    char *old_openarg = openarg;
    int old_leaveopen = leaveopen;
    
    int aflag = FALSE;
    int append = TRUE;
    char *filename = 0;
    char *type;
    int usage_error_occurred = FALSE;
    
    openarg = 0;
    leaveopen = FALSE;
    
    if (first_time) {
	Tcl_DStringInit(&dstring);
	first_time = FALSE;
    }
    
#define usage_error {usage_error_occurred = TRUE; goto error; }
    
    /* when this function returns, we guarantee that if logfile_all */
    /* is TRUE, then logfile is non-zero */
    
    argv++;
    argc--;
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-open")) {
	    if (!argv[1]) usage_error;
	    openarg = ckalloc(strlen(argv[1])+1);
	    strcpy(openarg,argv[1]);
	    argc--; argv++;
	} else if (streq(*argv,"-leaveopen")) {
	    if (!argv[1]) usage_error;
	    openarg = ckalloc(strlen(argv[1])+1);
	    strcpy(openarg,argv[1]);
	    leaveopen = TRUE;
	    argc--; argv++;
	} else if (streq(*argv,"-a")) {
	    aflag = TRUE;
	} else if (streq(*argv,"-info")) {
	    if (logfile) {
		if (logfile_all) strcat(interp->result,"-a ");
		if (!current_append) strcat(interp->result,"-noappend ");
		strcat(interp->result,Tcl_DStringValue(&dstring));
	    }
	    return TCL_OK;
	} else if (streq(*argv,"-noappend")) {
	    append = FALSE;
	} else break;
    }
    
    if (argc == 1) {
	filename = argv[0];
    } else if (argc > 1) {
	/* too many arguments */
	usage_error
    } 
    
    if (openarg && filename) {
	usage_error
    }
    if (aflag && !(openarg || filename)) {
	usage_error
    }
    
    logfile = 0;
    logfile_all = aflag;
    
    current_append = append;
    
    type = (append?"a":"w");
    
    if (filename) {
	logfile = Tcl_OpenFileChannel(interp, filename, type, O_CREAT|S_IWRITE);
	if (logfile == (Tcl_Channel) NULL) {
	    exp_error(interp,"%s: %s",filename,Tcl_PosixError(interp));
	    goto error;
	}
    } else if (openarg) {
	int mode;
	
	Tcl_DStringTrunc(&dstring,0);
	
	if (!(logfile = Tcl_GetChannel(interp,openarg,&mode))) {
	    return TCL_ERROR;
	}
	if (!(mode & TCL_WRITABLE)) {
	    exp_error(interp,"channel is not writable");
	}

	if (leaveopen) {
	    Tcl_DStringAppend(&dstring,"-leaveopen ",-1);
	} else {
	    Tcl_DStringAppend(&dstring,"-open ",-1);
	}
	Tcl_DStringAppend(&dstring,openarg,-1);
	
	/*
	 * It would be convenient now to tell Tcl to close its
	 * file descriptor.  Alas, if involved in a pipeline, Tcl
	 * will be unable to complete a wait on the process.
	 * So simply remember that we meant to close it.  We will
	 * do so later in our own close routine.
	 */
    }
    if (logfile) {
	Tcl_SetChannelOption(interp, logfile, "-buffering", "none");
    }
    
    if (old_logfile) {
	if (!old_openarg || !old_leaveopen) { 
	    Tcl_Close(interp, old_logfile);
	}
	if (old_openarg) {
	    ckfree(old_openarg);
	}
    }
    
    return TCL_OK;
    
 error:
    if (old_logfile) {
	logfile = old_logfile;
	logfile_all = old_logfile_all;
    }
    
    if (openarg) ckfree(openarg);
    openarg = old_openarg;
    leaveopen = old_leaveopen;
    
    if (usage_error_occurred) {
	exp_error(interp,"usage: log_file [-info] [-noappend] [[-a] file] [-[leave]open [open ...]]");
    }
    
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_LogUserCmd --
 *
 *	Implements the 'loguser' and 'exp_loguser' commands.
 *	Can turn logging to stdout on or off, and returns the
 *	previous logging status.
 *
 * Results:
 *	A standard TCL result
 *
 * Side Effects:
 *	Logging can be enabled or disabled.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_LogUserCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int old_loguser = loguser;
    
    if (argc == 0 || (argc == 2 && streq(argv[1],"-info"))) {
	/* do nothing */
    } else if (argc == 2) {
	if (0 == atoi(argv[1])) loguser = FALSE;
	else loguser = TRUE;
    } else {
	exp_error(interp,"usage: [-info|1|0]");
    }
    
    sprintf(interp->result,"%d",old_loguser);
    
    return(TCL_OK);
}

#ifdef TCL_DEBUGGER
/*
 *----------------------------------------------------------------------
 *
 * Exp_DebugCmd --
 *
 *	Implements the 'debug' and 'exp_debug' commands
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_DebugCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int now = FALSE;		/* soon if FALSE, now if TRUE */
    int exp_tcl_debugger_was_available = exp_tcl_debugger_available;

    if (argc > 3) goto usage;

    if (argc == 1) {
	sprintf(interp->result,"%d",exp_tcl_debugger_available);
	return TCL_OK;
    }

    argv++;

    while (*argv) {
	if (streq(*argv,"-now")) {
	    now = TRUE;
	    argv++;
	}
	else break;
    }

    if (!*argv) {
	if (now) {
	    Dbg_On(interp,1);
	    exp_tcl_debugger_available = 1;
	} else {
	    goto usage;
	}
    } else if (streq(*argv,"0")) {
	Dbg_Off(interp);
	exp_tcl_debugger_available = 0;
    } else {
	Dbg_On(interp,now);
	exp_tcl_debugger_available = 1;
    }
    sprintf(interp->result,"%d",exp_tcl_debugger_was_available);
    return(TCL_OK);
 usage:
    exp_error(interp,"usage: [[-now] 1|0]");
    return TCL_ERROR;
}
#endif /* TCL_DEBUGGER */

/*ARGSUSED*/
static int
Exp_ExpInternalCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    static Tcl_DString dstring;
    static int first_time = TRUE;
    int fopened = FALSE;

    if (first_time) {
	Tcl_DStringInit(&dstring);
	first_time = FALSE;
    }

    if (argc > 1 && streq(argv[1],"-info")) {
	if (debugfile) {
	    sprintf(interp->result,"-f %s ",
		    Tcl_DStringValue(&dstring));
	}
	strcat(interp->result,((exp_is_debugging==0)?"0":"1"));
	return TCL_OK;
    }

    argv++;
    argc--;
    while (argc) {
	if (!streq(*argv,"-f")) break;
	argc--;argv++;
	if (argc < 1) goto usage;
	if (debugfile) {
	    Tcl_Close(interp, debugfile);
	}

	debugfile = Tcl_OpenFileChannel(interp, argv[0], "a", O_APPEND|S_IWRITE);
	if (debugfile == (Tcl_Channel) NULL) {
	    exp_error(interp,"%s: %s",argv[0],Tcl_PosixError(interp));
	    goto error;
	}
	Tcl_DStringAppend(&dstring,argv[0],-1);

	Tcl_SetChannelOption(interp, debugfile, "-buffering", "none");
	fopened = TRUE;
	argc--;argv++;
    }

    if (argc != 1) goto usage;

    /* if no -f given, close file */
    if (fopened == FALSE && debugfile) {
	Tcl_Close(interp, debugfile);
	debugfile = NULL;
	Tcl_DStringFree(&dstring);
    }

    exp_is_debugging = atoi(*argv);
    return(TCL_OK);
 usage:
    exp_error(interp,"usage: [-f file] expr");
 error:
    Tcl_DStringFree(&dstring);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_ExitCmd --
 *
 *	Called on exit to do cleanup.
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

char *exp_onexit_action = 0;

/*ARGSUSED*/
static int
Exp_ExitCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int value = 0;

    argv++;

    if (*argv) {
	if (exp_flageq(*argv,"-onexit",3)) {
	    argv++;
	    if (*argv) {
		int len = strlen(*argv);
		if (exp_onexit_action)
		    ckfree(exp_onexit_action);
		exp_onexit_action = ckalloc(len + 1);
		strcpy(exp_onexit_action,*argv);
	    } else if (exp_onexit_action) {
		Tcl_AppendResult(interp,exp_onexit_action,(char *)0);
	    }
	    return TCL_OK;
	} else if (exp_flageq(*argv,"-noexit",3)) {
	    argv++;
	    exp_exit_handlers((ClientData)interp);
	    return TCL_OK;
	}
    }

    if (*argv) {
	if (Tcl_GetInt(interp, *argv, &value) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    exp_exit(interp,value);
    /*NOTREACHED*/
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_CloseCmd --
 *
 *	Currently closes a channel or sets up handlers for
 *	when the channel closes.
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_CloseCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    char *close_onexec = NULL;
    int slave_flag = FALSE;
    char *argv0 = argv[0];
    struct exp_f *f;
#if 0
    int slave;
#endif
    char *chanId = NULL;

    int argc_orig = argc;
    char **argv_orig = argv;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) {
		exp_error(interp,"usage: -i spawn_id");
		return(TCL_ERROR);
	    }
	    chanId = *argv;
	} else if (streq(*argv,"-slave")) {
	    slave_flag = TRUE;
	} else if (streq(*argv,"-onexec")) {
	    argc--; argv++;
	    if (!*argv) {
		exp_error(interp,"usage: -onexec channelId");
		return(TCL_ERROR);
	    }
	    close_onexec = *argv;
	} else break;
    }

    if (argc) {
	/* doesn't look like our format, it must be a Tcl-style file */
	/* handle.  Lucky that formats are easily distinguishable. */
	/* Historical note: we used "close"  long before there was a */
	/* Tcl builtin by the same name. */

	Tcl_Obj **objv;
	int i, result;
	Tcl_CmdInfo info;

	Tcl_ResetResult(interp);
	objv = (Tcl_Obj **) ckalloc((argc+1)*sizeof(Tcl_Obj *));
	objv[0] = Tcl_NewStringObj("exp_tcl_close", -1);
	for (i = 0; i < argc; i++) {
	    objv[i+1] = Tcl_NewStringObj(argv[i], -1);
	}

	if (0 == Tcl_GetCommandInfo(interp,"exp_tcl_close",&info)) {
	    info.clientData = 0;
	}
	result = info.objProc(info.objClientData,interp,argc+1,objv);
	for (i = 0; i < argc+1; i++) {
	    Tcl_DecrRefCount(objv[i]);
	}
	ckfree((char *) objv);
	return result;
    }

    if (chanId == NULL) {
	f = exp_update_master(interp, 1, 0);
    } else if (slave_flag) {
	f = exp_chan2f(interp, chanId, 1, 0, "-slave");
    } else {
	f = exp_chan2f(interp, chanId, 1, 0, argv0);
    }
    if (f == NULL) {
	return TCL_ERROR;
    }

    if (slave_flag) {
	if (f->slave_fd) {
#ifndef __WIN32__ /* XXX: This still needs some looking at */
	    close(f->slave_fd);
	    f->slave_fd = EXP_NOFD;

	    exp_slave_control(f,1);
#endif
	    return TCL_OK;
	}
	exp_error(interp,"no such slave");
	return TCL_ERROR;
    }

#ifdef XXX /* I'm not sure this is a good idea to support */
    if (onexec_flag) {
	/* heck, don't even bother to check if fd is open or a real */
	/* spawn id, nothing else depends on it */
	fcntl(m,F_SETFD,close_onexec);
	return TCL_OK;
    }
#endif

    return exp_close(interp, f);
}

/*ARGSUSED*/
static void
tcl_tracer(clientData,interp,level,command,cmdProc,cmdClientData,argc,argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int level;
    char *command;
    Tcl_CmdProc *cmdProc;
    ClientData cmdClientData;
    int argc;
    char *argv[];
{
    int i;
    
    /* come out on stderr, by using errorlog */
    errorlog("%2d",level);
    for (i = 0;i<level;i++) exp_nferrorlog("  ",0/*ignored - satisfy lint*/);
    errorlog("%s\r\n",command);
}

/*ARGSUSED*/
static int
Exp_StraceCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    static int trace_level = 0;
    static Tcl_Trace trace_handle;

    if (argc > 1 && streq(argv[1],"-info")) {
	sprintf(interp->result,"%d",trace_level);
	return TCL_OK;
    }

    if (argc != 2) {
	exp_error(interp,"usage: trace level");
	return(TCL_ERROR);
    }
    /* tracing already in effect, undo it */
    if (trace_level > 0) Tcl_DeleteTrace(interp,trace_handle);

    /* get and save new trace level */
    trace_level = atoi(argv[1]);
    if (trace_level > 0)
	trace_handle = Tcl_CreateTrace(interp,
				       trace_level,tcl_tracer,(ClientData)0);
    return(TCL_OK);
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_WaitCmd --
 *
 *	Implements the 'wait' and 'exp_wait' commands.  When a process
 *	has been spawned, the wait call must be made before it will
 *	go away.
 *
 * Results:
 *	A standard Tcl result
 *
 * Notes:
 *	XXX: This might need to go into the platform specific file.
 *	Need to make sure that we do the right thing when exp_open
 *	has been called on an identifier.
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_WaitCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    int master_supplied = FALSE;
    struct exp_f *f;	/* ditto */
    Tcl_HashEntry *hPtr;
    Tcl_HashSearch search;
    struct forked_proc *fp = 0;	/* handle to a pure forked proc */
    
#ifdef XXX
    struct exp_f ftmp;	/* temporary memory for either f or fp */
#endif
    
    int nowait = FALSE;
    int nohang = FALSE;
    char *chanId = NULL;
    char *argv0 = argv[0];
    Tcl_Pid result = 0;		/* 0 means child was successfully waited on */

    /* -1 means an error occurred */
    /* -2 means no eligible children to wait on */
#define NO_CHILD ((Tcl_Pid) -2)
    
    argv++;
    argc--;
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (argc==0) {
		exp_error(interp,"usage: -i spawn_id");
		return(TCL_ERROR);
	    }
	    chanId = *argv;
	} else if (streq(*argv,"-nowait")) {
	    nowait = TRUE;
	} else if (streq(*argv,"-nohang")) {
	    nohang = TRUE;
	}
    }
    
    if (chanId == NULL) {
	f = exp_update_master(interp, 0, 0);
    } else {
	f = exp_chan2f(interp, chanId, 0, 0, argv0);
    }
    if (f == NULL) {
	return TCL_ERROR;
    }
    
    if (f != exp_f_any) {
	/*
	 * Check if waited on already.  Things opened by "open", set
	 * with -nowait, or are special expect ids are marked sys_waited
	 * already
	 */
	if (!f->sys_waited) {
	    if (nowait) {
		/*
		 * should probably generate an error
		 * if SIGCHLD is trapped.
		 */

		/*
		 * pass to Tcl, so it can do wait in background.
		 */
		Tcl_DetachPids(1,&f->tclPid);
		exp_wait_zero(&f->wait);
		f->sys_waited = 1;
		f->user_waited = 1;

	    } else if (nohang) {
		exp_wait_zero(&f->wait);
		result = Tcl_WaitPid(f->tclPid,&f->wait,WNOHANG);

	    } else {
		while (1) {
		    if (Tcl_AsyncReady()) {
			int rc = Tcl_AsyncInvoke(interp,TCL_OK);
			if (rc != TCL_OK) return(rc);
		    }

		    exp_wait_zero(&f->wait);
		    result = Tcl_WaitPid(f->tclPid,&f->wait,0);
		    if (result == f->tclPid) break;
		    if (result == (Tcl_Pid) -1) {
			if (errno == EINTR) continue;
			else break;
		    }
		}
	    }
	}

	/*
	 * Now have Tcl reap anything we just detached. 
	 * This also allows procs user has created with "exec &"
	 * and and associated with an "exec &" process to be reaped.
	 */

	Tcl_ReapDetachedProcs();
	exp_rearm_sigchld(interp); /* new */
    } else {
	/*
	 * Wait for any of our own spawned processes. We call waitpid
	 * rather than wait to avoid running into someone else's processes.
	 * Yes, according to Ousterhout this is the best way to do it.
	 */

	hPtr = Tcl_FirstHashEntry(exp_f_table, &search);
	while (hPtr) {
	    f = (struct exp_f *) Tcl_GetHashValue(hPtr);

	    if (!f->valid) continue;
	    if (f->pid == EXP_NOPID) continue;
	    if (f->pid == exp_getpid) continue; /* skip ourself */
	    if (f->user_waited) continue; /* one wait only! */
	    if (f->sys_waited) break;
	restart:
	    exp_wait_zero(&f->wait);
	    result = Tcl_WaitPid(f->tclPid,&f->wait,WNOHANG);
	    if (result == f->tclPid) break;
	    if (result == 0) continue; /* busy, try next */
	    if (result == (Tcl_Pid) -1) {
		if (errno == EINTR) goto restart;
		else break;
	    }
	    hPtr = Tcl_NextHashEntry(&search);
	}
	
#ifdef XXX
	/* if it's not a spawned process, maybe its a forked process */
	for (fp=forked_proc_base;fp;fp=fp->next) {
	    if (fp->link_status == not_in_use) continue;
	restart2:
	    result = waitpid(fp->pid,&fp->wait_status,WNOHANG);
	    if (result == fp->pid) {
		m = -1;		/* DOCUMENT THIS! */
		break;
	    }
	    if (result == 0) continue; /* busy, try next */
	    if (result == -1) {
		if (errno == EINTR) goto restart2;
		else break;
	    }
	}
#endif /* XXX */
	
	if (hPtr == NULL && fp == NULL) {
	    result = NO_CHILD;	/* no children */
	    Tcl_ReapDetachedProcs();
	}
	exp_rearm_sigchld(interp);
    }
    
#ifdef XXX
    /*  sigh, wedge forked_proc into an exp_f structure so we don't
     *  have to rewrite remaining code (too much)
     */
    if (fp) {
	f = &ftmp;
	f->tclPid = fp->pid;
	f->wait = fp->wait_status;
    }
#endif
    /* non-portable assumption that pid_t can be printed with %d */

    if (result == (Tcl_Pid) -1) {
	sprintf(interp->result,"%d %s -1 %d POSIX %s %s",
		f->pid,f->spawnId,errno,Tcl_ErrnoId(),Tcl_ErrnoMsg(errno));
	result = TCL_OK;
	f->sys_waited = TRUE;
	f->user_waited = TRUE;
    } else if (result == NO_CHILD) {
	interp->result = "no children";
	return TCL_ERROR;
    } else {
	sprintf(interp->result,"%d %s 0 %d",
		f->pid,f->spawnId,WEXITSTATUS(f->wait));
	if (WIFSIGNALED(f->wait)) {
	    Tcl_AppendElement(interp,"CHILDKILLED");
	    Tcl_AppendElement(interp,Tcl_SignalId((int)(WTERMSIG(f->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WTERMSIG(f->wait))));
	} else if (WIFSTOPPED(f->wait)) {
	    Tcl_AppendElement(interp,"CHILDSUSP");
	    Tcl_AppendElement(interp,Tcl_SignalId((int) (WSTOPSIG(f->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WSTOPSIG(f->wait))));
	}
	if (nohang && result == 0) {
	    Tcl_AppendElement(interp,"NOEXIT");
	}
	if (result > 0 && WIFEXITED(f->wait)) {
	    f->sys_waited = TRUE;
	    f->user_waited = TRUE;
	}
    }

#ifdef XXX
    if (fp) {
	fp->link_status = not_in_use;
	return ((result == -1)?TCL_ERROR:TCL_OK);		
    }
#endif
    
    /*
     * if user has already called close, make sure fd really is closed
     * and forget about this entry entirely
     */
    if (f->user_closed) {
	exp_f_free(f);
    }
    return ((result == (Tcl_Pid) -1)?TCL_ERROR:TCL_OK);
}

/*ARGSUSED*/
int
Exp_InterpreterCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    if (argc != 1) {
	exp_error(interp,"no arguments allowed");
	return(TCL_ERROR);
    }
    
#ifdef __WIN32__
    exp_error(interp, "not implemented on Windows NT");
    return TCL_ERROR;
#endif
    return(exp_interpreter(interp));
    /* errors and ok, are caught by exp_interpreter() and discarded */
    /* to return TCL_OK, type "return" */
}

/* this command supercede's Tcl's builtin CONTINUE command */
/*ARGSUSED*/
int
Exp_ExpContinueDeprecatedCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    if (argc == 1) return(TCL_CONTINUE);
    else if (argc == 2) {
	if (streq(argv[1],"-expect")) {
	    debuglog("continue -expect is deprecated, use exp_continue\r\n");
	    return(EXP_CONTINUE);
	}
    }
    exp_error(interp,"usage: continue [-expect]\n");
    return(TCL_ERROR);
}

/* this command supercede's Tcl's builtin CONTINUE command */
/*ARGSUSED*/
int
Exp_ExpContinueCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    if (argc == 1) {
	return EXP_CONTINUE;
    } else if ((argc == 2) && (streq(argv[1],"-continue_timer"))) {
	return EXP_CONTINUE_TIMER;
    }

    exp_error(interp,"usage: exp_continue [-continue_timer]\n");
    return(TCL_ERROR);
}

/* most of this is directly from Tcl's definition for return */
/*ARGSUSED*/
int
Exp_InterReturnCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    /* let Tcl's return command worry about args */
    /* if successful (i.e., TCL_RETURN is returned) */
    /* modify the result, so that we will handle it specially */

    int result;
#if TCL_MAJOR_VERSION >= 8
    Tcl_Obj **objv;
    int i;

    objv = (Tcl_Obj **) ckalloc(argc*sizeof(Tcl_Obj *));
    for (i = 0; i < argc; i++) {
	objv[i] = Tcl_NewStringObj(argv[i], -1);
    }
    result = Tcl_ReturnObjCmd(clientData,interp,argc,objv);
    for (i = 0; i < argc; i++) {
	Tcl_DecrRefCount(objv[i]);
    }
    ckfree((char *) objv);
#else
    result = Tcl_ReturnCmd(clientData,interp,argc,argv);
#endif

    if (result == TCL_RETURN)
	result = EXP_TCL_RETURN;
    return result;

}

/*
 *----------------------------------------------------------------------
 *
 * Exp_OpenCmd --
 *
 *	Implements the exp_open command.  Makes a spawn id available
 *	to Tcl.  Since this happens by default, we don't have to do
 *	anything in the -leaveopen case.  In the normal case, we
 *	need to clean up the spawn identifier and that is all.
 *
 * Results:
 *	A standard Tcl result
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
int
Exp_OpenCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    struct exp_f *f;
    int leaveopen = FALSE;
    char *chanId = NULL;
    char *argv0 = argv[0];

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) {
		exp_error(interp,"usage: -i spawn_id");
		return TCL_ERROR;
	    }
	    chanId = *argv;
	} else if (streq(*argv,"-leaveopen")) {
	    leaveopen = TRUE;
	    argc--; argv++;
	} else break;
    }

    if (chanId == NULL) {
	f = exp_update_master(interp,0,0);
    } else {
	f = exp_chan2f(interp, chanId, 1, 0, argv0);
    }
    if (f == NULL) {
	return(TCL_ERROR);
    }
    if (f->channel == NULL) {
	exp_error(interp,
		  "%s: %s is an internal spawn id that cannot be expected as a channel id",
		  argv0, chanId);
	return TCL_ERROR;
    }
    if (! leaveopen) {
	/*
	 * Don't do any reference count check on f->leaveopen.  Just force
	 * the spawn id closed
	 */
	if (f->channel) {
	    Tcl_DeleteCloseHandler(f->channel, (Tcl_CloseProc *) exp_f_free,
				   (ClientData) f);
	}
	exp_f_free(f);
    }

    Tcl_AppendResult(interp, Tcl_GetChannelName(f->channel), (char *) NULL);
    return TCL_OK;
}

/* return 1 if a string is substring of a flag */
/* this version is the code used by the macro that everyone calls */
int
exp_flageq_code(flag,string,minlen)
char *flag;
char *string;
int minlen;		/* at least this many chars must match */
{
	for (;*flag;flag++,string++,minlen--) {
		if (*string == '\0') break;
		if (*string != *flag) return 0;
	}
	if (*string == '\0' && minlen <= 0) return 1;
	return 0;
}

void
exp_create_commands(interp,c)
    Tcl_Interp *interp;
    struct exp_cmd_data *c;
{
    Interp *iPtr = (Interp *) interp;
    char cmdnamebuf[80];

    for (;c->name;c++) {
	int create = FALSE;
	/* if already defined, don't redefine */
	if (c->flags & EXP_REDEFINE) create = TRUE;
	else if (!Tcl_FindHashEntry(&iPtr->globalNsPtr->cmdTable,c->name)) {
	    create = TRUE;
	}
	if (create) {
	    sprintf(cmdnamebuf, "rename %s exp_tcl_%s", c->name, c->name);
	    Tcl_GlobalEval(interp, cmdnamebuf);
	    Tcl_CreateCommand(interp,c->name,c->proc,
			      c->data, (Tcl_CmdDeleteProc *) NULL);
	}
	if (!(c->name[0] == 'e' &&
	      c->name[1] == 'x' &&
	      c->name[2] == 'p')
	    && !(c->flags & EXP_NOPREFIX))
	{
	    sprintf(cmdnamebuf,"exp_%s",c->name);
	    Tcl_CreateCommand(interp,cmdnamebuf,c->proc,
			      c->data, (Tcl_CmdDeleteProc *) NULL);
	}
    }
}

static struct exp_cmd_data cmd_data[]  = {
{"close",	Exp_CloseCmd,	0,	EXP_REDEFINE},
#ifdef TCL_DEBUGGER
{"debug",	Exp_DebugCmd,	0,	0},
#endif
{"exp_internal",Exp_ExpInternalCmd,	0,	0},
#ifdef XXX
{"disconnect",	Exp_DisconnectCmd,	0,	0},
#endif
{"exit",	Exp_ExitCmd,	0,	EXP_REDEFINE},
{"continue",	Exp_ExpContinueDeprecatedCmd,0,EXP_NOPREFIX|EXP_REDEFINE},
{"exp_continue",Exp_ExpContinueCmd,0,	0},
#ifdef XXX
{"fork",	Exp_ForkCmd,	0,	0},
#endif
{"exp_pid",	Exp_ExpPidCmd,	0,	0},
{"getpid",	Exp_GetpidDeprecatedCmd,0,	0},
{"interpreter",	Exp_InterpreterCmd,	0,	0},
{"kill",	Exp_KillCmd,	0,	0},
{"log_file",	Exp_LogFileCmd,	0,	0},
{"log_user",	Exp_LogUserCmd,	0,	0},
{"exp_open",	Exp_OpenCmd,	0,	0},
#ifdef XXX
{"overlay",	Exp_OverlayCmd,	0,	0},
#endif
{"inter_return",Exp_InterReturnCmd,	0,	0},
{"send",	Exp_SendCmd,	(ClientData)NULL,	0},
{"send_spawn",	Exp_SendCmd,	(ClientData)NULL,	0},/*deprecat*/
{"send_error",	Exp_SendCmd,	(ClientData)"stderr",	0},
{"send_log",	Exp_SendLogCmd,	0,	0},
{"send_tty",	Exp_SendCmd,	(ClientData)"exp_tty",	0},
{"send_user",	Exp_SendCmd,	(ClientData)"exp_user",	0},
{"sleep",	Exp_SleepCmd,	0,	0},
{"spawn",	Exp_SpawnCmd,	0,	0},
{"strace",	Exp_StraceCmd,	0,	0},
{"wait",	Exp_WaitCmd,	0,	0},
{0}};

/*
 *----------------------------------------------------------------------
 *
 * exp_init_most_cmds --
 *
 *	Initialize the large majority of commands that are used
 *	in expect
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
exp_init_most_cmds(interp)
    Tcl_Interp *interp;
{
    exp_create_commands(interp,cmd_data);

    exp_close_in_child = exp_close_tcl_files;
}

void
exp_init_spawn_id_vars(interp)
    Tcl_Interp *interp;
{
    Tcl_SetVar(interp,"user_spawn_id",EXP_SPAWN_ID_USER,0);
    Tcl_SetVar(interp,"error_spawn_id",EXP_SPAWN_ID_ERROR,0);
    Tcl_SetVar(interp,"tty_spawn_id","exp_tty",0);
}

/*
 *----------------------------------------------------------------------
 *
 * exp_init_spawn_ids --
 *
 *	Create the structures for the standard spawn ids.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
exp_init_spawn_ids(interp)
    Tcl_Interp *interp;
{
    Tcl_Channel chan, chanIn, chanOut;
    struct exp_f *f;

    exp_f_table = (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(exp_f_table, TCL_STRING_KEYS);

    chan = ExpCreatePairChannel(interp, "stdin", "stdout", "exp_user");
    f = exp_f_new(interp, chan, NULL, EXP_NOPID);
    Tcl_RegisterChannel(interp, chan);

    chan = Tcl_GetStdChannel(TCL_STDIN);
    f = exp_f_new(interp, chan, NULL,
		  (isatty(0) ? exp_getpid : EXP_NOPID));
    f->leaveopen = 1;
    if (strcmp(Tcl_GetChannelName(chan), "stdin") != 0) {
	f = exp_f_new(interp, chan, "stdin",
		      (isatty(0) ? exp_getpid : EXP_NOPID));
	f->leaveopen = 1;
    }
    chanIn = chan;

    chan = Tcl_GetStdChannel(TCL_STDOUT);
    if (chan != chanIn) {
	f = exp_f_new(interp, chan, NULL,
		      (isatty(1) ? exp_getpid : EXP_NOPID));
	f->leaveopen = 1;
    }
    if (strcmp(Tcl_GetChannelName(chan), "stdout") != 0) {
	f = exp_f_new(interp, chan, "stdout",
		      (isatty(1) ? exp_getpid : EXP_NOPID));
	f->leaveopen = 1;
    }
    chanOut = chan;

    chan = Tcl_GetStdChannel(TCL_STDERR);
    if ((chan != chanIn) && (chan != chanOut)) {
	f = exp_f_new(interp, chan, NULL,
		      (isatty(2) ? exp_getpid : EXP_NOPID));
	f->leaveopen = 1;
    }
    if (strcmp(Tcl_GetChannelName(chan), "stderr") != 0) {
	f = exp_f_new(interp, chan, "stderr",
		      (isatty(2) ? exp_getpid : EXP_NOPID));
	f->leaveopen = 1;
    }

    /*
     * Create the 'exp_any' spawn id that is meant to many any spawn ids.
     */

    f = exp_f_new(interp, NULL, "exp_any", exp_getpid);
    f->alwaysopen = 1;
    exp_f_any = f;

#ifdef XXX
    /* really should be in interpreter() but silly to do on every call */
    exp_adjust(&exp_fs[0]);
#endif
}
@


1.1.2.1.2.1
log
@A working set of code against Tcl8.4!
@
text
@a20 2
#define BUILD_expect

a2049 1
    return TCL_OK;
d2120 1
a2120 1
	objv[0] = Tcl_NewStringObj("close", -1);
d2125 1
a2125 1
	if (0 == Tcl_GetCommandInfo(interp,"close",&info)) {
d2128 1
a2128 1
	result = Tcl_CloseObjCmd(info.objClientData,interp,argc+1,objv);
d2655 2
a2656 2
    //Namespace *expNsPtr = (Namespace *) Tcl_FindNamespace(interp, "::exp", NULL, 0);
    //char cmdnamebuf[80];
d2659 1
d2661 19
a2679 8
	//if (!expNsPtr || !(Tcl_FindHashEntry(&expNsPtr->cmdTable,c->name))) {
	    //sprintf(cmdnamebuf, "::exp::%s",c->name); 
	    if (c->objproc) {
		Tcl_CreateObjCommand(interp,c->name,c->objproc,c->data,NULL);
	    } else {
		Tcl_CreateCommand(interp,c->name,c->proc,c->data,NULL);
	    }
	//}
d2684 1
a2684 1
{"exp_close",	0, Exp_CloseCmd,	0,	0},
d2686 1
a2686 1
{"debug",	0, Exp_DebugCmd,	0,	0},
d2688 1
a2688 1
{"internal", 0, Exp_ExpInternalCmd,	0,	0},
d2690 1
a2690 1
{"disconnect",	0, Exp_DisconnectCmd,	0,	0},
d2692 3
a2694 3
{"exp_exit",	0, Exp_ExitCmd,	0,	0},
/*{"exp::_continue",	0, Exp_ExpContinueDeprecatedCmd,0,0},*/
{"exp_continue",0,Exp_ExpContinueCmd,0,	0},
d2696 1
a2696 1
{"fork",	0, Exp_ForkCmd,	0,	0},
d2698 7
a2704 7
{"exp_pid",	0, Exp_ExpPidCmd,	0,	0},
{"getpid",	0, Exp_GetpidDeprecatedCmd,0,	0},
{"interpreter",	0, Exp_InterpreterCmd,	0,	0},
{"kill",	0, Exp_KillCmd,	0,	0},
{"log_file",	0, Exp_LogFileCmd,	0,	0},
{"log_user",	0, Exp_LogUserCmd,	0,	0},
{"exp_open",	0, Exp_OpenCmd,	0,	0},
d2706 1
a2706 1
{"overlay",	0, Exp_OverlayCmd,	0,	0},
d2708 11
a2718 11
{"inter_return",0, Exp_InterReturnCmd,	0,	0},
{"send",	0, Exp_SendCmd,	(ClientData)NULL,	0},
/*{"exp::send_spawn",	0, Exp_SendCmd,	(ClientData)NULL,	0},deprecat*/
{"send_error",	0, Exp_SendCmd,	(ClientData)"stderr",	0},
{"send_log",	0, Exp_SendLogCmd,	0,	0},
{"send_tty",	0, Exp_SendCmd,	(ClientData)"exp_tty",	0},
{"send_user",	0, Exp_SendCmd,	(ClientData)"exp_user",	0},
{"sleep",	0, Exp_SleepCmd,	0,	0},
{"spawn",	0, Exp_SpawnCmd,	0,	0},
{"strace",	0, Exp_StraceCmd,	0,	0},
{"wait",	0, Exp_WaitCmd,	0,	0},
@


1.1.2.1.2.2
log
@moved all header files over to a more core style with the beginnings of a
Stubs table.  This work is far from complete.
@
text
@d21 1
a23 1
/*
a33 3
*/

#include "expInt.h"
d188 1
a188 1
    CONST char *chan;			/* Channel name */
d191 1
a191 1
    CONST char *msg;
d529 1
a529 1
    exp_debuglog("getpid is deprecated, use pid\r\n");
d559 1
a559 1
    CONST char *s = exp_get_var(interp,EXP_SPAWN_ID_VARNAME);
d633 1
a633 1
    CONST char *s = exp_get_var(interp,"send_slow");
d732 1
a732 1
    CONST char *s = exp_get_var(interp,"send_human");
d854 1
a854 1
    exp_debuglog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
d1227 1
a1227 1
    CONST char *p;			/* string representation of list of spawn ids*/
d1374 1
a1374 1
    exp_debuglog("spawn: returns {%s}\r\n",interp->result);
d1424 2
a1425 2
    if (exp_debugfile) Tcl_Write(exp_debugfile, string, len);
    if (exp_logfile) Tcl_Write(exp_logfile, string, len);
d1580 1
a1580 1
	exp_debuglog("send: sending \"%s\" to {",dprintify(string));
d1584 2
a1585 2
	if (exp_debugfile) {
	    Tcl_Write(exp_debugfile, string, len);
d1590 4
a1593 4
	      strcmp((char *) clientData, "exp_tty") == 0) && exp_logfile_all) ||
	    exp_logfile) {
	    if (exp_logfile) {
		Tcl_Write(exp_logfile, string, len);
d1603 1
a1603 1
	    exp_debuglog(" %s ", f->spawnId);
d1646 1
a1646 1
	exp_debuglog("}\r\n");
d1687 2
a1688 2
    int old_logfile_all = exp_logfile_all;
    Tcl_Channel old_logfile = exp_logfile;
d1728 2
a1729 2
	    if (exp_logfile) {
		if (exp_logfile_all) strcat(interp->result,"-a ");
d1753 2
a1754 2
    exp_logfile = 0;
    exp_logfile_all = aflag;
d1761 2
a1762 2
	exp_logfile = Tcl_OpenFileChannel(interp, filename, type, O_CREAT|S_IWRITE);
	if (exp_logfile == (Tcl_Channel) NULL) {
d1771 1
a1771 1
	if (!(exp_logfile = Tcl_GetChannel(interp,openarg,&mode))) {
d1793 2
a1794 2
    if (exp_logfile) {
	Tcl_SetChannelOption(interp, exp_logfile, "-buffering", "none");
d1810 2
a1811 2
	exp_logfile = old_logfile;
	exp_logfile_all = old_logfile_all;
d1851 1
a1851 1
    int old_loguser = exp_loguser;
d1856 2
a1857 2
	if (0 == atoi(argv[1])) exp_loguser = FALSE;
	else exp_loguser = TRUE;
d1859 1
a1859 1
	exp_error(interp, "usage: [-info|1|0]");
d1862 1
a1862 1
    Tcl_SetObjResult(interp, Tcl_NewIntObj(old_loguser));
d1949 1
a1949 1
	if (exp_debugfile) {
d1963 2
a1964 2
	if (exp_debugfile) {
	    Tcl_Close(interp, exp_debugfile);
d1967 2
a1968 2
	exp_debugfile = Tcl_OpenFileChannel(interp, argv[0], "a", O_APPEND|S_IWRITE);
	if (exp_debugfile == (Tcl_Channel) NULL) {
d1974 1
a1974 1
	Tcl_SetChannelOption(interp, exp_debugfile, "-buffering", "none");
d1982 3
a1984 3
    if (fopened == FALSE && exp_debugfile) {
	Tcl_Close(interp, exp_debugfile);
	exp_debugfile = NULL;
d2117 1
a2117 2
	/* So what!  the global namespace belongs to the core. */
	/*Tcl_Obj **objv;
d2136 1
a2136 5
	return result;*/
	Tcl_SetResult(interp,
		"Cannot close the channel as it isn't an expect channel.",
		TCL_STATIC);
	return TCL_ERROR;
d2191 1
a2191 1
    exp_errorlog("%2d",level);
d2193 1
a2193 1
    exp_errorlog("%s\r\n",command);
d2498 1
a2498 1
	    exp_debuglog("continue -expect is deprecated, use exp_continue\r\n");
d2521 1
a2521 1
    exp_error(interp,"usage: exp::continue [-continue_timer]\n");
a2526 2

/* Why is this here?
d2537 1
a2537 1
/*
d2560 1
a2560 1
}*/
d2658 1
a2658 1
    Namespace *expNsPtr = (Namespace *) Tcl_FindNamespace(interp, "::exp", NULL, 0);
d2663 1
a2663 1
	if (!expNsPtr || !(Tcl_FindHashEntry(&expNsPtr->cmdTable,c->name))) {
d2670 1
a2670 1
	}
d2675 1
a2675 1
    {"exp_close",	0, Exp_CloseCmd,	0,	0},
d2677 1
a2677 1
    {"debug",	0, Exp_DebugCmd,	0,	0},
d2679 1
a2679 1
    {"exp_internal", 0, Exp_ExpInternalCmd,	0,	0},
d2681 1
a2681 1
    {"::exp::disconnect",	0, Exp_DisconnectCmd,	0,	0},
d2683 1
a2683 1
    {"exp_exit",	0, Exp_ExitCmd,	0,	0},
d2685 1
a2685 1
    {"exp_continue",0,Exp_ExpContinueCmd,0,	0},
d2687 1
a2687 1
    {"::exp::fork",	0, Exp_ForkCmd,	0,	0},
d2689 7
a2695 7
    {"exp_pid",	0, Exp_ExpPidCmd,	0,	0},
    {"exp_getpid",	0, Exp_GetpidDeprecatedCmd,0,	0},
    {"exp_interpreter",	0, Exp_InterpreterCmd,	0,	0},
    {"kill",	0, Exp_KillCmd,	0,	0},
    {"log_file",	0, Exp_LogFileCmd,	0,	0},
    {"log_user",	0, Exp_LogUserCmd,	0,	0},
    {"exp_open",	0, Exp_OpenCmd,	0,	0},
d2697 1
a2697 1
    {"overlay",	0, Exp_OverlayCmd,	0,	0},
d2699 12
a2710 13
    /*{"::exp::inter_return",0, Exp_InterReturnCmd,	0,	0}, why is this here?*/
    {"send",	0, Exp_SendCmd,	(ClientData)NULL,	0},
    /*{"exp::send_spawn",	0, Exp_SendCmd,	(ClientData)NULL,	0},deprecat*/
    {"send_error",	0, Exp_SendCmd,	(ClientData)"stderr",	0},
    {"send_log",	0, Exp_SendLogCmd,	0,	0},
    {"send_tty",	0, Exp_SendCmd,	(ClientData)"exp_tty",	0},
    {"send_user",	0, Exp_SendCmd,	(ClientData)"exp_user",	0},
    {"sleep",	0, Exp_SleepCmd,	0,	0},
    {"spawn",	0, Exp_SpawnCmd,	0,	0},
    {"strace",	0, Exp_StraceCmd,	0,	0},
    {"wait",	0, Exp_WaitCmd,	0,	0},
    {0}
};
d2739 3
a2741 3
    Tcl_SetVar(interp,"::exp::user_spawn_id",EXP_SPAWN_ID_USER,0);
    Tcl_SetVar(interp,"::exp::error_spawn_id",EXP_SPAWN_ID_ERROR,0);
    Tcl_SetVar(interp,"::exp::tty_spawn_id","exp_tty",0);
@


1.1.2.1.2.3
log
@More rounds of edits getting the new Stubs table more towards perfection.
@
text
@d158 1
a158 1
    CONST char *msg;
@


1.1.2.1.2.4
log
@All file comments have the same form.
@
text
@d1 1
a1 1
/* ----------------------------------------------------------------------------
d4 1
a4 1
 *	The bulk of the Expect commands, platform generic.
d6 1
a6 1
 * ----------------------------------------------------------------------------
a7 2
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
d11 8
a18 14
 * 
 * Copyright (c) 1997 Mitel Corporation
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
 *
 * Copyright (c) 2001-2002 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
 *
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: exp.h,v 1.1.4.4 2002/02/10 10:17:04 davygrvy Exp $
 * ----------------------------------------------------------------------------
d21 15
a36 1
#include <math.h>
@


1.1.2.1.2.5
log
@Changed a few functions to be CONST char* and some general reformatting
to improve readability.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expCommand.c,v 1.1.2.1.2.4 2002/02/10 12:04:22 davygrvy Exp $
d1080 5
a1084 5
    char *arg;	    /* spawn id list or a variable containing a list */
    int duration;   /* if we have to copy the args */
		    /* should only need do this in expect_before/after */
    Tcl_VarTraceProc *updateproc; /* proc to invoke if indirect is written */
    CONST char *msg;/* Error message identifier */
@


1.1.2.2
log
@large amount of edits to make it work (again).  Needs to be checked against
the snap29 mods.
@
text
@d21 11
a31 11
//#include <math.h>
//#include "tclInt.h"
//#include "tclPort.h"
//#include "exp_port.h"
//#include "expect_tcl.h"
//#include "exp_command.h"
//#include "exp_rename.h"
//#include "exp_log.h"
//#include "exp_event.h"
//#include "exp_prog.h"
//#include "exp_tty.h"
d33 2
a34 2
#include <math.h>		/* for log/pow computation in send -h */
#include "expInt.h"
d37 4
a40 1
 * These constants refer to the UTF string that encodes a null character.
d42 1
d44 5
a48 20
#define NULL_STRING "\300\200" /* hex C080 */
#define NULL_LENGTH 2

/*
 *  Found in either pty_sgtttyb.c, pty_termios.c, or pty_unicos.c
 */

extern int exp_getptymaster();
extern int exp_getptyslave();

int exp_forked = FALSE;		/* whether we are child process */

/* the following are use to create reserved addresses, to be used as ClientData */
/* args to be used to tell commands how they were called. */
/* The actual values won't be used, only the addresses, but I give them */
/* values out of my irrational fear the compiler might collapse them all. */
static int sendCD_error = 2;	/* called as send_error */
static int sendCD_user = 3;	/* called as send_user */
static int sendCD_proc = 4;	/* called as send or send_spawn */
static int sendCD_tty = 6;	/* called as send_tty */
d60 1
a60 4
 * exp_configure_count is incremented whenever a spawned process is closed
 * or an indirect list is modified.  This forces any (stack of) expect or
 * interact commands to reexamine the state of the world and adjust
 * accordingly.
d62 1
a62 1
int exp_configure_count = 0;
d64 4
a67 39
#ifdef HAVE_PTYTRAP
/* slaveNames provides a mapping from the pty slave names to our */
/* spawn id entry.  This is needed only on HPs for stty, sigh. */
static Tcl_HashTable slaveNames;
#endif /* HAVE_PTYTRAP */

typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    ExpState *stdinout;
    ExpState *stderrX;   /* grr....stderr is a macro */
    ExpState *devtty;
    ExpState *any; /* for any_spawn_id */

    Tcl_Channel *diagChannel;
    Tcl_DString diagDString;
    int diagEnabled;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;


struct slow_arg {
    int size;
    double time;
};


/* Local prototypes for functions used only here that are not shared. */
static void	exp_wait_zero _ANSI_ARGS_((WAIT_STATUS_TYPE *status));
static void	expBusy _ANSI_ARGS_((ExpState *esPtr));
static int	exact_write _ANSI_ARGS_((ExpState *esPtr,char *buffer,int rembytes));

static int	human_write _ANSI_ARGS_((Tcl_Interp *interp, ExpState *esPtr,
			char *buffer, struct human_arg *arg));
static int	get_slow_args _ANSI_ARGS_((Tcl_Interp *interp, struct slow_arg *x));
d69 1
a69 3


static void	tcl_tracer _ANSI_ARGS_((ClientData clientData,
d73 1
a73 4



static void	exp_i_add_f _ANSI_ARGS_((struct exp_i *,
d75 1
a75 1
static void	exp_f_closed _ANSI_ARGS_((struct exp_f *));
d81 1
a81 1
 * init_traps --
d83 2
a84 1
 *	Not sure what this does.
d90 1
a90 1
 *	No clue.
d95 2
a96 4
#ifdef FULLTRAPS
static void
init_traps(traps)
RETSIGTYPE (*traps[])();
d98 3
a100 1
	int i;
d102 4
a105 3
	for (i=1;i<NSIG;i++) {
		traps[i] = SIG_ERR;
	}
a106 2
#endif

d111 1
a111 1
 * exp_error --
d113 1
a113 2
 *	Formats an error message into the interp.  Do not terminate
 *	format strings with \n!!!.
a117 3
 * Side Effects:
 *	An error message is written into interp->result
 *
d120 3
a122 2
void
exp_error TCL_VARARGS_DEF(Tcl_Interp *,arg1)
d124 1
a124 4
	Tcl_Interp *interp;
	char *fmt;
	va_list args;
	char buffer[2000];
d126 3
a128 5
	interp = TCL_VARARGS_START(Tcl_Interp *,arg1,args);
	fmt = va_arg(args,char *);
	vsprintf(buffer,fmt,args);
	Tcl_SetResult(interp,buffer,TCL_VOLATILE);
	va_end(args);
d134 1
a134 1
 * expStateCurrent --
d136 1
a136 1
 *	If 0, may be immediately followed by return TCL_ERROR.
d139 4
a142 1
 *	current ExpState or 0
d146 3
a148 2
struct ExpState *
expStateCurrent(interp,opened,adjust,any)
d150 4
a153 3
    int opened;
    int adjust;
    int any;
d155 6
a160 1
    static char *user_spawn_id = "exp0";
d162 2
a163 4
    char *name = exp_get_var(interp,EXP_SPAWN_ID_VARNAME);
    if (!name) name = user_spawn_id;

    return expStateFromChannelName(interp,name,opened,adjust,any,EXP_SPAWN_ID_VARNAME);
d169 1
a169 1
 * expStateCheck --
d171 2
a172 1
 *	Add comment here.
d175 4
a178 1
 *	
d182 3
a184 2
ExpState *
expStateCheck(interp,esPtr,open,adjust,msg)
d186 3
a188 3
    ExpState *esPtr;
    int open;
    int adjust;
d191 12
a202 3
    if (open && !esPtr->open) {
	exp_error(interp,"%s: spawn id %s not open",msg,esPtr->name);
	return(0);
d204 2
a205 2
    if (adjust) expAdjust(esPtr);
    return esPtr;
d211 1
a211 1
 * expStateFromChannelName --
d213 1
a213 1
 *	Add comment here.
d216 4
a219 1
 *	
d223 3
a225 2
ExpState *
expStateFromChannelName(interp,name,open,adjust,any,msg)
d227 1
a227 4
    char *name;
    int open;
    int adjust;
    char *msg;
d229 6
a234 9
    ExpState *esPtr;
    Tcl_Channel channel;
    char *chanName;

    if (any) {
	if (0 == strcmp(name,EXP_SPAWN_ID_ANY_LIT)) {
	    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
	    return tsdPtr->any;
	}
d237 1
a237 2
    channel = Tcl_GetChannel(interp,name,(int *)0);
    if (!channel) return(0);
d239 17
a255 4
    chanName = Tcl_GetChannelName(channel);
    if (!isExpChannelName(chanName)) {
	exp_error(interp,"%s: %s is not an expect channel - use spawn -open to convert",msg,chanName);
	return(0);
d258 1
a258 3
    esPtr = (ExpState *)Tcl_GetChannelInstanceData(channel);

    return expStateCheck(interp,esPtr,open,adjust,msg);
d264 1
a264 1
 * exp_wait_zero --
d266 1
a266 1
 *	Zero out the wait status field.
d269 1
a269 1
 *	None
d273 5
a277 3
void
exp_wait_zero(status)
    WAIT_STATUS_TYPE *status;
d279 1
a279 1
    int i;
d281 3
a283 2
    for (i = 0; i < sizeof(WAIT_STATUS_TYPE); i++) {
	((char *)status)[i] = 0;
d285 1
d291 1
a291 1
 * exp_state_prep_for_invalidation --
d293 5
a297 1
 *	called just before an ExpState entry is about to be invalidated.
d300 1
a300 1
 *	None
d304 3
a306 2
void
exp_state_prep_for_invalidation(interp,esPtr)
d308 3
a310 1
    ExpState *esPtr;
d312 48
a359 1
    exp_ecmd_remove_state_direct_and_indirect(interp,esPtr);
d361 4
a364 1
    exp_configure_count++;
d366 3
a368 2
    if (esPtr->fg_armed) {
	exp_event_disarm_fg(esPtr);
d370 2
d377 1
a377 1
 * exp_trap_on --
d379 1
a379 1
 *	Add comment here.
d386 1
a386 1
/*ARGSUSED*/
d388 2
a389 2
exp_trap_on(master)
    int master;
d391 19
a409 4
#ifdef HAVE_PTYTRAP
    if (master == -1) return;
    exp_slave_control(master,1);
#endif /* HAVE_PTYTRAP */
d415 1
a415 1
 * exp_trap_off --
d417 2
a418 1
 *	Add comment here.
d425 4
a428 3
int
exp_trap_off(name)
    char *name;
d430 1
a430 3
#ifdef HAVE_PTYTRAP
    ExpState *esPtr;
    int enable = 0;
d432 1
a432 5
    Tcl_HashEntry *entry = Tcl_FindHashEntry(&slaveNames,name);
    if (!entry) {
	expDiagLog("exp_trap_off: no entry found for %s\n",name);
	return -1;
    }
d434 2
a435 3
    esPtr = (ExpState *)Tcl_GetHashValue(entry);
    
    exp_slave_control(esPtr->fdin,0);
d437 3
a439 4
    return esPtr->fdin;
#else
    return name[0];	/* pacify lint, use arg and return something */
#endif
d445 1
a445 1
 * expBusy --
d447 1
a447 1
 *	Add comment here.  Has OS depedancies.
d450 3
d455 3
d460 8
a467 3
void
expBusy(esPtr)
     ExpState *esPtr;
d469 18
a486 5
#ifndef __WIN32__
    int x = open("/dev/null",0);
    if (x != esPtr->fdin) {
	fcntl(x,F_DUPFD,esPtr->fdin);
	close(x);
d488 9
a496 5
    expCloseOnExec(esPtr->fdin);
    esPtr->fdBusy = TRUE;
#else
    /* what goes here? */
#endif
a498 28




























d502 1
a502 1
 * exp_close --
d504 2
a505 1
 *	Close a connection.
d508 3
d513 2
a514 2
 * Side Effects:
 *	A native file handle is closed
d518 5
a522 2
int
exp_close(interp, esPtr)
d524 2
a525 1
    ExpState *esPtr;
d527 2
a528 47
    if (0 == expStateCheck(interp,esPtr,1,0,"close")) return TCL_ERROR;
    esPtr->open = FALSE;

    /*
     * Ignore close errors from ptys.  Ptys on some systems return errors for
     * no evident reason.  Anyway, receiving an error upon pty-close doesn't
     * mean anything anyway as far as I know.  
     */

    close(esPtr->fdin);
    if (esPtr->fd_slave != EXP_NOFD) close(esPtr->fd_slave);
    if (esPtr->fdin != esPtr->fdout) close(esPtr->fdout);

    if (esPtr->channel_orig && !esPtr->leaveopen) {
	/*
	 * Ignore close errors from Tcl channels.  They indicate things
	 * like broken pipelines, etc, which don't affect our
	 * subsequent handling.
	 */
	Tcl_VarEval(interp,"close ",Tcl_GetChannelName(esPtr->channel_orig),
		(char *)0);
    }

#ifdef HAVE_PTYTRAP
    if (esPtr->slave_name) {
	Tcl_HashEntry *entry;
	
	entry = Tcl_FindHashEntry(&slaveNames,esPtr->slave_name);
	Tcl_DeleteHashEntry(entry);

	ckfree(esPtr->slave_name);
	esPtr->slave_name = 0;
    }
#endif

    exp_state_prep_for_invalidation(interp,esPtr);

    if (esPtr->user_waited) {
	if (esPtr->registered) {
	    Tcl_UnregisterChannel(interp,esPtr->channel);
	    /* at this point esPtr may have been freed so don't touch it
               any longer */
	}
    } else {
      expBusy(esPtr);
    }

d535 1
a535 1
 * expStateAnyIs --
d537 1
a537 3
 *	report whether this ExpState represents special spawn_id_any
 *	we need a separate function because spawn_id_any is thread-specific
 *	and can't be seen outside this file.
d540 1
d542 5
a549 7
int
expStateAnyIs(esPtr)
    ExpState *esPtr;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return (esPtr == tsdPtr->any);
}
d551 2
a552 101
/*
 *----------------------------------------------------------------------
 *
 * expDevttyIs --
 *
 *	Add comment here.
 *
 * Results:
 *	
 *
 *----------------------------------------------------------------------
 */
int
expDevttyIs(esPtr)
    ExpState *esPtr;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return (esPtr == tsdPtr->devtty);
}

/*
 *----------------------------------------------------------------------
 *
 * expStdinoutIs --
 *
 *	Add comment here.
 *
 * Results:
 *	
 *
 *----------------------------------------------------------------------
 */
int
expStdinoutIs(esPtr)
ExpState *esPtr;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return (tsdPtr->stdinout == esPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * expStdinoutGet --
 *
 *	Add comment here.
 *
 * Results:
 *	
 *
 *----------------------------------------------------------------------
 */
ExpState *
expStdinoutGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->stdinout;
}

/*
 *----------------------------------------------------------------------
 *
 * expDevttyGet --
 *
 *	Add comment here.
 *
 * Results:
 *	
 *
 *----------------------------------------------------------------------
 */
ExpState *
expDevttyGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->devtty;
}

/*
 *----------------------------------------------------------------------
 *
 * Exp_ExpPidCmd --
 *
 *	Implements the "exp_pid" command
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	None
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
int
Exp_ExpPidCmd(clientData,interp,argc,argv)
    ClientData clientData;
d554 2
a555 2
    int argc;
    char **argv;
d557 3
a559 17
    char *chanName = 0;
    ExpState *esPtr = 0;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-i")) {
	    argc--; argv++;
	    if (!*argv) goto usage;
	    chanName = *argv;
	} else goto usage;
    }

    if (chanName) {
	if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"exp_pid"))) return TCL_ERROR;
    } else {
	if (!(esPtr = expStateCurrent(interp,0,0,0))) return TCL_ERROR;
d561 1
a561 40
    
    sprintf(interp->result,"%d",esPtr->pid);
    return TCL_OK;
  usage:
    exp_error(interp,"usage: -i spawn_id");
    return TCL_ERROR;
}

#if 0
/*
 *----------------------------------------------------------------------
 *
 * Exp_GetpidDeprecatedCmd --
 *
 *	Implements the old 'getpid' command.  This command is has
 *	been deprecated and may not be supported in the future
 *
 * Results:
 *	A standard Tcl result
 *
 * Side Effects:
 *	None
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */

/*ARGSUSED*/
static int
Exp_GetpidDeprecatedCmd(clientData, interp, argc, argv)
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
{
    debuglog("getpid is deprecated, use pid\r\n");
    sprintf(interp->result,"%d",exp_getpidproc());
    return(TCL_OK);
a562 1
#endif
d603 4
a606 23
/*
 *----------------------------------------------------------------------
 *
 * exact_write --
 *
 *	If this works, exact_write should disappear and function should
 *	call Tcl_WriteChars directly.
 *
 * Notes:
 *	OS independent
 *
 *----------------------------------------------------------------------
 */
int
exact_write(esPtr,buffer,rembytes) /* INTL */
    ExpState *esPtr;
    char *buffer;
    int rembytes;
{
    Tcl_WriteChars(esPtr->channel,buffer,rembytes);
    return(0);
}

d624 2
a625 1
int
d630 1
a630 1
    int sc;		/* return from scanf */
a669 1
/* returns 0 for success, -1 for failure, pos. for Tcl return value */
d671 1
a671 1
slow_write(interp,esPtr,buffer,rembytes,arg) /* INTL */
d673 1
a673 1
    ExpState *esPtr;
d682 1
a682 1
		
d684 1
a684 1
	if (0 > Tcl_WriteChars(esPtr->channel,buffer,len)) return -1;
d691 1
a691 1
	    if (rc > 0) return rc;
d694 1
a694 1
    return 0;
d823 1
a823 1
 * human_write --
d838 1
d840 1
a840 1
human_write(interp,esPtr,buffer,arg) /* INTL */
d842 1
a842 1
    ExpState *esPtr;
a846 1
    int size;
d849 1
a850 2
    int in_word = TRUE;
    Tcl_UniChar ch;
d852 2
a853 2
    expDiagLog("human_write: avg_arr=%f/%f  1/shape=%f  min=%f  max=%f\r\n",
	    arg->alpha,arg->alpha_eow,arg->c,arg->min,arg->max);
d855 1
a855 2
    for (sp = buffer;*sp;sp += size) {
	size = Tcl_UtfToUniChar(sp, &ch);
d857 1
a857 1
	if (in_word && (Tcl_UniCharIsPunct(ch) || Tcl_UniCharIsSpace(ch)))
d860 1
a860 1
	in_word = !(Tcl_UniCharIsPunct(ch) || Tcl_UniCharIsSpace(ch));
d862 1
a862 1
	t = alpha * pow(-log((double)unit_random()),arg->c);
d868 2
a869 1
		/* skip sleep before writing first character */
d875 4
a878 2
	wc = Tcl_WriteChars(esPtr->channel, sp, size);
	if (0 > wc) return(wc);
d884 1
a884 1
struct exp_state_list *exp_state_list_pool = 0;
d887 1
a887 1
#define EXP_FD_INIT_COUNT	10
d898 1
a898 1
		EXP_I_INIT_COUNT * sizeof(struct exp_i));
d911 1
a911 1
    i->state_list = 0;
d917 20
a936 3
struct exp_state_list *
exp_new_state(esPtr)
    ExpState *esPtr;
d939 1
a939 1
    struct exp_state_list *fd;
d941 5
a945 6
    if (!exp_state_list_pool) {
	/* none avail, generate some new ones */
	exp_state_list_pool = fd = (struct exp_state_list *)ckalloc(
	    EXP_FD_INIT_COUNT * sizeof(struct exp_state_list));
	for (n=0;n<EXP_FD_INIT_COUNT-1;n++,fd++) {
	    fd->next = fd+1;
d947 1
a947 1
	fd->next = 0;
d950 5
a954 1
    /* now that we've made some, unlink one and give to user */
d956 12
a967 6
    fd = exp_state_list_pool;
    exp_state_list_pool = exp_state_list_pool->next;
    fd->esPtr = esPtr;
    /* fd->next is assumed to be changed by caller */
    return fd;
}
d970 2
a971 2
exp_free_state(fd_first)
    struct exp_state_list *fd_first;
d973 1
a973 1
    struct exp_state_list *fd, *penultimate;
d975 1
a975 1
    if (!fd_first) return;
d977 4
a980 2
    /* link entire chain back in at once by first finding last pointer */
    /* making that point back to pool, and then resetting pool to this */
d983 2
a984 2
    for (fd = fd_first;fd;fd=fd->next) {
	penultimate = fd;
d986 2
a987 2
    penultimate->next = exp_state_list_pool;
    exp_state_list_pool = fd_first;
d990 14
a1003 1
/* free a single fd */
d1005 2
a1006 2
exp_free_state_single(fd)
    struct exp_state_list *fd;
d1008 2
a1009 2
    fd->next = exp_state_list_pool;
    exp_state_list_pool = fd;
d1016 1
a1016 1
    Tcl_VarTraceProc *updateproc;	/* proc to invoke if indirect is written */
d1020 1
a1020 1
    exp_free_state(i->state_list);
d1024 2
a1025 2
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
		updateproc,(ClientData)i);
d1028 13
a1040 12
    /* here's the long form
       if duration & direct	free(var)  free(val)
	PERM	  DIR	    		1
	PERM	  INDIR	    1		1
	TMP	  DIR
	TMP	  INDIR			1
	Also if i->variable was a bogus variable name, i->value might not be
	set, so test i->value to protect this
	TMP in this case does NOT mean from the "expect" command.  Rather
	it means "an implicit spawn id from any expect or expect_XXX
	command".  In other words, there was no variable name provided.
    */
d1042 3
a1044 2
	    && (((i->direct == EXP_DIRECT) && (i->duration == EXP_PERMANENT))
	    || ((i->direct == EXP_INDIRECT) && (i->duration == EXP_TEMPORARY)))) {
d1055 23
a1077 2
/* generate a descriptor for a "-i" flag */
/* cannot fail */
d1079 1
a1079 1
exp_new_i_complex(interp,arg,duration,updateproc)
d1083 1
a1083 1
			/* should only need do this in expect_before/after */
d1085 1
d1089 18
a1106 8

    i = exp_new_i();

    i->direct = (isExpChannelName(arg)?EXP_DIRECT:EXP_INDIRECT);
#if OBSOLETE
    i->direct = (isdigit(arg[0]) || (arg[0] == '-'))?EXP_DIRECT:EXP_INDIRECT;
#endif
    if (i->direct == EXP_DIRECT) {
a1107 2
    } else {
	stringp = &i->variable;
d1117 2
a1118 2

    i->state_list = 0;
d1120 1
a1120 1

d1122 1
a1122 1

d1124 2
a1125 3
	Tcl_TraceVar(interp, i->variable,
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES,
		updateproc, (ClientData) i);
d1127 1
a1127 1

d1131 15
a1145 6
void
exp_i_add_state(i,esPtr)
    struct exp_i *i;
    ExpState *esPtr;
{
    struct exp_state_list *new_state;
a1146 6
    new_state = exp_new_state(esPtr);
    new_state->next = i->state_list;
    i->state_list = new_state;
}

/* this routine assumes i->esPtr is meaningful */
d1148 1
a1148 2
exp_i_parse_states(interp,i) /* INTL */
    Tcl_Interp *interp;
d1150 1
d1152 1
a1152 5
    struct ExpState *esPtr;
    char *p = i->value;
    int argc;
    char **argv;
    int j;
d1154 4
a1157 1
    if (Tcl_SplitList(NULL, p, &argc, &argv) != TCL_OK) goto error;
d1159 46
a1204 11
    for (j = 0; j < argc; j++) {
        esPtr = expStateFromChannelName(interp,argv[j],1,0,0,"");
	if (!esPtr) goto error;
	exp_i_add_state(i,esPtr);
    }
    ckfree((char*)argv);
    return;
error:
    expDiagLogU("exp_i_parse_states: ");
    expDiagLogU(Tcl_GetStringResult(interp));
    return;
d1207 13
a1219 1
/* updates a single exp_i struct */
d1225 1
a1225 1
    char *p;	/* string representation of list of spawn ids */
d1231 1
a1231 2
	    /* *really* big variable names could blow up expDiagLog! */
	    expDiagLog("warning: indirect variable %s undefined",i->variable);
d1233 1
a1233 1
    
d1236 1
a1236 1
      
d1243 2
a1244 2
	exp_free_state(i->state_list);
	i->state_list = 0;
d1248 1
a1248 1
	i->state_list = 0;
d1250 1
a1250 2
    exp_i_parse_states(interp, i);
    return;
d1253 13
d1267 4
a1270 4
exp_new_i_simple(esPtr,duration)
    ExpState *esPtr;
    int duration;   /* if we have to copy the args */
		    /* should only need do this in expect_before/after */
d1275 1
d1278 3
a1280 1
    exp_i_add_state(i,esPtr);
d1284 109
d1401 3
d1406 1
d1418 8
a1425 2
    expLogDiagU(*argv);
    return TCL_OK;
d1428 23
a1451 3
/* I've rewritten this to be unbuffered.  I did this so you could shove */
/* large files through "send".  If you are concerned about efficiency */
/* you should quote all your send args to make them one single argument. */
d1453 2
a1454 2
int
Exp_SendObjCmd(clientData, interp, objc, objv) /* INTL */
d1457 2
a1458 2
    int objc;
    Tcl_Obj *CONST objv[];
d1460 1
a1460 3
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr = 0;
    int rc; 	/* final result of this procedure */
d1463 1
a1463 1
#define SEND_STYLE_STRING_MASK	0x07	/* mask to detect a real string arg */
d1472 5
a1476 5
    int len = -1;		/* length of string to send */
    int zeros;		/* count of how many ascii zeros to send */

    char *chanName = 0;
    struct exp_state_list *state_list;
d1478 12
a1489 16
    int j;

    static char *options[] = {
	"-i", "-h", "-s", "-null", "-0", "-raw", "-break", "--", (char *)0
    };
    enum options {
	SEND_SPAWNID, SEND_HUMAN, SEND_SLOW, SEND_NULL, SEND_ZERO,
	SEND_RAW, SEND_BREAK, SEND_LAST
    };

    for (j = 1; j < objc; j++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[j]);
	if (name[0] != '-') {
d1491 43
a1533 3
	}
	if (Tcl_GetIndexFromObj(interp, objv[j], options, "flag", 0,
		&index) != TCL_OK) {
a1535 45
	switch ((enum options) index) {
	    case SEND_SPAWNID:
		j++;
		chanName = Tcl_GetString(objv[j]);
		break;

	    case SEND_LAST:
		j++;
		goto getString;

	    case SEND_HUMAN:
		if (-1 == get_human_args(interp,&human_args))
		    return(TCL_ERROR);
		send_style = SEND_STYLE_HUMAN;
		break;

	    case SEND_SLOW:
		if (-1 == get_slow_args(interp,&slow_args))
		    return(TCL_ERROR);
		send_style = SEND_STYLE_SLOW;
		break;

	    case SEND_NULL:
	    case SEND_ZERO:
		j++;
		if (j >= objc) {
		    zeros = 1;
		} else if (Tcl_GetIntFromObj(interp, objv[j], &zeros)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		if (zeros < 1) return TCL_OK;
		send_style = SEND_STYLE_ZERO;
		string = "<zero(s)>";
		break;

	    case SEND_RAW:
		want_cooked = FALSE;
		break;

	    case SEND_BREAK:
		send_style = SEND_STYLE_BREAK;
		string = "<break>";
		break;
	}
d1537 1
a1537 1

d1539 2
a1540 2
	if (j != objc-1) {
	    exp_error(interp,"usage: send [args] string");
d1543 1
a1543 4
getString:
	string = Tcl_GetStringFromObj(objv[j], &len);
    } else {
	len = strlen(string);
d1545 14
a1558 9

    if (clientData == &sendCD_user) esPtr = tsdPtr->stdinout;
    else if (clientData == &sendCD_error) esPtr = tsdPtr->stderrX;
    else if (clientData == &sendCD_tty) esPtr = tsdPtr->devtty;
    else if (!chanName) {
	/* we want to check if it is open */
	/* but since stdin could be closed, we have to first */
	/* get the fd and then convert it from 0 to 1 if necessary */
	if (!(esPtr = expStateCurrent(interp,0,0,0))) return(TCL_ERROR);
d1560 7
a1566 3

    if (esPtr) {
	i = exp_new_i_simple(esPtr,EXP_TEMPORARY);
d1568 5
a1572 1
	i = exp_new_i_complex(interp,chanName,FALSE,(Tcl_VarTraceProc *)0);
d1574 3
a1576 7

#define send_to_stderr	(clientData == &sendCD_error)
#define send_to_proc	(clientData == &sendCD_proc)
#define send_to_user	((clientData == &sendCD_user) || \
			 (clientData == &sendCD_tty))

    if (send_to_proc) {
d1578 1
a1578 3
	expDiagLogU("send: sending \"");
	expDiagLogU(expPrintify(string));
	expDiagLogU("\" to {");
d1582 12
a1593 1
	expLogDiagU(string);
d1595 3
d1599 3
a1601 5
    for (state_list=i->state_list;state_list;state_list=state_list->next) {
	esPtr = state_list->esPtr;

	if (send_to_proc) {
	    expDiagLog(" %s ",esPtr->name);
d1605 1
a1605 1
	if (0 == expStateCheck(interp,esPtr,1,0,"send")) {
d1609 1
d1613 18
a1630 21
	    case SEND_STYLE_PLAIN:
		rc = exact_write(esPtr,string,len);
		break;
	    case SEND_STYLE_SLOW:
		rc = slow_write(interp,esPtr,string,len,&slow_args);
		break;
	    case SEND_STYLE_HUMAN:
		rc = human_write(interp,esPtr,string,&human_args);
		break;
	    case SEND_STYLE_ZERO:
		for (;zeros>0;zeros--) {
		    rc = Tcl_WriteChars(esPtr->channel,
			    NULL_STRING, NULL_LENGTH);
		}
		/* catching error on last write is sufficient */
		rc = ((rc==1) ? 0 : -1);   /* normal is 1 not 0 */
		break;
	    case SEND_STYLE_BREAK:
		exp_tty_break(interp,esPtr->fdout);
		rc = 0;
		break;
d1635 2
a1636 1
		exp_error(interp,"write(spawn_id=%d): %s",esPtr->fdout,Tcl_PosixError(interp));
d1642 5
a1646 2
    if (send_to_proc) expDiagLogU("}\r\n");

d1653 18
d1679 12
a1690 4
    static char resultbuf[1000];
    char *chanName = 0;
    int leaveOpen = FALSE;
    int logAll = FALSE;
d1693 16
a1708 1

d1713 3
a1715 2
	    if (!argv[1]) goto usage_error;
	    chanName = argv[1];
d1718 4
a1721 3
	    if (!argv[1]) goto usage_error;
	    chanName = argv[1];
	    leaveOpen = TRUE;
d1724 1
a1724 1
	    logAll = TRUE;
d1726 4
a1729 13
	    resultbuf[0] = '\0';
	    if (expLogChannelGet()) {
		if (expLogAllGet()) strcat(resultbuf,"-a ");
		if (!expLogAppendGet()) strcat(resultbuf,"-noappend ");
		if (expLogFilenameGet()) {
		    strcat(resultbuf,expLogFilenameGet());
		} else {
		    if (expLogLeaveOpenGet()) {
			strcat(resultbuf,"-leaveopen ");
		    }
		    strcat(resultbuf,Tcl_GetChannelName(expLogChannelGet()));
		}
		Tcl_SetResult(interp,resultbuf,TCL_STATIC);
d1741 1
a1741 1
	goto usage_error;
d1744 5
a1748 2
    if (chanName && filename) {
	goto usage_error;
d1750 25
d1776 2
a1777 8
    /* check if user merely wants to change logAll (-a) */
    if (expLogChannelGet() && (chanName || filename)) {
	if (filename && (0 == strcmp(filename,expLogFilenameGet()))) {
	    expLogAllSet(logAll);
	    return TCL_OK;
	} else if (chanName && (0 == strcmp(filename,Tcl_GetChannelName(expLogChannelGet())))) {
	    expLogAllSet(logAll);
	    return TCL_OK;
d1779 1
a1779 2
	    exp_error(interp,"cannot start logging without first stopping logging");
	    return TCL_ERROR;
d1781 9
d1791 7
a1797 4

    if (filename) {
	if (TCL_ERROR == expLogChannelOpen(interp,filename,append)) {
	    return TCL_ERROR;
d1799 2
a1800 9
    } else if (chanName) {
	if (TCL_ERROR == expLogChannelSet(interp,chanName)) {
	    return TCL_ERROR;
	}
    } else {
	expLogChannelClose(interp);
	if (logAll) {
	    exp_error(interp,"cannot use -a without a file or channel");
	    return TCL_ERROR;
d1803 1
a1803 3
    expLogAllSet(logAll);
    expLogLeaveOpenSet(leaveOpen);

d1805 15
a1819 3

 usage_error:
    exp_error(interp,"usage: log_file [-info] [-noappend] [[-a] file] [-[leave]open [open ...]]");
d1823 18
d1842 1
a1842 1
int
d1849 2
a1850 2
    int old_loguser = expLogUserGet();

d1854 2
a1855 1
	expLogUserSet(atoi(argv[1]));
d1859 1
a1859 1

d1861 1
a1861 1

d1866 13
d1880 1
a1880 1
int
d1887 1
a1887 1
    int now = FALSE;	/* soon if FALSE, now if TRUE */
d1927 1
a1927 2
#endif

d1930 1
a1930 1
int
d1937 13
a1949 9
    int newChannel = FALSE;
    Tcl_Channel oldChannel;
    static char resultbuf[1000];

    if ((argc > 1) && streq(argv[1],"-info")) {
	resultbuf[0] = '\0';
	oldChannel = expDiagChannelGet();
	if (oldChannel) {
	    sprintf(resultbuf,"-f %s ",expDiagFilename());
d1951 1
a1951 2
	strcat(resultbuf,expDiagToStderrGet()?"1":"0");
	Tcl_SetResult(interp,resultbuf,TCL_STATIC);
a1956 1

d1961 8
a1968 3
	expDiagChannelClose(interp);
	if (TCL_OK != expDiagChannelOpen(interp,argv[0])) {
	    return TCL_ERROR;
d1970 4
a1973 1
	newChannel = TRUE;
d1978 1
a1978 1
    
d1980 4
a1983 2
    if (!newChannel) {
	expDiagChannelClose(interp);
d1985 2
a1986 1
    expDiagToStderrSet(atoi(*argv));
d1989 3
a1991 1
    exp_error(interp,"usage: [-f file] 0|1");
d1995 13
d2011 1
a2011 1
int
d2028 1
a2028 1
			ckfree(exp_onexit_action);
d2048 1
a2048 2
    Tcl_Exit(value);

a2049 1
    return TCL_OK;
d2052 14
d2068 5
a2072 5
Exp_CloseObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];	/* Argument objects. */
d2074 1
a2074 2
    int onexec_flag = FALSE;	/* true if -onexec seen */
    int close_onexec;
d2076 6
a2081 2
    ExpState *esPtr = 0;
    char *chanName = 0;
d2083 2
a2084 2
    int objc_orig = objc;
    Tcl_Obj *CONST *objv_orig = objv;
d2086 1
a2086 1
    objc--; objv++;
d2088 4
a2091 4
    for (;objc>0;objc--,objv++) {
	if (streq("-i",Tcl_GetString(*objv))) {
	    objc--; objv++;
	    if (objc == 0) {
d2095 2
a2096 2
	    chanName = Tcl_GetString(*objv);
	} else if (streq(Tcl_GetString(*objv),"-slave")) {
d2098 4
a2101 4
	} else if (streq(Tcl_GetString(*objv),"-onexec")) {
	    objc--; objv++;
	    if (objc == 0) {
		exp_error(interp,"usage: -onexec 0|1");
d2104 1
a2104 2
	    onexec_flag = TRUE;
	    close_onexec = atoi(Tcl_GetString(*objv));
d2108 1
a2108 1
    if (objc) {
d2114 2
d2117 1
d2119 7
a2125 1
	if (0 == Tcl_GetCommandInfo(interp,"close",&info)) {
d2128 6
a2133 1
	return(Tcl_CloseObjCmd(info.clientData,interp,objc_orig,objv_orig));
d2136 4
a2139 2
    if (chanName) {
	if (!(esPtr = expStateFromChannelName(interp,chanName,1,0,0,"close"))) return TCL_ERROR;
d2141 4
a2144 1
	if (!(esPtr = expStateCurrent(interp,1,0,0))) return TCL_ERROR;
d2148 4
a2151 5
	if (esPtr->fd_slave != EXP_NOFD) {
	    close(esPtr->fd_slave);
	    esPtr->fd_slave = EXP_NOFD;

	    exp_slave_control(esPtr->fdin,1);
d2153 2
a2155 3
	} else {
	    exp_error(interp,"no such slave");
	    return TCL_ERROR;
d2157 2
d2161 1
d2165 1
a2165 1
//	fcntl(esPtr->fdin,F_SETFD,close_onexec);
d2168 1
d2170 1
a2170 1
    return(exp_close(interp,esPtr));
d2186 5
a2190 6

    /* come out on stderr, by using expErrorLog */
    expErrorLog("%2d",level);
    for (i = 0;i<level;i++) expErrorLogU("  ");
    expErrorLogU(command);
    expErrorLogU("\r\n");
d2201 2
a2202 106
    static int trace_level = 0;
    static Tcl_Trace trace_handle;

    if (argc > 1 && streq(argv[1],"-info")) {
	sprintf(interp->result,"%d",trace_level);
	return TCL_OK;
    }

    if (argc != 2) {
	exp_error(interp,"usage: trace level");
	return(TCL_ERROR);
    }
    /* tracing already in effect, undo it */
    if (trace_level > 0) Tcl_DeleteTrace(interp,trace_handle);

    /* get and save new trace level */
    trace_level = atoi(argv[1]);
    if (trace_level > 0)
	trace_handle = Tcl_CreateTrace(interp, trace_level, tcl_tracer, NULL);
    return(TCL_OK);
}

/* following defn's are stolen from tclUnix.h */

/*
 * The type of the status returned by wait varies from UNIX system
 * to UNIX system.  The macro below defines it:
 */

#if 0
#ifndef NO_UNION_WAIT
#   define WAIT_STATUS_TYPE union wait
#else
#   define WAIT_STATUS_TYPE int
#endif
#endif /* 0 */

/*
 * following definitions stolen from tclUnix.h
 * (should have been made public!)

 * Supply definitions for macros to query wait status, if not already
 * defined in header files above.
 */

#if 0
#ifndef WIFEXITED
#   define WIFEXITED(stat)  (((*((int *) &(stat))) & 0xff) == 0)
#endif

#ifndef WEXITSTATUS
#   define WEXITSTATUS(stat) (((*((int *) &(stat))) >> 8) & 0xff)
#endif

#ifndef WIFSIGNALED
#   define WIFSIGNALED(stat) (((*((int *) &(stat)))) && ((*((int *) &(stat))) == ((*((int *) &(stat))) & 0x00ff)))
#endif

#ifndef WTERMSIG
#   define WTERMSIG(stat)    ((*((int *) &(stat))) & 0x7f)
#endif

#ifndef WIFSTOPPED
#   define WIFSTOPPED(stat)  (((*((int *) &(stat))) & 0xff) == 0177)
#endif

#ifndef WSTOPSIG
#   define WSTOPSIG(stat)    (((*((int *) &(stat))) >> 8) & 0xff)
#endif
#endif /* 0 */

/* end of stolen definitions */

/* Describe the processes created with Expect's fork.
This allows us to wait on them later.

This is maintained as a linked list.  As additional procs are forked,
new links are added.  As procs disappear, links are marked so that we
can reuse them later.
*/

struct forked_proc {
	int pid;
	WAIT_STATUS_TYPE wait_status;
	enum {not_in_use, wait_done, wait_not_done} link_status;
	struct forked_proc *next;
} *forked_proc_base = 0;

void
fork_clear_all()
{
	struct forked_proc *f;

	for (f=forked_proc_base;f;f=f->next) {
		f->link_status = not_in_use;
	}
}

void
fork_init(f,pid)
struct forked_proc *f;
int pid;
{
	f->pid = pid;
	f->link_status = wait_not_done;
}
d2204 4
a2207 6
/* make an entry for a new proc */
void
fork_add(pid)
int pid;
{
	struct forked_proc *f;
d2209 6
a2214 3
	for (f=forked_proc_base;f;f=f->next) {
		if (f->link_status == not_in_use) break;
	}
d2216 6
a2221 7
	/* add new entry to the front of the list */
	if (!f) {
		f = (struct forked_proc *)ckalloc(sizeof(struct forked_proc));
		f->next = forked_proc_base;
		forked_proc_base = f;
	}
	fork_init(f,pid);
d2224 19
a2242 4
/* Provide a last-chance guess for this if not defined already */
#ifndef WNOHANG
#define WNOHANG WNOHANG_BACKUP_VALUE
#endif
a2243 9
/* wait returns are a hodgepodge of things
 If wait fails, something seriously has gone wrong, for example:
   bogus arguments (i.e., incorrect, bogus spawn id)
   no children to wait on
   async event failed
 If wait succeeeds, something happened on a particular pid
   3rd arg is 0 if successfully reaped (if signal, additional fields supplied)
   3rd arg is -1 if unsuccessfully reaped (additional fields supplied)
*/
d2247 4
a2250 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2252 4
a2255 2
    char *chanName = 0;
    struct ExpState *esPtr;
d2257 5
a2261 3
    struct ExpState esTmp;	/* temporary memory for either f or fp */
    char spawn_id[20];

d2263 9
a2271 5
    int result = 0;		/* 0 means child was successfully waited on */
				/* -1 means an error occurred */
				/* -2 means no eligible children to wait on */
#define NO_CHILD -2

d2281 1
a2281 1
	    chanName = *argv;
d2284 2
d2288 3
a2290 3

    if (!chanName) {
	if (!(esPtr = expStateCurrent(interp,0,0,1))) return TCL_ERROR;
d2292 4
a2295 2
	if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,1,"wait")))
	    return TCL_ERROR;
d2297 13
d2311 11
a2321 8
    if (!expStateAnyIs(esPtr)) {
	/* check if waited on already */
	/* things opened by "open" or set with -nowait */
	/* are marked sys_waited already */
	if (!esPtr->sys_waited) {
	    if (nowait) {
		/* should probably generate an error */
		/* if SIGCHLD is trapped. */
a2322 4
		/* pass to Tcl, so it can do wait */
		/* in background */
		Tcl_DetachPids(1,(Tcl_Pid *)&esPtr->pid);
		exp_wait_zero(&esPtr->wait);
d2330 4
a2333 3
		    result = waitpid(esPtr->pid,&esPtr->wait,0);
		    if (result == esPtr->pid) break;
		    if (result == -1) {
d2346 1
a2346 1
	
d2349 6
d2356 9
a2364 14
	strcpy(spawn_id,esPtr->name);
    } else {
	/* wait for any of our own spawned processes */
	/* we call waitpid rather than wait to avoid running into */
	/* someone else's processes.  Yes, according to Ousterhout */
	/* this is the best way to do it. */

	int waited_on_forked_process = 0;

	esPtr = expWaitOnAny();
	if (!esPtr) {
	    /* if it's not a spawned process, maybe its a forked process */
	    for (fp=forked_proc_base;fp;fp=fp->next) {
		if (fp->link_status == not_in_use) continue;
d2366 20
a2385 10
		result = waitpid(fp->pid,&fp->wait_status,WNOHANG);
		if (result == fp->pid) {
		    waited_on_forked_process = 1;
		    break;
		}
		if (result == 0) continue;	/* busy, try next */
		if (result == -1) {
		    if (errno == EINTR) goto restart;
		    else break;
		}
d2387 4
a2390 10

	    if (waited_on_forked_process) {
		/*
		 * The literal spawn id in the return value from wait appears
		 * as a -1 to indicate a forked process was waited on.  
		 */
		strcpy(spawn_id,"-1");
	    } else {
		result = NO_CHILD;	/* no children */
		Tcl_ReapDetachedProcs();
a2391 1
	    exp_rearm_sigchld(interp);
d2393 7
d2401 3
a2403 2

    /*  sigh, wedge forked_proc into an ExpState structure so we don't
d2407 3
a2409 3
	esPtr = &esTmp;
	esPtr->pid = fp->pid;
	esPtr->wait = fp->wait_status;
d2411 1
a2411 1

d2414 1
a2414 1
    if (result == -1) {
d2416 1
a2416 1
		esPtr->pid,spawn_id,errno,Tcl_ErrnoId(),Tcl_ErrnoMsg(errno));
d2418 2
d2421 1
a2421 1
	exp_error(interp,"no children");
d2425 2
a2426 2
		esPtr->pid,spawn_id,WEXITSTATUS(esPtr->wait));
	if (WIFSIGNALED(esPtr->wait)) {
d2428 3
a2430 3
	    Tcl_AppendElement(interp,Tcl_SignalId((int)(WTERMSIG(esPtr->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WTERMSIG(esPtr->wait))));
	} else if (WIFSTOPPED(esPtr->wait)) {
d2432 9
a2440 2
	    Tcl_AppendElement(interp,Tcl_SignalId((int) (WSTOPSIG(esPtr->wait))));
	    Tcl_AppendElement(interp,Tcl_SignalMsg((int) (WSTOPSIG(esPtr->wait))));
d2443 2
a2444 1
			
d2449 8
a2456 9

    esPtr->sys_waited = TRUE;
    esPtr->user_waited = TRUE;

    /* if user has already called close, forget about this entry entirely */
    if (!esPtr->open) {
      if (esPtr->registered) {
	Tcl_UnregisterChannel(interp,esPtr->channel);
      }
d2458 1
a2458 2

    return ((result == -1)?TCL_ERROR:TCL_OK);
d2462 2
a2463 2
static int
Exp_ForkCmd(clientData, interp, argc, argv)
d2469 2
a2470 43
	int rc;
	if (argc > 1) {
		exp_error(interp,"usage: fork");
		return(TCL_ERROR);
	}

	rc = fork();
	if (rc == -1) {
		exp_error(interp,"fork: %s",Tcl_PosixError(interp));
		return TCL_ERROR;
	} else if (rc == 0) {
		/* child */
		exp_forked = TRUE;
		exp_getpid = getpid();
		fork_clear_all();
	} else {
		/* parent */
		fork_add(rc);
	}

	/* both child and parent follow remainder of code */
	sprintf(interp->result,"%d",rc);
	expDiagLog("fork: returns {%s}\r\n",interp->result);
	return(TCL_OK);
}

/*ARGSUSED*/
static int
Exp_DisconnectCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    

    /* tell CenterLine to ignore non-use of ttyfd */
    /*SUPPRESS 591*/
    int ttyfd;

    if (argc > 1) {
	exp_error(interp,"usage: disconnect");
d2473 4
a2476 71

    if (exp_disconnected) {
	exp_error(interp,"already disconnected");
	return(TCL_ERROR);
    }
    if (!exp_forked) {
	exp_error(interp,"can only disconnect child process");
	return(TCL_ERROR);
    }
    exp_disconnected = TRUE;

    /* ignore hangup signals generated by testing ptys in getptymaster */
    /* and other places */
//    signal(SIGHUP,SIG_IGN);

    /* reopen prevents confusion between send/expect_user */
    /* accidentally mapping to a real spawned process after a disconnect */

    /* if we're in a child that's about to be disconnected from the
       controlling tty, close and reopen 0, 1, and 2 but associated
       with /dev/null.  This prevents send and expect_user doing
       special things if newly spawned processes accidentally
       get allocated 0, 1, and 2.
    */
	   
    if (isatty(0)) {
	ExpState *stdinout = tsdPtr->stdinout;
	if (stdinout->valid) {
	    exp_close(interp,stdinout);
	    if (stdinout->registered) {
		Tcl_UnregisterChannel(interp,stdinout->channel);
	    }
	}
	open("/dev/null",0);
	open("/dev/null",1);
	/* tsdPtr->stdinout = expCreateChannel(interp,0,1,EXP_NOPID);*/
	/* tsdPtr->stdinout->keepForever = 1;*/
	}
    if (isatty(2)) {
	ExpState *devtty = tsdPtr->devtty;
	
	/* reopen stderr saves error checking in error/log routines. */
	if (devtty->valid) {
	    exp_close(interp,devtty);
	    if (devtty->registered) {
		Tcl_UnregisterChannel(interp,devtty->channel);
	    }
	}
	open("/dev/null",1);
	/* tsdPtr->devtty = expCreateChannel(interp,2,2,EXP_NOPID);*/
	/* tsdPtr->devtty->keepForever = 1;*/
    }

    Tcl_UnsetVar(interp,"tty_spawn_id",TCL_GLOBAL_ONLY);

#ifdef DO_SETSID
    setsid();
#else
#ifdef SYSV3
    /* put process in our own pgrp, and lose controlling terminal */
#ifdef sysV88
    /* With setpgrp first, child ends up with closed stdio */
    /* according to Dave Schmitt <daves@@techmpc.csg.gss.mot.com> */
    if (fork()) exit(0);
    expSetpgrp();
#else
    expSetpgrp();
    /*signal(SIGHUP,SIG_IGN); moved out to above */
    if (fork()) exit(0);	/* first child exits (as per Stevens, */
    /* UNIX Network Programming, p. 79-80) */
    /* second child process continues as daemon */
d2478 3
a2480 65
#else /* !SYSV3 */
    expSetpgrp();

/* Pyramid lacks this defn */
#ifdef TIOCNOTTY
    ttyfd = open("/dev/tty", O_RDWR);
    if (ttyfd >= 0) {
	/* zap controlling terminal if we had one */
	(void) ioctl(ttyfd, TIOCNOTTY, (char *)0);
	(void) close(ttyfd);
    }
#endif /* TIOCNOTTY */

#endif /* SYSV3 */
#endif /* DO_SETSID */
    return(TCL_OK);
}

/*ARGSUSED*/
static int
Exp_OverlayCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
	int newfd, oldfd;
	int dash_name = 0;
	char *command;

	argc--; argv++;
	while (argc) {
		if (*argv[0] != '-') break;	/* not a flag */
		if (streq(*argv,"-")) {		/* - by itself */
			argc--; argv++;
			dash_name = 1;
			continue;
		}
		newfd = atoi(argv[0]+1);
		argc--; argv++;
		if (argc == 0) {
			exp_error(interp,"overlay -# requires additional argument");
			return(TCL_ERROR);
		}
		oldfd = atoi(argv[0]);
		argc--; argv++;
		expDiagLog("overlay: mapping fd %d to %d\r\n",oldfd,newfd);
		if (oldfd != newfd) (void) dup2(oldfd,newfd);
		else expDiagLog("warning: overlay: old fd == new fd (%d)\r\n",oldfd);
	}
	if (argc == 0) {
		exp_error(interp,"need program name");
		return(TCL_ERROR);
	}
	command = argv[0];
	if (dash_name) {
		argv[0] = ckalloc(1+strlen(command));
		sprintf(argv[0],"-%s",command);
	}

	signal(SIGINT, SIG_DFL);
//	signal(SIGQUIT, SIG_DFL);
        (void) execvp(command,argv);
	exp_error(interp,"execvp(%s): %s\r\n",argv[0],Tcl_PosixError(interp));
	return(TCL_ERROR);
d2483 1
d2486 5
a2490 5
Exp_InterpreterObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d2492 5
a2496 27
    Tcl_Obj *eofObj = 0;
    int i;
    int index;
    int rc;

    static char *options[] = {
	"-eof", (char *)0
    };
    enum options {
	FLAG_EOF
    };

    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	case FLAG_EOF:
	    i++;
	    if (i >= objc) {
		Tcl_WrongNumArgs(interp, 1, objv,"-eof cmd");
		return TCL_ERROR;
	    }
	    eofObj = objv[i];
	    Tcl_IncrRefCount(eofObj);
	    break;
d2499 2
a2500 6

    /* errors and ok, are caught by exp_interpreter() and discarded */
    /* to return TCL_OK, type "return" */
    rc = exp_interpreter(interp,eofObj);
    if (eofObj) Tcl_DecrRefCount(eofObj);
    return rc;
d2507 4
a2510 4
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d2514 1
a2514 1
    } else if ((argc == 2) && (0 == strcmp(argv[1],"-continue_timer"))) {
d2525 5
a2529 5
Exp_InterReturnObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];
d2535 18
a2552 1
    int result = Tcl_ReturnObjCmd(clientData,interp,objc,objv);
d2554 1
a2554 1
        result = EXP_TCL_RETURN;
d2556 1
d2559 16
d2578 6
a2583 8
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
{
    ExpState *esPtr;
    char *chanName = 0;
    int newfd;
d2585 2
a2586 1
    Tcl_Channel channel;
d2597 1
a2597 1
	    chanName = *argv;
d2604 2
a2605 2
    if (!chanName) {
	if (!(esPtr = expStateCurrent(interp,1,0,0))) return TCL_ERROR;
d2607 4
a2610 2
	if (!(esPtr = expStateFromChannelName(interp,chanName,1,0,0,"exp_open")))
return TCL_ERROR;
d2612 4
a2615 4

    /* make a new copy of file descriptor */
    if (-1 == (newfd = dup(esPtr->fdin))) {
	exp_error(interp,"dup: %s",Tcl_PosixError(interp));
d2618 8
a2625 7

    if (!leaveopen) {
	/* remove from Expect's memory in anticipation of passing to Tcl */
	if (esPtr->pid != EXP_NOPID) {
	    Tcl_DetachPids(1,(Tcl_Pid *)&esPtr->pid);
	    esPtr->pid = EXP_NOPID;
	    esPtr->sys_waited = esPtr->user_waited = TRUE;
d2627 1
a2627 1
	exp_close(interp,esPtr);
d2630 1
a2630 12
    /*
     * Tcl's MakeFileChannel only allows us to pass a single file descriptor
     * but that shouldn't be a problem in practice since all of the channels
     * that Expect generates only have one fd.  Of course, this code won't
     * work if someone creates a pipeline, then passes it to spawn, and then
     * again to exp_open.  For that to work, Tcl would need a new API.
     * Oh, and we're also being rather cavalier with the permissions here,
     * but they're likely to be right for the same reasons.
     */
    channel = Tcl_MakeFileChannel((ClientData)newfd,TCL_READABLE|TCL_WRITABLE);
    Tcl_RegisterChannel(interp, channel);
    Tcl_AppendResult(interp, Tcl_GetChannelName(channel), (char *) NULL);
d2652 2
a2653 2
Tcl_Interp *interp;
struct exp_cmd_data *c;
d2655 24
a2678 28
	Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
	Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
	char cmdnamebuf[80];

	for (;c->name;c++) {
		/* if already defined, don't redefine */
		if ((c->flags & EXP_REDEFINE) ||
		    !(Tcl_FindHashEntry(&globalNsPtr->cmdTable,c->name) ||
		      Tcl_FindHashEntry(&currNsPtr->cmdTable,c->name))) {
			if (c->objproc)
				Tcl_CreateObjCommand(interp,c->name,
						     c->objproc,c->data,exp_deleteObjProc);
			else
				Tcl_CreateCommand(interp,c->name,c->proc,
						  c->data,exp_deleteProc);
		}
		if (!(c->name[0] == 'e' &&
		      c->name[1] == 'x' &&
		      c->name[2] == 'p')
		    && !(c->flags & EXP_NOPREFIX)) {
			sprintf(cmdnamebuf,"exp_%s",c->name);
			if (c->objproc)
				Tcl_CreateObjCommand(interp,cmdnamebuf,c->objproc,c->data,
						     exp_deleteObjProc);
			else
				Tcl_CreateCommand(interp,cmdnamebuf,c->proc,
						  c->data,exp_deleteProc);
		}
d2680 1
d2684 1
a2684 1
{"close",	Exp_CloseObjCmd,	0,	0,	EXP_REDEFINE},
d2686 1
a2686 1
{"debug",	exp_proc(Exp_DebugCmd),	0,	0},
d2688 31
a2718 22
{"exp_internal",exp_proc(Exp_ExpInternalCmd),	0,	0},
{"disconnect",	exp_proc(Exp_DisconnectCmd),	0,	0},
{"exit",	exp_proc(Exp_ExitCmd),	0,	EXP_REDEFINE},
{"exp_continue",exp_proc(Exp_ExpContinueCmd),0,	0},
{"fork",	exp_proc(Exp_ForkCmd),	0,	0},
{"exp_pid",	exp_proc(Exp_ExpPidCmd),	0,	0},
{"getpid",	exp_proc(Exp_GetpidDeprecatedCmd),0,	0},
{"interpreter",	Exp_InterpreterObjCmd,	0,	0,	0},
{"log_file",	exp_proc(Exp_LogFileCmd),	0,	0},
{"log_user",	exp_proc(Exp_LogUserCmd),	0,	0},
{"exp_open",	exp_proc(Exp_OpenCmd),	0,	0},
{"overlay",	exp_proc(Exp_OverlayCmd),	0,	0},
{"inter_return",Exp_InterReturnObjCmd,	0,	0,	0},
{"send",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_proc,0},
{"send_error",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_error,0},
{"send_log",	exp_proc(Exp_SendLogCmd),	0,	0},
{"send_tty",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_tty,0},
{"send_user",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_user,0},
{"sleep",	exp_proc(Exp_SleepCmd),	0,	0},
{"spawn",	exp_proc(Exp_SpawnCmd),	0,	0},
{"strace",	exp_proc(Exp_StraceCmd),	0,	0},
{"wait",	exp_proc(Exp_WaitCmd),	0,	0},
d2721 14
d2737 1
a2737 1
Tcl_Interp *interp;
d2741 87
a2827 3
#ifdef HAVE_PTYTRAP
    Tcl_InitHashTable(&slaveNames,TCL_STRING_KEYS);
#endif /* HAVE_PTYTRAP */
@


1.1.2.3
log
@large amount of edits to make it work (again).  Needs to be checked against
the snap29 mods.
@
text
@d21 12
d109 1
a109 3
/*
 * Local prototypes for functions used only in this file and are not shared.
 */
d125 7
d681 1
d710 2
a711 2
    expDiagLog("getpid is deprecated, use pid\r\n");
    sprintf(interp->result,"%d",getpid());
d714 1
d2071 4
a2074 4
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
d2254 1
a2254 1
//	rc = fork();
d2277 4
a2280 4
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
d2386 4
a2389 4
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
d2391 3
a2393 3
    int newfd, oldfd;
    int dash_name = 0;
    char *command;
d2395 19
a2413 7
    argc--; argv++;
    while (argc) {
	if (*argv[0] != '-') break;	/* not a flag */
	if (streq(*argv,"-")) {		/* - by itself */
	    argc--; argv++;
	    dash_name = 1;
	    continue;
a2414 2
	newfd = atoi(argv[0]+1);
	argc--; argv++;
d2416 7
a2422 2
	    exp_error(interp,"overlay -# requires additional argument");
	    return(TCL_ERROR);
a2423 15
	oldfd = atoi(argv[0]);
	argc--; argv++;
	expDiagLog("overlay: mapping fd %d to %d\r\n",oldfd,newfd);
	if (oldfd != newfd) (void) dup2(oldfd,newfd);
	else expDiagLog("warning: overlay: old fd == new fd (%d)\r\n",oldfd);
    }
    if (argc == 0) {
	exp_error(interp,"need program name");
	return(TCL_ERROR);
    }
    command = argv[0];
    if (dash_name) {
	argv[0] = ckalloc(1+strlen(command));
	sprintf(argv[0],"-%s",command);
    }
d2425 1
a2425 1
    signal(SIGINT, SIG_DFL);
d2427 3
a2429 3
    execvp(command,argv);
    exp_error(interp,"execvp(%s): %s\r\n",argv[0],Tcl_PosixError(interp));
    return(TCL_ERROR);
d2435 4
a2438 4
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d2481 4
a2484 4
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
d2500 4
a2503 4
    ClientData clientData;
    Tcl_Interp *interp;
    int objc;
    Tcl_Obj *CONST objv[];
d2518 4
a2521 4
    ClientData clientData;
    Tcl_Interp *interp;
    int argc;
    char **argv;
d2549 1
a2549 1
	    return TCL_ERROR;
d2587 10
a2596 10
    char *flag;
    char *string;
    int minlen;		/* at least this many chars must match */
{
    for (;*flag;flag++,string++,minlen--) {
	if (*string == '\0') break;
	if (*string != *flag) return 0;
    }
    if (*string == '\0' && minlen <= 0) return 1;
    return 0;
d2601 2
a2602 2
    Tcl_Interp *interp;
    struct exp_cmd_data *c;
d2604 28
a2631 27
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
    Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
    char cmdnamebuf[80];

    for (;c->name;c++) {
	/* if already defined, don't redefine */
	if ((c->flags & EXP_REDEFINE) ||
		!(Tcl_FindHashEntry(&globalNsPtr->cmdTable,c->name) ||
		Tcl_FindHashEntry(&currNsPtr->cmdTable,c->name))) {
	    if (c->objproc)
		Tcl_CreateObjCommand(interp,c->name,
			c->objproc,c->data,exp_deleteObjProc);
	    else
		Tcl_CreateCommand(interp,c->name,c->proc,
			c->data,exp_deleteProc);
	}
	if (!(c->name[0] == 'e' &&
		c->name[1] == 'x' &&
		c->name[2] == 'p')
		&& !(c->flags & EXP_NOPREFIX)) {
	    sprintf(cmdnamebuf,"exp_%s",c->name);
	    if (c->objproc)
		Tcl_CreateObjCommand(interp,cmdnamebuf,c->objproc,c->data,
			exp_deleteObjProc);
	    else
		Tcl_CreateCommand(interp,cmdnamebuf,c->proc,
			c->data,exp_deleteProc);
a2632 1
    }
d2636 1
a2636 1
    {"close",	Exp_CloseObjCmd,	0,	0,	EXP_REDEFINE},
d2638 1
a2638 1
    {"debug",	exp_proc(Exp_DebugCmd),	0,	0},
d2640 23
a2662 23
    {"exp_internal",exp_proc(Exp_ExpInternalCmd),	0,	0},
    {"disconnect",	exp_proc(Exp_DisconnectCmd),	0,	0},
    {"exit",	exp_proc(Exp_ExitCmd),	0,	EXP_REDEFINE},
    {"exp_continue",exp_proc(Exp_ExpContinueCmd),0,	0},
    {"fork",	exp_proc(Exp_ForkCmd),	0,	0},
    {"exp_pid",	exp_proc(Exp_ExpPidCmd),	0,	0},
    {"getpid",	exp_proc(Exp_GetpidDeprecatedCmd),0,	0},
    {"interpreter",	Exp_InterpreterObjCmd,	0,	0,	0},
    {"log_file",	exp_proc(Exp_LogFileCmd),	0,	0},
    {"log_user",	exp_proc(Exp_LogUserCmd),	0,	0},
    {"exp_open",	exp_proc(Exp_OpenCmd),	0,	0},
    {"overlay",	exp_proc(Exp_OverlayCmd),	0,	0},
    {"inter_return",Exp_InterReturnObjCmd,	0,	0,	0},
    {"send",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_proc,0},
    {"send_error",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_error,0},
    {"send_log",	exp_proc(Exp_SendLogCmd),	0,	0},
    {"send_tty",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_tty,0},
    {"send_user",	Exp_SendObjCmd,		0,	(ClientData)&sendCD_user,0},
    {"sleep",	exp_proc(Exp_SleepCmd),	0,	0},
    {"spawn",	exp_proc(Exp_SpawnCmd),	0,	0},
    {"strace",	exp_proc(Exp_StraceCmd),	0,	0},
    {"wait",	exp_proc(Exp_WaitCmd),	0,	0},
    {0}};
d2666 1
a2666 1
    Tcl_Interp *interp;
@


