head	5.37;
access;
symbols
	expect_5_45:5.37
	expect_6_branch:5.36.0.2
	expect_5_44_1_15:5.36
	activestate_win32_port_start:5.31
	telco-tec-win32-take2-branch:5.30.0.6
	telco-tec-win32-branch:5.30.0.4
	expect-sf418892-sf439042-branch:5.30.0.2
	tclpro-1-5-0:5.30
	tclpro-1-4-1:5.30
	tclpro-1-4-0:5.30
	expect-5-32-2:5.30
	expect-5-32-0:5.30
	ajuba-ajuba2-2-0:5.28.1.1.2.3
	scriptics-sc-2-0-b5:5.28.1.1.2.3
	scriptics-sc-2-0-fixed:5.28.1.1.2.3
	scriptics-sc-2-0-b2:5.28.1.1.2.3
	scriptics-sc-2-0-b1:5.28.1.1.2.3
	scriptics-sc-1-1:5.28.1.1.2.3
	scriptics-sc-1-1-b1:5.28.1.1.2.3
	scriptics-sc-1-1-branch:5.28.1.1.2.3.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.3
	scriptics-sc-1-0:5.28.1.1.2.3
	scriptics-sc-1-0-branch:5.28.1.1.2.3.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.3
	expect-5-31-3:5.28.1.1.2.3
	scriptics-bc-1-0-b1:5.28.1.1.2.3
	scriptics-tclpro-1-3-0:5.28.1.1.2.3
	scriptics-tclpro-1-3-b4:5.28.1.1.2.3
	scriptics-tclpro-1-3-b3:5.28.1.1.2.3
	expect-5-31:5.28.1.1.2.3
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.37
date	2010.08.27.21.51.53;	author hobbs;	state Exp;
branches;
next	5.36;

5.36
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.35;

5.35
date	2010.06.09.22.08.20;	author eee;	state Exp;
branches;
next	5.34;

5.34
date	2010.03.19.16.53.03;	author eee;	state Exp;
branches;
next	5.33;

5.33
date	2008.08.28.21.40.37;	author andreas_kupries;	state Exp;
branches;
next	5.32;

5.32
date	2007.07.11.20.22.10;	author andreas_kupries;	state Exp;
branches;
next	5.31;

5.31
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.30;

5.30
date	2000.05.01.06.21.21;	author libes;	state Exp;
branches
	5.30.4.1
	5.30.6.1;
next	5.29;

5.29
date	2000.01.06.23.22.05;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.07.17.49.39;	author libes;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.14.20.36.51;	author don;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.29.02.27.46;	author libes;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.12.04.06.18.24;	author libes;	state Exp;
branches;
next	;

5.30.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.30.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.37
log
@	* config.guess, config.sub, expect.m4 (removed):
	* configure, configure.in, tclconfig/tcl.m4: Update to TEA 3.9
	* Makefile.in, aclocal.m4: Partial cleanup of the build system.
	* testsuite/Makefile.in:   Remove unused EXP_ from configure.in
	* testsuite/aclocal.m4:    and no longer use Tk.
	* testsuite/configure:     Update testsuite bits to use TEA info.
	* testsuite/configure.in:
	Update expect to version 5.45

	* Dbg.c: account for removal of tcldbgcf.h
	* DbgMkfl.in, Dbgconfig.in, Dbgconfigure, DbgpkgInd.in (removed):
	* tcldbgcf.h.in (removed): removed Dbg debugger subcomponent as it
	no longer built and debugger functionality is included in expect
	library and binary

	* pty_termios.c: add HAVE_STRING_H include string.h
	* exp_trap.c: add HAVE_STRING_H include string.h

	* expectk.man, exp_main_tk.c (removed): expectk no longer
	built. Use tclsh with package require Tk and Expect instead.

	* tests/all.tcl: add package require Expect

	* example/archie, example/autoexpect: minor code cleanup
	* example/tkpasswd, example/tknewsbiff, example/tkterm: use
	package require statements in lieu of expectk
@
text
@/* exp_trap.c - Expect's trap command

Written by: Don Libes, NIST, 9/1/93

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include "expect_cf.h"

#include <stdio.h>
#include <signal.h>
#include <sys/types.h>

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#if defined(SIGCLD) && !defined(SIGCHLD)
#define SIGCHLD SIGCLD
#endif

#include "tcl.h"

#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"
#include "exp_log.h"

#ifdef TCL_DEBUGGER
#include "tcldbg.h"
#endif

#define NO_SIG 0

static struct trap {
	char *action;		/* Tcl command to execute upon sig */
				/* Each is handled by the eval_trap_action */
	int mark;		/* TRUE if signal has occurred */
	Tcl_Interp *interp;	/* interp to use or 0 if we should use the */
				/* interpreter active at the time the sig */
				/* is processed */
	int code;		/* return our new code instead of code */
				/* available when signal is processed */
	CONST char *name;	/* name of signal */
	int reserved;		/* if unavailable for trapping */
} traps[NSIG];

int sigchld_count = 0;	/* # of sigchlds caught but not yet processed */

static int eval_trap_action();

static int got_sig;		/* this records the last signal received */
				/* it is only a hint and can be wiped out */
				/* by multiple signals, but it will always */
				/* be left with a valid signal that is */
				/* pending */

static Tcl_AsyncHandler async_handler;

static CONST char *
signal_to_string(sig)
int sig;
{
	if (sig <= 0 || sig > NSIG) return("SIGNAL OUT OF RANGE");
	return(traps[sig].name);
}

/* current sig being processed by user sig handler */
static int current_sig = NO_SIG;

int exp_nostack_dump = FALSE;	/* TRUE if user has requested unrolling of */
				/* stack with no trace */



/*ARGSUSED*/
static int
tophalf(clientData,interp,code)
ClientData clientData;
Tcl_Interp *interp;
int code;
{
	struct trap *trap;	/* last trap processed */
	int rc;
	int i;
	Tcl_Interp *sig_interp;

	expDiagLog("sighandler: handling signal(%d)\r\n",got_sig);

	if (got_sig <= 0 || got_sig >= NSIG) {
		expErrorLog("caught impossible signal %d\r\n",got_sig);
		abort();
	}

	/* start to work on this sig.  got_sig can now be overwritten */
	/* and it won't cause a problem */
	current_sig = got_sig;
	trap = &traps[current_sig];

	trap->mark = FALSE;

	/* decrement below looks dangerous */
	/* Don't we need to temporarily block bottomhalf? */
	if (current_sig == SIGCHLD) {
		sigchld_count--;
		expDiagLog("sigchld_count-- == %d\n",sigchld_count);
	}

	if (!trap->action) {
		/* In this one case, we let ourselves be called when no */
		/* signaler predefined, since we are calling explicitly */
		/* from another part of the program, and it is just simpler */
		if (current_sig == 0) return code;
		expErrorLog("caught unexpected signal: %s (%d)\r\n",
			signal_to_string(current_sig),current_sig);
		abort();
	}

	if (trap->interp) {
		/* if trap requested original interp, use it */
		sig_interp = trap->interp;
	} else if (interp) {
		/* else if another interp is available, use it */
		sig_interp = interp;
	} else {
		/* fall back to exp_interp */
		sig_interp = exp_interp;
	}

	rc = eval_trap_action(sig_interp,current_sig,trap,code);
	current_sig = NO_SIG;

	/*
	 * scan for more signals to process
	 */

	/* first check for additional SIGCHLDs */
	if (sigchld_count) {
		got_sig = SIGCHLD;
		traps[SIGCHLD].mark = TRUE;
		Tcl_AsyncMark(async_handler);
	} else {
		got_sig = -1;
		for (i=1;i<NSIG;i++) {
			if (traps[i].mark) {
				got_sig = i;
				Tcl_AsyncMark(async_handler);
				break;
			}
		}
	}
	return rc;
}

#ifdef REARM_SIG
int sigchld_sleep;
static int rearm_sigchld = FALSE;	/* TRUE if sigchld needs to be */
					/* rearmed (i.e., because it has */
					/* just gone off) */
static int rearming_sigchld = FALSE;
#endif

/* called upon receipt of a user-declared signal */
static void
bottomhalf(sig)
int sig;
{
#ifdef REARM_SIG
	/*
	 * tiny window of death if same signal should arrive here
	 * before we've reinstalled it
	 */

	/* In SV, sigchld must be rearmed after wait to avoid recursion */
	if (sig != SIGCHLD) {
		signal(sig,bottomhalf);
	} else {
		/* request rearm */
		rearm_sigchld = TRUE;
		if (rearming_sigchld) sigchld_sleep = TRUE;
	}
#endif

	traps[sig].mark = TRUE;
	got_sig = sig;		/* just a hint - can be wiped out by another */
	Tcl_AsyncMark(async_handler);

	/* if we are called while this particular async is being processed */
	/* original async_proc will turn off "mark" so that when async_proc */
	/* is recalled, it will see that nothing was left to do */

	/* In case of SIGCHLD though, we must recall it as many times as
	 * we have received it.
	 */
	if (sig == SIGCHLD) {
		sigchld_count++;
	}
#if 0
	/* if we are doing an i_read, restart it */
#ifdef HAVE_SIGLONGJMP
      if (env_valid && (sig != 0)) siglongjmp(env,2);
#else
      if (env_valid && (sig != 0)) longjmp(env,2);
#endif  /* HAVE_SIGLONGJMP */
#endif /* 0 */
}

/*ARGSUSED*/
void
exp_rearm_sigchld(interp)
Tcl_Interp *interp;
{
#ifdef REARM_SIG
	if (rearm_sigchld) {
		rearm_sigchld = FALSE;
		rearming_sigchld = TRUE;
		signal(SIGCHLD,bottomhalf);
	}

	rearming_sigchld = FALSE;

	/* if the rearming immediately caused another SIGCHLD, slow down */
	/* It's probably one of Tcl's intermediary pipeline processes that */
	/* Tcl hasn't caught up with yet. */
	if (sigchld_sleep) {
		exp_dsleep(interp,0.2);
		sigchld_sleep = FALSE;
	}
#endif
}


void
exp_init_trap()
{
	int i;

	for (i=1;i<NSIG;i++) {
		traps[i].name = Tcl_SignalId(i);
		traps[i].action = 0;
		traps[i].reserved = FALSE;
	}

	/*
	 * fix up any special cases
	 */

#if defined(SIGCLD)
	/* Tcl names it SIGCLD, not good for portable scripts */
	traps[SIGCLD].name = "SIGCHLD";
#endif
#if defined(SIGALRM)
	traps[SIGALRM].reserved = TRUE;
#endif
#if defined(SIGKILL)
	traps[SIGKILL].reserved = TRUE;
#endif
#if defined(SIGSTOP)
	traps[SIGSTOP].reserved = TRUE;
#endif

	async_handler = Tcl_AsyncCreate(tophalf,(ClientData)0);

}

/* given signal index or name as string, */
/* returns signal index or -1 if bad arg */
int
exp_string_to_signal(interp,s)
Tcl_Interp *interp;
char *s;
{
	int sig;
	CONST char *name;

	/* try interpreting as an integer */
	if (1 == sscanf(s,"%d",&sig)) {
		if (sig > 0 && sig < NSIG) return sig;
	} else {
		/* try interpreting as a string */
		for (sig=1;sig<NSIG;sig++) {
			name = traps[sig].name;
			if (streq(s,name) || streq(s,name+3)) return(sig);
		}
	}

	exp_error(interp,"invalid signal %s",s);
	
	return -1;
}

/*ARGSUSED*/
int
Exp_TrapObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];
{
	char *action = 0;
	int n;		/* number of signals in list */
	Tcl_Obj **list;	/* list of signals */
	char *arg;
	int len;	/* length of action */
	int i;
	int show_name = FALSE;	/* if user asked for current sig by name */
	int show_number = FALSE;/* if user asked for current sig by number */
	int show_max = FALSE;	/* if user asked for NSIG-1 */
	int rc = TCL_OK;
	int new_code = FALSE;	/* if action result should overwrite orig */
	Tcl_Interp *new_interp = interp;/* interp in which to evaluate */
					/* action when signal occurs */

	objc--; objv++;

	while (objc) {
	  arg = Tcl_GetString(*objv);

		if (streq(arg,"-code")) {
			objc--; objv++; 
			new_code = TRUE;
		} else if (streq(arg,"-interp")) {
			objc--; objv++; 
			new_interp = 0;
		} else if (streq(arg,"-name")) {
			objc--; objv++;
			show_name = TRUE;
		} else if (streq(arg,"-number")) {
			objc--; objv++;
			show_number = TRUE;
		} else if (streq(arg,"-max")) {
			objc--; objv++;
			show_max = TRUE;
		} else break;
	}

	if (show_name || show_number || show_max) {
		if (objc > 0) goto usage_error;
		if (show_max) {
		  Tcl_SetObjResult(interp,Tcl_NewIntObj(NSIG-1));
		}

		if (current_sig == NO_SIG) {
		  Tcl_SetResult(interp,"no signal in progress",TCL_STATIC);
		  return TCL_ERROR;
		}
		if (show_name) {
		  /* skip over "SIG" */
		  /* TIP 27: Casting away the CONST should be ok because of TCL_STATIC
		   */
		  Tcl_SetResult(interp,(char*)signal_to_string(current_sig) + 3,TCL_STATIC);
		} else {
		  Tcl_SetObjResult(interp,Tcl_NewIntObj(current_sig));
		}
		return TCL_OK;
	}

	if (objc == 0 || objc > 2) goto usage_error;

	if (objc == 1) {
		int sig = exp_string_to_signal(interp,arg);
		if (sig == -1) return TCL_ERROR;

		if (traps[sig].action) {
			Tcl_SetResult(interp,traps[sig].action,TCL_STATIC);
		} else {
			Tcl_SetResult(interp,"SIG_DFL",TCL_STATIC);
		}
		return TCL_OK;
	}

	action = arg;

	/* objv[1] is the list of signals - crack it open */
	if (TCL_OK != Tcl_ListObjGetElements(interp,objv[1],&n,&list)) {
	  return TCL_ERROR;
	}

	for (i=0;i<n;i++) {
	  char *s;
	  int sig;

	  s = Tcl_GetString(list[i]);

		sig = exp_string_to_signal(interp,s);
		if (sig == -1) {
			rc = TCL_ERROR;
			break;
		}

		if (traps[sig].reserved) {
			exp_error(interp,"cannot trap %s",signal_to_string(sig));
			rc = TCL_ERROR;
			break;
		}

		expDiagLog("trap: setting up signal %d (\"%s\")\r\n",sig,s);
		if (traps[sig].action) ckfree(traps[sig].action);
		if (streq(action,"SIG_DFL")) {
			/* should've been free'd by now if nec. */
			traps[sig].action = 0;
			signal(sig,SIG_DFL);
#ifdef REARM_SIG
			if (sig == SIGCHLD)
				rearm_sigchld = FALSE;
#endif /*REARM_SIG*/
		} else {
			len = 1 + strlen(action);
			traps[sig].action = ckalloc(len);
			memcpy(traps[sig].action,action,len);
			traps[sig].interp = new_interp;
			traps[sig].code = new_code;
			if (streq(action,"SIG_IGN")) {
				signal(sig,SIG_IGN);
			} else signal(sig,bottomhalf);
		}
	}
	/* It is no longer necessary to free the split list since it */
	/* is still owned by Tcl, yes? */
	/*	ckfree((char *)list); */
	return(rc);
 usage_error:
	exp_error(interp,"usage: trap [command or SIG_DFL or SIG_IGN] {list of signals}");
	return TCL_ERROR;
}

/* called by tophalf() to process the given signal */
static int
eval_trap_action(interp,sig,trap,oldcode)
Tcl_Interp *interp;
int sig;
struct trap *trap;
int oldcode;
{
	int code_flag;
	int newcode;
	Tcl_Obj *eip;   /* errorInfo */
	Tcl_Obj *ecp;	/* errorCode */
	Tcl_Obj *irp;	/* interp's result */

	expDiagLogU("async event handler: Tcl_Eval(");
	expDiagLogU(trap->action);
	expDiagLogU(")\r\n");

	/* save to prevent user from redefining trap->code while trap */
	/* is executing */
	code_flag = trap->code;

	if (!code_flag) {
		/* 
		 * save return values
		 */

		eip = Tcl_GetVar2Ex(interp,"errorInfo","",TCL_GLOBAL_ONLY);
		if (eip) eip = Tcl_DuplicateObj(eip);
		ecp = Tcl_GetVar2Ex(interp,"errorCode","",TCL_GLOBAL_ONLY);
		if (ecp) ecp = Tcl_DuplicateObj(ecp);
		irp = Tcl_GetObjResult(interp);
		if (irp) irp = Tcl_DuplicateObj(irp);
	}

	newcode = Tcl_GlobalEval(interp,trap->action);

	/*
	 * if new code is to be ignored (usual case - see "else" below)
	 *	allow only OK/RETURN from trap, otherwise complain
	 */

	if (code_flag) {
		expDiagLog("return value = %d for trap %s, action ",newcode,signal_to_string(sig));
		expDiagLogU(trap->action);
		expDiagLogU("\r\n");
		if (0 != strcmp(Tcl_GetStringResult(interp),"")) {

			/*
			 * Check errorinfo and see if it contains -nostack.
			 * This shouldn't be necessary, but John changed the
			 * top level interp so that it distorts arbitrary
			 * return values into TCL_ERROR, so by the time we
			 * get back, we'll have lost the value of errorInfo
			 */

			eip = Tcl_GetVar2Ex(interp,"errorInfo","",TCL_GLOBAL_ONLY);
			if (eip) {
			  exp_nostack_dump = (0 == strncmp("-nostack",Tcl_GetString(eip),8));
			}
		}
	} else if (newcode != TCL_OK && newcode != TCL_RETURN) {
	  if (newcode != TCL_ERROR) {
	    exp_error(interp,"return value = %d for trap %s, action %s\r\n",newcode,signal_to_string(sig),trap->action);
	  }
	  Tcl_BackgroundError(interp);
	}

	if (!code_flag) {
		/*
		 * restore values
		 */
		Tcl_ResetResult(interp);	/* turns off Tcl's internal */
		   /* flags: ERR_IN_PROGRESS, ERROR_CODE_SET */
		   /* This also wipes clean errorInfo/Code/result which is why */
		   /* all the calls to Tcl_Dup earlier */

		if (eip) {
		  /* odd that Tcl doesn't have a call that does all this at once */
		  int len;
		  char *s = Tcl_GetStringFromObj(eip,&len);
		  Tcl_AddObjErrorInfo(interp,s,len);
		  Tcl_DecrRefCount(eip);
		  /* we never incr'd it, but the code allows this */
		} else {
		  Tcl_UnsetVar(interp,"errorInfo",0);
		}

		/* restore errorCode.  Note that Tcl_AddErrorInfo (above) */
		/* resets it to NONE.  If the previous value is NONE, it's */
		/* important to avoid calling Tcl_SetErrorCode since this */
		/* with cause Tcl to set its internal ERROR_CODE_SET flag. */
		if (ecp) {
		  if (!streq("NONE",Tcl_GetString(ecp)))
		    Tcl_SetErrorCode(interp,ecp);
		  /* we're just passing on the errorcode obj */
		  /* presumably, Tcl will incr ref count */
		} else {
		  Tcl_UnsetVar(interp,"errorCode",0);
		}

		newcode = oldcode;

		/* note that since newcode gets overwritten here by old code */
		/* it is possible to return in the middle of a trap by using */
		/* "return" (or "continue" for that matter)! */
	}
	return newcode;
}

static struct exp_cmd_data
cmd_data[]  = {
{"trap",	Exp_TrapObjCmd, 0,	(ClientData)EXP_SPAWN_ID_BAD,	0},
{0}};

void
exp_init_trap_cmds(interp)
Tcl_Interp *interp;
{
	exp_create_commands(interp,cmd_data);
}

@


5.36
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@d20 3
@


5.35
log
@ANSIfication changes.
@
text
@a15 1
#include <string.h>
a30 1
#include "exp_event.h"
d53 1
a53 1
static int eval_trap_action(Tcl_Interp *, int, struct trap *, int);
d64 2
a65 1
signal_to_string(int sig)
d81 4
a84 1
tophalf( ClientData clientData, Tcl_Interp *interp, int code)
d168 2
a169 1
bottomhalf( int sig)
d213 2
a214 1
exp_rearm_sigchld( Tcl_Interp *interp)
d237 1
a237 1
exp_init_trap(void)
d272 3
a274 1
exp_string_to_signal( Tcl_Interp *interp, char *s)
d297 5
a301 1
Exp_TrapObjCmd( ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
d303 1
a303 1
	char *action = NULL;
d432 5
a436 1
eval_trap_action( Tcl_Interp *interp, int sig, struct trap *trap, int oldcode)
d546 2
a547 1
exp_init_trap_cmds( Tcl_Interp *interp)
@


5.34
log
@More ANSIfication
@
text
@d16 1
d32 1
@


5.33
log
@
	* exp_trap.c (tophalf): Fixed inverted condition setting the
	  interpreter used for trap handling to NULL, causing a crash when
	  trying to handle ^C. This fixes [SF Bug 1757471] reported by
	  Matthias Kraft <matzek@@users.sourceforge.net>.
	* configure.in: Bumped version to 5.44.1.10.
	* configure: Regen'd, autoconf 2.59.
@
text
@d53 1
a53 1
static int eval_trap_action();
d64 1
a64 2
signal_to_string(sig)
int sig;
d80 1
a80 4
tophalf(clientData,interp,code)
ClientData clientData;
Tcl_Interp *interp;
int code;
d164 1
a164 2
bottomhalf(sig)
int sig;
d208 1
a208 2
exp_rearm_sigchld(interp)
Tcl_Interp *interp;
d231 1
a231 1
exp_init_trap()
d266 1
a266 3
exp_string_to_signal(interp,s)
Tcl_Interp *interp;
char *s;
d289 1
a289 5
Exp_TrapObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];
d291 1
a291 1
	char *action = 0;
d420 1
a420 5
eval_trap_action(interp,sig,trap,oldcode)
Tcl_Interp *interp;
int sig;
struct trap *trap;
int oldcode;
d530 1
a530 2
exp_init_trap_cmds(interp)
Tcl_Interp *interp;
@


5.32
log
@
	* Dbg.c: Cleaned up the direct access to interp->result,
	* exp_command.c: replaced with the proper functions and
	* expect.c: Tcl_Obj's.
	* exp_main_exp.c:
	* exp_main_sub.c:
	* exp_main_tk.c:
	* exp_prog.h:
	* exp_trap.c:
	* exp_tty.c:
	* exp_win.c:
	* exp_win.h:
@
text
@d125 1
a125 1
	} else if (!interp) {
@


5.31
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d442 1
a442 1
	Tcl_Obj *irp;	/* interp->result */
@


5.30
log
@Signal handler sometimes sent error to stderr inappropriately.
@
text
@d47 1
a47 1
	char *name;		/* name of signal */
d63 1
a63 1
static char *
d277 1
a277 1
	char *name;
d352 3
a354 1
		  Tcl_SetResult(interp,signal_to_string(current_sig) + 3,TCL_STATIC);
@


5.30.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.30.4.1
log
@Top-level source files removed.
@
text
@@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d377 1
a377 3
		expErrorLogU(Tcl_GetStringResult(interp));
		expErrorLogU("\r\n");
		goto usage_error;
a474 2
			expErrorLogU(interp->result);
			expErrorLogU("\r\n");
@


5.28
log
@Initial revision
@
text
@a89 1
/*	extern Tcl_Interp *exp_interp;*/
d91 1
a91 1
	exp_debuglog("sighandler: handling signal(%d)\r\n",got_sig);
d94 1
a94 1
		errorlog("caught impossible signal %d\r\n",got_sig);
d109 1
a109 1
		exp_debuglog("sigchld_count-- == %d\n",sigchld_count);
d117 1
a117 1
		errorlog("caught unexpected signal: %s (%d)\r\n",
d161 1
a161 1
					/* rearmed (i.e., because it has
a199 1
/*		exp_debuglog(stderr,"sigchld_count++ == %d\n",sigchld_count);*/
d203 6
a208 2
	if (env_valid && (sig != 0)) longjmp(env,2);
#endif
d297 1
a297 1
Exp_TrapCmd(clientData, interp, argc, argv)
d300 2
a301 2
int argc;
char **argv;
d305 2
a306 1
	char **list;	/* list of signals */
d317 4
a320 1
	argc--; argv++;
d322 2
a323 3
	while (*argv) {
		if (streq(*argv,"-code")) {
			argc--; argv++; 
d325 2
a326 2
		} else if (streq(*argv,"-interp")) {
			argc--; argv++; 
d328 2
a329 2
		} else if (streq(*argv,"-name")) {
			argc--; argv++;
d331 2
a332 2
		} else if (streq(*argv,"-number")) {
			argc--; argv++;
d334 2
a335 2
		} else if (streq(*argv,"-max")) {
			argc--; argv++;
d341 1
a341 1
		if (argc > 0) goto usage_error;
d343 1
a343 2
			sprintf(interp->result,"%d",NSIG-1);
			return TCL_OK;
d347 2
a348 2
			exp_error(interp,"no signal in progress");
			return TCL_ERROR;
d351 2
a352 2
			/* skip over "SIG" */
			interp->result = signal_to_string(current_sig) + 3;
d354 1
a354 1
			sprintf(interp->result,"%d",current_sig);
d359 1
a359 1
	if (argc == 0 || argc > 2) goto usage_error;
d361 2
a362 2
	if (argc == 1) {
		int sig = exp_string_to_signal(interp,*argv);
d366 1
a366 1
			Tcl_AppendResult(interp,traps[sig].action,(char *)0);
d368 1
a368 1
			interp->result = "SIG_DFL";
d373 1
a373 1
	action = *argv;
d375 4
a378 3
	/* argv[1] is the list of signals - crack it open */
	if (TCL_OK != Tcl_SplitList(interp,argv[1],&n,&list)) {
		errorlog("%s\r\n",interp->result);
d383 6
a388 1
		int sig = exp_string_to_signal(interp,list[i]);
d400 1
a400 11
#if 0
#ifdef TCL_DEBUGGER
		if (sig == SIGINT && exp_tcl_debugger_available) {
			exp_debuglog("trap: cannot trap SIGINT while using debugger\r\n");
			continue;
		}
#endif /* TCL_DEBUGGER */
#endif

		exp_debuglog("trap: setting up signal %d (\"%s\")\r\n",sig,list[i]);

a401 1

d421 3
a423 1
	ckfree((char *)list);
d440 7
a446 7
	Tcl_DString ei;	/* errorInfo */
	char *eip;
	Tcl_DString ec;	/* errorCode */
	char *ecp;
	Tcl_DString ir;	/* interp->result */

	exp_debuglog("async event handler: Tcl_Eval(%s)\r\n",trap->action);
d456 7
a462 13
		eip = Tcl_GetVar(interp,"errorInfo",TCL_GLOBAL_ONLY);
		if (eip) {
			Tcl_DStringInit(&ei);
			eip = Tcl_DStringAppend(&ei,eip,-1);
		}
		ecp = Tcl_GetVar(interp,"errorCode",TCL_GLOBAL_ONLY);
		if (ecp) {
			Tcl_DStringInit(&ec);
			ecp = Tcl_DStringAppend(&ec,ecp,-1);
		}
		/* I assume interp->result is always non-zero, right? */
		Tcl_DStringInit(&ir);
		Tcl_DStringAppend(&ir,interp->result,-1);
d473 6
a478 4
		exp_debuglog("return value = %d for trap %s, action %s\r\n",
				newcode,signal_to_string(sig),trap->action);
		if (*interp->result != 0) {
			errorlog("%s\r\n",interp->result);
d488 4
a491 3
			eip = Tcl_GetVar(interp,"errorInfo",TCL_GLOBAL_ONLY);
			exp_nostack_dump =
				(eip && (0 == strncmp("-nostack",eip,8)));
d494 4
a497 4
		if (newcode != TCL_ERROR) {
			exp_error(interp,"return value = %d for trap %s, action %s\r\n",newcode,signal_to_string(sig),trap->action);
		}
		Tcl_BackgroundError(interp);
d505 3
a507 1
				/* flags: ERR_IN_PROGRESS, ERROR_CODE_SET */
d510 6
a515 2
			Tcl_AddErrorInfo(interp,eip);
			Tcl_DStringFree(&ei);
d517 1
a517 1
			Tcl_UnsetVar(interp,"errorInfo",0);
d525 4
a528 3
			if (!streq("NONE",ecp))
				Tcl_SetErrorCode(interp,ecp,(char *)0);
			Tcl_DStringFree(&ec);
d530 1
a530 1
			Tcl_UnsetVar(interp,"errorCode",0);
a532 3
		Tcl_DStringResult(interp,&ir);
		Tcl_DStringFree(&ir);

d544 1
a544 1
{"trap",	exp_proc(Exp_TrapCmd),	(ClientData)EXP_SPAWN_ID_BAD,	0},
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Initial 8.1 changes.
@
text
@d295 1
a295 1
Exp_TrapObjCmd(clientData, interp, objc, objv)
d298 2
a299 2
int objc;
Tcl_Obj *CONST objv[];
d303 1
a303 2
	Tcl_Obj **list;	/* list of signals */
	char *arg;
d314 1
a314 1
	objc--; objv++;
d316 3
a318 5
	while (objc) {
	  arg = Tcl_GetString(*objv);

		if (streq(arg,"-code")) {
			objc--; objv++; 
d320 2
a321 2
		} else if (streq(arg,"-interp")) {
			objc--; objv++; 
d323 2
a324 2
		} else if (streq(arg,"-name")) {
			objc--; objv++;
d326 2
a327 2
		} else if (streq(arg,"-number")) {
			objc--; objv++;
d329 2
a330 2
		} else if (streq(arg,"-max")) {
			objc--; objv++;
d336 1
a336 1
		if (objc > 0) goto usage_error;
d338 2
a339 1
		  Tcl_SetObjResult(interp,Tcl_NewIntObj(NSIG-1));
d343 2
a344 2
		  Tcl_SetResult(interp,"no signal in progress",TCL_STATIC);
		  return TCL_ERROR;
d347 2
a348 2
		  /* skip over "SIG" */
		  Tcl_SetResult(interp,signal_to_string(current_sig) + 3,TCL_STATIC);
d350 1
a350 1
		  Tcl_SetObjResult(interp,Tcl_NewIntObj(current_sig));
d355 1
a355 1
	if (objc == 0 || objc > 2) goto usage_error;
d357 2
a358 2
	if (objc == 1) {
		int sig = exp_string_to_signal(interp,arg);
d362 1
a362 1
			Tcl_SetResult(interp,traps[sig].action,TCL_STATIC);
d364 1
a364 1
			Tcl_SetResult(interp,"SIG_DFL",TCL_STATIC);
d369 1
a369 1
	action = arg;
d371 3
a373 3
	/* objv[1] is the list of signals - crack it open */
	if (TCL_OK != Tcl_ListObjGetElements(interp,objv[1],&n,&list)) {
		errorlog("%s\r\n",Tcl_GetStringResult(interp));
d378 1
a378 6
	  char *s;
	  int sig;

	  s = Tcl_GetString(list[i]);

		sig = exp_string_to_signal(interp,s);
d390 11
a400 1
		exp_debuglog("trap: setting up signal %d (\"%s\")\r\n",sig,s);
d402 1
d422 1
a422 3
	/* It is no longer necessary to free the split list since it */
	/* is still owned by Tcl, yes? */
	/*	ckfree((char *)list); */
d439 5
a443 3
	Tcl_Obj *eip;   /* errorInfo */
	Tcl_Obj *ecp;	/* errorCode */
	Tcl_Obj *irp;	/* interp->result */
d455 13
a467 7

		eip = Tcl_GetVar2Ex(interp,"errorInfo","",TCL_GLOBAL_ONLY);
		if (eip) eip = Tcl_DuplicateObj(eip);
		ecp = Tcl_GetVar2Ex(interp,"errorCode","",TCL_GLOBAL_ONLY);
		if (ecp) ecp = Tcl_DuplicateObj(ecp);
		irp = Tcl_GetObjResult(interp);
		if (irp) irp = Tcl_DuplicateObj(irp);
d480 1
a480 1
		if (0 != strcmp(Tcl_GetStringResult(interp),"")) {
d491 3
a493 4
			eip = Tcl_GetVar2Ex(interp,"errorInfo","",TCL_GLOBAL_ONLY);
			if (eip) {
			  exp_nostack_dump = (0 == strncmp("-nostack",Tcl_GetString(eip),8));
			}
d496 4
a499 4
	  if (newcode != TCL_ERROR) {
	    exp_error(interp,"return value = %d for trap %s, action %s\r\n",newcode,signal_to_string(sig),trap->action);
	  }
	  Tcl_BackgroundError(interp);
d507 1
a507 3
		   /* flags: ERR_IN_PROGRESS, ERROR_CODE_SET */
		   /* This also wipes clean errorInfo/Code/result which is why */
		   /* all the calls to Tcl_Dup earlier */
d510 2
a511 6
		  /* odd that Tcl doesn't have a call that does all this at once */
		  int len;
		  char *s = Tcl_GetStringFromObj(eip,&len);
		  Tcl_AddObjErrorInfo(interp,s,len);
		  Tcl_DecrRefCount(eip);
		  /* we never incr'd it, but the code allows this */
d513 1
a513 1
		  Tcl_UnsetVar(interp,"errorInfo",0);
d521 3
a523 4
		  if (!streq("NONE",Tcl_GetString(ecp)))
		    Tcl_SetErrorCode(interp,ecp);
		  /* we're just passing on the errorcode obj */
		  /* presumably, Tcl will incr ref count */
d525 1
a525 1
		  Tcl_UnsetVar(interp,"errorCode",0);
d528 3
d542 1
a542 1
{"trap",	Exp_TrapObjCmd, 0,	(ClientData)EXP_SPAWN_ID_BAD,	0},
@


5.28.1.1.2.2
log
@fixed Log/Diag and ExpectCmd
@
text
@d90 1
d92 1
a92 1
	expDiagLog("sighandler: handling signal(%d)\r\n",got_sig);
d95 1
a95 1
		expErrorLog("caught impossible signal %d\r\n",got_sig);
d110 1
a110 1
		expDiagLog("sigchld_count-- == %d\n",sigchld_count);
d118 1
a118 1
		expErrorLog("caught unexpected signal: %s (%d)\r\n",
d201 1
d375 1
a375 2
		expErrorLogU(Tcl_GetStringResult(interp));
		expErrorLogU("\r\n");
d397 1
a397 1
		expDiagLog("trap: setting up signal %d (\"%s\")\r\n",sig,s);
d441 1
a441 3
	expDiagLogU("async event handler: Tcl_Eval(");
	expDiagLogU(trap->action);
	expDiagLogU(")\r\n");
d468 2
a469 3
		expDiagLog("return value = %d for trap %s, action ",newcode,signal_to_string(sig));
		expDiagLogU(trap->action);
		expDiagLogU("\r\n");
d471 1
a471 2
			expErrorLogU(interp->result);
			expErrorLogU("\r\n");
@


5.28.1.1.2.3
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d161 1
a161 1
					/* rearmed (i.e., because it has */
@


5.28.1.1.2.4
log
@Fixes to library.
Testing new fix to system command.
@
text
@d203 2
a204 6
#ifdef HAVE_SIGLONGJMP
      if (env_valid && (sig != 0)) siglongjmp(env,2);
#else
      if (env_valid && (sig != 0)) longjmp(env,2);
#endif  /* HAVE_SIGLONGJMP */
#endif /* 0 */
@


