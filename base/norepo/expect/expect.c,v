head	5.62;
access;
symbols
	expect_5_45:5.59
	expect_6_branch:5.58.0.2
	expect_5_44_1_15:5.58
	activestate_win32_port_start:5.38
	telco-tec-win32-take2-branch:5.32.0.6
	telco-tec-win32-branch:5.32.0.4
	expect-sf418892-sf439042-branch:5.32.0.2
	tclpro-1-5-0:5.32
	tclpro-1-4-1:5.32
	tclpro-1-4-0:5.32
	expect-5-32-2:5.32
	expect-5-32-0:5.32
	ajuba-ajuba2-2-0:5.29.2.25
	scriptics-sc-2-0-b5:5.29.2.25
	scriptics-sc-2-0-fixed:5.29.2.25
	scriptics-sc-2-0-b2:5.29.2.25
	scriptics-sc-2-0-b1:5.29.2.25
	scriptics-sc-1-1:5.29.2.25
	scriptics-sc-1-1-b1:5.29.2.25
	scriptics-sc-1-1-branch:5.29.2.25.0.4
	scriptics-sc-1-1-base:5.29.2.25
	scriptics-sc-1-0:5.29.2.25
	scriptics-sc-1-0-branch:5.29.2.25.0.2
	scriptics-sc-1-0-base:5.29.2.25
	expect-5-31-3:5.29.2.25
	scriptics-bc-1-0-b1:5.29.2.25
	scriptics-tclpro-1-3-0:5.29.2.22
	scriptics-tclpro-1-3-b4:5.29.2.22
	scriptics-tclpro-1-3-b3:5.29.2.22
	expect-5-31:5.29.2.22
	expect-5-31-branch:5.29.0.2
	expect-5-31-base:5.29
	scriptics-tclpro-1-2:5.29
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.62
date	2014.05.01.19.22.24;	author andreas_kupries;	state Exp;
branches;
next	5.61;

5.61
date	2013.11.04.19.03.00;	author andreas_kupries;	state Exp;
branches;
next	5.60;

5.60
date	2012.08.15.22.25.31;	author andreas_kupries;	state Exp;
branches;
next	5.59;

5.59
date	2010.10.26.22.09.36;	author andreas_kupries;	state Exp;
branches;
next	5.58;

5.58
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.57;

5.57
date	2010.06.09.22.08.20;	author eee;	state Exp;
branches;
next	5.56;

5.56
date	2010.03.19.16.53.03;	author eee;	state Exp;
branches;
next	5.55;

5.55
date	2010.03.11.21.55.45;	author eee;	state Exp;
branches;
next	5.54;

5.54
date	2008.10.03.17.05.14;	author andreas_kupries;	state Exp;
branches;
next	5.53;

5.53
date	2008.04.03.19.19.41;	author andreas_kupries;	state Exp;
branches;
next	5.52;

5.52
date	2008.04.03.19.07.14;	author andreas_kupries;	state Exp;
branches;
next	5.51;

5.51
date	2008.02.29.17.47.34;	author andreas_kupries;	state Exp;
branches;
next	5.50;

5.50
date	2007.09.24.18.34.13;	author andreas_kupries;	state Exp;
branches;
next	5.49;

5.49
date	2007.08.09.20.23.17;	author andreas_kupries;	state Exp;
branches;
next	5.48;

5.48
date	2007.07.17.18.39.23;	author andreas_kupries;	state Exp;
branches;
next	5.47;

5.47
date	2007.07.12.22.28.04;	author andreas_kupries;	state Exp;
branches;
next	5.46;

5.46
date	2007.07.11.21.35.08;	author andreas_kupries;	state Exp;
branches;
next	5.45;

5.45
date	2007.07.11.20.51.44;	author andreas_kupries;	state Exp;
branches;
next	5.44;

5.44
date	2007.07.11.20.22.10;	author andreas_kupries;	state Exp;
branches;
next	5.43;

5.43
date	2007.07.11.20.07.23;	author andreas_kupries;	state Exp;
branches;
next	5.42;

5.42
date	2007.07.11.20.00.35;	author andreas_kupries;	state Exp;
branches;
next	5.41;

5.41
date	2005.01.21.23.17.12;	author andreas_kupries;	state Exp;
branches;
next	5.40;

5.40
date	2004.07.15.20.24.40;	author andreas_kupries;	state Exp;
branches;
next	5.39;

5.39
date	2003.09.05.19.01.56;	author andreas_kupries;	state Exp;
branches;
next	5.38;

5.38
date	2002.04.16.21.00.29;	author libes;	state Exp;
branches;
next	5.37;

5.37
date	2002.04.07.21.26.52;	author libes;	state Exp;
branches;
next	5.36;

5.36
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.35;

5.35
date	2002.02.25.23.22.11;	author andreas_kupries;	state Exp;
branches;
next	5.34;

5.34
date	2002.02.07.23.46.49;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2001.11.09.19.36.18;	author andreas_kupries;	state Exp;
branches;
next	5.32;

5.32
date	2000.07.13.04.36.54;	author libes;	state Exp;
branches
	5.32.2.1
	5.32.4.1
	5.32.6.1;
next	5.31;

5.31
date	2000.06.08.19.17.21;	author libes;	state Exp;
branches;
next	5.30;

5.30
date	2000.01.06.23.22.05;	author wart;	state Exp;
branches;
next	5.29;

5.29
date	99.02.12.23.51.46;	author libes;	state Exp;
branches
	5.29.2.1;
next	5.28;

5.28
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.22;	author cvsadmin;	state Exp;
branches;
next	;

5.29.2.1
date	99.06.07.17.49.40;	author libes;	state Exp;
branches;
next	5.29.2.2;

5.29.2.2
date	99.06.10.22.01.44;	author don;	state Exp;
branches;
next	5.29.2.3;

5.29.2.3
date	99.06.11.02.10.20;	author stanton;	state Exp;
branches;
next	5.29.2.4;

5.29.2.4
date	99.06.11.20.11.51;	author don;	state Exp;
branches;
next	5.29.2.5;

5.29.2.5
date	99.06.12.01.44.18;	author stanton;	state Exp;
branches;
next	5.29.2.6;

5.29.2.6
date	99.06.14.20.36.52;	author don;	state Exp;
branches;
next	5.29.2.7;

5.29.2.7
date	99.06.14.23.54.07;	author don;	state Exp;
branches;
next	5.29.2.8;

5.29.2.8
date	99.06.15.01.32.11;	author don;	state Exp;
branches;
next	5.29.2.9;

5.29.2.9
date	99.06.15.10.02.38;	author don;	state Exp;
branches;
next	5.29.2.10;

5.29.2.10
date	99.06.15.19.11.59;	author don;	state Exp;
branches;
next	5.29.2.11;

5.29.2.11
date	99.06.15.20.40.47;	author stanton;	state Exp;
branches;
next	5.29.2.12;

5.29.2.12
date	99.06.15.21.09.58;	author stanton;	state Exp;
branches;
next	5.29.2.13;

5.29.2.13
date	99.06.15.22.53.00;	author don;	state Exp;
branches;
next	5.29.2.14;

5.29.2.14
date	99.06.16.03.02.41;	author don;	state Exp;
branches;
next	5.29.2.15;

5.29.2.15
date	99.06.16.08.16.00;	author don;	state Exp;
branches;
next	5.29.2.16;

5.29.2.16
date	99.06.18.01.41.51;	author stanton;	state Exp;
branches;
next	5.29.2.17;

5.29.2.17
date	99.06.20.06.32.20;	author libes;	state Exp;
branches;
next	5.29.2.18;

5.29.2.18
date	99.06.22.05.03.30;	author libes;	state Exp;
branches;
next	5.29.2.19;

5.29.2.19
date	99.06.22.22.15.38;	author stanton;	state Exp;
branches;
next	5.29.2.20;

5.29.2.20
date	99.06.23.17.25.18;	author libes;	state Exp;
branches;
next	5.29.2.21;

5.29.2.21
date	99.06.28.06.29.26;	author libes;	state Exp;
branches;
next	5.29.2.22;

5.29.2.22
date	99.06.29.02.27.46;	author libes;	state Exp;
branches;
next	5.29.2.23;

5.29.2.23
date	99.08.17.21.04.50;	author libes;	state Exp;
branches;
next	5.29.2.24;

5.29.2.24
date	99.08.17.21.26.05;	author libes;	state Exp;
branches;
next	5.29.2.25;

5.29.2.25
date	99.09.07.04.28.05;	author libes;	state Exp;
branches;
next	5.29.2.26;

5.29.2.26
date	99.12.04.06.18.25;	author libes;	state Exp;
branches;
next	5.29.2.27;

5.29.2.27
date	99.12.31.01.02.59;	author libes;	state Exp;
branches;
next	;

5.32.2.1
date	2001.11.09.19.40.02;	author andreas_kupries;	state Exp;
branches;
next	5.32.2.2;

5.32.2.2
date	2002.02.07.23.46.00;	author andreas_kupries;	state Exp;
branches;
next	5.32.2.3;

5.32.2.3
date	2002.02.25.23.21.56;	author andreas_kupries;	state Exp;
branches;
next	;

5.32.4.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;

5.32.6.1
date	2001.11.22.08.50.37;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.62
log
@* exp_main_sub.c: Updated EXP_VERSION to 5.45.3
* configure, configure.in: Updated expect to version 5.45.3

* expect.man [http://sourceforge.net/p/expect/bugs/86/]. Report
  and fix by Vitezlav Crhonek.

* expect.c [http://sourceforge.net/p/expect/bugs/76/]. Report and
  fix by Mutsuhito Iikura. On finding a full buffer during
  matching the sliding window mechanism slides too far, truncating
  the whole buffer and preventing matches across the boundary. Fix
  is shortening the slide distance (slide only one 1/3).

* expect.c: [http://sourceforge.net/p/expect/patches/18/]. Report
  and fix both by Nils Carlson <nils.carlson@@ludd.ltu.se>.
  Replaced a cc==0 check with proper Tcl_Eof() check.
@
text
@/* expect.c - expect commands

Written by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include <sys/types.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <ctype.h>	/* for isspace */
#include <time.h>	/* for time(3) */

#include "expect_cf.h"

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#include "tclInt.h"

#include "string.h"

#include "exp_rename.h"
#include "exp_prog.h"
#include "exp_command.h"
#include "exp_log.h"
#include "exp_event.h"
#include "exp_tty_in.h"
#include "exp_tstamp.h"	/* this should disappear when interact */
			/* loses ref's to it */
#ifdef TCL_DEBUGGER
#include "tcldbg.h"
#endif

#include "retoglob.c" /* RE 2 GLOB translator C variant */

/* initial length of strings that we can guarantee patterns can match */
int exp_default_match_max =	2000;
#define INIT_EXPECT_TIMEOUT_LIT	"10"	/* seconds */
#define INIT_EXPECT_TIMEOUT	10	/* seconds */
int exp_default_parity =	TRUE;
int exp_default_rm_nulls =	TRUE;
int exp_default_close_on_eof =  TRUE;

/* user variable names */
#define EXPECT_TIMEOUT		"timeout"
#define EXPECT_OUT		"expect_out"

extern int Exp_StringCaseMatch _ANSI_ARGS_((Tcl_UniChar *string, int strlen,
					    Tcl_UniChar *pattern,int plen,
					    int nocase,int *offset));

typedef struct ThreadSpecificData {
    int timeout;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 * addr of these placeholders appear as clientData in ExpectCmd * when called
 * as expect_user and expect_tty.  It would be nicer * to invoked
 * expDevttyGet() but C doesn't allow this in an array initialization, sigh.
 */
static ExpState StdinoutPlaceholder;
static ExpState DevttyPlaceholder;

/* 1 ecase struct is reserved for each case in the expect command.  Note that
 * eof/timeout don't use any of theirs, but the algorithm is simpler this way.
 */

struct ecase {	/* case for expect command */
	struct exp_i	*i_list;
	Tcl_Obj *pat;	/* original pattern spec */
	Tcl_Obj *body;	/* ptr to body to be executed upon match */
    Tcl_Obj *gate;	/* For PAT_RE, a gate-keeper glob pattern
			 * which is quicker to match and reduces
			 * the number of calls into expensive RE
			 * matching. Optional.
			 */
#define PAT_EOF		1
#define PAT_TIMEOUT	2
#define PAT_DEFAULT	3
#define PAT_FULLBUFFER	4
#define PAT_GLOB	5 /* glob-style pattern list */
#define PAT_RE		6 /* regular expression */
#define PAT_EXACT	7 /* exact string */
#define PAT_NULL	8 /* ASCII 0 */
#define PAT_TYPES	9 /* used to size array of pattern type descriptions */
	int use;	/* PAT_XXX */
    int simple_start;	/* offset (chars) from start of buffer denoting where a
			 * glob or exact match begins */
	int transfer;	/* if false, leave matched chars in input stream */
	int indices;	/* if true, write indices */
	int iread;	/* if true, reread indirects */
	int timestamp;	/* if true, write timestamps */
#define CASE_UNKNOWN	0
#define CASE_NORM	1
#define CASE_LOWER	2
	int Case;	/* convert case before doing match? */
};

/* descriptions of the pattern types, used for debugging */
char *pattern_style[PAT_TYPES];

struct exp_cases_descriptor {
	int count;
	struct ecase **cases;
};

/* This describes an Expect command */
static
struct exp_cmd_descriptor {
	int cmdtype;			/* bg, before, after */
	int duration;			/* permanent or temporary */
	int timeout_specified_by_flag;	/* if -timeout flag used */
	int timeout;			/* timeout period if flag used */
	struct exp_cases_descriptor ecd;
	struct exp_i *i_list;
} exp_cmds[4];

/* note that exp_cmds[FG] is just a fake, the real contents is stored in some
 * dynamically-allocated variable.  We use exp_cmds[FG] mostly as a well-known
 * address and also as a convenience and so we allocate just a few of its
 * fields that we need.
 */

static void
exp_cmd_init(
    struct exp_cmd_descriptor *cmd,
    int cmdtype,
    int duration)
{
	cmd->duration = duration;
	cmd->cmdtype = cmdtype;
	cmd->ecd.cases = 0;
	cmd->ecd.count = 0;
	cmd->i_list = 0;
}

static int i_read_errno;/* place to save errno, if i_read() == -1, so it
			   doesn't get overwritten before we get to read it */

#ifdef SIMPLE_EVENT
static int alarm_fired;	/* if alarm occurs */
#endif

void exp_background_channelhandlers_run_all();

/* exp_indirect_updateX is called by Tcl when an indirect variable is set */
static char *exp_indirect_update1( /* 1-part Tcl variable names */
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    struct exp_i *exp_i);
static char *exp_indirect_update2( /* 2-part Tcl variable names */
    ClientData clientData,
    Tcl_Interp *interp,	/* Interpreter containing variable. */
    char *name1,	/* Name of variable. */
    char *name2,	/* Second part of variable name. */
    int flags);		/* Information about what happened. */

#ifdef SIMPLE_EVENT
/*ARGSUSED*/
static RETSIGTYPE
sigalarm_handler(int n) /* unused, for compatibility with STDC */
{
	alarm_fired = TRUE;
}
#endif /*SIMPLE_EVENT*/

/* free up everything in ecase */
static void
free_ecase(
    Tcl_Interp *interp,
    struct ecase *ec,
    int free_ilist)		/* if we should free ilist */
{
    if (ec->i_list->duration == EXP_PERMANENT) {
	if (ec->pat)  { Tcl_DecrRefCount(ec->pat); }
	if (ec->gate) { Tcl_DecrRefCount(ec->gate); }
	if (ec->body) { Tcl_DecrRefCount(ec->body); }
    }

    if (free_ilist) {
	ec->i_list->ecount--;
	if (ec->i_list->ecount == 0) {
	    exp_free_i(interp,ec->i_list,exp_indirect_update2);
    }
    }

    ckfree((char *)ec);	/* NEW */
}

/* free up any argv structures in the ecases */
static void
free_ecases(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *eg,
    int free_ilist)		/* if true, free ilists */
{
	int i;

	if (!eg->ecd.cases) return;

	for (i=0;i<eg->ecd.count;i++) {
		free_ecase(interp,eg->ecd.cases[i],free_ilist);
	}
	ckfree((char *)eg->ecd.cases);

	eg->ecd.cases = 0;
	eg->ecd.count = 0;
}


#if 0
/* no standard defn for this, and some systems don't even have it, so avoid */
/* the whole quagmire by calling it something else */
static char *exp_strdup(char *s)
{
	char *news = ckalloc(strlen(s) + 1);
	strcpy(news,s);
	return(news);
}
#endif

/* return TRUE if string appears to be a set of arguments
   The intent of this test is to support the ability of commands to have
   all their args braced as one.  This conflicts with the possibility of
   actually intending to have a single argument.
   The bad case is in expect which can have a single argument with embedded
   \n's although it's rare.  Examples that this code should handle:
   \n		FALSE (pattern)
   \n\n		FALSE
   \n  \n \n	FALSE
   foo		FALSE
   foo\n	FALSE
   \nfoo\n	TRUE  (set of args)
   \nfoo\nbar	TRUE

   Current test is very cheap and almost always right :-)
*/
int 
exp_one_arg_braced(Tcl_Obj *objPtr)	/* INTL */
{
	int seen_nl = FALSE;
	char *p = Tcl_GetString(objPtr);

	for (;*p;p++) {
		if (*p == '\n') {
			seen_nl = TRUE;
			continue;
		}

		if (!isspace(*p)) { /* INTL: ISO space */
			return(seen_nl);
		}
	}
	return FALSE;
}

/* called to execute a command of only one argument - a hack to commands */
/* to be called with all args surrounded by an outer set of braces */
/* Returns a list object containing the new set of arguments */
/* Caller then has to either reinvoke itself, or better, simply replace
 * its current argumnts */
/*ARGSUSED*/
Tcl_Obj*
exp_eval_with_one_arg(
    ClientData clientData,
    Tcl_Interp *interp,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    Tcl_Obj* res = Tcl_NewListObj (1,objv);

#define NUM_STATIC_OBJS 20
    Tcl_Token *tokenPtr;
    CONST char *p;
    CONST char *next;
    int rc;
    int bytesLeft, numWords;
    Tcl_Parse parse;

    /*
     * Prepend the command name and the -nobrace switch so we can
     * reinvoke without recursing.
     */

    Tcl_ListObjAppendElement (interp, res, Tcl_NewStringObj("-nobrace", -1));

    p = Tcl_GetStringFromObj(objv[1], &bytesLeft);

    /*
     * Treat the pattern/action block like a series of Tcl commands.
     * For each command, parse the command words, perform substititions
     * on each word, and add the words to an array of values.  We don't
     * actually evaluate the individual commands, just the substitutions.
     */

    do {
	if (Tcl_ParseCommand(interp, p, bytesLeft, 0, &parse)
	        != TCL_OK) {
	    rc = TCL_ERROR;
	    goto done;
	}
	numWords = parse.numWords;
 	if (numWords > 0) {
	    /*
	     * Generate an array of objects for the words of the command.
	     */
    
	    /*
	     * For each word, perform substitutions then store the
	     * result in the objs array.
	     */
	    
	    for (tokenPtr = parse.tokenPtr; numWords > 0;
		 numWords--, tokenPtr += (tokenPtr->numComponents + 1)) {
		/* FUTURE: Save token information, do substitution later */

		Tcl_Obj* w = Tcl_EvalTokens(interp, tokenPtr+1,
			tokenPtr->numComponents);
		/* w has refCount 1 here, if not NULL */
		if (w == NULL) {
		    Tcl_DecrRefCount (res);
		    res = NULL;
		    goto done;

		}
		Tcl_ListObjAppendElement (interp, res, w);
		Tcl_DecrRefCount (w); /* Local reference goes away */
	    }
	}

	/*
	 * Advance to the next command in the script.
	 */
	next = parse.commandStart + parse.commandSize;
	bytesLeft -= next - p;
	p = next;
	Tcl_FreeParse(&parse);
    } while (bytesLeft > 0);

 done:
    return res;
}

static void
ecase_clear(struct ecase *ec)
{
	ec->i_list = 0;
	ec->pat = 0;
	ec->body = 0;
	ec->transfer = TRUE;
	ec->simple_start = 0;
	ec->indices = FALSE;
	ec->iread = FALSE;
	ec->timestamp = FALSE;
	ec->Case = CASE_NORM;
	ec->use = PAT_GLOB;
    ec->gate = NULL;
}

static struct ecase *
ecase_new(void)
{
	struct ecase *ec = (struct ecase *)ckalloc(sizeof(struct ecase));

	ecase_clear(ec);
	return ec;
}

/*

parse_expect_args parses the arguments to expect or its variants. 
It normally returns TCL_OK, and returns TCL_ERROR for failure.
(It can't return i_list directly because there is no way to differentiate
between clearing, say, expect_before and signalling an error.)

eg (expect_global) is initialized to reflect the arguments parsed
eg->ecd.cases is an array of ecases
eg->ecd.count is the # of ecases
eg->i_list is a linked list of exp_i's which represent the -i info

Each exp_i is chained to the next so that they can be easily free'd if
necessary.  Each exp_i has a reference count.  If the -i is not used
(e.g., has no following patterns), the ref count will be 0.

Each ecase points to an exp_i.  Several ecases may point to the same exp_i.
Variables named by indirect exp_i's are read for the direct values.

If called from a foreground expect and no patterns or -i are given, a
default exp_i is forced so that the command "expect" works right.

The exp_i chain can be broken by the caller if desired.

*/

static int
parse_expect_args(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *eg,
    ExpState *default_esPtr,	/* suggested ExpState if called as expect_user or _tty */
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int i;
    char *string;
    struct ecase ec;	/* temporary to collect args */

    eg->timeout_specified_by_flag = FALSE;

    ecase_clear(&ec);

    /* Allocate an array to store the ecases.  Force array even if 0 */
    /* cases.  This will often be too large (i.e., if there are flags) */
    /* but won't affect anything. */

    eg->ecd.cases = (struct ecase **)ckalloc(sizeof(struct ecase *) * (1+(objc/2)));

    eg->ecd.count = 0;

    for (i = 1;i<objc;i++) {
	int index;
	string = Tcl_GetString(objv[i]);
	if (string[0] == '-') {
	    static char *flags[] = {
		"-glob", "-regexp", "-exact", "-notransfer", "-nocase",
		"-i", "-indices", "-iread", "-timestamp", "-timeout",
		"-nobrace", "--", (char *)0
	    };
	    enum flags {
		EXP_ARG_GLOB, EXP_ARG_REGEXP, EXP_ARG_EXACT,
		EXP_ARG_NOTRANSFER, EXP_ARG_NOCASE, EXP_ARG_SPAWN_ID,
		EXP_ARG_INDICES, EXP_ARG_IREAD, EXP_ARG_TIMESTAMP,
		EXP_ARG_DASH_TIMEOUT, EXP_ARG_NOBRACE, EXP_ARG_DASH
	    };

	    /*
	     * Allow abbreviations of switches and report an error if we
	     * get an invalid switch.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
		    &index) != TCL_OK) {
		return TCL_ERROR;
	    }
	    switch ((enum flags) index) {
	    case EXP_ARG_GLOB:
	    case EXP_ARG_DASH:
		i++;
		/* assignment here is not actually necessary */
		/* since cases are initialized this way above */
		/* ec.use = PAT_GLOB; */
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-glob pattern");
		    return TCL_ERROR;
		}
		goto pattern;
	    case EXP_ARG_REGEXP:
		i++;
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,"-regexp regexp");
		    return TCL_ERROR;
		}
		ec.use = PAT_RE;

		/*
		 * Try compiling the expression so we can report
		 * any errors now rather then when we first try to
		 * use it.
		 */

		if (!(Tcl_GetRegExpFromObj(interp, objv[i],
					   TCL_REG_ADVANCED))) {
		    goto error;
		}

		/* Derive a gate keeper glob pattern which reduces the amount
		 * of RE matching.
		 */

		{
		    Tcl_Obj* g;
		    Tcl_UniChar* str;
		    int strlen;

		    str = Tcl_GetUnicodeFromObj (objv[i], &strlen);
		    g = exp_retoglob (str, strlen);

		    if (g) {
			ec.gate = g;

			expDiagLog("Gate keeper glob pattern for '%s'",Tcl_GetString(objv[i]));
			expDiagLog(" is '%s'. Activating booster.\n",Tcl_GetString(g));
		    } else {
			/* Ignore errors, fall back to regular RE matching */
			expDiagLog("Gate keeper glob pattern for '%s'",Tcl_GetString(objv[i]));
			expDiagLog(" is '%s'. Not usable, disabling the",Tcl_GetString(Tcl_GetObjResult (interp)));
			expDiagLog(" performance booster.\n");
		    }
		}

		goto pattern;
	    case EXP_ARG_EXACT:
		i++;
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-exact string");
		    return TCL_ERROR;
		}
		ec.use = PAT_EXACT;
		goto pattern;
	    case EXP_ARG_NOTRANSFER:
		ec.transfer = 0;
		break;
	    case EXP_ARG_NOCASE:
		ec.Case = CASE_LOWER;
		break;
	    case EXP_ARG_SPAWN_ID:
		i++;
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-i spawn_id");
		    goto error;
		}
		ec.i_list = exp_new_i_complex(interp,
				      Tcl_GetString(objv[i]),
				      eg->duration, exp_indirect_update2);
		if (!ec.i_list) goto error;
		ec.i_list->cmdtype = eg->cmdtype;

		/* link new i_list to head of list */
		ec.i_list->next = eg->i_list;
		eg->i_list = ec.i_list;
		break;
	    case EXP_ARG_INDICES:
		ec.indices = TRUE;
		break;
	    case EXP_ARG_IREAD:
		ec.iread = TRUE;
		break;
	    case EXP_ARG_TIMESTAMP:
		ec.timestamp = TRUE;
		break;
	    case EXP_ARG_DASH_TIMEOUT:
		i++;
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-timeout seconds");
		    goto error;
		}
		if (Tcl_GetIntFromObj(interp, objv[i],
				      &eg->timeout) != TCL_OK) {
		    goto error;
		}
		eg->timeout_specified_by_flag = TRUE;
		break;
	    case EXP_ARG_NOBRACE:
		/* nobrace does nothing but take up space */
		/* on the command line which prevents */
		/* us from re-expanding any command lines */
		/* of one argument that looks like it should */
		/* be expanded to multiple arguments. */
		break;
	    }
	    /*
	     * Keep processing arguments, we aren't ready for the
	     * pattern yet.
	     */
	    continue;
	} else {
	    /*
	     * We have a pattern or keyword.
	     */

	    static char *keywords[] = {
		"timeout", "eof", "full_buffer", "default", "null",
		(char *)NULL
	    };
	    enum keywords {
		EXP_ARG_TIMEOUT, EXP_ARG_EOF, EXP_ARG_FULL_BUFFER,
		EXP_ARG_DEFAULT, EXP_ARG_NULL
	    };

	    /*
	     * Match keywords exactly, otherwise they are patterns.
	     */

	    if (Tcl_GetIndexFromObj(interp, objv[i], keywords, "keyword",
		    1 /* exact */, &index) != TCL_OK) {
		Tcl_ResetResult(interp);
		goto pattern;
	    }
	    switch ((enum keywords) index) {
	    case EXP_ARG_TIMEOUT:
		ec.use = PAT_TIMEOUT;
		break;
	    case EXP_ARG_EOF:
		ec.use = PAT_EOF;
		break;
	    case EXP_ARG_FULL_BUFFER:
		ec.use = PAT_FULLBUFFER;
		break;
	    case EXP_ARG_DEFAULT:
		ec.use = PAT_DEFAULT;
		break;
	    case EXP_ARG_NULL:
		ec.use = PAT_NULL;
		break;
	    }
pattern:
	    /* if no -i, use previous one */
	    if (!ec.i_list) {
		/* if no -i flag has occurred yet, use default */
		if (!eg->i_list) {
		    if (default_esPtr != EXP_SPAWN_ID_BAD) {
			eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
		    } else {
		        default_esPtr = expStateCurrent(interp,0,0,1);
		        if (!default_esPtr) goto error;
		        eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
		    }
		}
		ec.i_list = eg->i_list;
	    }
	    ec.i_list->ecount++;

	    /* save original pattern spec */
	    /* keywords such as "-timeout" are saved as patterns here */
	    /* useful for debugging but not otherwise used */

	    ec.pat = objv[i];
	    if (eg->duration == EXP_PERMANENT) {
		Tcl_IncrRefCount(ec.pat);
		if (ec.gate) {
		    Tcl_IncrRefCount(ec.gate);
		}
	    }

	    i++;
	    if (i < objc) {
		ec.body = objv[i];
		if (eg->duration == EXP_PERMANENT) Tcl_IncrRefCount(ec.body);
	    } else {
		ec.body = NULL;
	    }

	    *(eg->ecd.cases[eg->ecd.count] = ecase_new()) = ec;

		/* clear out for next set */
	    ecase_clear(&ec);

	    eg->ecd.count++;
	}
    }

    /* if no patterns at all have appeared force the current */
    /* spawn id to be added to list anyway */

    if (eg->i_list == 0) {
	if (default_esPtr != EXP_SPAWN_ID_BAD) {
	    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
	} else {
	    default_esPtr = expStateCurrent(interp,0,0,1);
	    if (!default_esPtr) goto error;
	    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
	}
    }

    return(TCL_OK);

 error:
    /* very hard to free case_master_list here if it hasn't already */
    /* been attached to a case, ugh */

    /* note that i_list must be avail to free ecases! */
    free_ecases(interp,eg,0);

    if (eg->i_list)
	exp_free_i(interp,eg->i_list,exp_indirect_update2);
    return(TCL_ERROR);
}

#define EXP_IS_DEFAULT(x)	((x) == EXP_TIMEOUT || (x) == EXP_EOF)

static char yes[] = "yes\r\n";
static char no[] = "no\r\n";

/* this describes status of a successful match */
struct eval_out {
    struct ecase *e;		/* ecase that matched */
    ExpState *esPtr;		/* ExpState that matched */
    Tcl_UniChar* matchbuf;   /* Buffer that matched, */
    int          matchlen;   /* and #chars that matched, or
			      * #chars in buffer at EOF */
    /* This points into the esPtr->input.buffer ! */
};




/*
 *----------------------------------------------------------------------
 *
 * string_case_first --
 *
 *	Find the first instance of a pattern in a string.
 *
 * Results:
 *	Returns the pointer to the first instance of the pattern
 *	in the given string, or NULL if no match was found.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
string_case_first(	/* INTL */
    register Tcl_UniChar *string,	/* String (unicode). */
    int length,                         /* length of above string */
    register char *pattern)	/* Pattern, which may contain
				 * special characters (utf8). */
{
    Tcl_UniChar *s;
    char *p;
    int offset;
    register int consumed = 0;
    Tcl_UniChar ch1, ch2;
    Tcl_UniChar *bufend = string + length;

    while ((*string != 0) && (string < bufend)) {
	s = string;
	p = pattern;
        while ((*s) && (s < bufend)) {
	    ch1 = *s++;
            consumed++;
	    offset = TclUtfToUniChar(p, &ch2);
	    if (Tcl_UniCharToLower(ch1) != Tcl_UniCharToLower(ch2)) {
		break;
	    }
	    p += offset;
	}
	if (*p == '\0') {
	    return string;
	}
	string++;
        consumed++;
    }
    return NULL;
}

Tcl_UniChar *
string_first(	/* INTL */
    register Tcl_UniChar *string,       /* String (unicode). */
    int length,                         /* length of above string */
    register char *pattern)             /* Pattern, which may contain
                                         * special characters (utf8). */
{
    Tcl_UniChar *s;
    char *p;
    int offset;
    register int consumed = 0;
    Tcl_UniChar ch1, ch2;
    Tcl_UniChar *bufend = string + length;
    
    while ((*string != 0) && (string < bufend)) {
	s = string;
	p = pattern;
        while ((*s) && (s < bufend)) {
	    ch1 = *s++;
            consumed++;
	    offset = TclUtfToUniChar(p, &ch2);
	    if (ch1 != ch2) {
		break;
	    }
	    p += offset;
	}
        if (*p == '\0') {
	    return string;
	}
        string++;
        consumed++;
    }
    return NULL;
}

Tcl_UniChar *
string_first_char(	/* INTL */
    register Tcl_UniChar *string,	/* String. */
    register Tcl_UniChar pattern)
{
    /* unicode based Tcl_UtfFindFirst */

    Tcl_UniChar find;
    
    while (1) {
        find = *string;
	if (find == pattern) {
	    return string;
	}
	if (*string == '\0') {
	    return NULL;
	}
	string ++;
    }
    return NULL;
}

/* like eval_cases, but handles only a single cases that needs a real */
/* string match */
/* returns EXP_X where X is MATCH, NOMATCH, FULLBUFFER, TCLERRROR */
static int
eval_case_string(
    Tcl_Interp *interp,
    struct ecase *e,
    ExpState *esPtr,
    struct eval_out *o,		/* 'output' - i.e., final case of interest */
/* next two args are for debugging, when they change, reprint buffer */
    ExpState **last_esPtr,
    int *last_case,
    char *suffix)
{
    Tcl_RegExp re;
    Tcl_RegExpInfo info;
    Tcl_Obj* buf;
    Tcl_UniChar *str;
    int numchars, flags, dummy, globmatch;
    int result;

    str      = esPtr->input.buffer;
    numchars = esPtr->input.use;

    /* if ExpState or case changed, redisplay debug-buffer */
    if ((esPtr != *last_esPtr) || e->Case != *last_case) {
	expDiagLog("\r\nexpect%s: does \"",suffix);
	expDiagLogU(expPrintifyUni(str,numchars));
	expDiagLog("\" (spawn_id %s) match %s ",esPtr->name,pattern_style[e->use]);
	*last_esPtr = esPtr;
	*last_case = e->Case;
    }

    if (e->use == PAT_RE) {
	expDiagLog("\"");
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
	expDiagLog("\"? ");

	if (e->gate) {
	    int plen;
	    Tcl_UniChar* pat = Tcl_GetUnicodeFromObj(e->gate,&plen);

	    expDiagLog("Gate \"");
	    expDiagLogU(expPrintify(Tcl_GetString(e->gate)));
	    expDiagLog("\"? gate=");

	    globmatch = Exp_StringCaseMatch(str, numchars, pat, plen,
					    (e->Case == CASE_NORM) ? 0 : 1,
					    &dummy);
	} else {
	    expDiagLog("(No Gate, RE only) gate=");

	    /* No gate => RE matching always */
	    globmatch = 1;
	}
	if (globmatch < 0) {
	    expDiagLogU(no);
	    /* i.e. no match */
	} else {
	    expDiagLog("yes re=");

	if (e->Case == CASE_NORM) {
	    flags = TCL_REG_ADVANCED;
	} else {
	    flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
	}
		    
	re = Tcl_GetRegExpFromObj(interp, e->pat, flags);

	    /* ZZZ: Future optimization: Avoid copying */
	    buf = Tcl_NewUnicodeObj (str, numchars);
	    Tcl_IncrRefCount (buf);
	    result = Tcl_RegExpExecObj(interp, re, buf, 0 /* offset */,
		-1 /* nmatches */, 0 /* eflags */);
	    Tcl_DecrRefCount (buf);
	if (result > 0) {
	    o->e = e;

	    /*
	     * Retrieve the byte offset of the end of the
	     * matched string.  
	     */

	    Tcl_RegExpGetInfo(re, &info);
		o->matchlen = info.matches[0].end;
		o->matchbuf = str;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return(EXP_MATCH);
	} else if (result == 0) {
	    expDiagLogU(no);
	} else { /* result < 0 */
	    return(EXP_TCLERROR);
	}
	}
    } else if (e->use == PAT_GLOB) {
	int match; /* # of chars that matched */

	expDiagLog("\"");
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
	expDiagLog("\"? ");
	if (str) {
	    int plen;
	    Tcl_UniChar* pat = Tcl_GetUnicodeFromObj(e->pat,&plen);

	    match = Exp_StringCaseMatch(str,numchars, pat, plen,
		    (e->Case == CASE_NORM) ? 0 : 1,
		    &e->simple_start);
	    if (match != -1) {
		o->e = e;
		o->matchlen = match;
		o->matchbuf = str;
		o->esPtr = esPtr;
		expDiagLogU(yes);
		return(EXP_MATCH);
	    }
	}
	expDiagLogU(no);
    } else if (e->use == PAT_EXACT) {
	int patLength;
	char *pat = Tcl_GetStringFromObj(e->pat, &patLength);
	Tcl_UniChar *p;

	if (e->Case == CASE_NORM) {
	    p = string_first(str, numchars, pat); /* NEW function in this file, see above */
	} else {
	    p = string_case_first(str, numchars, pat);
	}	    

	expDiagLog("\"");
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
	expDiagLog("\"? ");
	if (p) {
	    /* Bug 3095935. Go from #bytes to #chars */
	    patLength = Tcl_NumUtfChars (pat, patLength);

	    e->simple_start = p - str;
	    o->e = e;
	    o->matchlen = patLength;
	    o->matchbuf = str;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return(EXP_MATCH);
	} else expDiagLogU(no);
    } else if (e->use == PAT_NULL) {
	CONST Tcl_UniChar *p;
	expDiagLogU("null? ");
	p = string_first_char (str, 0); /* NEW function in this file, see above */

	if (p) {
	    o->e = e;
	    o->matchlen = p-str; /* #chars */
	    o->matchbuf = str;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return EXP_MATCH;
	}
	expDiagLogU(no);
    } else if (e->use == PAT_FULLBUFFER) {
        expDiagLogU(Tcl_GetString(e->pat));
	expDiagLogU("? ");
	/* this must be the same test as in expIRead */
	/* We drop one third when are at least 2/3 full */
	/* condition is (size >= max*2/3) <=> (size*3 >= max*2) */
	if (((expSizeGet(esPtr)*3) >= (esPtr->input.max*2)) && (numchars > 0)) {
	    o->e = e;
	    o->matchlen = numchars/3;
	    o->matchbuf = str;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return(EXP_FULLBUFFER);
	} else {
	    expDiagLogU(no);
	}
    }
    return(EXP_NOMATCH);
}

/* sets o.e if successfully finds a matching pattern, eof, timeout or deflt */
/* returns original status arg or EXP_TCLERROR */
static int
eval_cases(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *eg,
    ExpState *esPtr,
    struct eval_out *o,		/* 'output' - i.e., final case of interest */
/* next two args are for debugging, when they change, reprint buffer */
    ExpState **last_esPtr,
    int *last_case,
    int status,
    ExpState *(esPtrs[]),
    int mcount,
    char *suffix)
{
    int i;
    ExpState *em;   /* ExpState of ecase */
    struct ecase *e;

    if (o->e || status == EXP_TCLERROR || eg->ecd.count == 0) return(status);

    if (status == EXP_TIMEOUT) {
	for (i=0;i<eg->ecd.count;i++) {
	    e = eg->ecd.cases[i];
	    if (e->use == PAT_TIMEOUT || e->use == PAT_DEFAULT) {
		o->e = e;
		break;
	    }
	}
	return(status);
    } else if (status == EXP_EOF) {
	for (i=0;i<eg->ecd.count;i++) {
	    e = eg->ecd.cases[i];
	    if (e->use == PAT_EOF || e->use == PAT_DEFAULT) {
		struct exp_state_list *slPtr;

		for (slPtr=e->i_list->state_list; slPtr ;slPtr=slPtr->next) {
		    em = slPtr->esPtr;
		    if (expStateAnyIs(em) || em == esPtr) {
			o->e = e;
			return(status);
		    }
		}
	    }
	}
	return(status);
    }

    /* the top loops are split from the bottom loop only because I can't */
    /* split'em further. */

    /* The bufferful condition does not prevent a pattern match from */
    /* occurring and vice versa, so it is scanned with patterns */
    for (i=0;i<eg->ecd.count;i++) {
	struct exp_state_list *slPtr;
	int j;

	e = eg->ecd.cases[i];
	if (e->use == PAT_TIMEOUT ||
		e->use == PAT_DEFAULT ||
		e->use == PAT_EOF) continue;

	for (slPtr = e->i_list->state_list; slPtr; slPtr = slPtr->next) {
	    em = slPtr->esPtr;
	    /* if em == EXP_SPAWN_ID_ANY, then user is explicitly asking */
	    /* every case to be checked against every ExpState */
	    if (expStateAnyIs(em)) {
		/* test against each spawn_id */
		for (j=0;j<mcount;j++) {
		    status = eval_case_string(interp,e,esPtrs[j],o,
			    last_esPtr,last_case,suffix);
		    if (status != EXP_NOMATCH) return(status);
		}
	    } else {
		/* reject things immediately from wrong spawn_id */
		if (em != esPtr) continue;

		status = eval_case_string(interp,e,esPtr,o,last_esPtr,last_case,suffix);
		if (status != EXP_NOMATCH) return(status);
	    }
	}
    }
    return(EXP_NOMATCH);
}

static void
ecases_remove_by_expi(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    struct exp_i *exp_i)
{
	int i;

	/* delete every ecase dependent on it */
	for (i=0;i<ecmd->ecd.count;) {
		struct ecase *e = ecmd->ecd.cases[i];
		if (e->i_list == exp_i) {
			free_ecase(interp,e,0);

			/* shift remaining elements down */
			/* but only if there are any left */
			/* Use memmove to handle the overlap */
			/* memcpy breaks */
			if (i+1 != ecmd->ecd.count) {
				memmove(&ecmd->ecd.cases[i],
				       &ecmd->ecd.cases[i+1],
					((ecmd->ecd.count - i) - 1) * 
					sizeof(struct exp_cmd_descriptor *));
			}
			ecmd->ecd.count--;
			if (0 == ecmd->ecd.count) {
				ckfree((char *)ecmd->ecd.cases);
				ecmd->ecd.cases = 0;
			}
		} else {
			i++;
		}
	}
}

/* remove exp_i from list */
static void
exp_i_remove(
    Tcl_Interp *interp,
    struct exp_i **ei,	/* list to remove from */
    struct exp_i *exp_i)	/* element to remove */
{
	/* since it's in middle of list, free exp_i by hand */
	for (;*ei; ei = &(*ei)->next) {
		if (*ei == exp_i) {
			*ei = exp_i->next;
			exp_i->next = 0;
			exp_free_i(interp,exp_i,exp_indirect_update2);
			break;
		}
	}
}

/* remove exp_i from list and remove any dependent ecases */
static void
exp_i_remove_with_ecases(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    struct exp_i *exp_i)
{
	ecases_remove_by_expi(interp,ecmd,exp_i);
	exp_i_remove(interp,&ecmd->i_list,exp_i);
}

/* remove ecases tied to a single direct spawn id */
static void
ecmd_remove_state(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    ExpState *esPtr,
    int direct)
{
    struct exp_i *exp_i, *next;
    struct exp_state_list **slPtr;

    for (exp_i=ecmd->i_list;exp_i;exp_i=next) {
	next = exp_i->next;

	if (!(direct & exp_i->direct)) continue;

	for (slPtr = &exp_i->state_list;*slPtr;) {
	    if (esPtr == ((*slPtr)->esPtr)) {
		struct exp_state_list *tmp = *slPtr;
		*slPtr = (*slPtr)->next;
		exp_free_state_single(tmp);

		/* if last bg ecase, disarm spawn id */
		if ((ecmd->cmdtype == EXP_CMD_BG) && (!expStateAnyIs(esPtr))) {
		    esPtr->bg_ecount--;
		    if (esPtr->bg_ecount == 0) {
			exp_disarm_background_channelhandler(esPtr);
			esPtr->bg_interp = 0;
		    }
		}
		
		continue;
	    }
	    slPtr = &(*slPtr)->next;
	}

	/* if left with no ExpStates (and is direct), get rid of it */
	/* and any dependent ecases */
	if (exp_i->direct == EXP_DIRECT && !exp_i->state_list) {
	    exp_i_remove_with_ecases(interp,ecmd,exp_i);
	}
    }
}

/* this is called from exp_close to clean up the ExpState */
void
exp_ecmd_remove_state_direct_and_indirect(
    Tcl_Interp *interp,
    ExpState *esPtr)
{
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_BEFORE],esPtr,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_AFTER],esPtr,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_BG],esPtr,EXP_DIRECT|EXP_INDIRECT);

	/* force it - explanation in exp_tk.c where this func is defined */
	exp_disarm_background_channelhandler_force(esPtr);
}

/* arm a list of background ExpState's */
static void
state_list_arm(
    Tcl_Interp *interp,
    struct exp_state_list *slPtr)
{
    /* for each spawn id in list, arm if necessary */
    for (;slPtr;slPtr=slPtr->next) {
	ExpState *esPtr = slPtr->esPtr;    
	if (expStateAnyIs(esPtr)) continue;

	if (esPtr->bg_ecount == 0) {
	    exp_arm_background_channelhandler(esPtr);
	    esPtr->bg_interp = interp;
	}
	esPtr->bg_ecount++;
    }
}

/* return TRUE if this ecase is used by this fd */
static int
exp_i_uses_state(
    struct exp_i *exp_i,
    ExpState *esPtr)
{
	struct exp_state_list *fdp;

	for (fdp = exp_i->state_list;fdp;fdp=fdp->next) {
		if (fdp->esPtr == esPtr) return 1;
	}
	return 0;
}

static void
ecase_append(
    Tcl_Interp *interp,
    struct ecase *ec)
{
	if (!ec->transfer) Tcl_AppendElement(interp,"-notransfer");
	if (ec->indices) Tcl_AppendElement(interp,"-indices");
	if (!ec->Case) Tcl_AppendElement(interp,"-nocase");

	if (ec->use == PAT_RE) Tcl_AppendElement(interp,"-re");
	else if (ec->use == PAT_GLOB) Tcl_AppendElement(interp,"-gl");
	else if (ec->use == PAT_EXACT) Tcl_AppendElement(interp,"-ex");
	Tcl_AppendElement(interp,Tcl_GetString(ec->pat));
	Tcl_AppendElement(interp,ec->body?Tcl_GetString(ec->body):"");
}

/* append all ecases that match this exp_i */
static void
ecase_by_exp_i_append(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    struct exp_i *exp_i)
{
	int i;
	for (i=0;i<ecmd->ecd.count;i++) {
		if (ecmd->ecd.cases[i]->i_list == exp_i) {
			ecase_append(interp,ecmd->ecd.cases[i]);
		}
	}
}

static void
exp_i_append(
    Tcl_Interp *interp,
    struct exp_i *exp_i)
{
	Tcl_AppendElement(interp,"-i");
	if (exp_i->direct == EXP_INDIRECT) {
		Tcl_AppendElement(interp,exp_i->variable);
	} else {
		struct exp_state_list *fdp;

		/* if more than one element, add braces */
	if (exp_i->state_list->next) {
			Tcl_AppendResult(interp," {",(char *)0);
	}

		for (fdp = exp_i->state_list;fdp;fdp=fdp->next) {
			char buf[25];	/* big enough for a small int */
			sprintf(buf,"%ld", (long)fdp->esPtr);
			Tcl_AppendElement(interp,buf);
		}

	if (exp_i->state_list->next) {
			Tcl_AppendResult(interp,"} ",(char *)0);
	}
}
}

/* return current setting of the permanent expect_before/after/bg */
int
expect_info(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    struct exp_i *exp_i;
    int i;
    int direct = EXP_DIRECT|EXP_INDIRECT;
    char *iflag = 0;
    int all = FALSE;	/* report on all fds */
    ExpState *esPtr = 0;

    static char *flags[] = {"-i", "-all", "-noindirect", (char *)0};
    enum flags {EXP_ARG_I, EXP_ARG_ALL, EXP_ARG_NOINDIRECT};

    /* start with 2 to skip over "cmdname -info" */
    for (i = 2;i<objc;i++) {
	/*
	 * Allow abbreviations of switches and report an error if we
	 * get an invalid switch.
	 */

	int index;
	if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum flags) index) {
	case EXP_ARG_I:
	    i++;
	    if (i >= objc) {
		Tcl_WrongNumArgs(interp, 1, objv,"-i spawn_id");
		return TCL_ERROR;
	    }
	    break;
	case EXP_ARG_ALL:
	    all = TRUE;
	    break;
	case EXP_ARG_NOINDIRECT:
	    direct &= ~EXP_INDIRECT;
	    break;
	}
    }

    if (all) {
	/* avoid printing out -i when redundant */
	struct exp_i *previous = 0;

	for (i=0;i<ecmd->ecd.count;i++) {
	    if (previous != ecmd->ecd.cases[i]->i_list) {
		exp_i_append(interp,ecmd->ecd.cases[i]->i_list);
		previous = ecmd->ecd.cases[i]->i_list;
	    }
	    ecase_append(interp,ecmd->ecd.cases[i]);
	}
	return TCL_OK;
    }

    if (!iflag) {
	if (!(esPtr = expStateCurrent(interp,0,0,0))) {
	    return TCL_ERROR;
	}
    } else if (!(esPtr = expStateFromChannelName(interp,iflag,0,0,0,"dummy"))) {
	/* not a valid ExpState so assume it is an indirect variable */
	Tcl_ResetResult(interp);
	for (i=0;i<ecmd->ecd.count;i++) {
	    if (ecmd->ecd.cases[i]->i_list->direct == EXP_INDIRECT &&
		    streq(ecmd->ecd.cases[i]->i_list->variable,iflag)) {
		ecase_append(interp,ecmd->ecd.cases[i]);
	    }
	}
	return TCL_OK;
    }
    
    /* print ecases of this direct_fd */
    for (exp_i=ecmd->i_list;exp_i;exp_i=exp_i->next) {
	if (!(direct & exp_i->direct)) continue;
	if (!exp_i_uses_state(exp_i,esPtr)) continue;
	ecase_by_exp_i_append(interp,ecmd,exp_i);
    }

    return TCL_OK;
}

/* Exp_ExpectGlobalObjCmd is invoked to process expect_before/after/background */
/*ARGSUSED*/
int
Exp_ExpectGlobalObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int result = TCL_OK;
    struct exp_i *exp_i, **eip;
    struct exp_state_list *slPtr;   /* temp for interating over state_list */
    struct exp_cmd_descriptor eg;
    int count;
    Tcl_Obj* new_cmd = NULL;

    struct exp_cmd_descriptor *ecmd = (struct exp_cmd_descriptor *) clientData;

    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	/* expect {...} */

	new_cmd = exp_eval_with_one_arg(clientData,interp,objv);
	if (!new_cmd) return TCL_ERROR;
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	/* expect -brace {...} ... fake command line for reparsing */

	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];

	new_cmd = exp_eval_with_one_arg(clientData,interp,new_objv);
	if (!new_cmd) return TCL_ERROR;
    }

    if (new_cmd) {
	/* Replace old arguments with result of the reparse */
	Tcl_ListObjGetElements (interp, new_cmd, &objc, (Tcl_Obj***) &objv);
    }

    if (objc > 1 && (Tcl_GetString(objv[1])[0] == '-')) {
	if (exp_flageq("info",Tcl_GetString(objv[1])+1,4)) {
	    int res = expect_info(interp,ecmd,objc,objv);
	    if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
	    return res;
	} 
    }

    exp_cmd_init(&eg,ecmd->cmdtype,EXP_PERMANENT);

    if (TCL_ERROR == parse_expect_args(interp,&eg,EXP_SPAWN_ID_BAD,
	    objc,objv)) {
	if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
	return TCL_ERROR;
    }

    /*
     * visit each NEW direct exp_i looking for spawn ids.
     * When found, remove them from any OLD exp_i's.
     */

    /* visit each exp_i */
    for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	if (exp_i->direct == EXP_INDIRECT) continue;
	/* for each spawn id, remove it from ecases */
	for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
	    ExpState *esPtr = slPtr->esPtr;

	    /* validate all input descriptors */
	    if (!expStateAnyIs(esPtr)) {
		if (!expStateCheck(interp,esPtr,1,1,"expect")) {
		    result = TCL_ERROR;
		    goto cleanup;
		}
	    }
	    
	    /* remove spawn id from exp_i */
	    ecmd_remove_state(interp,ecmd,esPtr,EXP_DIRECT);
	}
    }
	
    /*
     * For each indirect variable, release its old ecases and 
     * clean up the matching spawn ids.
     * Same logic as in "expect_X delete" command.
     */

    for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	struct exp_i **old_i;

	if (exp_i->direct == EXP_DIRECT) continue;

	for (old_i = &ecmd->i_list;*old_i;) {
	    struct exp_i *tmp;

	    if (((*old_i)->direct == EXP_DIRECT) ||
		    (!streq((*old_i)->variable,exp_i->variable))) {
		old_i = &(*old_i)->next;
		continue;
	    }

	    ecases_remove_by_expi(interp,ecmd,*old_i);
	    
	    /* unlink from middle of list */
	    tmp = *old_i;
	    *old_i = tmp->next;
	    tmp->next = 0;
	    exp_free_i(interp,tmp,exp_indirect_update2);
	}

	/* if new one has ecases, update it */
	if (exp_i->ecount) {
	    /* Note: The exp_indirect_ functions are Tcl_VarTraceProc's, and
	     * are used as such in other places of Expect. We cannot use a
	     * Tcl_Obj* as return value :(
	     */
	    char *msg = exp_indirect_update1(interp,ecmd,exp_i);
	    if (msg) {
		/* unusual way of handling error return */
		/* because of Tcl's variable tracing */
		Tcl_SetResult (interp, msg, TCL_VOLATILE);
		result = TCL_ERROR;
		goto indirect_update_abort;
	    }
	}
    }
    /* empty i_lists have to be removed from global eg.i_list */
    /* before returning, even if during error */
 indirect_update_abort:

    /*
     * New exp_i's that have 0 ecases indicate fd/vars to be deleted.
     * Now that the deletions have been done, discard the new exp_i's.
     */

    for (exp_i=eg.i_list;exp_i;) {
	struct exp_i *next = exp_i->next;

	if (exp_i->ecount == 0) {
	    exp_i_remove(interp,&eg.i_list,exp_i);
	}
	exp_i = next;
    }
    if (result == TCL_ERROR) goto cleanup;

    /*
     * arm all new bg direct fds
     */

    if (ecmd->cmdtype == EXP_CMD_BG) {
	for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	    if (exp_i->direct == EXP_DIRECT) {
		state_list_arm(interp,exp_i->state_list);
	    }
	}
    }

    /*
     * now that old ecases are gone, add new ecases and exp_i's (both
     * direct and indirect).
     */

    /* append ecases */

    count = ecmd->ecd.count + eg.ecd.count;
    if (eg.ecd.count) {
	int start_index; /* where to add new ecases in old list */

	if (ecmd->ecd.count) {
	    /* append to end */
	    ecmd->ecd.cases = (struct ecase **)ckrealloc((char *)ecmd->ecd.cases, count * sizeof(struct ecase *));
	    start_index = ecmd->ecd.count;
	} else {
	    /* append to beginning */
	    ecmd->ecd.cases = (struct ecase **)ckalloc(eg.ecd.count * sizeof(struct ecase *));
	    start_index = 0;
	}
	memcpy(&ecmd->ecd.cases[start_index],eg.ecd.cases,
		eg.ecd.count*sizeof(struct ecase *));
	ecmd->ecd.count = count;
    }

    /* append exp_i's */
    for (eip = &ecmd->i_list;*eip;eip = &(*eip)->next) {
	/* empty loop to get to end of list */
    }
    /* *exp_i now points to end of list */

    *eip = eg.i_list;	/* connect new list to end of current list */

  cleanup:
    if (result == TCL_ERROR) {
	/* in event of error, free any unreferenced ecases */
	/* but first, split up i_list so that exp_i's aren't */
	/* freed twice */

	for (exp_i=eg.i_list;exp_i;) {
	    struct exp_i *next = exp_i->next;
	    exp_i->next = 0;
	    exp_i = next;
	}
	free_ecases(interp,&eg,1);
    } else {
	if (eg.ecd.cases) ckfree((char *)eg.ecd.cases);
    }

    if (ecmd->cmdtype == EXP_CMD_BG) {
	exp_background_channelhandlers_run_all();
    }

    if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
    return(result);
}

/* adjusts file according to user's size request */
void
expAdjust(ExpState *esPtr)
{
    int new_msize, excess;
    Tcl_UniChar *string;

    /*
     * Resize buffer to user's request * 3 + 1.
     *
     * x3: in case the match straddles two bufferfuls, and to allow
     *     reading a bufferful even when we reach near fullness of two.
     *     (At shuffle time this means we look for 2/3 full buffer and
     *      drop a 1/3, i.e. half of that).
     *
     * NOTE: The unmodified expect got the same effect by comparing
     *       apples and oranges in shuffle mgmt, i.e bytes vs. chars,
     *       and automatically extending the buffer (Tcl_Obj string)
     *       to hold that much.
     *
     * +1: for trailing null.
     */

    new_msize = esPtr->umsize * 3 + 1;

    if (new_msize != esPtr->input.max) {

	if (esPtr->input.use > new_msize) {
	    /*
	     * too much data, forget about data at beginning of buffer
	     */

	    string = esPtr->input.buffer;
	    excess = esPtr->input.use - new_msize; /* #chars */

	    memcpy (string, string + excess, new_msize * sizeof (Tcl_UniChar));
	    esPtr->input.use = new_msize;

	} else {
	    /*
	     * too little data - length < new_mbytes
	     * Make larger if the max is also too small.
	     */

	    if (esPtr->input.max < new_msize) {
	        esPtr->input.buffer = (Tcl_UniChar*) \
		    Tcl_Realloc ((char*)esPtr->input.buffer,
				 new_msize * sizeof (Tcl_UniChar));
	    }
	}

	esPtr->key = expect_key++;
	esPtr->input.max = new_msize;
    }
}

#if OBSOLETE
/* Strip parity */
static void
expParityStrip(
    Tcl_Obj *obj,
    int offsetBytes)
{
    char *p, ch;
    
    int changed = FALSE;
    
    for (p = Tcl_GetString(obj) + offsetBytes;*p;p++) {
	ch = *p & 0x7f;
	if (ch != *p) changed = TRUE;
	else *p &= 0x7f;
    }

    if (changed) {
	/* invalidate the unicode rep */
	if (obj->typePtr->freeIntRepProc) {
	    obj->typePtr->freeIntRepProc(obj);
	}
    }
}

/* This function is only used when debugging.  It checks when a string's
   internal UTF is sane and whether an offset into the string appears to
   be at a UTF boundary.
*/
static void
expValid(
    Tcl_Obj *obj,
    int offset)
{
  char *s, *end;
  int len;

  s = Tcl_GetStringFromObj(obj,&len);

  if (offset > len) {
    printf("offset (%d) > length (%d)\n",offset,len);
    fflush(stdout);
    abort();
  }

  /* first test for null terminator */
  end = s + len;
  if (*end != '\0') {
    printf("obj lacks null terminator\n");
    fflush(stdout);
    abort();
  }

  /* check for valid UTF sequence */
  while (*s) {
    Tcl_UniChar uc;

	s += TclUtfToUniChar(s,&uc);
    if (s > end) {
      printf("UTF out of sync with terminator\n");
      fflush(stdout);
      abort();
    }
  }
  s += offset;
  while (*s) {
    Tcl_UniChar uc;

	s += TclUtfToUniChar(s,&uc);
    if (s > end) {
      printf("UTF from offset out of sync with terminator\n");
      fflush(stdout);
      abort();
    }
  }
}
#endif /*OBSOLETE*/

/* Strip nulls from object, beginning at offset */
static int
expNullStrip(
    ExpUniBuf* buf,
    int offsetChars)
{
    Tcl_UniChar *src, *src2, *dest, *end;
    int newsize;       /* size of obj after all nulls removed */

    src2 = src = dest = buf->buffer + offsetChars;
    end               = buf->buffer + buf->use;

    while (src < end) {
	if (*src) {
	    *dest = *src;
	    dest ++;
	}
	src ++;
    }
    newsize = offsetChars + (dest - src2);
    buf->use = newsize;
    return newsize;
}

/* returns # of bytes read or (non-positive) error of form EXP_XXX */
/* returns 0 for end of file */
/* If timeout is non-zero, set an alarm before doing the read, else assume */
/* the read will complete immediately. */
/*ARGSUSED*/
static int
expIRead( /* INTL */
    Tcl_Interp *interp,
    ExpState *esPtr,
    int timeout,
    int save_flags)
{
    int cc = EXP_TIMEOUT;
    int size;

    /* We drop one third when are at least 2/3 full */
    /* condition is (size >= max*2/3) <=> (size*3 >= max*2) */
    if (expSizeGet(esPtr)*3 >= esPtr->input.max*2)
	exp_buffer_shuffle(interp,esPtr,save_flags,EXPECT_OUT,"expect");
    size = expSizeGet(esPtr);

#ifdef SIMPLE_EVENT
 restart:

    alarm_fired = FALSE;

    if (timeout > -1) {
	signal(SIGALRM,sigalarm_handler);
	alarm((timeout > 0)?timeout:1);
    }
#endif

    cc = Tcl_ReadChars(esPtr->channel, esPtr->input.newchars,
		       esPtr->input.max - esPtr->input.use,
		       0 /* no append */);
    i_read_errno = errno;

    if (cc > 0) {
        memcpy (esPtr->input.buffer + esPtr->input.use,
		Tcl_GetUnicodeFromObj (esPtr->input.newchars, NULL),
		cc * sizeof (Tcl_UniChar));
	esPtr->input.use += cc;
    }

#ifdef SIMPLE_EVENT
    alarm(0);

    if (cc == -1) {
	/* check if alarm went off */
	if (i_read_errno == EINTR) {
	    if (alarm_fired) {
		return EXP_TIMEOUT;
	    } else {
		if (Tcl_AsyncReady()) {
		    int rc = Tcl_AsyncInvoke(interp,TCL_OK);
		    if (rc != TCL_OK) return(exp_tcl2_returnvalue(rc));
		}
		goto restart;
	    }
	}
    }
#endif
    return cc;	
}

/*
 * expRead() does the logical equivalent of a read() for the expect command.
 * This includes figuring out which descriptor should be read from.
 *
 * The result of the read() is left in a spawn_id's buffer rather than
 * explicitly passing it back.  Note that if someone else has modified a buffer
 * either before or while this expect is running (i.e., if we or some event has
 * called Tcl_Eval which did another expect/interact), expRead will also call
 * this a successful read (for the purposes if needing to pattern match against
 * it).
 */

/* if it returns a negative number, it corresponds to a EXP_XXX result */
/* if it returns a non-negative number, it means there is data */
/* (0 means nothing new was actually read, but it should be looked at again) */
int
expRead(
    Tcl_Interp *interp,
    ExpState *(esPtrs[]),		/* If 0, then esPtrOut already known and set */
    int esPtrsMax,			/* number of esPtrs */
    ExpState **esPtrOut,		/* Out variable to leave new ExpState. */
    int timeout,
    int key)
{
    ExpState *esPtr;

    int size;
    int cc;
    int write_count;
    int tcl_set_flags;	/* if we have to discard chars, this tells */
			/* whether to show user locally or globally */

    if (esPtrs == 0) {
	/* we already know the ExpState, just find out what happened */
	cc = exp_get_next_event_info(interp,*esPtrOut);
	tcl_set_flags = TCL_GLOBAL_ONLY;
    } else {
	cc = exp_get_next_event(interp,esPtrs,esPtrsMax,esPtrOut,timeout,key);
	tcl_set_flags = 0;
    }

    esPtr = *esPtrOut;

    if (cc == EXP_DATA_NEW) {
	/* try to read it */
	cc = expIRead(interp,esPtr,timeout,tcl_set_flags);
	
	if (Tcl_Eof(esPtr->channel)) {
	    cc = EXP_EOF;
	}
    } else if (cc == EXP_DATA_OLD) {
	cc = 0;
    } else if (cc == EXP_RECONFIGURE) {
	return EXP_RECONFIGURE;
    }

    if (cc == EXP_ABEOF) {	/* abnormal EOF */
	/* On many systems, ptys produce EIO upon EOF - sigh */
	if (i_read_errno == EIO) {
	    /* Sun, Cray, BSD, and others */
	    cc = EXP_EOF;
	} else if (i_read_errno == EINVAL) {
	    /* Solaris 2.4 occasionally returns this */
	    cc = EXP_EOF;
	} else {
	    if (i_read_errno == EBADF) {
		exp_error(interp,"bad spawn_id (process died earlier?)");
	    } else {
		exp_error(interp,"i_read(spawn_id fd=%d): %s",esPtr->fdin,
			Tcl_PosixError(interp));
		if (esPtr->close_on_eof) {
		exp_close(interp,esPtr);
	    }
	    }
	    return(EXP_TCLERROR);
	    /* was goto error; */
	}
    }

    /* EOF, TIMEOUT, and ERROR return here */
    /* In such cases, there is no need to update screen since, if there */
    /* was prior data read, it would have been sent to the screen when */
    /* it was read. */
    if (cc < 0) return (cc);

    /*
     * update display
     */

    size = expSizeGet(esPtr);
    if (size) write_count = size - esPtr->printed;
    else write_count = 0;
    
    if (write_count) {
	/*
	 * Show chars to user if they've requested it, UNLESS they're seeing it
	 * already because they're typing it and tty driver is echoing it.
	 * Also send to Diag and Log if appropriate.
	 */
	expLogInteractionU(esPtr,esPtr->input.buffer + esPtr->printed, write_count);
	    
	/*
	 * strip nulls from input, since there is no way for Tcl to deal with
	 * such strings.  Doing it here lets them be sent to the screen, just
	 * in case they are involved in formatting operations
	 */
	if (esPtr->rm_nulls) size = expNullStrip(&esPtr->input,esPtr->printed);
	esPtr->printed = size; /* count'm even if not logging */
    }
    return(cc);
}

/* when buffer fills, copy second half over first and */
/* continue, so we can do matches over multiple buffers */
void
exp_buffer_shuffle( /* INTL */
    Tcl_Interp *interp,
    ExpState *esPtr,
    int save_flags,
    char *array_name,
    char *caller_name)
{
    Tcl_UniChar *str;
    Tcl_UniChar *p;
    int numchars, newlen, skiplen;
    Tcl_UniChar lostChar;

    /*
     * allow user to see data we are discarding
     */

    expDiagLog("%s: set %s(spawn_id) \"%s\"\r\n",
	    caller_name,array_name,esPtr->name);
    Tcl_SetVar2(interp,array_name,"spawn_id",esPtr->name,save_flags);

    /*
     * The internal storage buffer object should only be referred
     * to by the channel that uses it.  We always copy the contents
     * out of the object before passing the data to anyone outside
     * of these routines.  This ensures that the object always has
     * a refcount of 1 so we can safely modify the contents in place.
     */

    str      = esPtr->input.buffer;
    numchars = esPtr->input.use;

    /* We discard 1/3 of the data in the buffer.
     */
    skiplen = numchars/3;
    p       = str + skiplen;

    /*
     * before doing move, show user data we are discarding
     */

    lostChar = *p;
    /* Temporarily stick null in middle of string to terminate */
    *p = 0;

    expDiagLog("%s: set %s(buffer) \"",caller_name,array_name);
    expDiagLogU(expPrintifyUni(str,numchars));
    expDiagLogU("\"\r\n");
    Tcl_SetVar2Ex(interp,array_name,"buffer",
		  Tcl_NewUnicodeObj (str, skiplen),
	    save_flags);

    /*
     * Restore damage done fir display above.
     */
    *p = lostChar;

    /*
     * move the higher 2/3 of the string down over the lower 2/3.
     * This destroys the 1st 1/3.
     */

    newlen = numchars - skiplen;
    memmove(str, p, newlen * sizeof(Tcl_UniChar));
    esPtr->input.use = newlen;

    esPtr->printed -= skiplen;
    if (esPtr->printed < 0) esPtr->printed = 0;
}

/* map EXP_ style return value to TCL_ style return value */
/* not defined to work on TCL_OK */
int
exp_tcl2_returnvalue(int x)
{
	switch (x) {
	case TCL_ERROR:			return EXP_TCLERROR;
	case TCL_RETURN:		return EXP_TCLRET;
	case TCL_BREAK:			return EXP_TCLBRK;
	case TCL_CONTINUE:		return EXP_TCLCNT;
	case EXP_CONTINUE:		return EXP_TCLCNTEXP;
	case EXP_CONTINUE_TIMER:	return EXP_TCLCNTTIMER;
	case EXP_TCL_RETURN:		return EXP_TCLRETTCL;
	}
    /* Must not reach this location. Can happen only if x is an
     * illegal value. Added return to suppress compiler warning.
     */
    return -1000;
}

/* map from EXP_ style return value to TCL_ style return values */
int
exp_2tcl_returnvalue(int x)
{
	switch (x) {
	case EXP_TCLERROR:		return TCL_ERROR;
	case EXP_TCLRET:		return TCL_RETURN;
	case EXP_TCLBRK:		return TCL_BREAK;
	case EXP_TCLCNT:		return TCL_CONTINUE;
	case EXP_TCLCNTEXP:		return EXP_CONTINUE;
	case EXP_TCLCNTTIMER:		return EXP_CONTINUE_TIMER;
	case EXP_TCLRETTCL:		return EXP_TCL_RETURN;
	}
    /* Must not reach this location. Can happen only if x is an
     * illegal value. Added return to suppress compiler warning.
     */
    return -1000;
}

/* variables predefined by expect are retrieved using this routine
which looks in the global space if they are not in the local space.
This allows the user to localize them if desired, and also to
avoid having to put "global" in procedure definitions.
*/
char *
exp_get_var(
    Tcl_Interp *interp,
    char *var)
{
    char *val;

    if (NULL != (val = Tcl_GetVar(interp,var,0 /* local */)))
	return(val);
    return(Tcl_GetVar(interp,var,TCL_GLOBAL_ONLY));
}

static int
get_timeout(Tcl_Interp *interp)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    CONST char *t;

    if (NULL != (t = exp_get_var(interp,EXPECT_TIMEOUT))) {
	tsdPtr->timeout = atoi(t);
    }
    return(tsdPtr->timeout);
}

/* make a copy of a linked list (1st arg) and attach to end of another (2nd
arg) */
static int
update_expect_states(
    struct exp_i *i_list,
    struct exp_state_list **i_union)
{
    struct exp_i *p;

    /* for each i_list in an expect statement ... */
    for (p=i_list;p;p=p->next) {
	struct exp_state_list *slPtr;

	/* for each esPtr in the i_list */
	for (slPtr=p->state_list;slPtr;slPtr=slPtr->next) {
	    struct exp_state_list *tmpslPtr;
	    struct exp_state_list *u;

	    if (expStateAnyIs(slPtr->esPtr)) continue;
	    
	    /* check this one against all so far */
	    for (u = *i_union;u;u=u->next) {
		if (slPtr->esPtr == u->esPtr) goto found;
	    }
	    /* if not found, link in as head of list */
	    tmpslPtr = exp_new_state(slPtr->esPtr);
	    tmpslPtr->next = *i_union;
	    *i_union = tmpslPtr;
	    found:;
	}
    }
    return TCL_OK;
}

char *
exp_cmdtype_printable(int cmdtype)
{
	switch (cmdtype) {
	case EXP_CMD_FG: return("expect");
	case EXP_CMD_BG: return("expect_background");
	case EXP_CMD_BEFORE: return("expect_before");
	case EXP_CMD_AFTER: return("expect_after");
	}
    /*#ifdef LINT*/
	return("unknown expect command");
    /*#endif*/
}

/* exp_indirect_update2 is called back via Tcl's trace handler whenever */
/* an indirect spawn id list is changed */
/*ARGSUSED*/
static char *
exp_indirect_update2(
    ClientData clientData,
    Tcl_Interp *interp,	/* Interpreter containing variable. */
    char *name1,	/* Name of variable. */
    char *name2,	/* Second part of variable name. */
    int flags)		/* Information about what happened. */
{
	char *msg;

	struct exp_i *exp_i = (struct exp_i *)clientData;
	exp_configure_count++;
	msg = exp_indirect_update1(interp,&exp_cmds[exp_i->cmdtype],exp_i);

	exp_background_channelhandlers_run_all();

	return msg;
}

static char *
exp_indirect_update1(
    Tcl_Interp *interp,
    struct exp_cmd_descriptor *ecmd,
    struct exp_i *exp_i)
{
	struct exp_state_list *slPtr;	/* temp for interating over state_list */

	/*
	 * disarm any ExpState's that lose all their active spawn ids
	 */

	if (ecmd->cmdtype == EXP_CMD_BG) {
		/* clean up each spawn id used by this exp_i */
		for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
			ExpState *esPtr = slPtr->esPtr;

			if (expStateAnyIs(esPtr)) continue;

			/* silently skip closed or preposterous fds */
			/* since we're just disabling them anyway */
			/* preposterous fds will have been reported */
			/* by code in next section already */
			if (!expStateCheck(interp,slPtr->esPtr,1,0,"")) continue;

			/* check before decrementing, ecount may not be */
			/* positive if update is called before ecount is */
			/* properly synchronized */
			if (esPtr->bg_ecount > 0) {
				esPtr->bg_ecount--;
			}
			if (esPtr->bg_ecount == 0) {
				exp_disarm_background_channelhandler(esPtr);
				esPtr->bg_interp = 0;
			}
		}
	}

	/*
	 * reread indirect variable
	 */

	exp_i_update(interp,exp_i);

	/*
	 * check validity of all fd's in variable
	 */

	for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
	    /* validate all input descriptors */

	    if (expStateAnyIs(slPtr->esPtr)) continue;

	    if (!expStateCheck(interp,slPtr->esPtr,1,1,
		    exp_cmdtype_printable(ecmd->cmdtype))) {
	    /* Note: Cannot construct a Tcl_Obj* here, the function is a
	     * Tcl_VarTraceProc and the API wants a char*.
	     *
	     * DANGER: The buffer may overflow if either the existing result,
	     * the variable name, or both become to large.
	     */
		static char msg[200];
		sprintf(msg,"%s from indirect variable (%s)",
		    Tcl_GetStringResult (interp),exp_i->variable);
		return msg;
	    }
	}

	/* for each spawn id in list, arm if necessary */
	if (ecmd->cmdtype == EXP_CMD_BG) {
		state_list_arm(interp,exp_i->state_list);
	}

	return (char *)0;
}

int
expMatchProcess(
    Tcl_Interp *interp,
    struct eval_out *eo,	/* final case of interest */
    int cc,			/* EOF, TIMEOUT, etc... */
    int bg,			/* 1 if called from background handler, */
				/* else 0 */
    char *detail)
{
    ExpState *esPtr = 0;
    Tcl_Obj *body = 0;
    Tcl_UniChar *buffer;
    struct ecase *e = 0;	/* points to current ecase */
    int match = -1;		/* characters matched */
    /* uprooted by a NULL */
    int result = TCL_OK;

#define out(indexName, value) \
 expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,indexName); \
 expDiagLogU(expPrintify(value)); \
 expDiagLogU("\"\r\n"); \
 Tcl_SetVar2(interp, EXPECT_OUT,indexName,value,(bg ? TCL_GLOBAL_ONLY : 0));

    /* The numchars argument allows us to avoid sticking a \0 into the buffer */
#define outuni(indexName, value,numchars) \
 expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,indexName); \
 expDiagLogU(expPrintifyUni(value,numchars)); \
 expDiagLogU("\"\r\n"); \
 Tcl_SetVar2Ex(interp, EXPECT_OUT,indexName,Tcl_NewUnicodeObj(value,numchars),(bg ? TCL_GLOBAL_ONLY : 0));

    if (eo->e) {
	e = eo->e;
	body = e->body;
	if (cc != EXP_TIMEOUT) {
	    esPtr = eo->esPtr;
	    match = eo->matchlen;
	    buffer = eo->matchbuf;
	}
    } else if (cc == EXP_EOF) {
	/* read an eof but no user-supplied case */
	esPtr = eo->esPtr;
	match = eo->matchlen;
	buffer = eo->matchbuf;
    }			

    if (match >= 0) {
	char name[20], value[20];
	int i;

	if (e && e->use == PAT_RE) {
	    Tcl_RegExp re;
	    int flags;
	    Tcl_RegExpInfo info;
	    Tcl_Obj *buf;

	    /* No gate keeper required here, we know that the RE
	     * matches, we just do it again to get all the captured
	     * pieces
	     */

	    if (e->Case == CASE_NORM) {
		flags = TCL_REG_ADVANCED;
	    } else {
		flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
	    }
		    
	    re = Tcl_GetRegExpFromObj(interp, e->pat, flags);
	    Tcl_RegExpGetInfo(re, &info);

	    buf = Tcl_NewUnicodeObj (buffer,esPtr->input.use);
	    for (i=0;i<=info.nsubs;i++) {
		int start, end;
		Tcl_Obj *val;

		start = info.matches[i].start;
		end = info.matches[i].end-1;
		if (start == -1) continue;

		if (e->indices) {
		    /* start index */
		    sprintf(name,"%d,start",i);
		    sprintf(value,"%d",start);
		    out(name,value);

		    /* end index */
		    sprintf(name,"%d,end",i);
		    sprintf(value,"%d",end);
		    out(name,value);
		}

				/* string itself */
		sprintf(name,"%d,string",i);
		val = Tcl_GetRange(buf, start, end);
		expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,name);
		expDiagLogU(expPrintifyObj(val));
		expDiagLogU("\"\r\n");
		Tcl_SetVar2Ex(interp,EXPECT_OUT,name,val,(bg ? TCL_GLOBAL_ONLY : 0));
	    }
	    Tcl_DecrRefCount (buf);
	} else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
	    Tcl_UniChar *str;

	    if (e->indices) {
		/* start index */
		sprintf(value,"%d",e->simple_start);
		out("0,start",value);

		/* end index */
		sprintf(value,"%d",e->simple_start + match - 1);
		out("0,end",value);
	    }

	    /* string itself */
	    str = esPtr->input.buffer + e->simple_start;
	    outuni("0,string",str,match);

				/* redefine length of string that */
				/* matched for later extraction */
	    match += e->simple_start;
	} else if (e && e->use == PAT_NULL && e->indices) {
				/* start index */
	    sprintf(value,"%d",match-1);
	    out("0,start",value);
				/* end index */
	    sprintf(value,"%d",match-1);
	    out("0,end",value);
	} else if (e && e->use == PAT_FULLBUFFER) {
	    expDiagLogU("expect_background: full buffer\r\n");
	}
    }

    /* this is broken out of (match > 0) (above) since it can be */
    /* that an EOF occurred with match == 0 */
    if (eo->esPtr) {
	Tcl_UniChar *str;
	int numchars;

	out("spawn_id",esPtr->name);

	str      = esPtr->input.buffer;
	numchars = esPtr->input.use;

	/* Save buf[0..match] */
	outuni("buffer",str,match);

	/* "!e" means no case matched - transfer by default */
	if (!e || e->transfer) {
	    int remainder = numchars-match;
	    /* delete matched chars from input buffer */
	    esPtr->printed -= match;
	    if (numchars != 0) {
		memmove(str,str+match,remainder*sizeof(Tcl_UniChar));
	    }
	    esPtr->input.use = remainder;
	}

	if (cc == EXP_EOF) {
	    /* exp_close() deletes all background bodies */
	    /* so save eof body temporarily */
	    if (body) { Tcl_IncrRefCount(body); }
	    if (esPtr->close_on_eof) {
	    exp_close(interp,esPtr);
	}
    }
    }

    if (body) {
	if (!bg) {
	    result = Tcl_EvalObjEx(interp,body,0);
	} else {
	    result = Tcl_EvalObjEx(interp,body,TCL_EVAL_GLOBAL);
	    if (result != TCL_OK) Tcl_BackgroundError(interp);
	}
	if (cc == EXP_EOF) { Tcl_DecrRefCount(body); }
    }
    return result;
}

/* this function is called from the background when input arrives */
/*ARGSUSED*/
void
exp_background_channelhandler( /* INTL */
    ClientData clientData,
    int mask)
{
  char backup[EXP_CHANNELNAMELEN+1]; /* backup copy of esPtr channel name! */

    ExpState *esPtr;
    Tcl_Interp *interp;
    int cc;			/* number of bytes returned in a single read */
				/* or negative EXP_whatever */
    struct eval_out eo;		/* final case of interest */
    ExpState *last_esPtr;	/* for differentiating when multiple esPtrs */
				/* to print out better debugging messages */
    int last_case;		/* as above but for case */

    /* restore our environment */
    esPtr = (ExpState *)clientData;

    /* backup just in case someone zaps esPtr in the middle of our work! */
    strcpy(backup,esPtr->name); 

    interp = esPtr->bg_interp;

    /* temporarily prevent this handler from being invoked again */
    exp_block_background_channelhandler(esPtr);

    /*
     * if mask == 0, then we've been called because the patterns changed not
     * because the waiting data has changed, so don't actually do any I/O
     */
    if (mask == 0) {
	cc = 0;
    } else {
	esPtr->notifiedMask = mask;
	esPtr->notified = FALSE;
	cc = expRead(interp,(ExpState **)0,0,&esPtr,EXP_TIME_INFINITY,0);
    }

do_more_data:
    eo.e = 0;		/* no final case yet */
    eo.esPtr = 0;		/* no final file selected yet */
    eo.matchlen = 0;		/* nothing matched yet */

    /* force redisplay of buffer when debugging */
    last_esPtr = 0;

    if (cc == EXP_EOF) {
	/* do nothing */
    } else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
	goto finish;
	/* 
	 * if we were going to do this right, we should differentiate between
	 * things like HP ioctl-open-traps that fall out here and should
	 * rightfully be ignored and real errors that should be reported.  Come
	 * to think of it, the only errors will come from HP ioctl handshake
	 * botches anyway.
	 */
    } else {
	/* normal case, got data */
	/* new data if cc > 0, same old data if cc == 0 */

	/* below here, cc as general status */
	cc = EXP_NOMATCH;
    }

    cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_BG],
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
    if (cc == EXP_TCLERROR) {
		/* only likely problem here is some internal regexp botch */
		Tcl_BackgroundError(interp);
		goto finish;
    }
    /* special eof code that cannot be done in eval_cases */
    /* or above, because it would then be executed several times */
    if (cc == EXP_EOF) {
	eo.esPtr = esPtr;
	eo.matchlen = expSizeGet(eo.esPtr);
	eo.matchbuf = eo.esPtr->input.buffer;
	expDiagLogU("expect_background: read eof\r\n");
	goto matched;
    }
    if (!eo.e) {
	/* if we get here, there must not have been a match */
	goto finish;
    }

 matched:
    expMatchProcess(interp, &eo, cc, 1 /* bg */,"expect_background");

    /*
     * Event handler will not call us back if there is more input
     * pending but it has already arrived.  bg_status will be
     * "blocked" only if armed.
     */

    /*
     * Connection could have been closed on us.  In this case,
     * exitWhenBgStatusUnblocked will be 1 and we should disable the channel
     * handler and release the esPtr.
     */

    /* First check that the esPtr is even still valid! */
    /* 
     * It isn't sufficient to just check that 'Tcl_GetChannel' still knows about
     * backup since it is possible that esPtr was lost in the background AND
     * another process spawned and reassigned the same name. 
     */
    if (!expChannelStillAlive(esPtr, backup)) {
      expDiagLog("expect channel %s lost in background handler\n",backup);
      return;
    }

    if ((!esPtr->freeWhenBgHandlerUnblocked) && (esPtr->bg_status == blocked)) {
	if (0 != (cc = expSizeGet(esPtr))) {
	    goto do_more_data;
	}
    }
 finish:
    exp_unblock_background_channelhandler(esPtr);
    if (esPtr->freeWhenBgHandlerUnblocked)
	expStateFree(esPtr);
}

/*ARGSUSED*/
int
Exp_ExpectObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int cc;			/* number of chars returned in a single read */
				/* or negative EXP_whatever */
    ExpState *esPtr = 0;

    int i;			/* misc temporary */
    struct exp_cmd_descriptor eg;
    struct exp_state_list *state_list;	/* list of ExpStates to watch */
    struct exp_state_list *slPtr;	/* temp for interating over state_list */
    ExpState **esPtrs;
    int mcount;			/* number of esPtrs to watch */

    struct eval_out eo;		/* final case of interest */

    int result;			/* Tcl result */
    
    time_t start_time_total;	/* time at beginning of this procedure */
    time_t start_time = 0;	/* time when restart label hit */
    time_t current_time = 0;	/* current time (when we last looked)*/
    time_t end_time;		/* future time at which to give up */

    ExpState *last_esPtr;	/* for differentiating when multiple f's */
				/* to print out better debugging messages */
    int last_case;		/* as above but for case */
    int first_time = 1;		/* if not "restarted" */
    
    int key;			/* identify this expect command instance */
    int configure_count;	/* monitor exp_configure_count */

    int timeout;		/* seconds */
    int remtime;		/* remaining time in timeout */
    int reset_timer;		/* should timer be reset after continue? */
    Tcl_Time temp_time;
    Tcl_Obj* new_cmd = NULL;

    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	/* expect {...} */

	new_cmd = exp_eval_with_one_arg(clientData,interp,objv);
	if (!new_cmd) return TCL_ERROR;
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	/* expect -brace {...} ... fake command line for reparsing */

	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];

	new_cmd = exp_eval_with_one_arg(clientData,interp,new_objv);
	if (!new_cmd) return TCL_ERROR;
    }

    if (new_cmd) {
	/* Replace old arguments with result of the reparse */
	Tcl_ListObjGetElements (interp, new_cmd, &objc, (Tcl_Obj***) &objv);
    }

    Tcl_GetTime (&temp_time);
    start_time_total = temp_time.sec;
    start_time = start_time_total;
    reset_timer = TRUE;
    
    if (&StdinoutPlaceholder == (ExpState *)clientData) {
	clientData = (ClientData) expStdinoutGet();
    } else if (&DevttyPlaceholder == (ExpState *)clientData) {
	clientData = (ClientData) expDevttyGet();
    }
	
    /* make arg list for processing cases */
    /* do it dynamically, since expect can be called recursively */

    exp_cmd_init(&eg,EXP_CMD_FG,EXP_TEMPORARY);
    state_list = 0;
    esPtrs = 0;
    if (TCL_ERROR == parse_expect_args(interp,&eg, (ExpState *)clientData,
				       objc,objv)) {
	if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
	return TCL_ERROR;
    }

 restart_with_update:
    /* validate all descriptors and flatten ExpStates into array */

    if ((TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_BEFORE].i_list,&state_list))
	    || (TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_AFTER].i_list, &state_list))
	    || (TCL_ERROR == update_expect_states(eg.i_list,&state_list))) {
	result = TCL_ERROR;
	goto cleanup;
    }

    /* declare ourselves "in sync" with external view of close/indirect */
    configure_count = exp_configure_count;

    /* count and validate state_list */
    mcount = 0;
    for (slPtr=state_list;slPtr;slPtr=slPtr->next) {
	mcount++;
	/* validate all input descriptors */
	if (!expStateCheck(interp,slPtr->esPtr,1,1,"expect")) {
	    result = TCL_ERROR;
	    goto cleanup;
	}
    }

    /* make into an array */
    esPtrs = (ExpState **)ckalloc(mcount * sizeof(ExpState *));
    for (slPtr=state_list,i=0;slPtr;slPtr=slPtr->next,i++) {
	esPtrs[i] = slPtr->esPtr;
    }

  restart:
    if (first_time) first_time = 0;
    else {
        Tcl_GetTime (&temp_time);
	start_time = temp_time.sec;
    }

    if (eg.timeout_specified_by_flag) {
	timeout = eg.timeout;
    } else {
	/* get the latest timeout */
	timeout = get_timeout(interp);
    }

    key = expect_key++;

    result = TCL_OK;
    last_esPtr = 0;

    /*
     * end of restart code
     */

    eo.e = 0;		/* no final case yet */
    eo.esPtr = 0;	/* no final ExpState selected yet */
    eo.matchlen = 0;	/* nothing matched yet */

    /* timeout code is a little tricky, be very careful changing it */
    if (timeout != EXP_TIME_INFINITY) {
	/* if exp_continue -continue_timer, do not update end_time */
	if (reset_timer) {
	    Tcl_GetTime (&temp_time);
	    current_time = temp_time.sec;
	    end_time = current_time + timeout;
	} else {
	    reset_timer = TRUE;
	}
    }

    /* remtime and current_time updated at bottom of loop */
    remtime = timeout;

    for (;;) {
	if ((timeout != EXP_TIME_INFINITY) && (remtime < 0)) {
	    cc = EXP_TIMEOUT;
	} else {
	    cc = expRead(interp,esPtrs,mcount,&esPtr,remtime,key);
	}

	/*SUPPRESS 530*/
	if (cc == EXP_EOF) {
	    /* do nothing */
	} else if (cc == EXP_TIMEOUT) {
	    expDiagLogU("expect: timed out\r\n");
	} else if (cc == EXP_RECONFIGURE) {
	    reset_timer = FALSE;
	    goto restart_with_update;
	} else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
	    goto error;
	} else {
	    /* new data if cc > 0, same old data if cc == 0 */
	    
	    /* below here, cc as general status */
	    cc = EXP_NOMATCH;

	    /* force redisplay of buffer when debugging */
	    last_esPtr = 0;
	}

	cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
	cc = eval_cases(interp,&eg,
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
	cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
	if (cc == EXP_TCLERROR) goto error;
	/* special eof code that cannot be done in eval_cases */
	/* or above, because it would then be executed several times */
	if (cc == EXP_EOF) {
	    eo.esPtr = esPtr;
	    eo.matchlen = expSizeGet(eo.esPtr);
	    eo.matchbuf = eo.esPtr->input.buffer;
	    expDiagLogU("expect: read eof\r\n");
	    break;
	} else if (cc == EXP_TIMEOUT) break;

	/* break if timeout or eof and failed to find a case for it */

	if (eo.e) break;

	/* no match was made with current data, force a read */
	esPtr->force_read = TRUE;

	if (timeout != EXP_TIME_INFINITY) {
	    Tcl_GetTime (&temp_time);
	    current_time = temp_time.sec;
	    remtime = end_time - current_time;
	}
    }

    goto done;

error:
    result = exp_2tcl_returnvalue(cc);
 done:
    if (result != TCL_ERROR) {
	result = expMatchProcess(interp, &eo, cc, 0 /* not bg */,"expect");
    }

 cleanup:
    if (result == EXP_CONTINUE_TIMER) {
	reset_timer = FALSE;
	result = EXP_CONTINUE;
    }

    if ((result == EXP_CONTINUE) && (configure_count == exp_configure_count)) {
	expDiagLogU("expect: continuing expect\r\n");
	goto restart;
    }

    if (state_list) {
	exp_free_state(state_list);
	state_list = 0;
    }
    if (esPtrs) {
	ckfree((char *)esPtrs);
	esPtrs = 0;
    }

    if (result == EXP_CONTINUE) {
	expDiagLogU("expect: continuing expect after update\r\n");
	goto restart_with_update;
    }

    free_ecases(interp,&eg,0);	/* requires i_lists to be avail */
    exp_free_i(interp,eg.i_list,exp_indirect_update2);

    if (new_cmd) { Tcl_DecrRefCount (new_cmd); }
    return(result);
}

/*ARGSUSED*/
static int
Exp_TimestampObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
	char *format = 0;
	time_t seconds = -1;
	int gmt = FALSE;	/* local time by default */
	struct tm *tm;
	Tcl_DString dstring;
    int i;

    static char* options[] = {
	"-format",
	"-gmt",
	"-seconds",
	NULL
    };
    enum options {
	TS_FORMAT,
	TS_GMT,
	TS_SECONDS
    };

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	case TS_FORMAT:
	    i++;
	    if (i >= objc) goto usage_error;
	    format = Tcl_GetString (objv[i]);
	    break;
	case TS_GMT:
	    gmt = TRUE;
	    break;
	case TS_SECONDS: {
	    int sec;
	    i++;
	    if (i >= objc) goto usage_error;
	    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &sec)) {
		goto usage_error;
	    }
	    seconds = sec;
	}
	    break;
	}
    }

    if (i < objc) goto usage_error;

    if (seconds == -1) {
	time(&seconds);
    }

    if (format) {
	if (gmt) {
	    tm = gmtime(&seconds);
	} else {
	    tm = localtime(&seconds);
	}
	Tcl_DStringInit(&dstring);
	exp_strftime(format,tm,&dstring);
	Tcl_DStringResult(interp,&dstring);
    } else {
	Tcl_SetObjResult (interp, Tcl_NewIntObj (seconds));
    }
	
    return TCL_OK;
 usage_error:
    exp_error(interp,"args: [-seconds #] [-format format] [-gmt]");
    return TCL_ERROR;

}

/* Helper function hnadling the common processing of -d and -i options of
 * various commands.
 */

static int
process_di _ANSI_ARGS_ ((Tcl_Interp* interp,
			 int objc,
			 Tcl_Obj *CONST objv[],		/* Argument objects. */
			 int* at,
			 int* Default,
			 ExpState **esOut,
			 CONST char* cmd));

static int
process_di (
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[],		/* Argument objects. */
    int* at,
    int* Default,
    ExpState **esOut,
    CONST char* cmd)
{
    static char* options[] = {
	"-d",
	"-i",
	NULL
    };
    enum options {
	DI_DEFAULT,
	DI_ID
    };
    int def = FALSE;
    char* chan = NULL;
    int i;
    ExpState *esPtr;

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
	}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	case DI_DEFAULT:
	    def = TRUE;
	    break;
	case DI_ID:
	    i++;
	    if (i >= objc) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chan = Tcl_GetString (objv[i]);
	    break;
	}
    }

    if (def && chan) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

    /* Not all arguments processed, more than two remaining, only at most one
     * remaining is expected/allowed.
     */
    if (i < (objc-1)) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
	    }
	    
    if (!def) {
	if (!chan) {
	    esPtr = expStateCurrent(interp,0,0,0);
	} else {
	    esPtr = expStateFromChannelName(interp,chan,0,0,0,(char*)cmd);
	}
	if (!esPtr) return(TCL_ERROR);
    }

    *at = i;
    *Default = def;
    *esOut = esPtr;
    return TCL_OK;
}


/*ARGSUSED*/
int
Exp_MatchMaxObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int size = -1;
    ExpState *esPtr = 0;
    int Default = FALSE;
    int i;

    if (TCL_OK != process_di (interp, objc, objv, &i, &Default, &esPtr, "match_max"))
	return TCL_ERROR;

    /* No size argument */
    if (i == objc) {
	if (Default) {
	    size = exp_default_match_max;
	} else {
	    size = esPtr->umsize;
	}
	Tcl_SetObjResult (interp, Tcl_NewIntObj (size));
	return(TCL_OK);
    }
    
    /*
     * All that's left is to set the size
     */

    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &size)) {
	return TCL_ERROR;
    }

    if (size <= 0) {
	exp_error(interp,"must be positive");
	return(TCL_ERROR);
    }

    if (Default) exp_default_match_max = size;
    else esPtr->umsize = size;

    return(TCL_OK);
}

/*ARGSUSED*/
int
Exp_RemoveNullsObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int value = -1;
    ExpState *esPtr = 0;
    int Default = FALSE;
    int i;

    if (TCL_OK != process_di (interp, objc, objv, &i, &Default, &esPtr, "remove_nulls"))
	return TCL_ERROR;

    /* No flag argument */
    if (i == objc) {
	if (Default) {
	  value = exp_default_rm_nulls;
	} else {
	  value = esPtr->rm_nulls;
	}
	Tcl_SetObjResult (interp, Tcl_NewIntObj (value));
	return(TCL_OK);
    }

    /* all that's left is to set the value */

    if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[i], &value)) {
	return TCL_ERROR;
    }

    if ((value != 0) && (value != 1)) {
	exp_error(interp,"must be 0 or 1");
	return(TCL_ERROR);
    }

    if (Default) exp_default_rm_nulls = value;
    else esPtr->rm_nulls = value;

    return(TCL_OK);
}

/*ARGSUSED*/
int
Exp_ParityObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int parity;
    ExpState *esPtr = 0;
    int Default = FALSE;
    int i;

    if (TCL_OK != process_di (interp, objc, objv, &i, &Default, &esPtr, "parity"))
	return TCL_ERROR;

    /* No parity argument */
    if (i == objc) {
	if (Default) {
	    parity = exp_default_parity;
	} else {
	    parity = esPtr->parity;
	}
	Tcl_SetObjResult (interp, Tcl_NewIntObj (parity));
	return(TCL_OK);
    }

    /* all that's left is to set the parity */

    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &parity)) {
	return TCL_ERROR;
    }

    if (Default) exp_default_parity = parity;
    else esPtr->parity = parity;

    return(TCL_OK);
}

/*ARGSUSED*/
int
Exp_CloseOnEofObjCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
    int close_on_eof;
    ExpState *esPtr = 0;
    int Default = FALSE;
    int i;

    if (TCL_OK != process_di (interp, objc, objv, &i, &Default, &esPtr, "close_on_eof"))
	return TCL_ERROR;

    /* No flag argument */
    if (i == objc) {
	if (Default) {
	    close_on_eof = exp_default_close_on_eof;
	} else {
	    close_on_eof = esPtr->close_on_eof;
	}
	Tcl_SetObjResult (interp, Tcl_NewIntObj (close_on_eof));
	return(TCL_OK);
    }

    /* all that's left is to set the close_on_eof */

    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &close_on_eof)) {
	return TCL_ERROR;
    }

    if (Default) exp_default_close_on_eof = close_on_eof;
    else esPtr->close_on_eof = close_on_eof;

    return(TCL_OK);
}

#if DEBUG_PERM_ECASES
/* This big chunk of code is just for debugging the permanent */
/* expect cases */
void
exp_fd_print(struct exp_state_list *slPtr)
{
	if (!slPtr) return;
	printf("%d ",slPtr->esPtr);
	exp_fd_print(slPtr->next);
}

void
exp_i_print(struct exp_i *exp_i)
{
	if (!exp_i) return;
	printf("exp_i %x",exp_i);
	printf((exp_i->direct == EXP_DIRECT)?" direct":" indirect");
	printf((exp_i->duration == EXP_PERMANENT)?" perm":" tmp");
	printf("  ecount = %d\n",exp_i->ecount);
	printf("variable %s, value %s\n",
		((exp_i->variable)?exp_i->variable:"--"),
		((exp_i->value)?exp_i->value:"--"));
	printf("ExpStates: ");
	exp_fd_print(exp_i->state_list); printf("\n");
	exp_i_print(exp_i->next);
}

void
exp_ecase_print(struct ecase *ecase)
{
	printf("pat <%s>\n",ecase->pat);
	printf("exp_i = %x\n",ecase->i_list);
}

void
exp_ecases_print(struct exp_cases_descriptor *ecd)
{
	int i;

	printf("%d cases\n",ecd->count);
	for (i=0;i<ecd->count;i++) exp_ecase_print(ecd->cases[i]);
}

void
exp_cmd_print(struct exp_cmd_descriptor *ecmd)
{
	printf("expect cmd type: %17s",exp_cmdtype_printable(ecmd->cmdtype));
	printf((ecmd->duration==EXP_PERMANENT)?" perm ": "tmp ");
	/* printdict */
	exp_ecases_print(&ecmd->ecd);
	exp_i_print(ecmd->i_list);
}

void
exp_cmds_print(void)
{
	exp_cmd_print(&exp_cmds[EXP_CMD_BEFORE]);
	exp_cmd_print(&exp_cmds[EXP_CMD_AFTER]);
	exp_cmd_print(&exp_cmds[EXP_CMD_BG]);
}

/*ARGSUSED*/
int
cmdX(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *CONST objv[])		/* Argument objects. */
{
	exp_cmds_print();
	return TCL_OK;
}
#endif /*DEBUG_PERM_ECASES*/

void
expExpectVarsInit(void)
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->timeout = INIT_EXPECT_TIMEOUT;
}

static struct exp_cmd_data
cmd_data[]  = {
{"expect",	Exp_ExpectObjCmd,	0,	(ClientData)0,	0},
{"expect_after",Exp_ExpectGlobalObjCmd, 0,	(ClientData)&exp_cmds[EXP_CMD_AFTER],0},
{"expect_before",Exp_ExpectGlobalObjCmd,0,	(ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
{"expect_user",	Exp_ExpectObjCmd,	0,	(ClientData)&StdinoutPlaceholder,0},
{"expect_tty",	Exp_ExpectObjCmd,	0,	(ClientData)&DevttyPlaceholder,0},
{"expect_background",Exp_ExpectGlobalObjCmd,0,	(ClientData)&exp_cmds[EXP_CMD_BG],0},
    {"match_max",	 Exp_MatchMaxObjCmd,     0,	(ClientData)0,	0},
    {"remove_nulls",     Exp_RemoveNullsObjCmd,  0,	(ClientData)0,	0},
    {"parity",	         Exp_ParityObjCmd,       0,	(ClientData)0,	0},
    {"close_on_eof",     Exp_CloseOnEofObjCmd,   0,	(ClientData)0,	0},
    {"timestamp",	 Exp_TimestampObjCmd,    0,	(ClientData)0,	0},
{0}};

void
exp_init_expect_cmds(Tcl_Interp *interp)
{
	exp_create_commands(interp,cmd_data);

	Tcl_SetVar(interp,EXPECT_TIMEOUT,INIT_EXPECT_TIMEOUT_LIT,0);

	exp_cmd_init(&exp_cmds[EXP_CMD_BEFORE],EXP_CMD_BEFORE,EXP_PERMANENT);
	exp_cmd_init(&exp_cmds[EXP_CMD_AFTER ],EXP_CMD_AFTER, EXP_PERMANENT);
	exp_cmd_init(&exp_cmds[EXP_CMD_BG    ],EXP_CMD_BG,    EXP_PERMANENT);
	exp_cmd_init(&exp_cmds[EXP_CMD_FG    ],EXP_CMD_FG,    EXP_TEMPORARY);

	/* preallocate to one element, so future realloc's work */
	exp_cmds[EXP_CMD_BEFORE].ecd.cases = 0;
	exp_cmds[EXP_CMD_AFTER ].ecd.cases = 0;
	exp_cmds[EXP_CMD_BG    ].ecd.cases = 0;

	pattern_style[PAT_EOF] = "eof";
	pattern_style[PAT_TIMEOUT] = "timeout";
	pattern_style[PAT_DEFAULT] = "default";
	pattern_style[PAT_FULLBUFFER] = "full buffer";
	pattern_style[PAT_GLOB] = "glob pattern";
	pattern_style[PAT_RE] = "regular expression";
	pattern_style[PAT_EXACT] = "exact string";
	pattern_style[PAT_NULL] = "null";

#if 0
    Tcl_CreateObjCommand(interp,"x",cmdX,(ClientData)0,exp_deleteProc);
#endif
}

void
exp_init_sig(void) {
#if 0
	signal(SIGALRM,sigalarm_handler);
	signal(SIGINT,sigint_handler);
#endif
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.61
log
@
	* exp_main_sub.c: Updated EXP_VERSION to 5.45.2
	* configure, configure.in: Updated expect to version 5.45.2

	* expect.c: [http://sourceforge.net/p/expect/patches/16/]. Report
	  and fix both by Per Cederqvist. Replaced a memcpy with memmove
	  as the latter properly handles overlapping memory, whereas the
	  original code does not.
@
text
@d975 3
a977 3
      expDiagLogU(Tcl_GetString(e->pat));
      expDiagLogU("? ");
      /* this must be the same test as in expIRead */
d981 2
a982 2
	o->e = e;
	    o->matchlen = numchars;
d984 6
a989 6
	o->esPtr = esPtr;
	expDiagLogU(yes);
	return(EXP_FULLBUFFER);
      } else {
	expDiagLogU(no);
      }
d1864 1
a1864 4
	/* the meaning of 0 from i_read means eof.  Muck with it a */
	/* little, so that from now on it means "no new data arrived */
	/* but it should be looked at again anyway". */
	if (cc == 0) {
a1865 6
	} else if (cc > 0) {
	    /* successfully read data */
	} else {
	    /* failed to read data - some sort of error was encountered such as
	     * an interrupt with that forced an error return
	     */
d1963 2
d1973 1
a1973 1
    /* temporarily stick null in middle of string */
d1984 1
a1984 1
     * restore damage
d1989 2
a1990 1
     * move 2nd half of string down to 1st half
@


5.60
log
@
	* exp_main_sub.c: Updated EXP_VERSION to 5.45.1
	* configure, configure.in: Updated expect to version 5.45.1

	* exp_chan.c: Applied patch sent in by Ogawa Hirofumi
	  <hirofumi@@mail.parknet.co.jp>. The patch fixes a problem when
	  talking a tty where the writer has died. Some operating systems
	  report the condition as EIO with nothing read, while this
	  actually an EOF. Without the patch the returned data is
	  incomplete due to the error reported immediately and dropping
	  data in buffers.

	* exp_chan.c: [Bug 3526461]: Applied patch by Michael Cleverly
	  <cleverly@@users.sourceforge.net> fixing a problem with the
	  iteration over the expect channel list where the loop code may
	  modify the list, breaking the iterator.

	* exp_chan.c: [Bug 3526707]: Applied patch by Michael Cleverly
	* exp_command.h: <cleverly@@users.sourceforge.net> fixing problem
	* expect.c: with an insufficient test for a lost channel in
	  exp_background_channelhandler.
@
text
@d1096 2
d1099 1
a1099 1
				memcpy(&ecmd->ecd.cases[i],
@


5.59
log
@
	* expect.c: [Bug 3095935]: Convert #bytes information to #chars to
	  prevent later code to fail when copying strings around and
	  miscalculating how much to copy, for strings containing
	  non-ASCII utf chars.
@
text
@d2506 6
a2511 2
    /* This ought to be sufficient. */
    if (0 == Tcl_GetChannel(interp,backup,(int *)0)) {
@


5.58
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@d949 3
d2350 1
a2350 1
    /* this is broken out of (match > 0) (above) since it can */
@


5.57
log
@ANSIfication changes.
@
text
@d58 1
a58 1
extern int Exp_StringCaseMatch (Tcl_UniChar *string, int strlen,
d60 1
a60 1
					    int nocase,int *offset);
d146 1
a146 1
	cmd->i_list = NULL;
d156 1
a156 1
void exp_background_channelhandlers_run_all(void);
d222 12
d262 1
a262 1
		if (!isspace((unsigned char)*p)) { /* INTL: ISO space */
d358 3
a360 3
	ec->i_list = NULL;
	ec->pat = NULL;
	ec->body = NULL;
d437 1
a437 1
		"-nobrace", "--", NULL
d583 1
a583 1
		NULL
d595 1
a595 1
		    TCL_EXACT, &index) != TCL_OK) {
d706 1
a706 1

d1102 1
a1102 1
				ecmd->ecd.cases = NULL;
d1121 1
a1121 1
			exp_i->next = NULL;
d1166 1
a1166 1
			esPtr->bg_interp = NULL;
d1274 1
a1274 1
			Tcl_AppendResult(interp," {",(char *)NULL);
d1283 2
a1284 3
		if (exp_i->state_list->next) {
				Tcl_AppendResult(interp,"} ",(char *)NULL);
		}
d1287 1
d1300 1
a1300 1
    char *iflag = NULL;
d1302 1
a1302 1
    ExpState *esPtr = NULL;
d1304 1
a1304 1
    static char *flags[] = {"-i", "-all", "-noindirect", NULL};
d1338 1
a1338 1
	struct exp_i *previous = NULL;
d1481 1
a1481 1
	    tmp->next = NULL;
d1573 1
a1573 1
	    exp_i->next = NULL;
d2213 1
a2213 1
	return NULL;
d2225 2
a2226 2
    ExpState *esPtr = NULL;
    Tcl_Obj *body = NULL;
d2228 1
a2228 1
    struct ecase *e = NULL;	/* points to current ecase */
d2432 1
a2432 1
	cc = expRead(interp,(ExpState **)NULL,0,&esPtr,EXP_TIME_INFINITY,0);
d2436 2
a2437 2
    eo.e = NULL;		/* no final case yet */
    eo.esPtr = NULL;		/* no final file selected yet */
d2441 1
a2441 1
    last_esPtr = NULL;
d2530 1
a2530 1
    ExpState *esPtr = NULL;
d2598 2
a2599 2
    state_list = NULL;
    esPtrs = NULL;
d2653 1
a2653 1
    last_esPtr = NULL;
d2659 2
a2660 2
    eo.e = NULL;		/* no final case yet */
    eo.esPtr = NULL;	/* no final ExpState selected yet */
d2702 1
a2702 1
	    last_esPtr = NULL;
d2758 1
a2758 1
	state_list = NULL;
d2762 1
a2762 1
	esPtrs = NULL;
d2785 1
a2785 1
	char *format = NULL;
d2869 9
d2966 1
a2966 1
    ExpState *esPtr = NULL;
d3012 1
a3012 1
    ExpState *esPtr = NULL;
d3056 1
a3056 1
    ExpState *esPtr = NULL;
d3095 1
a3095 1
    ExpState *esPtr = NULL;
d3260 1
a3260 1

@


5.56
log
@More ANSIfication
@
text
@d250 1
a250 1
		if (!isspace(*p)) { /* INTL: ISO space */
@


5.55
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@d58 1
a58 1
extern int Exp_StringCaseMatch _ANSI_ARGS_((Tcl_UniChar *string, int strlen,
d60 1
a60 1
					    int nocase,int *offset));
d146 1
a146 1
	cmd->i_list = 0;
d156 1
a156 1
void exp_background_channelhandlers_run_all();
a221 12

#if 0
/* no standard defn for this, and some systems don't even have it, so avoid */
/* the whole quagmire by calling it something else */
static char *exp_strdup(char *s)
{
	char *news = ckalloc(strlen(s) + 1);
	strcpy(news,s);
	return(news);
}
#endif

d346 3
a348 3
	ec->i_list = 0;
	ec->pat = 0;
	ec->body = 0;
d425 1
a425 1
		"-nobrace", "--", (char *)0
d571 1
a571 1
		(char *)NULL
d583 1
a583 1
		    1 /* exact */, &index) != TCL_OK) {
d1090 1
a1090 1
				ecmd->ecd.cases = 0;
d1109 1
a1109 1
			exp_i->next = 0;
d1154 1
a1154 1
			esPtr->bg_interp = 0;
d1262 1
a1262 1
			Tcl_AppendResult(interp," {",(char *)0);
d1271 3
a1273 2
	if (exp_i->state_list->next) {
			Tcl_AppendResult(interp,"} ",(char *)0);
a1275 1
}
d1288 1
a1288 1
    char *iflag = 0;
d1290 1
a1290 1
    ExpState *esPtr = 0;
d1292 1
a1292 1
    static char *flags[] = {"-i", "-all", "-noindirect", (char *)0};
d1326 1
a1326 1
	struct exp_i *previous = 0;
d1469 1
a1469 1
	    tmp->next = 0;
d1561 1
a1561 1
	    exp_i->next = 0;
d2201 1
a2201 1
	return (char *)0;
d2213 2
a2214 2
    ExpState *esPtr = 0;
    Tcl_Obj *body = 0;
d2216 1
a2216 1
    struct ecase *e = 0;	/* points to current ecase */
d2420 1
a2420 1
	cc = expRead(interp,(ExpState **)0,0,&esPtr,EXP_TIME_INFINITY,0);
d2424 2
a2425 2
    eo.e = 0;		/* no final case yet */
    eo.esPtr = 0;		/* no final file selected yet */
d2429 1
a2429 1
    last_esPtr = 0;
d2518 1
a2518 1
    ExpState *esPtr = 0;
d2586 2
a2587 2
    state_list = 0;
    esPtrs = 0;
d2641 1
a2641 1
    last_esPtr = 0;
d2647 2
a2648 2
    eo.e = 0;		/* no final case yet */
    eo.esPtr = 0;	/* no final ExpState selected yet */
d2690 1
a2690 1
	    last_esPtr = 0;
d2746 1
a2746 1
	state_list = 0;
d2750 1
a2750 1
	esPtrs = 0;
d2773 1
a2773 1
	char *format = 0;
a2856 9
process_di _ANSI_ARGS_ ((Tcl_Interp* interp,
			 int objc,
			 Tcl_Obj *CONST objv[],		/* Argument objects. */
			 int* at,
			 int* Default,
			 ExpState **esOut,
			 CONST char* cmd));

static int
d2945 1
a2945 1
    ExpState *esPtr = 0;
d2991 1
a2991 1
    ExpState *esPtr = 0;
d3035 1
a3035 1
    ExpState *esPtr = 0;
d3074 1
a3074 1
    ExpState *esPtr = 0;
@


5.54
log
@
	* configure.in: Bumped version to 5.44.1.11.
	* configure: Regen'd, autoconf 2.59.

	* exp_command.c (Exp_OverlayObjCmd): Fixed [Expect SF Bug 2127456]
	  reported by <eee@@users.sourceforge.net>, with thanks. Changed
	  retrieval of command from objv[0] (== 'overlay' itself), to
	  objv[i] containing the actual user command.

	* expect.c (string_case_first, string_first, eval_case_string):
	  Applied patch supplied by Andy Belsey <Andrew.Belsey@@Sun.COM>
	  fixing the seg.fault in 'expect -exact'. With thanks for both
	  the analysis of the problem and the patch. See also [Expect SF
	  Bug 2114547].
@
text
@d706 1
a706 1

d3260 1
a3260 1

@


5.53
log
@
	* configure.in: Bumped version to 5.44.1.7.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* exp_command.c: Fixed more compiler warnings, and started
	* exp_command.h: to ansify the code base, beginning with
	* exp_inter.c: the introduction of proper function prototypes.
	* exp_main_exp.c:
	* exp_pty.h:
	* exp_tty.c:
	* exp_tty.h:
	* exp_win.c:
	* expect.c:
	* pty_termios.c:
	* retoglob.c:
@
text
@d727 1
d734 1
d736 3
a738 2
    
    while (*string != 0) {
d741 1
a741 1
	while (*s) {
d743 1
d754 1
d761 4
a764 3
    register Tcl_UniChar *string,	/* String (unicode). */
    register char *pattern)	/* Pattern, which may contain
				 * special characters (utf8). */
d769 1
d771 1
d773 1
a773 1
    while (*string != 0) {
d776 1
a776 1
	while (*s) {
d778 1
d785 1
a785 1
	if (*p == '\0') {
d788 2
a789 1
	string++;
d940 1
a940 1
	    p = string_first(str, pat); /* NEW function in this file, see above */
d942 1
a942 1
	    p = string_case_first(str, pat);
@


5.52
log
@
	* configure.in: Bumped version to 5.44.1.6.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* configure.in: Fixed checking of stty on linux, do not restrict
	  to specific cpu's. Further try with stdin, and stdin redirected
	  to /dev/tty when determining if stdout is read.

	* testsuite/configure.in: Brought up to TEA 3.5.
	* testsuite/aclocal.m4: New file, to import the TEA definitions.

	* Dbg.c: Added missed CONST in declaration and definition of
	  'debugger_trap'.

	* exp_command.c: Fixed pointer aliasing trouble with
	  'Tcl_DetachPids', and added the missing initialization of the
	  command string in the 'overlay' command.

	* expect.c: Fixed missing initialization of 'simple_start' element
	  of 'ecase'.

	* exp_inter.c: Fixed bogus use of 'slen' in 'intMatch'. The
	  relevant string is Tcl_Unichar, not Utf.

	* Makefile.in: Replaced bogus INSTALL_ROOT with DESTDIR, and added
	  missing DESTDIR references to the target for the installation of
	  the manpages.
@
text
@d37 1
a37 1
#include "exp_tty.h"
d137 4
a140 4
exp_cmd_init(cmd,cmdtype,duration)
struct exp_cmd_descriptor *cmd;
int duration;
int cmdtype;
d159 10
a168 2
static char *exp_indirect_update1();	/* 1-part Tcl variable names */
static char *exp_indirect_update2();	/* 2-part Tcl variable names */
d173 1
a173 2
sigalarm_handler(n)
int n;		       	/* unused, for compatibility with STDC */
d181 4
a184 4
free_ecase(interp,ec,free_ilist)
Tcl_Interp *interp;
struct ecase *ec;
int free_ilist;		/* if we should free ilist */
d204 4
a207 4
free_ecases(interp,eg,free_ilist)
Tcl_Interp *interp;
struct exp_cmd_descriptor *eg;
int free_ilist;		/* if true, free ilists */
d226 1
a226 2
static char *exp_strdup(s)
char *s;
d251 1
a251 2
exp_one_arg_braced(objPtr)	/* INTL */
Tcl_Obj *objPtr;
d276 4
a279 4
exp_eval_with_one_arg(clientData,interp,objv) /* INTL */
ClientData clientData;
Tcl_Interp *interp;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d356 1
a356 2
ecase_clear(ec)
struct ecase *ec;
d372 1
a372 1
ecase_new()
d407 6
a412 6
parse_expect_args(interp,eg,default_esPtr,objc,objv)
Tcl_Interp *interp;
struct exp_cmd_descriptor *eg;
ExpState *default_esPtr;	/* suggested ExpState if called as expect_user or _tty */
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d725 3
a727 3
string_case_first(string,pattern)	/* INTL */
     register Tcl_UniChar *string;	/* String (unicode). */
    register char *pattern;	/* Pattern, which may contain
d755 3
a757 3
string_first(string,pattern)	/* INTL */
     register Tcl_UniChar *string;	/* String (unicode). */
     register char *pattern;	/* Pattern, which may contain
d785 3
a787 3
string_first_char(string,pattern)	/* INTL */
     register Tcl_UniChar *string;	/* String. */
     register Tcl_UniChar pattern;
d810 5
a814 5
eval_case_string(interp,e,esPtr,o,last_esPtr,last_case,suffix)
Tcl_Interp *interp;
struct ecase *e;
ExpState *esPtr;
struct eval_out *o;		/* 'output' - i.e., final case of interest */
d816 3
a818 3
ExpState **last_esPtr;
int *last_case;
char *suffix;
d984 5
a988 5
eval_cases(interp,eg,esPtr,o,last_esPtr,last_case,status,esPtrs,mcount,suffix)
Tcl_Interp *interp;
struct exp_cmd_descriptor *eg;
ExpState *esPtr;
struct eval_out *o;		/* 'output' - i.e., final case of interest */
d990 6
a995 6
ExpState **last_esPtr;
int *last_case;
int status;
ExpState *(esPtrs[]);
int mcount;
char *suffix;
d1068 4
a1071 4
ecases_remove_by_expi(interp,ecmd,exp_i)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d1102 4
a1105 4
exp_i_remove(interp,ei,exp_i)
Tcl_Interp *interp;
struct exp_i **ei;	/* list to remove from */
struct exp_i *exp_i;	/* element to remove */
d1120 4
a1123 4
exp_i_remove_with_ecases(interp,ecmd,exp_i)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d1131 5
a1135 5
ecmd_remove_state(interp,ecmd,esPtr,direct)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
ExpState *esPtr;
int direct;
d1175 3
a1177 3
exp_ecmd_remove_state_direct_and_indirect(interp,esPtr)
Tcl_Interp *interp;
ExpState *esPtr;
d1189 3
a1191 3
state_list_arm(interp,slPtr)
Tcl_Interp *interp;
struct exp_state_list *slPtr;
d1208 3
a1210 3
exp_i_uses_state(exp_i,esPtr)
struct exp_i *exp_i;
ExpState *esPtr;
d1221 3
a1223 3
ecase_append(interp,ec)
Tcl_Interp *interp;
struct ecase *ec;
d1238 4
a1241 4
ecase_by_exp_i_append(interp,ecmd,exp_i)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d1252 3
a1254 3
exp_i_append(interp,exp_i)
Tcl_Interp *interp;
struct exp_i *exp_i;
d1268 2
a1269 2
			char buf[10];	/* big enough for a small int */
			sprintf(buf,"%d",fdp->esPtr);
d1281 5
a1285 5
expect_info(interp,ecmd,objc,objv)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d1369 5
a1373 5
Exp_ExpectGlobalObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d1581 1
a1581 2
expAdjust(esPtr)
ExpState *esPtr;
d1638 3
a1640 3
expParityStrip(obj,offsetBytes)
    Tcl_Obj *obj;
    int offsetBytes;
d1665 3
a1667 3
expValid(obj,offset)
     Tcl_Obj *obj;
     int offset;
d1715 3
a1717 3
expNullStrip(buf,offsetChars)
     ExpUniBuf* buf;
     int offsetChars;
d1743 5
a1747 5
expIRead(interp,esPtr,timeout,save_flags) /* INTL */
Tcl_Interp *interp;
ExpState *esPtr;
int timeout;
int save_flags;
d1818 7
a1824 7
expRead(interp,esPtrs,esPtrsMax,esPtrOut,timeout,key)
Tcl_Interp *interp;
ExpState *(esPtrs[]);		/* If 0, then esPtrOut already known and set */
int esPtrsMax;			/* number of esPtrs */
ExpState **esPtrOut;		/* Out variable to leave new ExpState. */
int timeout;
int key;
d1926 6
a1931 6
exp_buffer_shuffle(interp,esPtr,save_flags,array_name,caller_name) /* INTL */
Tcl_Interp *interp;
ExpState *esPtr;
int save_flags;
char *array_name;
char *caller_name;
d1995 1
a1995 2
exp_tcl2_returnvalue(x)
int x;
d2014 1
a2014 2
exp_2tcl_returnvalue(x)
int x;
d2037 3
a2039 3
exp_get_var(interp,var)
Tcl_Interp *interp;
char *var;
d2049 1
a2049 2
get_timeout(interp)
Tcl_Interp *interp;
d2063 3
a2065 3
update_expect_states(i_list,i_union)
struct exp_i *i_list;
struct exp_state_list **i_union;
d2095 1
a2095 2
exp_cmdtype_printable(cmdtype)
int cmdtype;
d2112 6
a2117 6
exp_indirect_update2(clientData, interp, name1, name2, flags)
ClientData clientData;
Tcl_Interp *interp;	/* Interpreter containing variable. */
char *name1;		/* Name of variable. */
char *name2;		/* Second part of variable name. */
int flags;		/* Information about what happened. */
d2131 4
a2134 4
exp_indirect_update1(interp,ecmd,exp_i)
Tcl_Interp *interp;
struct exp_cmd_descriptor *ecmd;
struct exp_i *exp_i;
d2207 5
a2211 5
expMatchProcess(interp, eo, cc, bg, detail)
    Tcl_Interp *interp;
    struct eval_out *eo;	/* final case of interest */
    int cc;			/* EOF, TIMEOUT, etc... */
    int bg;			/* 1 if called from background handler, */
d2213 1
a2213 1
    char *detail;
d2387 3
a2389 3
exp_background_channelhandler(clientData,mask) /* INTL */
ClientData clientData;
int mask;
d2512 5
a2516 5
Exp_ExpectObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d2769 5
a2773 5
Exp_TimestampObjCmd(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2868 8
a2875 8
process_di (interp,objc,objv,at,Default,esOut,cmd)
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
     int* at;
     int* Default;
     CONST char* cmd;
     ExpState **esOut;
d2949 5
a2953 5
Exp_MatchMaxObjCmd(clientData,interp,objc,objv)
     ClientData clientData;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d2995 5
a2999 5
Exp_RemoveNullsObjCmd(clientData,interp,objc,objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3039 5
a3043 5
Exp_ParityObjCmd(clientData,interp,objc,objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3078 5
a3082 5
Exp_CloseOnEofObjCmd(clientData,interp,objc,objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3119 1
a3119 2
exp_fd_print(slPtr)
struct exp_state_list *slPtr;
d3127 1
a3127 2
exp_i_print(exp_i)
struct exp_i *exp_i;
d3143 1
a3143 2
exp_ecase_print(ecase)
struct ecase *ecase;
d3150 1
a3150 2
exp_ecases_print(ecd)
struct exp_cases_descriptor *ecd;
d3159 1
a3159 2
exp_cmd_print(ecmd)
struct exp_cmd_descriptor *ecmd;
d3169 1
a3169 1
exp_cmds_print()
d3178 5
a3182 5
cmdX(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
d3190 1
a3190 1
expExpectVarsInit()
d3213 1
a3213 2
exp_init_expect_cmds(interp)
Tcl_Interp *interp;
d3244 1
a3244 1
exp_init_sig() {
@


5.51
log
@
	* expect.c: Fixed refcounting error when parsing a single expect
	* configure.in: argument into a list of patterns and
	* configure: actions. Updated the version number to 5.44.1.5.
	* Dbg.c: Added missing 'return TCL_OK' to debugger_trap.
@
text
@d358 1
@


5.50
log
@
	* exp_inter.c: Changed inclusion of tcl.h to tclInt.h to get the
	* expect.c: definition of TCL_REG_BOSONLY, which was moved to that
	  header in Tcl 8.5. Ditto for expect.c, for the macro
	  TclUtfToUniChar (was a function in 8.4). Expect now compiles
	  again for both Tcl 8.4 and 8.5.

	* configure.in: Bumped version to 5.44.1.4.
	* configure: Regenerated.
@
text
@d325 1
d333 1
@


5.49
log
@
	* expect.c (Exp_TimestampObjCmd): Fixed argument processing broken
	  by objc,objv conversion. Tried to use command name as the
	  argument for -seconds. Also did not detect when one argument to
	  many was specified.

	* configure.in: Bumped version to 5.44.1.2.
	* configure: Regenerated.
@
text
@d28 1
a28 1
#include "tcl.h"
@


5.48
log
@
	* expect.c: Circumvented problems with the C compiler by use of a
	  temporary variable to hold the unicode pointer of a glob
	  pattern. The computed pattern length given to
	  Exp_StringCaseMatch was bogus.

	* exp_glob.c: Added tracing of the glob matcher internals (Can be
	  enabled by define EXP_INTERNAL_TRACE_GLOB). Fixed bug in a guard
	  condition in the optimized handling of '*'. The bad condition
	  caused the code to miss possible matches at the beginning of the
	  input (first char).

	* tests/expect.test: Added tests which check the glob matcher and
	  RE gate keeping.

	* configure.in: Bumped to 5.44.1.1 to separate this from the
	  regular 5.44.1 sources.
	* configure: Regenerated.
@
text
@d1395 1
a1395 1
	Tcl_ListObjGetElements (interp, new_cmd, &objc, &objv);
d2568 1
a2568 1
	Tcl_ListObjGetElements (interp, new_cmd, &objc, &objv);
d2811 1
a2811 1
			gmt = TRUE;
d2817 1
a2817 1
	    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[0], &sec)) {
d2824 3
a2826 1
	}
d2828 3
a2830 1
    if (i < (objc-1)) goto usage_error;
d2832 5
a2836 2
	if (seconds == -1) {
		time(&seconds);
a2837 7

	if (format) {
		if (gmt) {
			tm = gmtime(&seconds);
		} else {
			tm = localtime(&seconds);
		}
d2839 3
a2841 3
		exp_strftime(format,tm,&dstring);
		Tcl_DStringResult(interp,&dstring);
	} else {
d2843 1
a2843 1
	}
d2845 1
a2845 1
	return TCL_OK;
d2847 2
a2848 2
	exp_error(interp,"args: [-seconds #] [-format format]");
	return TCL_ERROR;
@


5.47
log
@
	* expect.c: Found bugs mismanaging input and pattern in the
	* exp_glob.c: updated glob matcher. We cannot check for '\0'
	  anymore to find the end of the string, these are counted
	  arrays now. Rewritten to use sentinel pointers.
@
text
@d495 1
a495 1
			expDiagLog(" is '%s'. Activating booster.\n",Tcl_GetString(Tcl_GetObjResult (interp)));
d839 2
d843 1
a843 1
	    expDiagLog("\"? ");
d845 1
a845 2
	    globmatch = Exp_StringCaseMatch(str, numchars,
					    Tcl_GetUnicodeFromObj (e->gate, &plen), plen,
d849 1
a849 1
	    expDiagLog("(No Gate, RE only) ");
d858 2
a895 1
	int plen;
d901 4
a904 2
	    match = Exp_StringCaseMatch(str,numchars,
					Tcl_GetUnicodeFromObj(e->pat,&plen), plen,
@


5.46
log
@
	* exp_chan.c: Converted the buffering system from UTF-8 in Tcl_Obj
	* exp_command.h: to UTF-16 C-array, to avoid the repeated conversion
	* expect.c: of the input from utf-8 to utf-16. Updated the glob
	* exp_glob.c: matching code to use the same tricks for speed which
	* exp_inter.c: are used by the Tcl core. Extended the regexp
	* exp_log.c: matching path with a glob matcher which uses a gate
	* exp_log.h: keeper glob pattern to weed out most non-candidates
	* retoglob.c (New file): in a speedy manner. Regexp matching now
	  has to be done only for the small number of candidates
	  identified by the gate keeper. Overall speed improvement as glob
	  matching is faster than regexp matching. Added code translating
	  regular expressions into their gate keeper glob pattern.
@
text
@d59 1
a59 1
					    Tcl_UniChar *pattern,
d493 3
d838 5
d844 1
a844 1
					    Tcl_GetUnicodeFromObj (e->gate, &dummy),
d848 2
d893 1
d900 1
a900 1
					Tcl_GetUnicodeFromObj(e->pat,&dummy),
@


5.45
log
@
	* Dbg.c: Converted the lot of argc,argv based command
	* exp_command.c: implementations over to objc,objv.
	* expect.c:
	* exp_main_sub.c:
@
text
@d44 2
d58 4
d77 2
a78 1
eof/timeout don't use any of theirs, but the algorithm is simpler this way. */
d84 5
d99 2
a100 2
	int simple_start;/* offset from start of buffer denoting where a */
			/* glob or exact match begins */
d180 3
a182 2
	if (ec->pat) Tcl_DecrRefCount(ec->pat);
	if (ec->body) Tcl_DecrRefCount(ec->body);
d187 1
a187 1
	if (ec->i_list->ecount == 0)
d190 1
d266 3
a268 1
/* returns TCL_whatever */
d270 1
a270 1
int
d276 2
a278 2
    Tcl_Obj *staticObjArray[NUM_STATIC_OBJS];
    int maxobjs = NUM_STATIC_OBJS;
d280 2
a281 1
    char *p, *next;
d283 1
a283 2
    Tcl_Obj **objs = staticObjArray;
    int objc, bytesLeft, numWords, i;
d290 2
a291 5
    objc = 2;
    objs[0] = objv[0];
    objs[1] = Tcl_NewStringObj("-nobrace", -1);
    Tcl_IncrRefCount(objs[0]);
    Tcl_IncrRefCount(objs[1]);
a313 11
	    if (objc + numWords > maxobjs) {
		Tcl_Obj ** newobjs;
		maxobjs = (objc + numWords) * 2;
		newobjs = (Tcl_Obj **)ckalloc(maxobjs * sizeof (Tcl_Obj *));
		memcpy(newobjs, objs, objc*sizeof(Tcl_Obj *));
		if (objs != staticObjArray) {
		    ckfree((char*)objs);
		}
		objs = newobjs;   
	    }

d321 3
a323 1
		objs[objc] = Tcl_EvalTokens(interp, tokenPtr+1,
d325 3
a327 2
		if (objs[objc] == NULL) {
		    rc = TCL_ERROR;
d329 1
d331 1
a331 1
		objc++;
a343 5
    /*
     * Now evaluate the entire command with no further substitutions.
     */

    rc = Tcl_EvalObjv(interp, objc, objs, 0);
d345 1
a345 8
    for (i = 0; i < objc; i++) {
	Tcl_DecrRefCount(objs[i]);
    }
    if (objs != staticObjArray) {
	ckfree((char *) objs);
    }
    return(rc);
#undef NUM_STATIC_OBJS
d361 1
d478 23
d628 6
a633 1
	    if (eg->duration == EXP_PERMANENT) Tcl_IncrRefCount(ec.pat);
d688 4
a691 3
    Tcl_Obj *buffer;		/* buffer that matched */
    int match;			/* # of bytes in buffer that matched */
			        /* or # of bytes in buffer at EOF */
d714 1
a714 1
char *
d716 1
a716 1
    register char *string;	/* String. */
d718 1
a718 1
				 * special characters. */
d720 2
a721 1
    char *s, *p;
d729 2
a730 2
	    s += Tcl_UtfToUniChar(s, &ch1);
	    offset = Tcl_UtfToUniChar(p, &ch2);
d744 52
a809 1
    Tcl_Obj *buffer;
d812 3
a814 2
    char *str;
    int length, flags;
d817 2
a818 2
    buffer = esPtr->buffer;
    str = Tcl_GetStringFromObj(buffer, &length);
d823 1
a823 1
	expDiagLogU(expPrintify(str));
d833 14
d855 4
a858 1
	result = Tcl_RegExpExecObj(interp, re, buffer, 0 /* offset */,
d860 1
a861 1

d870 2
a871 2
	    o->match = Tcl_UtfAtIndex(str, info.matches[0].end) - str;
	    o->buffer = buffer;
d880 1
d882 1
a882 1
	int match; /* # of bytes that matched */
d887 3
a889 3
	if (buffer) {
	    match = Exp_StringCaseMatch(Tcl_GetString(buffer),
		    Tcl_GetString(e->pat),
d894 2
a895 2
		o->match = match;
		o->buffer = buffer;
d905 1
a905 1
	char *p;
d908 1
a908 1
	    p = strstr(str, pat);
d919 2
a920 2
	    o->match = patLength;
	    o->buffer = buffer;
d926 1
a926 1
	CONST char *p;
d928 1
a928 1
	p = Tcl_UtfFindFirst(str, 0);
d932 2
a933 2
	    o->match = p-str;
	    o->buffer = buffer;
d943 3
a945 2
      if ((expSizeGet(esPtr) + TCL_UTF_MAX >= esPtr->msize)
	    && (length > 0)) {
d947 2
a948 2
	o->match = length;
	o->buffer = esPtr->buffer;
d1358 1
d1363 4
a1366 1
	return(exp_eval_with_one_arg(clientData,interp,objv));
d1368 2
d1373 8
a1380 1
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d1385 3
a1387 1
	    return(expect_info(interp,ecmd,objc,objv));
d1395 1
d1553 1
d1562 2
a1563 7
    int new_msize;
    int length;
    Tcl_Obj *newObj;
    char *string;
    int excessBytes;
    char *excessGuess;
    CONST char *p;
d1566 12
a1577 2
     * Resize buffer to user's request * 2 + 1.
     * x2: in case the match straddles two bufferfuls.
d1581 1
a1581 1
    new_msize = esPtr->umsize*2 + 1;
d1583 3
a1585 3
    if (new_msize != esPtr->msize) {
	string = Tcl_GetStringFromObj(esPtr->buffer, &length);
	if (length > new_msize) {
d1590 2
a1591 1
	    excessBytes = length - new_msize;	/* initial guess */
d1593 2
a1594 8
	    /*
	     * Alas, string + excessBytes may be in the middle of a UTF char.
	     * Find out for sure.
	     */
	    excessGuess = string + excessBytes;
	    for (p=string;;p=Tcl_UtfNext(p)) {
		if (p >= excessGuess) break;
	    }
a1595 3
	    /* now we can calculate a valid # of excess bytes */
	    excessBytes = p - string;
	    newObj = Tcl_NewStringObj(string + excessBytes,length - excessBytes);
d1598 2
a1599 1
	     * too little data
d1602 5
a1606 10
	    /* first copy what's there */
	    newObj = Tcl_NewStringObj(string,length);

	    /*
	     * Force object to allocate a buffer at least new_msize bytes long,
	     * then reset correct string length.
	     */

	    Tcl_SetObjLength(newObj,new_msize);
	    Tcl_SetObjLength(newObj,length);
a1607 3
	Tcl_IncrRefCount(newObj);
	Tcl_DecrRefCount(esPtr->buffer);
	esPtr->buffer = newObj;
d1610 1
a1610 1
	esPtr->msize = new_msize;
a1637 1
#endif /*OBSOLETE*/
d1671 1
a1671 1
    s += Tcl_UtfToUniChar(s,&uc);
d1682 1
a1682 1
    s += Tcl_UtfToUniChar(s,&uc);
d1690 1
d1692 1
a1692 1
/* Strip UTF-encoded nulls from object, beginning at offset */
d1694 3
a1696 3
expNullStrip(obj,offsetBytes)
    Tcl_Obj *obj;
    int offsetBytes;
d1698 1
a1698 3
    char *src, *src2;
    char *dest;
    Tcl_UniChar uc;
d1701 2
a1702 1
    src2 = src = dest = Tcl_GetString(obj) + offsetBytes;
d1704 4
a1707 4
    while (*src) {
	src += Tcl_UtfToUniChar(src,&uc);
	if (uc != 0) {
	    dest += Tcl_UniCharToUtf(uc,dest);
d1709 1
d1711 2
a1712 2
    newsize = offsetBytes + (dest - src2);
    Tcl_SetObjLength(obj,newsize);
d1729 1
a1729 1
    int size = expSizeGet(esPtr);
d1731 3
a1733 1
    if (size + TCL_UTF_MAX >= esPtr->msize) 
d1748 3
a1750 5
    
    cc = Tcl_ReadChars(esPtr->channel,
	    esPtr->buffer,
	    esPtr->msize - (size / TCL_UTF_MAX),
	    1 /* append */);
d1753 7
d1889 1
a1889 1
	expLogInteractionU(esPtr,Tcl_GetString(esPtr->buffer) + esPtr->printed);
d1896 1
a1896 1
	if (esPtr->rm_nulls) size = expNullStrip(esPtr->buffer,esPtr->printed);
d1912 4
a1915 6
    char *str;
    char *middleGuess;
    char *p;
    int length, newlen;
    int skiplen;
    char lostByte;
d1933 2
a1934 16
    if (Tcl_IsShared(esPtr->buffer)) {
	panic("exp_buffer_shuffle called with shared buffer object");
    }

    str = Tcl_GetStringFromObj(esPtr->buffer,&length);

    /* guess at the middle */
    middleGuess = str + length/2;

    /* crawl our way into the middle of the string
     * to make sure we are at a UTF char boundary
     */

    /* TIP 27: We cast CONST away to allow the restoration the lostByte later on
     * See 'restore damage' below.
     */
d1936 2
a1937 3
    for (p=str;*p;p = (char*) Tcl_UtfNext(p)) {
	if (p > middleGuess) break;   /* ok, that's enough */
    }
d1940 1
a1940 1
     * p is now at the beginning of a UTF char in the middle of the string
d1943 1
a1943 5
    /*
     * before doing move, show user data we are discarding
     */
    skiplen = p-str;
    lostByte = *p;
d1945 1
a1945 1
    Tcl_SetObjLength(esPtr->buffer,skiplen);
d1948 1
a1948 1
    expDiagLogU(expPrintify(Tcl_GetString(esPtr->buffer)));
d1950 2
a1951 1
    Tcl_SetVar2(interp,array_name,"buffer",Tcl_GetString(esPtr->buffer),
d1957 1
a1957 1
    *p = lostByte;
d1963 3
a1965 4
    newlen = length - skiplen;
    memmove(str,p, newlen);

    Tcl_SetObjLength(esPtr->buffer,newlen);
d2200 1
a2200 1
    Tcl_Obj *buffer;
a2202 1
    char match_char;	/* place to hold char temporarily */
d2212 7
d2224 2
a2225 2
	    match = eo->match;
	    buffer = eo->buffer;
d2230 2
a2231 2
	match = eo->match;
	buffer = eo->buffer;
d2242 6
d2258 1
d2281 1
a2281 1
		val = Tcl_GetRange(buffer, start, end);
d2287 1
d2289 1
a2289 1
	    char *str;
d2302 2
a2303 6
	    str = Tcl_GetString(esPtr->buffer) + e->simple_start;
	    /* temporarily null-terminate in middle */
	    match_char = str[match];
	    str[match] = 0;
	    out("0,string",str);
	    str[match] = match_char;
d2323 2
a2324 2
	char *str;
	int length;
d2328 3
a2330 1
	str = Tcl_GetStringFromObj(esPtr->buffer, &length);
d2332 1
a2332 6
	/* temporarily null-terminate string in middle */
	match_char = str[match];
	str[match] = 0;
	out("buffer",str);
	/* remove middle-null-terminator */
	str[match] = match_char;
d2336 1
d2339 2
a2340 2
	    if (length != 0) {
		memmove(str,str+match,length-match);
d2342 1
a2342 1
	    Tcl_SetObjLength(esPtr->buffer, length-match);
d2348 1
a2348 1
	    if (body) Tcl_IncrRefCount(body);
d2411 1
a2411 1
    eo.match = 0;		/* nothing matched yet */
d2450 2
a2451 2
	eo.match = expSizeGet(eo.esPtr);
	eo.buffer = eo.esPtr->buffer;
d2533 1
d2536 4
a2539 1
	return(exp_eval_with_one_arg(clientData,interp,objv));
d2541 2
d2546 8
a2553 1
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d2573 3
a2575 2
    if (TCL_ERROR == parse_expect_args(interp,&eg,
	    (ExpState *)clientData,objc,objv))
d2577 1
d2634 1
a2634 1
    eo.match = 0;	/* nothing matched yet */
d2689 2
a2690 2
	    eo.match = expSizeGet(eo.esPtr);
	    eo.buffer = eo.esPtr->buffer;
d2694 1
d2746 1
d3239 8
@


5.44
log
@
	* Dbg.c: Cleaned up the direct access to interp->result,
	* exp_command.c: replaced with the proper functions and
	* expect.c: Tcl_Obj's.
	* exp_main_exp.c:
	* exp_main_sub.c:
	* exp_main_tk.c:
	* exp_prog.h:
	* exp_trap.c:
	* exp_tty.c:
	* exp_win.c:
	* exp_win.h:
@
text
@d2638 1
a2638 1
Exp_TimestampCmd(clientData, interp, argc, argv)
d2641 2
a2642 2
int argc;
char **argv;
d2649 1
d2651 31
a2681 14
	argc--; argv++;

	while (*argv) {
		if (streq(*argv,"-format")) {
			argc--; argv++;
			if (!*argv) goto usage_error;
			format = *argv;
			argc--; argv++;
		} else if (streq(*argv,"-seconds")) {
			argc--; argv++;
			if (!*argv) goto usage_error;
			seconds = atoi(*argv);
			argc--; argv++;
		} else if (streq(*argv,"-gmt")) {
d2683 12
a2694 2
			argc--; argv++;
		} else break;
d2697 1
a2697 1
	if (argc) goto usage_error;
a2702 2
	Tcl_DStringInit(&dstring);

d2709 1
a2709 1
/*		exp_strftime(interp->result,TCL_RESULT_SIZE,format,tm);*/
d2713 1
a2713 1
		sprintf(interp->result,"%ld",seconds);
d2723 15
a2737 4
/*ARGSUSED*/
int
Exp_MatchMaxCmd(clientData,interp,argc,argv)
ClientData clientData;
d2739 40
a2778 16
int argc;
char **argv;
{
    int size = -1;
    ExpState *esPtr = 0;
    char *chanName = 0;
    int Default = FALSE;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
d2782 3
a2784 2
	    chanName = *argv;
	} else break;
d2787 1
a2787 1
    if (Default && chanName) {
d2792 6
a2797 4
    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
		return(TCL_ERROR);
d2799 4
d2804 1
a2804 3
	    
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"match_max")))
		return(TCL_ERROR);
d2806 1
d2809 25
a2833 1
    if (argc == 0) {
d2839 1
a2839 6
	sprintf(interp->result,"%d",size);
	return(TCL_OK);
    }

    if (argc > 1) {
	exp_error(interp,"too many arguments");
d2847 4
a2850 1
    size = atoi(argv[0]);
d2864 1
a2864 1
Exp_RemoveNullsCmd(clientData,interp,argc,argv)
d2867 2
a2868 2
int argc;
char **argv;
a2871 1
    char *chanName = 0;
d2873 1
d2875 2
a2876 29
    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else break;
    }

    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0)))
		return(TCL_ERROR);
	} else {
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"remove_nulls")))
		return(TCL_ERROR);
	}
    }
d2878 2
a2879 1
    if (argc == 0) {
d2885 1
a2885 1
	sprintf(interp->result,"%d",value);
d2889 4
a2892 3
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
d2895 1
a2895 3
    /* all that's left is to set the value */
    value = atoi(argv[0]);
    if (value != 0 && value != 1) {
d2908 1
a2908 1
Exp_ParityCmd(clientData,interp,argc,argv)
d2911 2
a2912 2
int argc;
char **argv;
a2915 1
    char *chanName = 0;
d2917 1
d2919 2
a2920 1
    argc--; argv++;
d2922 2
a2923 31
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else break;
    }

    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
		return(TCL_ERROR);
	    }
	} else {
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"parity"))) {
		return(TCL_ERROR);
	    }
	}
    }

    if (argc == 0) {
d2929 1
a2929 1
	sprintf(interp->result,"%d",parity);
d2933 4
a2936 3
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
a2938 3
    /* all that's left is to set the parity */
    parity = atoi(argv[0]);

d2947 1
a2947 1
Exp_CloseOnEofCmd(clientData,interp,argc,argv)
d2950 2
a2951 2
int argc;
char **argv;
a2954 1
    char *chanName = 0;
d2956 1
d2958 2
a2959 1
    argc--; argv++;
d2961 2
a2962 31
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else break;
    }

    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
		return(TCL_ERROR);
	    }
	} else {
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"close_on_eof"))) {
		return(TCL_ERROR);
	    }
	}
    }

    if (argc == 0) {
d2968 1
a2968 1
	sprintf(interp->result,"%d",close_on_eof);
d2972 4
a2975 3
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
a2977 3
    /* all that's left is to set the close_on_eof */
    close_on_eof = atoi(argv[0]);

d3052 1
a3052 1
cmdX(clientData, interp, argc, argv)
d3055 2
a3056 2
int argc;
char **argv;
d3079 5
a3083 5
{"match_max",	exp_proc(Exp_MatchMaxCmd),	0,	0},
{"remove_nulls",exp_proc(Exp_RemoveNullsCmd),	0,	0},
{"parity",	exp_proc(Exp_ParityCmd),	0,	0},
{"close_on_eof",exp_proc(Exp_CloseOnEofCmd),	0,	0},
{"timestamp",	exp_proc(Exp_TimestampCmd),	0,	0},
d3114 1
a3114 2
	Tcl_CreateCommand(interp,"x",
		cmdX,(ClientData)0,exp_deleteProc);
@


5.43
log
@
	* exp_command.c: Reformatted overlong lines, whitespace,
	* expect.c: comments. Added braces to some if-constructs.
	* exp_inter.c: Reworked if-constructs interleaved with
	* exp_tty.c: #if for better formatting in emacs.
@
text
@d1343 4
d1351 1
a1351 1
		strcpy(interp->result,msg);
d2079 6
d2087 1
a2087 1
			interp->result,exp_i->variable);
@


5.42
log
@
	* Dbg.c: Added note about unhandled cases in a switch.
	* exp_chan.c: Added code to suppress unhandled warning for
	  unreachable code.
	* exp_command.c: Removed unused variable.
	* expect.c: Removed unused static function, added code to suppress
	  unhandled warning for unreachable code.
@
text
@d117 6
a122 4
/* note that exp_cmds[FG] is just a fake, the real contents is stored
   in some dynamically-allocated variable.  We use exp_cmds[FG] mostly
   as a well-known address and also as a convenience and so we allocate
   just a few of its fields that we need. */
d1145 1
a1145 1
		if (exp_i->state_list->next)
d1147 1
d1155 1
a1155 1
		if (exp_i->state_list->next)
d1159 1
a1294 1

d1707 1
d2255 1
a2255 1
	if (cc == EXP_EOF) Tcl_DecrRefCount(body);
a3079 2


@


5.41
log
@
	* exp_inter.c: Changed all uses of 'time(3)' to Tcl_GetTime. IOW
	* expect.c:    go through the abstract core API instead of
	               directly acessing OS time. This makes the code
	               dependent on Tcl 8.4, as Tcl_GetTime was not public
	               before. See TIP #73 for its introduction into the
	               public API. As for the reason behind _this_ change
	               see TIP #233. Our change here now causes Expect to
	               be automatically in sync with any virtualization
	               set up in the core.
@
text
@a211 16
/* In many places, there is no need to malloc a copy of a string, since it */
/* will be freed before we return to Tcl */
static void
save_str(lhs,rhs,nosave)
char **lhs;	/* left hand side */
char *rhs;	/* right hand side */
int nosave;
{
	if (nosave || (rhs == 0)) {
		*lhs = rhs;
	} else {
		*lhs = ckalloc(strlen(rhs) + 1);
		strcpy(*lhs,rhs);
	}
}

d1889 4
d1909 4
d1989 1
a1989 1
#ifdef LINT
d1991 1
a1991 1
#endif
@


5.40
log
@
	* Merged changes from the official version 5.42b0 of expect into
	  the SF sources. See details below (In the ChangeLog).
@
text
@d2429 1
d2440 2
a2441 1
    time(&start_time_total);
d2493 4
a2496 1
    else time(&start_time);
d2522 2
a2523 1
	    time(&current_time);
d2584 2
a2585 1
	    time(&current_time);
@


5.39
log
@
	* Merged changes from the official version 5.39 of expect into the
	  SF sources. See details below. Partially already done.

	  --------------------
	  Poorva Gupta <poorva@@cup.hp.xcom> noted that grantpt/unlockpt
	  order was backward.  Strange that this was never a prob before!

	  Eric Raymond <esr@@snark.thyrsus.xcom> provided a troff-related
	  fix for the multixterm man page.

	  Nicolas Roeser <n-roeser@@gmx.xnet> noted confusion with md5 so I
	  made the Expect page more explicit about which file that hash
	  was based on.

	  Josh Purinton noted that earlier fix wasn't quite right.  Exit
	  on INT/TERM should cause Expect to exit with signal embedded in
	  status.  He also requested I obfuscate email addresses in this
	  file.

	  Guido Ostkamp <Guido.Ostkamp@@t-online.xde> and Igor Sobrado
	  <sobrado@@string1.ciencias.uniovi.xes> noted that fixline1
	  rewrote scripts to be expect scripts even if they were expectk
	  scripts.

	  Dirk Petera <dirkpetera@@yahoo.xcom> noted that any_spawn_id used
	  to work but did no longer.  Looks like a bug left over from the
	  the I18L conversion.  Fixed.

	  Steve Szabo noted exp_log_file -open channel failed.  Fixed.

	  Fixed bug from 5.31 that prevent stty from returning messages
	  from underlying program.

	  Thomas Dickey <dickey@@herndon4.his.xcom> noted that ncurses
	  ignores 2-char term names because of, well, poor assumptions and
	  coding.  Changed tkterm to use longer names.

	  Heath Moore <hmoore@@systran.xcom> noted that exp_clib could lock
	  up if remtime happened to be precisely 0.  Recoded to avoid.

	  At request of Per Otterholm <otterholm@@telia.xcom>, wrote script
	  to read from stdin and echo passwords (exercise 9 in Tk chapter
	  of Expect book).  Added to example directory as passwdprompt.

	  Josh Purinton <josh@@purinton.xorg> pointed out that by default,
	  SIGINT/TERM should cause expect's return status to be 1, not 0.

	  Paul Reithmuller <paul.reithmuller@@eng.sun.xcom> noted that
	  unbuffer shouldn't postprocess its output.  Added stty_init.

	  Mordechai T. Abzug <morty@@sanctuary.arbutus.md.xus> noted that
	  log_file wasn't recording -append status.

	  James Kelly <macubergeek@@comcast.xnet> noted weather example
	  needed new source.

	  Dimitar Haralanov <mitko@@tahoenetworks.xcom> noted that interact
	  dumped core with interact { timeout 1 }
	  --------------------
@
text
@d50 1
d1758 1
d1761 1
d2246 1
d2250 1
d2900 69
d3067 1
@


5.38
log
@misc updates
@
text
@d1047 1
a1047 1
		if ((ecmd->cmdtype == EXP_CMD_BG) && (expStateAnyIs(esPtr))) {
d2030 1
a2030 1
	 * disarm any ExpState's that lose all their ecases
@


5.37
log
@Fixed bug in background handler that would occur when an action did a wait
thereby invalidating esPtr.
@
text
@d1925 1
a1925 1
CONST char *
d1930 1
a1930 1
    CONST char *val;
@


5.36
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d2266 2
d2279 4
d2366 7
@


5.35
log
@
	* expect.c: Applied patch by Don Libes fixing improper
	  internationalization.
@
text
@d844 1
a844 1
	char *p;
d1463 1
a1463 1
    char *p;
d1842 6
a1847 1
    for (p=str;*p;p = Tcl_UtfNext(p)) {
d1925 1
a1925 1
char *
d1930 1
a1930 1
    char *val;
d1942 1
a1942 1
    char *t;
@


5.34
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@d858 4
a861 1
      if ((Tcl_GetCharLength(esPtr->buffer) == esPtr->msize)
a862 2
	expDiagLogU(Tcl_GetString(e->pat));
	expDiagLogU("? ");
@


5.33
log
@
Upgrading to 5.33.
@
text
@d520 1
@


5.32
log
@Fixed segfaulting when reading channels with nulls.
@
text
@d856 2
a857 1
    } else if ((Tcl_GetCharLength(esPtr->buffer) == esPtr->msize)
d867 3
@


5.32.6.1
log
@A working set of code against Tcl8.4!
@
text
@@


5.32.2.1
log
@Upgrading to 5.33.
@
text
@d856 1
a856 2
    } else if (e->use == PAT_FULLBUFFER) {
      if ((Tcl_GetCharLength(esPtr->buffer) == esPtr->msize)
a865 3
      } else {
	expDiagLogU(no);
      }
@


5.32.2.2
log
@
	* Applied patch for SF #514590 to correct behaviour of expect when
	  expecting and send from and to bogus spawn id's.
@
text
@a519 1
		if (!ec.i_list) goto error;
@


5.32.2.3
log
@
	* expect.c: Applied patch by Don Libes fixing improper
	  internationalization.
@
text
@d858 1
a858 4
      expDiagLogU(Tcl_GetString(e->pat));
      expDiagLogU("? ");
      /* this must be the same test as in expIRead */
      if ((expSizeGet(esPtr) + TCL_UTF_MAX >= esPtr->msize)
d860 2
@


5.32.4.1
log
@Top-level source files removed.
@
text
@@


5.31
log
@Fixed printf formats in several pty diags.
@
text
@d1539 52
d1592 1
a1592 1
static void
d1600 1
d1610 3
a1612 1
    Tcl_SetObjLength(obj,offsetBytes + (dest - src2));
d1785 1
a1785 1
	if (esPtr->rm_nulls) expNullStrip(esPtr->buffer,esPtr->printed);
@


5.30
log
@Merge of expect5-31-branch to mainline
@
text
@d2721 1
a2721 1
	    value = exp_default_match_max;
d2723 1
a2723 1
	    value = esPtr->rm_nulls;
@


5.29
log
@numerous edits - getting synchronized (first time I've used CVS), see
HISTORY file for more info
@
text
@a16 3
#if 0
#include <setjmp.h>
#endif
a31 1
#include "tclRegexp.h"
d55 14
d74 2
a75 2
	char *pat;	/* original pattern spec */
	char *body;	/* ptr to body to be executed upon match */
a89 1
/*	int iwrite;*/	/* if true write spawn_id */
a95 1
	regexp *re;	/* if this is 0, then pattern match via glob */
a135 6
#if 0
static jmp_buf env;	/* for interruptable read() */
			/* longjmp(env,1) times out the read */
			/* longjmp(env,2) restarts the read */
static int env_valid = FALSE;	/* whether we can longjmp or not */
#endif
d141 1
a141 1
void exp_background_filehandlers_run_all();
a146 2
static int	exp_i_read _ANSI_ARGS_((Tcl_Interp *,int,int,int));

a153 5
#if 0
	/* check env_valid first to protect us from the alarm occurring */
	/* in the window between i_read and alarm(0) */
	if (env_valid) longjmp(env,1);
#endif /*0*/
a156 81
#if 0
/*ARGSUSED*/
static RETSIGTYPE
sigalarm_handler(n)
int n;		       	/* unused, for compatibility with STDC */
{
#ifdef REARM_SIG
	signal(SIGALRM,sigalarm_handler);
#endif

	/* check env_valid first to protect us from the alarm occurring */
	/* in the window between i_read and alarm(0) */
	if (env_valid) longjmp(env,1);
}
#endif /*0*/

#if 0

/* upon interrupt, act like timeout */
/*ARGSUSED*/
static RETSIGTYPE
sigint_handler(n)
int n;			/* unused, for compatibility with STDC */
{
#ifdef REARM_SIG
	signal(SIGINT,sigint_handler);/* not nec. for BSD, but doesn't hurt */
#endif

#ifdef TCL_DEBUGGER
	if (exp_tcl_debugger_available) {
		/* if the debugger is active and we're reading something, */
		/* force the debugger to go interactive now and when done, */
		/* restart the read.  */

		Dbg_On(exp_interp,env_valid);

		/* restart the read */
		if (env_valid) longjmp(env,2);

		/* if no read is in progess, just let debugger start at */
		/* the next command. */
		return;
	}
#endif

#if 0
/* the ability to timeout a read via ^C is hereby removed 8-Mar-1993 - DEL */

	/* longjmp if we are executing a read inside of expect command */
	if (env_valid) longjmp(env,1);
#endif

	/* if anywhere else in code, prepare to exit */
	exp_exit(exp_interp,0);
}
#endif /*0*/

/* remove nulls from s.  Initially, the number of chars in s is c, */
/* not strlen(s).  This count does not include the trailing null. */
/* returns number of nulls removed. */
static int
rm_nulls(s,c)
char *s;
int c;
{
	char *s2 = s;	/* points to place in original string to put */
			/* next non-null character */
	int count = 0;
	int i;

	for (i=0;i<c;i++,s++) {
		if (0 == *s) {
			count++;
			continue;
		}
		if (count) *s2 = *s;
		s2++;
	}
	return(count);
}

d164 10
a173 1
	if (ec->re) ckfree((char *)ec->re);
d175 1
a175 12
	if (ec->i_list->duration == EXP_PERMANENT) {
		if (ec->pat) ckfree(ec->pat);
		if (ec->body) ckfree(ec->body);
	}

	if (free_ilist) {
		ec->i_list->ecount--;
		if (ec->i_list->ecount == 0)
			exp_free_i(interp,ec->i_list,exp_indirect_update2);
	}

	ckfree((char *)ec);	/* NEW */
d244 2
a245 2
exp_one_arg_braced(p)
char *p;
d248 1
d256 1
a256 1
		if (!isspace(*p)) {
d268 1
a268 1
exp_eval_with_one_arg(clientData,interp,argv)
d271 1
a271 1
char **argv;
d273 68
a340 8
	char *buf;
	int rc;
	char *a;

	/* + 11 is for " -nobrace " and null at end */
	buf = ckalloc(strlen(argv[0]) + strlen(argv[1]) + 11);
	/* recreate statement (with -nobrace to prevent recursion) */
	sprintf(buf,"%s -nobrace %s",argv[0],argv[1]);
d343 1
a343 1
	 * replace top-level newlines with blanks
d345 9
d355 10
a364 21
	/* Should only be necessary to run over argv[1] and then sprintf */
	/* that into the buffer, but the ICEM guys insist that writing */
	/* back over the original arguments makes their Tcl compiler very */
	/* unhappy. */
	for (a=buf;*a;) {
		extern char *TclWordEnd();

		for (;isspace(*a);a++) {
			if (*a == '\n') *a = ' ';
		}
#if TCL_MAJOR_VERSION < 8
		a = TclWordEnd(a,0,(int *)0)+1;
#else
		a = TclWordEnd(a,&a[strlen(a)],0,(int *)0)+1;
#endif
	}

	rc = Tcl_Eval(interp,buf);

	ckfree(buf);
	return(rc);
a375 1
/*	ec->iwrite = FALSE;*/
a377 1
	ec->re = 0;
d418 1
a418 1
parse_expect_args(interp,eg,default_spawn_id,argc,argv)
d421 40
a460 7
int default_spawn_id;	/* suggested master if called as expect_user or _tty */
int argc;
char **argv;
{
	int i;
	char *arg;
	struct ecase ec;	/* temporary to collect args */
d462 23
a484 2
	argv++;
	argc--;
d486 5
a490 3
	eg->timeout_specified_by_flag = FALSE;

	ecase_clear(&ec);
d492 3
a494 98
	/* Allocate an array to store the ecases.  Force array even if 0 */
	/* cases.  This will often be too large (i.e., if there are flags) */
	/* but won't affect anything. */

	eg->ecd.cases = (struct ecase **)ckalloc(
		sizeof(struct ecase *) * (1+(argc/2)));

	eg->ecd.count = 0;

	for (i = 0;i<argc;i++) {
		arg = argv[i];
	
		if (exp_flageq("timeout",arg,7)) {
			ec.use = PAT_TIMEOUT;
		} else if (exp_flageq("eof",arg,3)) {
			ec.use = PAT_EOF;
		} else if (exp_flageq("full_buffer",arg,11)) {
			ec.use = PAT_FULLBUFFER;
		} else if (exp_flageq("default",arg,7)) {
			ec.use = PAT_DEFAULT;
		} else if (exp_flageq("null",arg,4)) {
			ec.use = PAT_NULL;
		} else if (arg[0] == '-') {
			arg++;
			if (exp_flageq1('-',arg)		/* "--" is deprecated */
			  || exp_flageq("glob",arg,2)) {
				i++;
				/* assignment here is not actually necessary */
				/* since cases are initialized this way above */
				/* ec.use = PAT_GLOB; */
			} else if (exp_flageq("regexp",arg,2)) {
				i++;
				ec.use = PAT_RE;
				TclRegError((char *)0);
				if (!(ec.re = TclRegComp(argv[i]))) {
					exp_error(interp,"bad regular expression: %s",
								TclGetRegError());
					goto error;
				}
			} else if (exp_flageq("exact",arg,2)) {
				i++;
				ec.use = PAT_EXACT;
			} else if (exp_flageq("notransfer",arg,1)) {
				ec.transfer = 0;
				continue;
			} else if (exp_flageq("nocase",arg,3)) {
				ec.Case = CASE_LOWER;
				continue;
			} else if (exp_flageq1('i',arg)) {
				i++;
				if (i>=argc) {
					exp_error(interp,"-i requires following spawn_id");
					goto error;
				}

				ec.i_list = exp_new_i_complex(interp,argv[i],
					eg->duration,exp_indirect_update2);

				ec.i_list->cmdtype = eg->cmdtype;

				/* link new i_list to head of list */
				ec.i_list->next = eg->i_list;
				eg->i_list = ec.i_list;

				continue;
			} else if (exp_flageq("indices",arg,2)) {
				ec.indices = TRUE;
				continue;
			} else if (exp_flageq("iwrite",arg,2)) {
/*				ec.iwrite = TRUE;*/
				continue;
			} else if (exp_flageq("iread",arg,2)) {
				ec.iread = TRUE;
				continue;
			} else if (exp_flageq("timestamp",arg,2)) {
				ec.timestamp = TRUE;
				continue;
			} else if (exp_flageq("timeout",arg,2)) {
				i++;
				if (i>=argc) {
					exp_error(interp,"-timeout requires following # of seconds");
					goto error;
				}

				eg->timeout = atoi(argv[i]);
				eg->timeout_specified_by_flag = TRUE;
				continue;
			} else if (exp_flageq("nobrace",arg,7)) {
				/* nobrace does nothing but take up space */
				/* on the command line which prevents */
				/* us from re-expanding any command lines */
				/* of one argument that looks like it should */
				/* be expanded to multiple arguments. */
				continue;
			} else {
				exp_error(interp,"usage: unrecognized flag <%s>",arg);
				goto error;
			}
d496 81
d578 34
a611 13
		/* if no -i, use previous one */
		if (!ec.i_list) {
			/* if no -i flag has occurred yet, use default */
			if (!eg->i_list) {
				if (default_spawn_id != EXP_SPAWN_ID_BAD) {
					eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
				} else {
					/* it'll be checked later, if used */
					(void) exp_update_master(interp,&default_spawn_id,0,0);
					eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
				}
			}
			ec.i_list = eg->i_list;
d613 18
a630 9
		ec.i_list->ecount++;

		/* save original pattern spec */
		/* keywords such as "-timeout" are saved as patterns here */
		/* useful for debugging but not otherwise used */
		save_str(&ec.pat,argv[i],eg->duration == EXP_TEMPORARY);
		save_str(&ec.body,argv[i+1],eg->duration == EXP_TEMPORARY);
			
		i++;
d632 1
a632 1
		*(eg->ecd.cases[eg->ecd.count] = ecase_new()) = ec;
d635 1
a635 1
		ecase_clear(&ec);
d637 1
a637 1
		eg->ecd.count++;
d639 1
d641 2
a642 2
	/* if no patterns at all have appeared force the current */
	/* spawn id to be added to list anyway */
d644 7
a650 8
	if (eg->i_list == 0) {
		if (default_spawn_id != EXP_SPAWN_ID_BAD) {
			eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
		} else {
			/* it'll be checked later, if used */
			(void) exp_update_master(interp,&default_spawn_id,0,0);
			eg->i_list = exp_new_i_simple(default_spawn_id,eg->duration);
		}
d652 1
d654 1
a654 1
	return(TCL_OK);
d657 2
a658 5
	/* very hard to free case_master_list here if it hasn't already */
	/* been attached to a case, ugh */

	/* note that i_list must be avail to free ecases! */
	free_ecases(interp,eg,0);
d660 2
a661 7
	/* undo temporary ecase */
	/* free_ecase doesn't quite handle this right, so do it by hand */
	if (ec.re) ckfree((char *)ec.re);
	if (eg->duration == EXP_PERMANENT) {
		if (ec.pat) ckfree(ec.pat);
		if (ec.body) ckfree(ec.body);
	}
d663 3
a665 3
	if (eg->i_list)
		exp_free_i(interp,eg->i_list,exp_indirect_update2);
	return(TCL_ERROR);
d675 5
a679 5
	struct ecase *e;		/* ecase that matched */
	struct exp_f *f;			/* struct exp_f that matched */
	char *buffer;			/* buffer that matched */
	int match;			/* # of chars in buffer that matched */
					/* or # of chars in buffer at EOF */
d683 48
d735 1
a735 1
eval_case_string(interp,e,m,o,last_f,last_case,suffix)
d738 1
a738 1
int m;
d741 1
a741 1
struct exp_f **last_f;
d745 30
a774 2
	struct exp_f *f = exp_fs + m;
	char *buffer;
d776 47
a822 2
	/* if -nocase, use the lowerized buffer */
	buffer = ((e->Case == CASE_NORM)?f->buffer:f->lower);
d824 5
a828 29
	/* if master or case changed, redisplay debug-buffer */
	if ((f != *last_f) || e->Case != *last_case) {
		debuglog("\r\nexpect%s: does \"%s\" (spawn_id %d) match %s ",
			 	suffix,
				dprintify(buffer),f-exp_fs,
				pattern_style[e->use]);
		*last_f = f;
		*last_case = e->Case;
	}

	if (e->use == PAT_RE) {
		debuglog("\"%s\"? ",dprintify(e->pat));
		TclRegError((char *)0);
		if (buffer && TclRegExec(e->re,buffer,buffer)) {
			o->e = e;
			o->match = e->re->endp[0]-buffer;
			o->buffer = buffer;
			o->f = f;
			debuglog(yes);
			return(EXP_MATCH);
		} else {
			debuglog(no);
			if (TclGetRegError()) {
			    exp_error(interp,"-re failed: %s",TclGetRegError());
			    return(EXP_TCLERROR);
		        }
		    }
	} else if (e->use == PAT_GLOB) {
		int match; /* # of chars that matched */
d830 38
a867 48
	        debuglog("\"%s\"? ",dprintify(e->pat));
		if (buffer && (-1 != (match = Exp_StringMatch(
				buffer,e->pat,&e->simple_start)))) {
			o->e = e;
			o->match = match;
			o->buffer = buffer;
			o->f = f;
			debuglog(yes);
			return(EXP_MATCH);
		} else debuglog(no);
	} else if (e->use == PAT_EXACT) {
		char *p = strstr(buffer,e->pat);
	        debuglog("\"%s\"? ",dprintify(e->pat));
		if (p) {
			e->simple_start = p - buffer;
			o->e = e;
			o->match = strlen(e->pat);
			o->buffer = buffer;
			o->f = f;
			debuglog(yes);
			return(EXP_MATCH);
		} else debuglog(no);
	} else if (e->use == PAT_NULL) {
		int i = 0;
		debuglog("null? ");
		for (;i<f->size;i++) {
			if (buffer[i] == 0) {
				o->e = e;
				o->match = i+1;	/* in this case, match is */
						/* just the # of chars + 1 */
						/* before the null */
				o->buffer = buffer;
				o->f = f;
				debuglog(yes);
				return EXP_MATCH;
			}
		}
		debuglog(no);
	} else if ((f->size == f->msize) && (f->size > 0)) {
		debuglog("%s? ",e->pat);
		o->e = e;
		o->match = f->umsize;
		o->buffer = f->buffer;
		o->f = f;
		debuglog(yes);
		return(EXP_FULLBUFFER);
	}
	return(EXP_NOMATCH);
d873 1
a873 1
eval_cases(interp,eg,m,o,last_f,last_case,status,masters,mcount,suffix)
d876 1
a876 1
int m;
d879 1
a879 1
struct exp_f **last_f;
d882 1
a882 1
int *masters;
d886 3
a888 3
	int i;
	int em;	/* master of ecase */
	struct ecase *e;
d890 1
a890 1
	if (o->e || status == EXP_TCLERROR || eg->ecd.count == 0) return(status);
d892 21
a912 23
	if (status == EXP_TIMEOUT) {
		for (i=0;i<eg->ecd.count;i++) {
			e = eg->ecd.cases[i];
			if (e->use == PAT_TIMEOUT || e->use == PAT_DEFAULT) {
				o->e = e;
				break;
			}
		}
		return(status);
	} else if (status == EXP_EOF) {
		for (i=0;i<eg->ecd.count;i++) {
			e = eg->ecd.cases[i];
			if (e->use == PAT_EOF || e->use == PAT_DEFAULT) {
				struct exp_fd_list *fdl;

				for (fdl=e->i_list->fd_list; fdl ;fdl=fdl->next) {
					em = fdl->fd;
					if (em == EXP_SPAWN_ID_ANY || em == m) {
						o->e = e;
						return(status);
					}
				}
			}
d914 1
a914 1
		return(status);
d916 2
d919 2
a920 27
	/* the top loops are split from the bottom loop only because I can't */
	/* split'em further. */

	/* The bufferful condition does not prevent a pattern match from */
	/* occurring and vice versa, so it is scanned with patterns */
	for (i=0;i<eg->ecd.count;i++) {
		struct exp_fd_list *fdl;
		int j;

		e = eg->ecd.cases[i];
		if (e->use == PAT_TIMEOUT ||
		    e->use == PAT_DEFAULT ||
		    e->use == PAT_EOF) continue;

		for (fdl = e->i_list->fd_list; fdl; fdl = fdl->next) {
			em = fdl->fd;
			/* if em == EXP_SPAWN_ID_ANY, then user is explicitly asking */
			/* every case to be checked against every master */
			if (em == EXP_SPAWN_ID_ANY) {
				/* test against each spawn_id */
				for (j=0;j<mcount;j++) {
					status = eval_case_string(interp,e,masters[j],o,last_f,last_case,suffix);
					if (status != EXP_NOMATCH) return(status);
				}
			} else {
				/* reject things immediately from wrong spawn_id */
				if (em != m) continue;
d922 29
a950 4
				status = eval_case_string(interp,e,m,o,last_f,last_case,suffix);
				if (status != EXP_NOMATCH) return(status);
			}
		}
d952 2
a953 1
	return(EXP_NOMATCH);
d1020 1
a1020 1
ecmd_remove_fd(interp,ecmd,m,direct)
d1023 1
a1023 1
int m;
d1026 2
a1027 2
	struct exp_i *exp_i, *next;
	struct exp_fd_list **fdl;
d1029 2
a1030 2
	for (exp_i=ecmd->i_list;exp_i;exp_i=next) {
		next = exp_i->next;
d1032 1
a1032 1
		if (!(direct & exp_i->direct)) continue;
d1034 13
a1046 18
		for (fdl = &exp_i->fd_list;*fdl;) {
			if (m == ((*fdl)->fd)) {
				struct exp_fd_list *tmp = *fdl;
				*fdl = (*fdl)->next;
				exp_free_fd_single(tmp);

				/* if last bg ecase, disarm spawn id */
				if ((ecmd->cmdtype == EXP_CMD_BG) && (m != EXP_SPAWN_ID_ANY)) {
					exp_fs[m].bg_ecount--;
					if (exp_fs[m].bg_ecount == 0) {
						exp_disarm_background_filehandler(m);
						exp_fs[m].bg_interp = 0;
					}
				}

				continue;
			}
			fdl = &(*fdl)->next;
d1048 5
d1054 4
a1057 5
		/* if left with no fds (and is direct), get rid of it */
		/* and any dependent ecases */
		if (exp_i->direct == EXP_DIRECT && !exp_i->fd_list) {
			exp_i_remove_with_ecases(interp,ecmd,exp_i);
		}
d1059 1
d1062 1
a1062 1
/* this is called from exp_close to clean up the fd */
d1064 1
a1064 1
exp_ecmd_remove_fd_direct_and_indirect(interp,m)
d1066 1
a1066 1
int m;
d1068 3
a1070 3
	ecmd_remove_fd(interp,&exp_cmds[EXP_CMD_BEFORE],m,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_fd(interp,&exp_cmds[EXP_CMD_AFTER],m,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_fd(interp,&exp_cmds[EXP_CMD_BG],m,EXP_DIRECT|EXP_INDIRECT);
d1073 1
a1073 1
	exp_disarm_background_filehandler_force(m);
d1076 1
a1076 1
/* arm a list of background fd's */
d1078 1
a1078 1
fd_list_arm(interp,fdl)
d1080 1
a1080 1
struct exp_fd_list *fdl;
d1082 8
a1089 10
	/* for each spawn id in list, arm if necessary */
	for (;fdl;fdl=fdl->next) {
		int m = fdl->fd;
		if (m == EXP_SPAWN_ID_ANY) continue;

		if (exp_fs[m].bg_ecount == 0) {
			exp_arm_background_filehandler(m);
			exp_fs[m].bg_interp = interp;
		}
		exp_fs[m].bg_ecount++;
d1091 2
d1097 1
a1097 1
exp_i_uses_fd(exp_i,fd)
d1099 1
a1099 1
int fd;
d1101 1
a1101 1
	struct exp_fd_list *fdp;
d1103 2
a1104 2
	for (fdp = exp_i->fd_list;fdp;fdp=fdp->next) {
		if (fdp->fd == fd) return 1;
a1115 1
/*	if (ec->iwrite) Tcl_AppendElement(interp,"-iwrite");*/
d1118 1
a1118 1
	if (ec->re) Tcl_AppendElement(interp,"-re");
d1121 2
a1122 2
	Tcl_AppendElement(interp,ec->pat);
	Tcl_AppendElement(interp,ec->body?ec->body:"");
d1149 1
a1149 1
		struct exp_fd_list *fdp;
d1152 1
a1152 1
		if (exp_i->fd_list->next)
d1155 1
a1155 1
		for (fdp = exp_i->fd_list;fdp;fdp=fdp->next) {
d1157 1
a1157 1
			sprintf(buf,"%d",fdp->fd);
d1161 1
a1161 1
		if (exp_i->fd_list->next)
d1166 1
a1166 2
#if 0
/* delete ecases based on named -i descriptors */
d1168 1
a1168 1
expect_delete(interp,ecmd,argc,argv)
d1171 2
a1172 2
int argc;
char **argv;
d1174 6
a1179 15
	while (*argv) {
		if (streq(argv[0],"-i") && argv[1]) {
			iflag = argv[1];
			argc-=2; argv+=2;
		} else if (streq(argv[0],"-all")) {
			all = TRUE;
			argc--; argv++;
		} else if (streq(argv[0],"-noindirect")) {
			direct &= ~EXP_INDIRECT;
			argc--; argv++;
		} else {
			exp_error(interp,"usage: -delete [-all | -i spawn_id]\n");
			return TCL_ERROR;
		}
	}
d1181 2
a1182 6
	if (all) {
		/* same logic as at end of regular expect cmd */
		free_ecases(interp,ecmd,0);
		exp_free_i(interp,ecmd->i_list,exp_indirect_update2);
		return TCL_OK;
	}
d1184 6
a1189 6
	if (!iflag) {
		if (0 == exp_update_master(interp,&m,0,0)) {
			return TCL_ERROR;
		}
	} else if (Tcl_GetInt(interp,iflag,&m) != TCL_OK) {
		/* handle as in indirect */
d1191 25
a1215 1
		struct exp_i **old_i;
d1217 6
a1222 17
		for (old_i=&ecmd->i_list;*old_i;) {
			struct exp_i *tmp;

			if ((*old_i)->direct == EXP_DIRECT) continue;
			if (!streq((*old_i)->variable,iflag)) continue;

			ecases_remove_by_expi(interp,ecmd,*old_i);

			/* unlink from middle of list */
			tmp = *old_i;
			*old_i = tmp->next;
			tmp->next = 0;
			exp_free_i(interp,tmp_i,exp_indirect_update2);
		} else {
			old_i = &(*old_i)->next;
		}
		return TCL_OK;
d1224 2
d1227 12
a1238 10
	/* delete ecases of this direct_fd */
	/* unfinish after this ... */
	for (exp_i=ecmd->i_list;exp_i;exp_i=exp_i->next) {
		if (!(direct & exp_i->direct)) continue;
		if (!exp_i_uses_fd(exp_i,m)) continue;

		/* delete each ecase that uses this exp_i */


		ecase_by_exp_i_append(interp,ecmd,exp_i);
d1240 9
d1250 1
a1250 1
	return TCL_OK;
a1251 1
#endif
d1253 2
a1254 1
/* return current setting of the permanent expect_before/after/bg */
d1256 2
a1257 1
expect_info(interp,ecmd,argc,argv)
d1259 2
a1260 3
struct exp_cmd_descriptor *ecmd;
int argc;
char **argv;
d1262 22
a1283 6
	struct exp_i *exp_i;
	int i;
	int direct = EXP_DIRECT|EXP_INDIRECT;
	char *iflag = 0;
	int all = FALSE;	/* report on all fds */
	int m;
d1285 1
a1285 15
	while (*argv) {
		if (streq(argv[0],"-i") && argv[1]) {
			iflag = argv[1];
			argc-=2; argv+=2;
		} else if (streq(argv[0],"-all")) {
			all = TRUE;
			argc--; argv++;
		} else if (streq(argv[0],"-noindirect")) {
			direct &= ~EXP_INDIRECT;
			argc--; argv++;
		} else {
			exp_error(interp,"usage: -info [-all | -i spawn_id]\n");
			return TCL_ERROR;
		}
	}
d1287 4
a1290 3
	if (all) {
		/* avoid printing out -i when redundant */
		struct exp_i *previous = 0;
d1292 65
a1356 8
		for (i=0;i<ecmd->ecd.count;i++) {
			if (previous != ecmd->ecd.cases[i]->i_list) {
				exp_i_append(interp,ecmd->ecd.cases[i]->i_list);
				previous = ecmd->ecd.cases[i]->i_list;
			}
			ecase_append(interp,ecmd->ecd.cases[i]);
		}
		return TCL_OK;
d1358 4
d1363 65
a1427 15
	if (!iflag) {
		if (0 == exp_update_master(interp,&m,0,0)) {
			return TCL_ERROR;
		}
	} else if (Tcl_GetInt(interp,iflag,&m) != TCL_OK) {
		/* handle as in indirect */
		Tcl_ResetResult(interp);
		for (i=0;i<ecmd->ecd.count;i++) {
			if (ecmd->ecd.cases[i]->i_list->direct == EXP_INDIRECT &&
			    streq(ecmd->ecd.cases[i]->i_list->variable,iflag)) {
				ecase_append(interp,ecmd->ecd.cases[i]);
			}
		}
		return TCL_OK;
	}
d1429 13
a1441 6
	/* print ecases of this direct_fd */
	for (exp_i=ecmd->i_list;exp_i;exp_i=exp_i->next) {
		if (!(direct & exp_i->direct)) continue;
		if (!exp_i_uses_fd(exp_i,m)) continue;
		ecase_by_exp_i_append(interp,ecmd,exp_i);
	}
d1443 1
a1443 1
	return TCL_OK;
d1446 4
a1449 8
/* Exp_ExpectGlobalCmd is invoked to process expect_before/after */
/*ARGSUSED*/
int
Exp_ExpectGlobalCmd(clientData, interp, argc, argv)
ClientData clientData;
Tcl_Interp *interp;
int argc;
char **argv;
d1451 41
a1491 5
	int result = TCL_OK;
	struct exp_i *exp_i, **eip;
	struct exp_fd_list *fdl;	/* temp for interating over fd_list */
	struct exp_cmd_descriptor eg;
	int count;
d1493 2
a1494 1
	struct exp_cmd_descriptor *ecmd = (struct exp_cmd_descriptor *) clientData;
d1496 4
a1499 8
	if ((argc == 2) && exp_one_arg_braced(argv[1])) {
		return(exp_eval_with_one_arg(clientData,interp,argv));
	} else if ((argc == 3) && streq(argv[1],"-brace")) {
		char *new_argv[2];
		new_argv[0] = argv[0];
		new_argv[1] = argv[2];
		return(exp_eval_with_one_arg(clientData,interp,new_argv));
	}
d1501 2
a1502 4
	if (argc > 1 && (argv[1][0] == '-')) {
		if (exp_flageq("info",&argv[1][1],4)) {
			return(expect_info(interp,ecmd,argc-2,argv+2));
		} 
d1504 3
d1508 4
a1511 1
	exp_cmd_init(&eg,ecmd->cmdtype,EXP_PERMANENT);
d1513 21
a1533 3
	if (TCL_ERROR == parse_expect_args(interp,&eg,EXP_SPAWN_ID_BAD,
					argc,argv)) {
		return TCL_ERROR;
d1535 3
d1539 9
a1547 4
	/*
	 * visit each NEW direct exp_i looking for spawn ids.
	 * When found, remove them from any OLD exp_i's.
	 */
d1549 1
a1549 15
	/* visit each exp_i */
	for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
		if (exp_i->direct == EXP_INDIRECT) continue;

		/* for each spawn id, remove it from ecases */
		for (fdl=exp_i->fd_list;fdl;fdl=fdl->next) {
			int m = fdl->fd;

			/* validate all input descriptors */
			if (m != EXP_SPAWN_ID_ANY) {
				if (!exp_fd2f(interp,m,1,1,"expect")) {
					result = TCL_ERROR;
					goto cleanup;
				}
			}
d1551 4
a1554 3
			/* remove spawn id from exp_i */
			ecmd_remove_fd(interp,ecmd,m,EXP_DIRECT);
		}
d1556 3
a1558 6
	
	/*
	 * For each indirect variable, release its old ecases and 
	 * clean up the matching spawn ids.
	 * Same logic as in "expect_X delete" command.
	 */
d1560 14
a1573 2
	for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
		struct exp_i **old_i;
d1575 3
a1577 1
		if (exp_i->direct == EXP_DIRECT) continue;
d1579 2
a1580 2
		for (old_i = &ecmd->i_list;*old_i;) {
			struct exp_i *tmp;
d1582 1
a1582 5
			if (((*old_i)->direct == EXP_DIRECT) ||
			    (!streq((*old_i)->variable,exp_i->variable))) {
				old_i = &(*old_i)->next;
				continue;
			}
d1584 5
a1588 24
			ecases_remove_by_expi(interp,ecmd,*old_i);

			/* unlink from middle of list */
			tmp = *old_i;
			*old_i = tmp->next;
			tmp->next = 0;
			exp_free_i(interp,tmp,exp_indirect_update2);
		}

		/* if new one has ecases, update it */
		if (exp_i->ecount) {
			char *msg = exp_indirect_update1(interp,ecmd,exp_i);
			if (msg) {
				/* unusual way of handling error return */
				/* because of Tcl's variable tracing */
				strcpy(interp->result,msg);
				result = TCL_ERROR;
				goto indirect_update_abort;
			}
		}
	}
	/* empty i_lists have to be removed from global eg.i_list */
	/* before returning, even if during error */
 indirect_update_abort:
d1590 6
a1595 4
	/*
	 * New exp_i's that have 0 ecases indicate fd/vars to be deleted.
	 * Now that the deletions have been done, discard the new exp_i's.
	 */
d1597 2
a1598 2
	for (exp_i=eg.i_list;exp_i;) {
		struct exp_i *next = exp_i->next;
d1600 9
a1608 2
		if (exp_i->ecount == 0) {
			exp_i_remove(interp,&eg.i_list,exp_i);
d1610 2
a1611 1
		exp_i = next;
d1613 4
a1616 1
	if (result == TCL_ERROR) goto cleanup;
d1618 11
a1628 3
	/*
	 * arm all new bg direct fds
	 */
d1630 2
a1631 125
	if (ecmd->cmdtype == EXP_CMD_BG) {
		for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
			if (exp_i->direct == EXP_DIRECT) {
				fd_list_arm(interp,exp_i->fd_list);
			}
		}
	}

	/*
	 * now that old ecases are gone, add new ecases and exp_i's (both
	 * direct and indirect).
	 */

	/* append ecases */

	count = ecmd->ecd.count + eg.ecd.count;
	if (eg.ecd.count) {
		int start_index; /* where to add new ecases in old list */

		if (ecmd->ecd.count) {
			/* append to end */
			ecmd->ecd.cases = (struct ecase **)ckrealloc((char *)ecmd->ecd.cases, count * sizeof(struct ecase *));
			start_index = ecmd->ecd.count;
		} else {
			/* append to beginning */
			ecmd->ecd.cases = (struct ecase **)ckalloc(eg.ecd.count * sizeof(struct ecase *));
			start_index = 0;
		}
		memcpy(&ecmd->ecd.cases[start_index],eg.ecd.cases,
					eg.ecd.count*sizeof(struct ecase *));
		ecmd->ecd.count = count;
	}

	/* append exp_i's */
	for (eip = &ecmd->i_list;*eip;eip = &(*eip)->next) {
		/* empty loop to get to end of list */
	}
	/* *exp_i now points to end of list */

	*eip = eg.i_list;	/* connect new list to end of current list */

 cleanup:
	if (result == TCL_ERROR) {
		/* in event of error, free any unreferenced ecases */
		/* but first, split up i_list so that exp_i's aren't */
		/* freed twice */

		for (exp_i=eg.i_list;exp_i;) {
			struct exp_i *next = exp_i->next;
			exp_i->next = 0;
			exp_i = next;
		}
		free_ecases(interp,&eg,1);
	} else {
		if (eg.ecd.cases) ckfree((char *)eg.ecd.cases);
	}

	if (ecmd->cmdtype == EXP_CMD_BG) {
		exp_background_filehandlers_run_all();
	}

	return(result);
}

/* adjusts file according to user's size request */
void
exp_adjust(f)
struct exp_f *f;
{
	int new_msize;

	/* get the latest buffer size.  Double the user input for */
	/* two reasons.  1) Need twice the space in case the match */
	/* straddles two bufferfuls, 2) easier to hack the division */
	/* by two when shifting the buffers later on.  The extra  */
	/* byte in the malloc's is just space for a null we can slam on the */
	/* end.  It makes the logic easier later.  The -1 here is so that */
	/* requests actually come out to even/word boundaries (if user */
	/* gives "reasonable" requests) */
	new_msize = f->umsize*2 - 1;
	if (new_msize != f->msize) {
		if (!f->buffer) {
			/* allocate buffer space for 1st time */
			f->buffer = ckalloc((unsigned)new_msize+1);
			f->lower = ckalloc((unsigned)new_msize+1);
			f->size = 0;
		} else {
			/* buffer already exists - resize */

			/* if truncated, forget about some data */
			if (f->size > new_msize) {
				/* copy end of buffer down */
				memmove(f->buffer,f->buffer+(f->size - new_msize),new_msize);
				memmove(f->lower, f->lower +(f->size - new_msize),new_msize);
				f->size = new_msize;

				f->key = expect_key++;
			}

			f->buffer = ckrealloc(f->buffer,new_msize+1);
			f->lower = ckrealloc(f->lower,new_msize+1);
		}
		f->msize = new_msize;
		f->buffer[f->size] = '\0';
		f->lower[f->size] = '\0';
	}
}


/*

 expect_read() does the logical equivalent of a read() for the
expect command.  This includes figuring out which descriptor should
be read from.

The result of the read() is left in a spawn_id's buffer rather than
explicitly passing it back.  Note that if someone else has modified a
buffer either before or while this expect is running (i.e., if we or
some event has called Tcl_Eval which did another expect/interact),
expect_read will also call this a successful read (for the purposes if
needing to pattern match against it).

*/
/* if it returns a negative number, it corresponds to a EXP_XXX result */
/* if it returns a non-negative number, it means there is data */
d1634 1
a1634 1
expect_read(interp,masters,masters_max,m,timeout,key)
d1636 3
a1638 7
int *masters;			/* If 0, then m is already known and set. */
int masters_max;		/* If *masters is not-zero, then masters_max */
				/* is the number of masters. */
				/* If *masters is zero, then masters_max */
				/* is used as the mask (ready vs except). */
				/* Crude but simplifies the interface. */
int *m;				/* Out variable to leave new master. */
d1642 1
a1642 49
	struct exp_f *f;
	int cc;
	int write_count;
	int tcl_set_flags;	/* if we have to discard chars, this tells */
				/* whether to show user locally or globally */

	if (masters == 0) {
		/* we already know the master, just find out what happened */
		cc = exp_get_next_event_info(interp,*m,masters_max);
		tcl_set_flags = TCL_GLOBAL_ONLY;
	} else {
		cc = exp_get_next_event(interp,masters,masters_max,m,timeout,key);
		tcl_set_flags = 0;
	}

	if (cc == EXP_DATA_NEW) {
		/* try to read it */

		cc = exp_i_read(interp,*m,timeout,tcl_set_flags);

		/* the meaning of 0 from i_read means eof.  Muck with it a */
		/* little, so that from now on it means "no new data arrived */
		/* but it should be looked at again anyway". */
		if (cc == 0) {
			cc = EXP_EOF;
		} else if (cc > 0) {
			f = exp_fs + *m;
			f->buffer[f->size += cc] = '\0';

			/* strip parity if requested */
			if (f->parity == 0) {
				/* do it from end backwards */
				char *p = f->buffer + f->size - 1;
				int count = cc;
				while (count--) {
					*p-- &= 0x7f;
				}
			}
		} /* else {
			assert(cc < 0) in which case some sort of error was
			encountered such as an interrupt with that forced an
			error return
		} */
	} else if (cc == EXP_DATA_OLD) {
		f = exp_fs + *m;
		cc = 0;
	} else if (cc == EXP_RECONFIGURE) {
		return EXP_RECONFIGURE;
	}
d1644 90
a1733 61
	if (cc == EXP_ABEOF) {	/* abnormal EOF */
		/* On many systems, ptys produce EIO upon EOF - sigh */
		if (i_read_errno == EIO) {
			/* Sun, Cray, BSD, and others */
			cc = EXP_EOF;
		} else if (i_read_errno == EINVAL) {
			/* Solaris 2.4 occasionally returns this */
			cc = EXP_EOF;
		} else {
			if (i_read_errno == EBADF) {
				exp_error(interp,"bad spawn_id (process died earlier?)");
			} else {
				exp_error(interp,"i_read(spawn_id=%d): %s",*m,
					Tcl_PosixError(interp));
				exp_close(interp,*m);
			}
			return(EXP_TCLERROR);
			/* was goto error; */
		}
	}

	/* EOF, TIMEOUT, and ERROR return here */
	/* In such cases, there is no need to update screen since, if there */
	/* was prior data read, it would have been sent to the screen when */
	/* it was read. */
	if (cc < 0) return (cc);

	/* update display */

	if (f->size) write_count = f->size - f->printed;
	else write_count = 0;

	if (write_count) {
		if (logfile_all || (loguser && logfile)) {
			fwrite(f->buffer + f->printed,1,write_count,logfile);
		}
		/* don't write to user if they're seeing it already, */
		/* that is, typing it! */
		if (loguser && !exp_is_stdinfd(*m) && !exp_is_devttyfd(*m))
			fwrite(f->buffer + f->printed,
					1,write_count,stdout);
		if (debugfile) fwrite(f->buffer + f->printed,
					1,write_count,debugfile);

		/* remove nulls from input, since there is no way */
		/* for Tcl to deal with such strings.  Doing it here */
		/* lets them be sent to the screen, just in case */
		/* they are involved in formatting operations */
		if (f->rm_nulls) {
			f->size -= rm_nulls(f->buffer + f->printed,write_count);
		}
		f->buffer[f->size] = '\0';

		/* copy to lowercase buffer */
		exp_lowmemcpy(f->lower+f->printed,
			      f->buffer+f->printed,
					1 + f->size - f->printed);

		f->printed = f->size; /* count'm even if not logging */
	}
	return(cc);
d1739 1
a1739 1
exp_buffer_shuffle(interp,f,save_flags,array_name,caller_name)
d1741 1
a1741 1
struct exp_f *f;
d1746 65
a1810 3
	char spawn_id[10];	/* enough for a %d */
	char match_char;	/* place to hold char temporarily */
				/* uprooted by a NULL */
d1812 2
a1813 2
	int first_half = f->size/2;
	int second_half = f->size - first_half;
d1815 1
a1815 3
	/*
	 * allow user to see data we are discarding
	 */
d1817 2
a1818 21
	sprintf(spawn_id,"%d",f-exp_fs);
	debuglog("%s: set %s(spawn_id) \"%s\"\r\n",
		 caller_name,array_name,dprintify(spawn_id));
	Tcl_SetVar2(interp,array_name,"spawn_id",spawn_id,save_flags);

	/* temporarily null-terminate buffer in middle */
	match_char = f->buffer[first_half];
	f->buffer[first_half] = 0;

	debuglog("%s: set %s(buffer) \"%s\"\r\n",
		 caller_name,array_name,dprintify(f->buffer));
	Tcl_SetVar2(interp,array_name,"buffer",f->buffer,save_flags);

	/* remove middle-null-terminator */
	f->buffer[first_half] = match_char;

	memcpy(f->buffer,f->buffer+first_half,second_half);
	memcpy(f->lower, f->lower +first_half,second_half);
	f->size = second_half;
	f->printed -= first_half;
	if (f->printed < 0) f->printed = 0;
a1853 58
/* returns # of chars read or (non-positive) error of form EXP_XXX */
/* returns 0 for end of file */
/* If timeout is non-zero, set an alarm before doing the read, else assume */
/* the read will complete immediately. */
/*ARGSUSED*/
static int
exp_i_read(interp,m,timeout,save_flags)
Tcl_Interp *interp;
int m;
int timeout;
int save_flags;
{
	struct exp_f *f;
	int cc = EXP_TIMEOUT;

	f = exp_fs + m;
	if (f->size == f->msize) 
		exp_buffer_shuffle(interp,f,save_flags,EXPECT_OUT,"expect");

#ifdef SIMPLE_EVENT
 restart:

	alarm_fired = FALSE;

	if (timeout > -1) {
		signal(SIGALRM,sigalarm_handler);
		alarm((timeout > 0)?timeout:1);
	}
#endif

	cc = read(m,f->buffer+f->size, f->msize-f->size);
	i_read_errno = errno;

#ifdef SIMPLE_EVENT
	alarm(0);

	if (cc == -1) {
		/* check if alarm went off */
		if (i_read_errno == EINTR) {
			if (alarm_fired) {
				return EXP_TIMEOUT;
			} else {
				if (Tcl_AsyncReady()) {
					int rc = Tcl_AsyncInvoke(interp,TCL_OK);
					if (rc != TCL_OK) return(exp_tcl2_returnvalue(rc));
				}
				if (!f->valid) {
					exp_error(interp,"spawn_id %d no longer valid",f-exp_fs);
					return EXP_TCLERROR;
				}
				goto restart;
			}
		}
	}
#endif
	return(cc);
}

d1864 1
a1864 1
	char *val;
d1866 3
a1868 3
	if (NULL != (val = Tcl_GetVar(interp,var,0 /* local */)))
		return(val);
	return(Tcl_GetVar(interp,var,TCL_GLOBAL_ONLY));
d1875 2
a1876 2
	static int timeout = INIT_EXPECT_TIMEOUT;
 	char *t;
d1878 4
a1881 4
	if (NULL != (t = exp_get_var(interp,EXPECT_TIMEOUT))) {
		timeout = atoi(t);
	}
	return(timeout);
d1887 1
a1887 1
update_expect_fds(i_list,fd_union)
d1889 1
a1889 1
struct exp_fd_list **fd_union;
d1891 1
a1891 12
	struct exp_i *p;

	/* for each i_list in an expect statement ... */
	for (p=i_list;p;p=p->next) {
		struct exp_fd_list *fdl;

		/* for each fd in the i_list */
		for (fdl=p->fd_list;fdl;fdl=fdl->next) {
			struct exp_fd_list *tmpfdl;
			struct exp_fd_list *u;

			if (fdl->fd == EXP_SPAWN_ID_ANY) continue;
d1893 20
a1912 10
			/* check this one against all so far */
			for (u = *fd_union;u;u=u->next) {
				if (fdl->fd == u->fd) goto found;
			}
			/* if not found, link in as head of list */
			tmpfdl = exp_new_fd(fdl->fd);
			tmpfdl->next = *fd_union;
			*fd_union = tmpfdl;
		found:;
		}
d1914 2
a1915 1
	return TCL_OK;
d1950 1
a1950 1
	exp_background_filehandlers_run_all();
d1961 1
a1961 1
	struct exp_fd_list *fdl;	/* temp for interating over fd_list */
d1964 1
a1964 1
	 * disarm any fd's that lose all their ecases
d1969 2
a1970 2
		for (fdl=exp_i->fd_list;fdl;fdl=fdl->next) {
			int m = fdl->fd;
d1972 1
a1972 1
			if (m == EXP_SPAWN_ID_ANY) continue;
d1978 1
a1978 1
			if (!exp_fd2f(interp,fdl->fd,1,0,"")) continue;
d1983 2
a1984 2
			if (exp_fs[m].bg_ecount > 0) {
				exp_fs[m].bg_ecount--;
d1986 3
a1988 3
			if (exp_fs[m].bg_ecount == 0) {
				exp_disarm_background_filehandler(m);
				exp_fs[m].bg_interp = 0;
d2003 12
a2014 11
	for (fdl=exp_i->fd_list;fdl;fdl=fdl->next) {
		/* validate all input descriptors */
		if (fdl->fd == EXP_SPAWN_ID_ANY) continue;

		if (!exp_fd2f(interp,fdl->fd,1,1,
				exp_cmdtype_printable(ecmd->cmdtype))) {
			static char msg[200];
			sprintf(msg,"%s from indirect variable (%s)",
				interp->result,exp_i->variable);
			return msg;
		}
d2019 1
a2019 1
		fd_list_arm(interp,exp_i->fd_list);
d2025 42
a2066 5
void
exp_background_filehandlers_run_all()
{
	int m;
	struct exp_f *f;
d2068 32
a2099 8
	/* kick off any that already have input waiting */
	for (m=0;m<=exp_fd_max;m++) {
		f = exp_fs + m;
		if (!f->valid) continue;

		/* is bg_interp the best way to check if armed? */
		if (f->bg_interp && (f->size > 0)) {
			exp_background_filehandler((ClientData)f->fd_ptr,0/*ignored*/);
d2101 86
d2188 3
d2196 1
a2196 1
exp_background_filehandler(clientData,mask)
d2200 3
a2202 4
	int m;

	Tcl_Interp *interp;
	int cc;			/* number of chars returned in a single read */
d2204 2
a2205 6
	struct exp_f *f;		/* file associated with master */

	int i;			/* trusty temporary */

	struct eval_out eo;	/* final case of interest */
	struct exp_f *last_f;	/* for differentiating when multiple f's */
d2207 1
a2207 1
	int last_case;		/* as above but for case */
d2209 18
a2226 17
	/* restore our environment */
	m = *(int *)clientData;
	f = exp_fs + m;
	interp = f->bg_interp;

	/* temporarily prevent this handler from being invoked again */
	exp_block_background_filehandler(m);

	/* if mask == 0, then we've been called because the patterns changed */
	/* not because the waiting data has changed, so don't actually do */
	/* any I/O */

	if (mask == 0) {
		cc = 0;
	} else {
		cc = expect_read(interp,(int *)0,mask,&m,EXP_TIME_INFINITY,0);
	}
d2229 33
a2261 32
	eo.e = 0;		/* no final case yet */
	eo.f = 0;		/* no final file selected yet */
	eo.match = 0;		/* nothing matched yet */

	/* force redisplay of buffer when debugging */
	last_f = 0;

	if (cc == EXP_EOF) {
		/* do nothing */
	} else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
		goto finish;
		/* if we were going to do this right, we should */
		/* differentiate between things like HP ioctl-open-traps */
		/* that fall out here and should rightfully be ignored */
		/* and real errors that should be reported.  Come to */
		/* think of it, the only errors will come from HP */
		/* ioctl handshake botches anyway. */
	} else {
		/* normal case, got data */
		/* new data if cc > 0, same old data if cc == 0 */

		/* below here, cc as general status */
		cc = EXP_NOMATCH;
	}

	cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
			m,&eo,&last_f,&last_case,cc,&m,1,"_background");
	cc = eval_cases(interp,&exp_cmds[EXP_CMD_BG],
			m,&eo,&last_f,&last_case,cc,&m,1,"_background");
	cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
			m,&eo,&last_f,&last_case,cc,&m,1,"_background");
	if (cc == EXP_TCLERROR) {
d2265 14
a2278 14
	}
	/* special eof code that cannot be done in eval_cases */
	/* or above, because it would then be executed several times */
	if (cc == EXP_EOF) {
		eo.f = exp_fs + m;
		eo.match = eo.f->size;
		eo.buffer = eo.f->buffer;
		debuglog("expect_background: read eof\r\n");
		goto matched;
	}
	if (!eo.e) {
		/* if we get here, there must not have been a match */
		goto finish;
	}
d2281 1
a2281 166
#define out(i,val)  debuglog("expect_background: set %s(%s) \"%s\"\r\n",EXPECT_OUT,i, \
						dprintify(val)); \
		    Tcl_SetVar2(interp,EXPECT_OUT,i,val,TCL_GLOBAL_ONLY);
	{
/*		int iwrite = FALSE;*/	/* write spawn_id? */
		char *body = 0;
		char *buffer;	/* pointer to normal or lowercased data */
		struct ecase *e = 0;	/* points to current ecase */
		int match = -1;		/* characters matched */
		char match_char;	/* place to hold char temporarily */
					/* uprooted by a NULL */
		char *eof_body = 0;

		if (eo.e) {
			e = eo.e;
			body = e->body;
/*			iwrite = e->iwrite;*/
			if (cc != EXP_TIMEOUT) {
				f = eo.f;
				match = eo.match;
				buffer = eo.buffer;
			}
#if 0
			if (e->timestamp) {
				char value[20];

				time(&current_time);
				elapsed_time = current_time - start_time;
				elapsed_time_total = current_time - start_time_total;
				sprintf(value,"%d",elapsed_time);
				out("seconds",value);
				sprintf(value,"%d",elapsed_time_total);
				out("seconds_total",value);
				/* deprecated */
				exp_timestamp(interp,&current_time,EXPECT_OUT);
			}
#endif
		} else if (cc == EXP_EOF) {
			/* read an eof but no user-supplied case */
			f = eo.f;
			match = eo.match;
			buffer = eo.buffer;
		}			

		if (match >= 0) {
			char name[20], value[20];

			if (e && e->use == PAT_RE) {
				regexp *re = e->re;

				for (i=0;i<NSUBEXP;i++) {
					int offset;

					if (re->startp[i] == 0) continue;

					if (e->indices) {
					  /* start index */
					  sprintf(name,"%d,start",i);
					  offset = re->startp[i]-buffer;
					  sprintf(value,"%d",offset);
					  out(name,value);

					  /* end index */
					  sprintf(name,"%d,end",i);
					  sprintf(value,"%d",
						re->endp[i]-buffer-1);
					  out(name,value);
					}

					/* string itself */
					sprintf(name,"%d,string",i);

					/* temporarily null-terminate in */
					/* middle */
					match_char = *re->endp[i];
					*re->endp[i] = 0;
					out(name,re->startp[i]);
					*re->endp[i] = match_char;
				}
				/* redefine length of string that */
				/* matched for later extraction */
				match = re->endp[0]-buffer;
			} else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
				char *str;

				if (e->indices) {
				  /* start index */
				  sprintf(value,"%d",e->simple_start);
				  out("0,start",value);

				  /* end index */
				  sprintf(value,"%d",e->simple_start + match - 1);
				  out("0,end",value);
				}

				/* string itself */
				str = f->buffer + e->simple_start;
				/* temporarily null-terminate in middle */
				match_char = str[match];
				str[match] = 0;
				out("0,string",str);
				str[match] = match_char;

				/* redefine length of string that */
				/* matched for later extraction */
				match += e->simple_start;
			} else if (e && e->use == PAT_NULL && e->indices) {
				/* start index */
				sprintf(value,"%d",match-1);
				out("0,start",value);
				/* end index */
				sprintf(value,"%d",match-1);
				out("0,end",value);
			} else if (e && e->use == PAT_FULLBUFFER) {
				debuglog("expect_background: full buffer\r\n");
			}
		}

		/* this is broken out of (match > 0) (above) since it can */
		/* that an EOF occurred with match == 0 */
		if (eo.f) {
			char spawn_id[10];	/* enough for a %d */

/*			if (iwrite) {*/
				sprintf(spawn_id,"%d",f-exp_fs);
				out("spawn_id",spawn_id);
/*			}*/

			/* save buf[0..match] */
			/* temporarily null-terminate string in middle */
			match_char = f->buffer[match];
			f->buffer[match] = 0;
			out("buffer",f->buffer);
			/* remove middle-null-terminator */
			f->buffer[match] = match_char;

			/* "!e" means no case matched - transfer by default */
			if (!e || e->transfer) {
				/* delete matched chars from input buffer */
				f->size -= match;
				f->printed -= match;
				if (f->size != 0) {
				   memmove(f->buffer,f->buffer+match,f->size);
				   memmove(f->lower,f->lower+match,f->size);
				}
				f->buffer[f->size] = '\0';
				f->lower[f->size] = '\0';
			}

			if (cc == EXP_EOF) {
				/* exp_close() deletes all background bodies */
				/* so save eof body temporarily */
				if (body) {
					eof_body = ckalloc(strlen(body)+1);
					strcpy(eof_body,body);
					body = eof_body;
				}

				exp_close(interp,f - exp_fs);
			}

		}

		if (body) {
			int result = Tcl_GlobalEval(interp,body);
			if (result != TCL_OK) Tcl_BackgroundError(interp);
d2283 15
a2297 14
			if (eof_body) ckfree(eof_body);
		}


		/*
		 * Event handler will not call us back if there is more input
		 * pending but it has already arrived.  bg_status will be
		 * "blocked" only if armed.
		 */
		if (exp_fs[m].valid && (exp_fs[m].bg_status == blocked)
		 && (f->size > 0)) {
			cc = f->size;
			goto do_more_data;
		}
d2299 1
d2301 3
a2303 3
	/* fd could have gone away, so check before using */
	if (exp_fs[m].valid)
		exp_unblock_background_filehandler(m);
a2304 1
#undef out
d2308 1
a2308 1
Exp_ExpectCmd(clientData, interp, argc, argv)
d2311 2
a2312 2
int argc;
char **argv;
d2314 1
a2314 1
	int cc;			/* number of chars returned in a single read */
d2316 17
a2332 21
	int m;			/* before doing an actual read, attempt */
				/* to match upon any spawn_id */
	struct exp_f *f;		/* file associated with master */

	int i;			/* trusty temporary */
	struct exp_cmd_descriptor eg;
	struct exp_fd_list *fd_list;	/* list of masters to watch */
	struct exp_fd_list *fdl;	/* temp for interating over fd_list */
	int *masters;		/* array of masters to watch */
	int mcount;		/* number of masters to watch */

	struct eval_out eo;	/* final case of interest */

	int result;		/* Tcl result */

	time_t start_time_total;/* time at beginning of this procedure */
	time_t start_time = 0;	/* time when restart label hit */
	time_t current_time = 0;/* current time (when we last looked)*/
	time_t end_time;	/* future time at which to give up */
	time_t elapsed_time_total;/* time from now to match/fail/timeout */
	time_t elapsed_time;	/* time from restart to (ditto) */
d2334 1
a2334 1
	struct exp_f *last_f;	/* for differentiating when multiple f's */
d2336 31
a2366 2
	int last_case;		/* as above but for case */
	int first_time = 1;	/* if not "restarted" */
d2368 6
a2373 29
	int key;		/* identify this expect command instance */
	int configure_count;	/* monitor exp_configure_count */

	int timeout;		/* seconds */
	int remtime;		/* remaining time in timeout */
	int reset_timer;	/* should timer be reset after continue? */

	if ((argc == 2) && exp_one_arg_braced(argv[1])) {
		return(exp_eval_with_one_arg(clientData,interp,argv));
	} else if ((argc == 3) && streq(argv[1],"-brace")) {
		char *new_argv[2];
		new_argv[0] = argv[0];
		new_argv[1] = argv[2];
		return(exp_eval_with_one_arg(clientData,interp,new_argv));
	}

	time(&start_time_total);
	start_time = start_time_total;
	reset_timer = TRUE;

	/* make arg list for processing cases */
	/* do it dynamically, since expect can be called recursively */

	exp_cmd_init(&eg,EXP_CMD_FG,EXP_TEMPORARY);
	fd_list = 0;
	masters = 0;
	if (TCL_ERROR == parse_expect_args(interp,&eg,
					*(int *)clientData,argc,argv))
		return TCL_ERROR;
d2376 1
a2376 2
	/* validate all descriptors */
	/* and flatten fds into array */
d2378 59
a2436 5
	if ((TCL_ERROR == update_expect_fds(exp_cmds[EXP_CMD_BEFORE].i_list,&fd_list))
	 || (TCL_ERROR == update_expect_fds(exp_cmds[EXP_CMD_AFTER].i_list, &fd_list))
	 || (TCL_ERROR == update_expect_fds(eg.i_list,&fd_list))) {
		result = TCL_ERROR;
		goto cleanup;
d2438 1
d2440 2
a2441 2
	/* declare ourselves "in sync" with external view of close/indirect */
	configure_count = exp_configure_count;
d2443 5
a2447 9
	/* count and validate fd_list */
	mcount = 0;
	for (fdl=fd_list;fdl;fdl=fdl->next) {
		mcount++;
		/* validate all input descriptors */
		if (!exp_fd2f(interp,fdl->fd,1,1,"expect")) {
			result = TCL_ERROR;
			goto cleanup;
		}
d2450 15
a2464 5
	/* make into an array */
	masters = (int *)ckalloc(mcount * sizeof(int));
	for (fdl=fd_list,i=0;fdl;fdl=fdl->next,i++) {
		masters[i] = fdl->fd;
	}
d2466 2
a2467 9
     restart:
	if (first_time) first_time = 0;
	else time(&start_time);

	if (eg.timeout_specified_by_flag) {
		timeout = eg.timeout;
	} else {
		/* get the latest timeout */
		timeout = get_timeout(interp);
d2470 17
a2486 4
	key = expect_key++;

	result = TCL_OK;
	last_f = 0;
d2488 1
a2488 1
	/* end of restart code */
d2490 2
a2491 3
	eo.e = 0;		/* no final case yet */
	eo.f = 0;		/* no final file selected yet */
	eo.match = 0;		/* nothing matched yet */
a2492 1
	/* timeout code is a little tricky, be very careful changing it */
d2494 2
a2495 7
		/* if exp_continue -continue_timer, do not update end_time */
		if (reset_timer) {
			time(&current_time);
			end_time = current_time + timeout;
		} else {
			reset_timer = TRUE;
		}
d2497 1
d2499 1
a2499 62
	/* remtime and current_time updated at bottom of loop */
	remtime = timeout;

	for (;;) {
		if ((timeout != EXP_TIME_INFINITY) && (remtime < 0)) {
			cc = EXP_TIMEOUT;
		} else {
			cc = expect_read(interp,masters,mcount,&m,remtime,key);
		}

		/*SUPPRESS 530*/
		if (cc == EXP_EOF) {
			/* do nothing */
		} else if (cc == EXP_TIMEOUT) {
			debuglog("expect: timed out\r\n");
		} else if (cc == EXP_RECONFIGURE) {
			reset_timer = FALSE;
			goto restart_with_update;
		} else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
			goto error;
		} else {
			/* new data if cc > 0, same old data if cc == 0 */

			f = exp_fs + m;

			/* below here, cc as general status */
			cc = EXP_NOMATCH;

			/* force redisplay of buffer when debugging */
			last_f = 0;
		}

		cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
			m,&eo,&last_f,&last_case,cc,masters,mcount,"");
		cc = eval_cases(interp,&eg,
			m,&eo,&last_f,&last_case,cc,masters,mcount,"");
		cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
			m,&eo,&last_f,&last_case,cc,masters,mcount,"");
		if (cc == EXP_TCLERROR) goto error;
		/* special eof code that cannot be done in eval_cases */
		/* or above, because it would then be executed several times */
		if (cc == EXP_EOF) {
			eo.f = exp_fs + m;
			eo.match = eo.f->size;
			eo.buffer = eo.f->buffer;
			debuglog("expect: read eof\r\n");
			break;
		} else if (cc == EXP_TIMEOUT) break;
		/* break if timeout or eof and failed to find a case for it */

		if (eo.e) break;

		/* no match was made with current data, force a read */
		f->force_read = TRUE;

		if (timeout != EXP_TIME_INFINITY) {
			time(&current_time);
			remtime = end_time - current_time;
		}
	}

	goto done;
d2502 1
a2502 1
	result = exp_2tcl_returnvalue(cc);
d2504 3
a2506 169
#define out(i,val)  debuglog("expect: set %s(%s) \"%s\"\r\n",EXPECT_OUT,i, \
						dprintify(val)); \
		    Tcl_SetVar2(interp,EXPECT_OUT,i,val,0);

	if (result != TCL_ERROR) {
/*		int iwrite = FALSE;*/	/* write spawn_id? */
		char *body = 0;
		char *buffer;	/* pointer to normal or lowercased data */
		struct ecase *e = 0;	/* points to current ecase */
		int match = -1;		/* characters matched */
		char match_char;	/* place to hold char temporarily */
					/* uprooted by a NULL */
		char *eof_body = 0;

		if (eo.e) {
			e = eo.e;
			body = e->body;
/*			iwrite = e->iwrite;*/
			if (cc != EXP_TIMEOUT) {
				f = eo.f;
				match = eo.match;
				buffer = eo.buffer;
			}
			if (e->timestamp) {
				char value[20];

				time(&current_time);
				elapsed_time = current_time - start_time;
				elapsed_time_total = current_time - start_time_total;
				sprintf(value,"%d",elapsed_time);
				out("seconds",value);
				sprintf(value,"%d",elapsed_time_total);
				out("seconds_total",value);

				/* deprecated */
				exp_timestamp(interp,&current_time,EXPECT_OUT);
			}
		} else if (cc == EXP_EOF) {
			/* read an eof but no user-supplied case */
			f = eo.f;
			match = eo.match;
			buffer = eo.buffer;
		}			

		if (match >= 0) {
			char name[20], value[20];

			if (e && e->use == PAT_RE) {
				regexp *re = e->re;

				for (i=0;i<NSUBEXP;i++) {
					int offset;

					if (re->startp[i] == 0) continue;

					if (e->indices) {
					  /* start index */
					  sprintf(name,"%d,start",i);
					  offset = re->startp[i]-buffer;
					  sprintf(value,"%d",offset);
					  out(name,value);

					  /* end index */
					  sprintf(name,"%d,end",i);
					  sprintf(value,"%d",
						re->endp[i]-buffer-1);
					  out(name,value);
					}

					/* string itself */
					sprintf(name,"%d,string",i);

					/* temporarily null-terminate in */
					/* middle */
					match_char = *re->endp[i];
					*re->endp[i] = 0;
					out(name,re->startp[i]);
					*re->endp[i] = match_char;
				}
				/* redefine length of string that */
				/* matched for later extraction */
				match = re->endp[0]-buffer;
			} else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
				char *str;

				if (e->indices) {
				  /* start index */
				  sprintf(value,"%d",e->simple_start);
				  out("0,start",value);

				  /* end index */
				  sprintf(value,"%d",e->simple_start + match - 1);
				  out("0,end",value);
				}

				/* string itself */
				str = f->buffer + e->simple_start;
				/* temporarily null-terminate in middle */
				match_char = str[match];
				str[match] = 0;
				out("0,string",str);
				str[match] = match_char;

				/* redefine length of string that */
				/* matched for later extraction */
				match += e->simple_start;
			} else if (e && e->use == PAT_NULL && e->indices) {
				/* start index */
				sprintf(value,"%d",match-1);
				out("0,start",value);
				/* end index */
				sprintf(value,"%d",match-1);
				out("0,end",value);
			} else if (e && e->use == PAT_FULLBUFFER) {
				debuglog("expect: full buffer\r\n");
			}
		}

		/* this is broken out of (match > 0) (above) since it can */
		/* that an EOF occurred with match == 0 */
		if (eo.f) {
			char spawn_id[10];	/* enough for a %d */

/*			if (iwrite) {*/
				sprintf(spawn_id,"%d",f-exp_fs);
				out("spawn_id",spawn_id);
/*			}*/

			/* save buf[0..match] */
			/* temporarily null-terminate string in middle */
			match_char = f->buffer[match];
			f->buffer[match] = 0;
			out("buffer",f->buffer);
			/* remove middle-null-terminator */
			f->buffer[match] = match_char;

			/* "!e" means no case matched - transfer by default */
			if (!e || e->transfer) {
				/* delete matched chars from input buffer */
				f->size -= match;
				f->printed -= match;
				if (f->size != 0) {
				   memmove(f->buffer,f->buffer+match,f->size);
				   memmove(f->lower,f->lower+match,f->size);
				}
				f->buffer[f->size] = '\0';
				f->lower[f->size] = '\0';
			}

			if (cc == EXP_EOF) {
				/* exp_close() deletes all background bodies */
				/* so save eof body temporarily */
				if (body) {
					eof_body = ckalloc(strlen(body)+1);
					strcpy(eof_body,body);
					body = eof_body;
				}

				exp_close(interp,f - exp_fs);
			}

		}

		if (body) {
			result = Tcl_Eval(interp,body);

			if (eof_body) ckfree(eof_body);
		}
	}
d2509 23
a2531 33
	if (result == EXP_CONTINUE_TIMER) {
		reset_timer = FALSE;
		result = EXP_CONTINUE;
	}

	if ((result == EXP_CONTINUE)
	     && (configure_count == exp_configure_count)) {
		debuglog("expect: continuing expect\r\n");
		goto restart;
	}

	if (fd_list) {
		exp_free_fd(fd_list);
		fd_list = 0;
	}
	if (masters) {
		ckfree((char *)masters);
		masters = 0;
	}

	if (result == EXP_CONTINUE) {
		debuglog("expect: continuing expect after update\r\n");
		goto restart_with_update;
	}

	free_ecases(interp,&eg,0);	/* requires i_lists to be avail */
	exp_free_i(interp,eg.i_list,exp_indirect_update2);

	return(result);
}
#undef out

/* beginning of deprecated code */
d2533 2
a2534 9
#define out(elt)		Tcl_SetVar2(interp,array,elt,ascii,0);
void
exp_timestamp(interp,timeval,array)
Tcl_Interp *interp;
time_t *timeval;
char *array;
{
	struct tm *tm;
	char *ascii;
d2536 1
a2536 27
	tm = localtime(timeval);	/* split */
	ascii = asctime(tm);		/* print */
	ascii[24] = '\0';		/* zap trailing \n */

	out("timestamp");

	sprintf(ascii,"%ld",*timeval);
	out("epoch");

	sprintf(ascii,"%d",tm->tm_sec);
	out("sec");
	sprintf(ascii,"%d",tm->tm_min);
	out("min");
	sprintf(ascii,"%d",tm->tm_hour);
	out("hour");
	sprintf(ascii,"%d",tm->tm_mday);
	out("mday");
	sprintf(ascii,"%d",tm->tm_mon);
	out("mon");
	sprintf(ascii,"%d",tm->tm_year);
	out("year");
	sprintf(ascii,"%d",tm->tm_wday);
	out("wday");
	sprintf(ascii,"%d",tm->tm_yday);
	out("yday");
	sprintf(ascii,"%d",tm->tm_isdst);
	out("isdst");
a2537 1
/* end of deprecated code */
a2599 13
/* lowmemcpy - like memcpy but it lowercases result */
void
exp_lowmemcpy(dest,src,n)
char *dest;
char *src;
int n;
{
	for (;n>0;n--) {
		*dest = ((isascii(*src) && isupper(*src))?tolower(*src):*src);
		src++;	dest++;
	}
}

d2608 19
a2626 4
	int size = -1;
	int m = -1;
	struct exp_f *f;
	int Default = FALSE;
d2628 4
a2631 1
	argc--; argv++;
d2633 8
a2640 23
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-d")) {
			Default = TRUE;
		} else if (streq(*argv,"-i")) {
			argc--;argv++;
			if (argc < 1) {
				exp_error(interp,"-i needs argument");
				return(TCL_ERROR);
			}
			m = atoi(*argv);
		} else break;
	}

	if (!Default) {
		if (m == -1) {
			if (!(f = exp_update_master(interp,&m,0,0)))
				return(TCL_ERROR);
		} else {
			if (!(f = exp_fd2f(interp,m,0,0,"match_max")))
				return(TCL_ERROR);
		}
	} else if (m != -1) {
		exp_error(interp,"cannot do -d and -i at the same time");
d2643 1
d2645 5
a2649 8
	if (argc == 0) {
		if (Default) {
			size = exp_default_match_max;
		} else {
			size = f->umsize;
		}
		sprintf(interp->result,"%d",size);
		return(TCL_OK);
d2651 3
d2655 14
a2668 11
	if (argc > 1) {
		exp_error(interp,"too many arguments");
		return(TCL_OK);
	}

	/* all that's left is to set the size */
	size = atoi(argv[0]);
	if (size <= 0) {
		exp_error(interp,"must be positive");
		return(TCL_ERROR);
	}
d2670 2
a2671 2
	if (Default) exp_default_match_max = size;
	else f->umsize = size;
d2673 1
a2673 1
	return(TCL_OK);
d2684 19
a2702 4
	int value = -1;
	int m = -1;
	struct exp_f *f;
	int Default = FALSE;
d2704 4
a2707 1
	argc--; argv++;
d2709 6
a2714 23
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-d")) {
			Default = TRUE;
		} else if (streq(*argv,"-i")) {
			argc--;argv++;
			if (argc < 1) {
				exp_error(interp,"-i needs argument");
				return(TCL_ERROR);
			}
			m = atoi(*argv);
		} else break;
	}

	if (!Default) {
		if (m == -1) {
			if (!(f = exp_update_master(interp,&m,0,0)))
				return(TCL_ERROR);
		} else {
			if (!(f = exp_fd2f(interp,m,0,0,"remove_nulls")))
				return(TCL_ERROR);
		}
	} else if (m != -1) {
		exp_error(interp,"cannot do -d and -i at the same time");
d2717 1
d2719 5
a2723 8
	if (argc == 0) {
		if (Default) {
			value = exp_default_match_max;
		} else {
			value = f->rm_nulls;
		}
		sprintf(interp->result,"%d",value);
		return(TCL_OK);
d2725 3
d2729 4
a2732 4
	if (argc > 1) {
		exp_error(interp,"too many arguments");
		return(TCL_OK);
	}
d2734 6
a2739 6
	/* all that's left is to set the value */
	value = atoi(argv[0]);
	if (value != 0 && value != 1) {
		exp_error(interp,"must be 0 or 1");
		return(TCL_ERROR);
	}
d2741 2
a2742 2
	if (Default) exp_default_rm_nulls = value;
	else f->rm_nulls = value;
d2744 1
a2744 1
	return(TCL_OK);
d2755 19
a2773 4
	int parity;
	int m = -1;
	struct exp_f *f;
	int Default = FALSE;
d2775 4
a2778 1
	argc--; argv++;
d2780 7
a2786 23
	for (;argc>0;argc--,argv++) {
		if (streq(*argv,"-d")) {
			Default = TRUE;
		} else if (streq(*argv,"-i")) {
			argc--;argv++;
			if (argc < 1) {
				exp_error(interp,"-i needs argument");
				return(TCL_ERROR);
			}
			m = atoi(*argv);
		} else break;
	}

	if (!Default) {
		if (m == -1) {
			if (!(f = exp_update_master(interp,&m,0,0)))
				return(TCL_ERROR);
		} else {
			if (!(f = exp_fd2f(interp,m,0,0,"parity")))
				return(TCL_ERROR);
		}
	} else if (m != -1) {
		exp_error(interp,"cannot do -d and -i at the same time");
d2788 1
d2790 1
d2792 5
a2796 8
	if (argc == 0) {
		if (Default) {
			parity = exp_default_parity;
		} else {
			parity = f->parity;
		}
		sprintf(interp->result,"%d",parity);
		return(TCL_OK);
d2798 3
d2802 4
a2805 4
	if (argc > 1) {
		exp_error(interp,"too many arguments");
		return(TCL_OK);
	}
d2807 2
a2808 2
	/* all that's left is to set the parity */
	parity = atoi(argv[0]);
d2810 2
a2811 2
	if (Default) exp_default_parity = parity;
	else f->parity = parity;
d2813 1
a2813 1
	return(TCL_OK);
d2820 2
a2821 2
exp_fd_print(fdl)
struct exp_fd_list *fdl;
d2823 3
a2825 3
	if (!fdl) return;
	printf("%d ",fdl->fd);
	exp_fd_print(fdl->next);
d2840 2
a2841 2
	printf("fds: ");
	exp_fd_print(exp_i->fd_list); printf("\n");
d2895 7
a2901 3
/* need address for passing into cmdExpect */
static int spawn_id_bad = EXP_SPAWN_ID_BAD;
static int spawn_id_user = EXP_SPAWN_ID_USER;
d2905 6
a2910 6
{"expect",	exp_proc(Exp_ExpectCmd),	(ClientData)&spawn_id_bad,	0},
{"expect_after",exp_proc(Exp_ExpectGlobalCmd),(ClientData)&exp_cmds[EXP_CMD_AFTER],0},
{"expect_before",exp_proc(Exp_ExpectGlobalCmd),(ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
{"expect_user",	exp_proc(Exp_ExpectCmd),	(ClientData)&spawn_id_user,	0},
{"expect_tty",	exp_proc(Exp_ExpectCmd),	(ClientData)&exp_dev_tty,	0},
{"expect_background",exp_proc(Exp_ExpectGlobalCmd),(ClientData)&exp_cmds[EXP_CMD_BG],0},
d2913 1
a2913 1
{"parity",	exp_proc(Exp_ParityCmd),		0,	0},
d2923 2
a2925 1
	Tcl_SetVar(interp,EXP_SPAWN_ID_ANY_VARNAME,EXP_SPAWN_ID_ANY_LIT,0);
@


5.29.2.1
log
@Initial 8.1 changes.
@
text
@d87 1
a87 1
	Tcl_RegExp re;	/* if this is 0, then pattern match via glob */
d383 3
d387 1
@


5.29.2.2
log
@Added Exp channel driver and modified rest to support it.
@
text
@a58 10
typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    int timeout;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

d64 2
a65 2
	Tcl_Obj *pat;	/* original pattern spec */
	Tcl_Obj *body;	/* ptr to body to be executed upon match */
d87 1
d139 1
a139 1
void exp_background_channelhandlers_run_all();
d250 2
d253 2
a254 2
		if (ec->pat) Tcl_DecrRefCount(ec->pat);
		if (ec->body) Tcl_DecrRefCount(ec->body);
d404 1
d445 1
a445 1
parse_expect_args(interp,eg,default_esPtr,objc,objv)
d448 3
a450 3
ExpState *default_esPtr;	/* suggested master if called as expect_user or _tty */
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d456 2
a457 14
	static char *options[] = {
	    "timeout", "eof", "full_buffer", "default", "null", "--",
	    "-glob", "-regexp", "-exact", "-notransfer", "-nocase",
	    "-i", "-indices", "-iwrite", "-iread", "-timestamp", "-timeout",
	    "-nobrace", (char *) NULL
	};
	enum options {
	    EXP_ARG_TIMEOUT, EXP_ARG_EOF, EXP_ARG_FULL_BUFFER,
	    EXP_ARG_DEFAULT, EXP_ARG_NULL, EXP_ARG_DASH, EXP_ARG_GLOB,
	    EXP_ARG_REGEXP, EXP_ARG_EXACT, EXP_ARG_NOTRANSFER, EXP_ARG_NOCASE,
	    EXP_ARG_SPAWN_ID, EXP_ARG_INDICES, EXP_ARG_IWRITE, EXP_ARG_IREAD,
	    EXP_ARG_TIMESTAMP, EXP_ARG_DASH_TIMEOUT, EXP_ARG_NOBRACE
	};
	int index;
d468 1
a468 1
		sizeof(struct ecase *) * (1+(objc/2)));
d472 4
a475 5
	for (i = 1;i<objc;i++) {
	    if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0,
		    &index) == TCL_OK) {
		switch ((enum options) index) {
		    case EXP_ARG_TIMEOUT:
d477 1
a477 2
			goto pattern;
		    case EXP_ARG_EOF:
d479 1
a479 2
			goto pattern;
		    case EXP_ARG_FULL_BUFFER:
d481 1
a481 2
			goto pattern;
		    case EXP_ARG_DEFAULT:
d483 1
a483 2
			goto pattern;
		    case EXP_ARG_NULL:
d485 32
a516 42
			goto pattern;
		    case EXP_ARG_DASH:
		    case EXP_ARG_GLOB:
			/* assignment here is not actually necessary */
			/* since cases are initialized this way above */
			/* ec.use = PAT_GLOB; */
			goto pattern;
		    case EXP_ARG_REGEXP:
			if (i >= objc-1) {
			    Tcl_WrongNumArgs(interp, 1, objv,
				    "-regexp regexp");
			    return TCL_ERROR;
			}
			ec.use = PAT_RE;

			/*
			 * Try compiling the expression so we can report
			 * any errors now rather then when we first try to
			 * use it.
			 */

			if (!(Tcl_GetRegExpFromObj(interp, objv[i+1],
				REG_ADVANCED))) {
			    goto error;
			}
			goto pattern;
		    case EXP_ARG_EXACT:
			ec.use = PAT_EXACT;
			goto pattern;

		    case EXP_ARG_NOTRANSFER:
			ec.transfer = 0;
			break;
		    case EXP_ARG_NOCASE:
			ec.Case = CASE_LOWER;
			break;
		    case EXP_ARG_SPAWN_ID:
			i++;
			if (i>=objc) {
			    exp_error(interp,"-i requires following spawn_id");
			    goto error;
			}
d518 2
a519 3
			ec.i_list = exp_new_i_complex(interp,
				Tcl_GetString(objv[i]),
				eg->duration, exp_indirect_update2);
d521 1
a521 1
			ec.i_list->cmdtype = eg->cmdtype;
d524 8
a531 7
			ec.i_list->next = eg->i_list;
			eg->i_list = ec.i_list;
			break;
		    case EXP_ARG_INDICES:
			ec.indices = TRUE;
			break;
		    case EXP_ARG_IWRITE:
d533 18
a550 20
			break;
		    case EXP_ARG_IREAD:
			ec.iread = TRUE;
			break;
		    case EXP_ARG_TIMESTAMP:
			ec.timestamp = TRUE;
			break;
		    case EXP_ARG_DASH_TIMEOUT:
			i++;
			if (i>=objc) {
			    exp_error(interp,"-timeout requires following # of seconds");
			    goto error;
			}
			if (Tcl_GetIntFromObj(interp, objv[i],
				&eg->timeout) != TCL_OK) {
			    goto error;
			}
			eg->timeout_specified_by_flag = TRUE;
			break;
		    case EXP_ARG_NOBRACE:
d556 5
a560 1
			break;
a561 6
		/*
		 * Keep processing arguments, we aren't ready for the
		 * pattern yet.
		 */
		continue;
	    }
d563 13
a575 16
	    /*
	     * We have a pattern of some kind.
	     */

	    pattern:
	    /* if no -i, use previous one */
	    if (!ec.i_list) {
		/* if no -i flag has occurred yet, use default */
		if (!eg->i_list) {
		    if (default_esPtr != EXP_SPAWN_ID_BAD) {
			eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
		    } else {
			/* it'll be checked later, if used */
			*default_esPtr = expGetCurrentState(interp,0,0);
			eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
		    }
d577 1
a577 19
		ec.i_list = eg->i_list;
	    }
	    ec.i_list->ecount++;

	    /* save original pattern spec */
	    /* keywords such as "-timeout" are saved as patterns here */
	    /* useful for debugging but not otherwise used */

	    i++;
	    ec.pat = objv[i];
	    Tcl_IncrRefCount(ec.pat);

	    i++;
	    if (i < objc) {
		ec.body = objv[i];
		Tcl_IncrRefCount(ec.body);
	    } else {
		ec.body = NULL;
	    }
d579 9
a587 1
	    *(eg->ecd.cases[eg->ecd.count] = ecase_new()) = ec;
d590 1
a590 1
	    ecase_clear(&ec);
d592 1
a592 1
	    eg->ecd.count++;
d599 2
a600 2
		if (default_esPtr != EXP_SPAWN_ID_BAD) {
			eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
d602 3
a604 3
		    /* it'll be checked later, if used */
		    *default_esPtr = expGetCurrentState(interp,0,0);
		    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
d617 8
d637 5
a641 5
    struct ecase *e;		/* ecase that matched */
    ExpState *esPtr;		/* ExpState that matched */
    Tcl_Obj *buffer;		/* buffer that matched */
    int match;			/* # of chars in buffer that matched */
			        /* or # of chars in buffer at EOF */
a644 48


/*
 *----------------------------------------------------------------------
 *
 * string_case_first --
 *
 *	Find the first instance of a pattern in a string.
 *
 * Results:
 *	Returns the pointer to the first instance of the pattern
 *	in the given string, or NULL if no match was found.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
string_case_first(string,pattern)	/* INTL */
    register char *string;	/* String. */
    register char *pattern;	/* Pattern, which may contain
				 * special characters. */
{
    char *s, *p;
    int offset;
    Tcl_UniChar ch1, ch2;
    
    while (*string != 0) {
	s = string;
	p = pattern;
	while (*s) {
	    s += Tcl_UtfToUniChar(s, &ch1);
	    offset = Tcl_UtfToUniChar(p, &ch2);
	    if (Tcl_UniCharToLower(ch1) != Tcl_UniCharToLower(ch2)) {
		break;
	    }
	    p += offset;
	}
	if (*p == '\0') {
	    return string;
	}
	string++;
    }
    return NULL;
}

d649 1
a649 1
eval_case_string(interp,e,esPtr,o,last_esPtr,last_case,suffix)
d652 1
a652 1
ExpState *esPtr;
d655 1
a655 1
ExpState **last_esPtr;
d659 2
a660 5
	Tcl_Obj *buffer;
	Tcl_RegExp re;
	Tcl_RegExpInfo info;
	char *str;
	int length, flags;
d662 2
a663 2
	buffer = esPtr->buffer;
	str = Tcl_GetStringFromObj(buffer, &length);
d666 6
a671 6
	if ((f != *last_esPtr) || e->Case != *last_case) {
		debuglog("\r\nexpect%s: does \"%s\" (spawn_id %s) match %s ",
			suffix,
			dprintify(buffer),esPtr->name,
			pattern_style[e->use]);
		*last_esPtr = esPtr;
d676 16
a691 30
	    debuglog("\"%s\"? ",dprintify(e->pat));
	    if (e->Case == CASE_NORM) {
		flags = TCL_REG_ADVANCED;
	    } else {
		flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
	    }
		    
	    re = Tcl_GetRegExpFromObj(interp, e->pat, flags);

	    if (!buffer) {
		debuglog(no);
	    } else if (Tcl_RegExpMatchObj(interp, re, buffer, 0) < 0) {
		debuglog(no);
		return(EXP_TCLERROR);
	    } else {

		o->e = e;

		/*
		 * Retrieve the byte offset of the end of the
		 * matched string.  
		 */

		Tcl_RegExpGetInfo(re, &info);
		o->match = Tcl_UtfAtIndex(str, info.matches[0].end) - str;
		o->buffer = buffer;
		o->esPtr = esPtr;
		debuglog(yes);
		return(EXP_MATCH);
	    }
d693 1
a693 1
	    int match; /* # of chars that matched */
d695 10
a704 16
	    debuglog("\"%s\"? ",dprintify(e->pat));
	    if (buffer) {
		match = Exp_StringCaseMatch(Tcl_GetString(buffer),
			Tcl_GetString(e->pat),
			(e->Case == CASE_NORM) ? 0 : 1,
			&e->simple_start);
		if (match != -1) {
		    o->e = e;
		    o->match = match;
		    o->buffer = buffer;
		    o->esPtr = esPtr;
		    debuglog(yes);
		    return(EXP_MATCH);
		}
	    }
	    debuglog(no);
d706 11
a716 21
	    int patLength;
	    char *pat = Tcl_GetStringFromObj(e->pat, &patLength);
	    int size = (patLength < length) ? patLength : length;
	    char *p;

	    if (e->Case == CASE_NORM) {
		p = strstr(str, pat);
	    } else {
		p = string_case_first(str, pat);
	    }	    

	    debuglog("\"%s\"? ",dprintify(pat));
	    if (p) {
		e->simple_start = p - str;
		o->e = e;
		o->match = e->simple_start + patLength;
		o->buffer = buffer;
		o->esPtr = esPtr;
		debuglog(yes);
		return(EXP_MATCH);
	    } else debuglog(no);
d718 16
a733 15
	    Tcl_UniChar ch;
	    char *p;
	    debuglog("null? ");
	    p = Tcl_UtfFindFirst(str, 0);

	    if (p) {
		o->e = e;
		o->match = p-str;
		o->buffer = buffer;
		o->esPtr = esPtr;
		debuglog(yes);
		return EXP_MATCH;
	    }
	    debuglog(no);
	} else if ((length == esPtr->msize) && (length > 0)) {
d736 3
a738 3
		o->match = length;
		o->buffer = esPtr->buffer;
		o->esPtr = esPtr;
d748 1
a748 1
eval_cases(interp,eg,esPtr,o,last_esPtr,last_case,status,masters,mcount,suffix)
d751 1
a751 1
ExpState *esPtr;
d754 1
a754 1
ExpState **last_esPtr;
d780 1
a780 1
				struct exp_state_list *slPtr;
d782 3
a784 3
				for (slPtr=e->i_list->state_list; slPtr ;slPtr=slPtr->next) {
					em = slPtr->esPtr;
					if (expIsStateAny(em) || em == m) {
d800 1
a800 1
		struct exp_state_list *slPtr;
d808 2
a809 2
		for (slPtr = e->i_list->state_list; slPtr; slPtr = slPtr->next) {
			em = slPtr->esPtr;
d812 1
a812 1
			if (expIsStateAny(em)) {
d815 1
a815 1
					status = eval_case_string(interp,e,masters[j],o,last_esPtr,last_case,suffix);
d822 1
a822 1
				status = eval_case_string(interp,e,m,o,last_esPtr,last_case,suffix);
d894 1
a894 1
ecmd_remove_state(interp,ecmd,esPtr,direct)
d897 1
a897 1
ExpState *esPtr;
d900 5
a904 2
    struct exp_i *exp_i, *next;
    struct exp_state_list **slPtr;
d906 1
a906 2
    for (exp_i=ecmd->i_list;exp_i;exp_i=next) {
	next = exp_i->next;
d908 14
a921 1
	if (!(direct & exp_i->direct)) continue;
d923 3
a925 13
	for (slPtr = &exp_i->state_list;*slPtr;) {
	    if (esPtr == ((*slPtr)->esPtr)) {
		struct exp_state_list *tmp = *slPtr;
		*slPtr = (*slPtr)->next;
		exp_free_state_single(tmp);

		/* if last bg ecase, disarm spawn id */
		if ((ecmd->cmdtype == EXP_CMD_BG) && (expIsStateAny(esPtr))) {
		    esPtr->bg_ecount--;
		    if (esPtr->bg_ecount == 0) {
			exp_disarm_background_channelhandler(esPtr);
			esPtr->bg_interp = 0;
		    }
a926 5
		
		continue;
	    }
	    slPtr = &(*slPtr)->next;
	}
d928 5
a932 4
	/* if left with no ExpStates (and is direct), get rid of it */
	/* and any dependent ecases */
	if (exp_i->direct == EXP_DIRECT && !exp_i->state_list) {
	    exp_i_remove_with_ecases(interp,ecmd,exp_i);
a933 1
    }
d936 1
a936 1
/* this is called from exp_close to clean up the ExpState */
d938 1
a938 1
exp_ecmd_remove_state_direct_and_indirect(interp,esPtr)
d940 1
a940 1
ExpState *esPtr;
d942 3
a944 3
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_BEFORE],esPtr,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_AFTER],esPtr,EXP_DIRECT|EXP_INDIRECT);
	ecmd_remove_state(interp,&exp_cmds[EXP_CMD_BG],esPtr,EXP_DIRECT|EXP_INDIRECT);
d947 1
a947 1
	exp_disarm_background_channelhandler_force(esPtr);
d950 1
a950 1
/* arm a list of background ExpState's */
d952 1
a952 1
state_list_arm(interp,slPtr)
d954 1
a954 1
struct exp_state_list *slPtr;
d956 10
a965 8
    /* for each spawn id in list, arm if necessary */
    for (;slPtr;slPtr=slPtr->next) {
	ExpState *esPtr = slPtr->esPtr;    
	if (expIsStateAny(esPtr)) continue;

	if (esPtr->bg_ecount == 0) {
	    exp_arm_background_channelhandler(esPtr);
	    esPtr->bg_interp = interp;
a966 2
	esPtr->bg_ecount++;
    }
d975 1
a975 1
	struct exp_state_list *fdp;
d977 2
a978 2
	for (fdp = exp_i->state_list;fdp;fdp=fdp->next) {
		if (fdp->esPtr == fd) return 1;
d993 1
a993 1
	if (ec->use == PAT_RE) Tcl_AppendElement(interp,"-re");
d996 2
a997 2
	Tcl_AppendElement(interp,Tcl_GetString(ec->pat));
	Tcl_AppendElement(interp,ec->body?Tcl_GetString(ec->body):"");
d1024 1
a1024 1
		struct exp_state_list *fdp;
d1027 1
a1027 1
		if (exp_i->state_list->next)
d1030 1
a1030 1
		for (fdp = exp_i->state_list;fdp;fdp=fdp->next) {
d1032 1
a1032 1
			sprintf(buf,"%d",fdp->esPtr);
d1036 1
a1036 1
		if (exp_i->state_list->next)
d1041 76
d1130 1
a1130 1
	ExpState *esPtr = 0;
d1163 5
a1167 7
	    if (!(esPtr = expGetCurrentState(interp,0,0))) {
		return TCL_ERROR;
	    }
	} else {
	    if (!(esPtr = expGetState(interp,iflag,0,0,"dummy"))) {
		/* if this is not a valid ExpState, then assume it is an
		   indirect */
d1181 1
a1181 1
		if (!exp_i_uses_state(exp_i,esPtr)) continue;
d1197 16
a1212 22
    int result = TCL_OK;
    struct exp_i *exp_i, **eip;
    struct exp_state_list *slPtr;	/* temp for interating over state_list */
    struct exp_cmd_descriptor eg;
    int count;

    struct exp_cmd_descriptor *ecmd = (struct exp_cmd_descriptor *) clientData;

    if ((argc == 2) && exp_one_arg_braced(argv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,argv));
    } else if ((argc == 3) && streq(argv[1],"-brace")) {
	char *new_argv[2];
	new_argv[0] = argv[0];
	new_argv[1] = argv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_argv));
    }

    if (argc > 1 && (argv[1][0] == '-')) {
	if (exp_flageq("info",&argv[1][1],4)) {
	    return(expect_info(interp,ecmd,argc-2,argv+2));
	} 
    }
d1214 12
a1225 1
    exp_cmd_init(&eg,ecmd->cmdtype,EXP_PERMANENT);
d1227 20
a1246 4
    if (TCL_ERROR == parse_expect_args(interp,&eg,EXP_SPAWN_ID_BAD,
	    argc,argv)) {
	return TCL_ERROR;
    }
d1248 3
a1250 23
    /*
     * visit each NEW direct exp_i looking for spawn ids.
     * When found, remove them from any OLD exp_i's.
     */

    /* visit each exp_i */
    for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	if (exp_i->direct == EXP_INDIRECT) continue;

	/* for each spawn id, remove it from ecases */
	for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
	    int m = slPtr->esPtr;

	    /* validate all input descriptors */
	    if (!expIsStateAny(esPtr)) {
		if (!exp_fd2f(interp,m,1,1,"expect")) {
		    result = TCL_ERROR;
		    goto cleanup;
		}
	    }
	    
	    /* remove spawn id from exp_i */
	    ecmd_remove_state(interp,ecmd,m,EXP_DIRECT);
a1251 1
    }
d1253 40
a1292 39
    /*
     * For each indirect variable, release its old ecases and 
     * clean up the matching spawn ids.
     * Same logic as in "expect_X delete" command.
     */

    for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	struct exp_i **old_i;

	if (exp_i->direct == EXP_DIRECT) continue;

	for (old_i = &ecmd->i_list;*old_i;) {
	    struct exp_i *tmp;

	    if (((*old_i)->direct == EXP_DIRECT) ||
		    (!streq((*old_i)->variable,exp_i->variable))) {
		old_i = &(*old_i)->next;
		continue;
	    }

	    ecases_remove_by_expi(interp,ecmd,*old_i);
	    
	    /* unlink from middle of list */
	    tmp = *old_i;
	    *old_i = tmp->next;
	    tmp->next = 0;
	    exp_free_i(interp,tmp,exp_indirect_update2);
	}

	/* if new one has ecases, update it */
	if (exp_i->ecount) {
	    char *msg = exp_indirect_update1(interp,ecmd,exp_i);
	    if (msg) {
		/* unusual way of handling error return */
		/* because of Tcl's variable tracing */
		strcpy(interp->result,msg);
		result = TCL_ERROR;
		goto indirect_update_abort;
	    }
d1294 2
a1295 3
    }
    /* empty i_lists have to be removed from global eg.i_list */
    /* before returning, even if during error */
d1298 4
a1301 18
    /*
     * New exp_i's that have 0 ecases indicate fd/vars to be deleted.
     * Now that the deletions have been done, discard the new exp_i's.
     */

    for (exp_i=eg.i_list;exp_i;) {
	struct exp_i *next = exp_i->next;

	if (exp_i->ecount == 0) {
	    exp_i_remove(interp,&eg.i_list,exp_i);
	}
	exp_i = next;
    }
    if (result == TCL_ERROR) goto cleanup;

    /*
     * arm all new bg direct fds
     */
d1303 67
a1369 23
    if (ecmd->cmdtype == EXP_CMD_BG) {
	for (exp_i=eg.i_list;exp_i;exp_i=exp_i->next) {
	    if (exp_i->direct == EXP_DIRECT) {
		state_list_arm(interp,exp_i->state_list);
	    }
	}
    }

    /*
     * now that old ecases are gone, add new ecases and exp_i's (both
     * direct and indirect).
     */

    /* append ecases */

    count = ecmd->ecd.count + eg.ecd.count;
    if (eg.ecd.count) {
	int start_index; /* where to add new ecases in old list */

	if (ecmd->ecd.count) {
	    /* append to end */
	    ecmd->ecd.cases = (struct ecase **)ckrealloc((char *)ecmd->ecd.cases, count * sizeof(struct ecase *));
	    start_index = ecmd->ecd.count;
d1371 2
a1372 22
	    /* append to beginning */
	    ecmd->ecd.cases = (struct ecase **)ckalloc(eg.ecd.count * sizeof(struct ecase *));
	    start_index = 0;
	}
	memcpy(&ecmd->ecd.cases[start_index],eg.ecd.cases,
		eg.ecd.count*sizeof(struct ecase *));
	ecmd->ecd.count = count;
    }

    /* append exp_i's */
    for (eip = &ecmd->i_list;*eip;eip = &(*eip)->next) {
	/* empty loop to get to end of list */
    }
    /* *exp_i now points to end of list */

    *eip = eg.i_list;	/* connect new list to end of current list */

  cleanup:
    if (result == TCL_ERROR) {
	/* in event of error, free any unreferenced ecases */
	/* but first, split up i_list so that exp_i's aren't */
	/* freed twice */
d1374 3
a1376 13
	for (exp_i=eg.i_list;exp_i;) {
	    struct exp_i *next = exp_i->next;
	    exp_i->next = 0;
	    exp_i = next;
	}
	free_ecases(interp,&eg,1);
    } else {
	if (eg.ecd.cases) ckfree((char *)eg.ecd.cases);
    }

    if (ecmd->cmdtype == EXP_CMD_BG) {
	exp_background_channelhandlers_run_all();
    }
d1378 1
a1378 1
    return(result);
d1383 2
a1384 2
exp_adjust(esPtr)
ExpState *esPtr;
d1386 29
a1414 34
    int new_msize;
    int length;
    Tcl_Obj *newObj;
    char *string;

    /* get the latest buffer size.  Double the user input for */
    /* two reasons.  1) Need twice the space in case the match */
    /* straddles two bufferfuls, 2) easier to hack the division */
    /* by two when shifting the buffers later on.  The extra  */
    /* byte in the malloc's is just space for a null we can slam on the */
    /* end.  It makes the logic easier later.  The -1 here is so that */
    /* requests actually come out to even/word boundaries (if user */
    /* gives "reasonable" requests) */
    new_msize = esPtr->umsize*2 - 1;
    if (new_msize != esPtr->msize) {
	if (!esPtr->buffer) {
	    esPtr->buffer = Tcl_NewObj();
	    Tcl_IncrRefCount(esPtr->buffer);
	} else {
	    /* buffer already exists - resize */
	    string = Tcl_GetStringFromObj(esPtr->buffer, &length);
		
	    /* if truncated, forget about some data */
	    if (length > new_msize) {
		newObj = Tcl_NewStringObj(string, new_msize);
		Tcl_IncrRefCount(newObj);
		Tcl_DecrRefCount(esPtr->buffer);
		esPtr->buffer = newObj;
	    } else {
		/*
		 * Force the object to allocate a buffer at least
		 * new_msize bytes long, then reset the correct string
		 * length.
		 */
d1416 6
a1421 4
		Tcl_SetObjLength(esPtr->buffer, new_msize);
		Tcl_SetObjLength(esPtr->buffer, length);
	    }
	    esPtr->key = expect_key++;
a1422 2
	esPtr->msize = new_msize;
    }
d1444 1
a1444 1
expect_read(interp,masters,masters_max,esPtrOut,timeout,key)
d1446 1
a1446 1
ExpState (*esPtrs)[];		/* If 0, then m is already known and set. */
d1452 1
a1452 1
ExpState **esPtrOut;		/* Out variable to leave new master. */
d1456 14
a1469 14
    ExpState *esPtr;
    int cc;
    int write_count;
    int tcl_set_flags;	/* if we have to discard chars, this tells */
			/* whether to show user locally or globally */

    if (esPtrs == 0) {
	/* we already know the master, just find out what happened */
	cc = exp_get_next_event_info(interp,&esPtr,masters_max);
	tcl_set_flags = TCL_GLOBAL_ONLY;
    } else {
	cc = exp_get_next_event(interp,esPtrs,masters_max,&esPtr,timeout,key);
	tcl_set_flags = 0;
    }
d1471 94
a1564 83
    if (cc == EXP_DATA_NEW) {
	/* try to read it */
	
	cc = exp_i_read(interp,esPtr,timeout,tcl_set_flags);
	
	/* the meaning of 0 from i_read means eof.  Muck with it a */
	/* little, so that from now on it means "no new data arrived */
	/* but it should be looked at again anyway". */
	if (cc == 0) {
	    cc = EXP_EOF;
	} else if (cc > 0) {
	    esPtr->buffer[esPtr->size += cc] = '\0';
	    
	    /* strip parity if requested */
	    if (esPtr->parity == 0) {
		/* do it from end backwards */
		char *p = esPtr->buffer + esPtr->size - 1;
		int count = cc;
		while (count--) {
		    *p-- &= 0x7f;
		}
	    }
	} /* else {
	     assert(cc < 0) in which case some sort of error was
	     encountered such as an interrupt with that forced an
	     error return
	     } */
    } else if (cc == EXP_DATA_OLD) {
	cc = 0;
    } else if (cc == EXP_RECONFIGURE) {
	return EXP_RECONFIGURE;
    }

    if (cc == EXP_ABEOF) {	/* abnormal EOF */
	/* On many systems, ptys produce EIO upon EOF - sigh */
	if (i_read_errno == EIO) {
	    /* Sun, Cray, BSD, and others */
	    cc = EXP_EOF;
	} else if (i_read_errno == EINVAL) {
	    /* Solaris 2.4 occasionally returns this */
	    cc = EXP_EOF;
	} else {
	    if (i_read_errno == EBADF) {
		exp_error(interp,"bad spawn_id (process died earlier?)");
	    } else {
		exp_error(interp,"i_read(spawn_id fd=%d): %s",esPtr->fdin,
			Tcl_PosixError(interp));
		exp_close(interp,esPtr);
	    }
	    return(EXP_TCLERROR);
	    /* was goto error; */
	}
    }

    /* EOF, TIMEOUT, and ERROR return here */
    /* In such cases, there is no need to update screen since, if there */
    /* was prior data read, it would have been sent to the screen when */
    /* it was read. */
    if (cc < 0) return (cc);

    /* update display */

    if (esPtr->size) write_count = esPtr->size - esPtr->printed;
    else write_count = 0;
    
    if (write_count) {
	if (logfile_all || (loguser && logfile)) {
	    fwrite(esPtr->buffer + esPtr->printed,1,write_count,logfile);
	}
	/* don't write to user if they're seeing it already, */
	/* that is, typing it! */
	if (loguser && !expIsStateStdinout(esPtr) && !expIsStateDevtty(esPtr))
	    fwrite(esPtr->buffer + esPtr->printed,
		    1,write_count,stdout);
	if (debugfile) fwrite(esPtr->buffer + esPtr->printed,
		1,write_count,debugfile);
	    
	/* remove nulls from input, since there is no way */
	/* for Tcl to deal with such strings.  Doing it here */
	/* lets them be sent to the screen, just in case */
	/* they are involved in formatting operations */
	if (esPtr->rm_nulls) {
	    esPtr->size -= rm_nulls(esPtr->buffer + esPtr->printed,write_count);
d1566 1
a1566 10
	esPtr->buffer[esPtr->size] = '\0';
	
	/* copy to lowercase buffer */
	exp_lowmemcpy(esPtr->lower+esPtr->printed,
		esPtr->buffer+esPtr->printed,
		1 + esPtr->size - esPtr->printed);
	    
	esPtr->printed = esPtr->size; /* count'm even if not logging */
    }
    return(cc);
d1572 1
a1572 1
exp_buffer_shuffle(interp,esPtr,save_flags,array_name,caller_name)
d1574 1
a1574 1
ExpState *esPtr;
d1579 1
d1583 2
a1584 2
	int first_half = esPtr->size/2;
	int second_half = esPtr->size - first_half;
d1590 1
d1592 2
a1593 4
		 caller_name,array_name,esPtr->name);
	Tcl_SetVar2(interp,array_name,"spawn_id",esPtr->name,save_flags);

/*SCOTT*/
d1596 2
a1597 2
	match_char = esPtr->buffer[first_half];
	esPtr->buffer[first_half] = 0;
d1600 2
a1601 2
		 caller_name,array_name,dprintify(esPtr->buffer));
	Tcl_SetVar2(interp,array_name,"buffer",esPtr->buffer,save_flags);
d1604 1
a1604 1
	esPtr->buffer[first_half] = match_char;
d1606 5
a1610 5
	memcpy(esPtr->buffer,esPtr->buffer+first_half,second_half);
	memcpy(esPtr->lower, esPtr->lower +first_half,second_half);
	esPtr->size = second_half;
	esPtr->printed -= first_half;
	if (esPtr->printed < 0) esPtr->printed = 0;
d1652 1
a1652 1
exp_i_read(interp,esPtr,timeout,save_flags)
d1654 1
a1654 1
ExpState *esPtr;
d1658 2
a1659 1
    int cc = EXP_TIMEOUT;
d1661 3
a1663 2
    if (esPtr->size == esPtr->msize) 
	exp_buffer_shuffle(interp,f,save_flags,EXPECT_OUT,"expect");
d1668 1
a1668 1
    alarm_fired = FALSE;
d1670 4
a1673 4
    if (timeout > -1) {
	signal(SIGALRM,sigalarm_handler);
	alarm((timeout > 0)?timeout:1);
    }
d1676 2
a1677 3
/*SCOTT*/
    cc = Tcl_ReadChars(m,esPtr->buffer+esPtr->size, esPtr->msize-esPtr->size);
    i_read_errno = errno;
d1680 1
a1680 1
    alarm(0);
d1682 16
a1697 9
    if (cc == -1) {
	/* check if alarm went off */
	if (i_read_errno == EINTR) {
	    if (alarm_fired) {
		return EXP_TIMEOUT;
	    } else {
		if (Tcl_AsyncReady()) {
		    int rc = Tcl_AsyncInvoke(interp,TCL_OK);
		    if (rc != TCL_OK) return(exp_tcl2_returnvalue(rc));
a1698 2
		goto restart;
	    }
a1699 1
    }
d1714 1
a1714 1
    char *val;
d1716 3
a1718 3
    if (NULL != (val = Tcl_GetVar(interp,var,0 /* local */)))
	return(val);
    return(Tcl_GetVar(interp,var,TCL_GLOBAL_ONLY));
d1725 2
a1726 2
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *t;
d1728 4
a1731 4
    if (NULL != (t = exp_get_var(interp,EXPECT_TIMEOUT))) {
	tsdPtr->timeout = atoi(t);
    }
    return(tsdPtr->timeout);
d1737 1
a1737 1
update_expect_states(i_list,i_union)
d1739 1
a1739 1
struct exp_state_list **i_union;
d1741 1
a1741 1
    struct exp_i *p;
d1743 21
a1763 20
    /* for each i_list in an expect statement ... */
    for (p=i_list;p;p=p->next) {
	struct exp_state_list *slPtr;

	/* for each esPtr in the i_list */
	for (slPtr=p->state_list;slPtr;slPtr=slPtr->next) {
	    struct exp_state_list *tmpslPtr;
	    struct exp_state_list *u;

	    if (expIsStateAny(slPtr->esPtr)) continue;
	    
	    /* check this one against all so far */
	    for (u = *i_union;u;u=u->next) {
		if (slPtr->esPtr == u->esPtr) goto found;
	    }
	    /* if not found, link in as head of list */
	    tmpslPtr = exp_new_state(slPtr->esPtr);
	    tmpslPtr->next = *i_union;
	    *i_union = tmpslPtr;
	    found:;
d1765 1
a1765 2
    }
    return TCL_OK;
d1800 1
a1800 1
	exp_background_channelhandlers_run_all();
d1811 1
a1811 1
	struct exp_state_list *slPtr;	/* temp for interating over state_list */
d1814 1
a1814 1
	 * disarm any ExpState's that lose all their ecases
d1819 2
a1820 2
		for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
			int m = slPtr->esPtr;
d1822 1
a1822 1
			if (expIsStateAny(esPtr)) continue;
d1828 1
a1828 1
			if (!expCheckState(interp,slPtr->esPtr,1,0,"")) continue;
d1833 2
a1834 2
			if (esPtr->bg_ecount > 0) {
				esPtr->bg_ecount--;
d1836 3
a1838 3
			if (esPtr->bg_ecount == 0) {
				exp_disarm_background_channelhandler(esPtr);
				esPtr->bg_interp = 0;
d1853 3
a1855 4
	for (slPtr=exp_i->state_list;slPtr;slPtr=slPtr->next) {
	    /* validate all input descriptors */

	    if (expIsStateAny(slPtr->esPtr)) continue;
d1857 1
a1857 1
		if (!exp_fd2f(interp,slPtr->esPtr,1,1,
d1868 1
a1868 1
		state_list_arm(interp,exp_i->state_list);
d1874 18
d1895 1
a1895 1
exp_background_channelhandler(clientData,mask)
d1899 1
a1899 1
    ExpState *esPtr;
d1901 2
a1902 2
    Tcl_Interp *interp;
    int cc;			/* number of chars returned in a single read */
d1904 1
d1906 1
a1906 1
    int i;			/* trusty temporary */
d1908 2
a1909 2
    struct eval_out eo;	/* final case of interest */
    ExpState *last_esPtr;	/* for differentiating when multiple f's */
d1911 1
a1911 1
    int last_case;		/* as above but for case */
d1913 17
a1929 16
    /* restore our environment */
    esPtr = *(ExpState *)clientData;
    interp = esPtr->bg_interp;

    /* temporarily prevent this handler from being invoked again */
    exp_block_background_channelhandler(esPtr);

    /* if mask == 0, then we've been called because the patterns changed */
    /* not because the waiting data has changed, so don't actually do */
    /* any I/O */

    if (mask == 0) {
	cc = 0;
    } else {
	cc = expect_read(interp,(ExpState **)0,mask,&esPtr,EXP_TIME_INFINITY,0);
    }
d1932 32
a1963 32
    eo.e = 0;		/* no final case yet */
    eo.f = 0;		/* no final file selected yet */
    eo.match = 0;		/* nothing matched yet */

    /* force redisplay of buffer when debugging */
    last_esPtr = 0;

    if (cc == EXP_EOF) {
	/* do nothing */
    } else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
	goto finish;
	/* if we were going to do this right, we should */
	/* differentiate between things like HP ioctl-open-traps */
	/* that fall out here and should rightfully be ignored */
	/* and real errors that should be reported.  Come to */
	/* think of it, the only errors will come from HP */
	/* ioctl handshake botches anyway. */
    } else {
	/* normal case, got data */
	/* new data if cc > 0, same old data if cc == 0 */

	/* below here, cc as general status */
	cc = EXP_NOMATCH;
    }

    cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_BG],
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
    cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
	    esPtr,&eo,&last_esPtr,&last_case,cc,&esPtr,1,"_background");
    if (cc == EXP_TCLERROR) {
d1972 2
a1973 2
		eo.match = eo.esPtr->size;
		eo.buffer = eo.esPtr->buffer;
d1987 1
d1999 1
d2001 1
a2001 1
				esPtr = eo.esPtr;
d2005 15
d2022 1
a2022 1
			esPtr = eo.esPtr;
d2079 1
a2079 1
				str = esPtr->buffer + e->simple_start;
d2106 4
a2109 2
			sprintf(spawn_id,"%d",f-exp_fs);
			out("spawn_id",spawn_id);
d2113 3
a2115 3
			match_char = esPtr->buffer[match];
			esPtr->buffer[match] = 0;
			out("buffer",esPtr->buffer);
d2117 1
a2117 1
			esPtr->buffer[match] = match_char;
d2122 5
a2126 5
				esPtr->size -= match;
				esPtr->printed -= match;
				if (esPtr->size != 0) {
				   memmove(esPtr->buffer,esPtr->buffer+match,esPtr->size);
				   memmove(esPtr->lower,esPtr->lower+match,esPtr->size);
d2128 2
a2129 2
				esPtr->buffer[esPtr->size] = '\0';
				esPtr->lower[esPtr->size] = '\0';
d2159 3
a2161 3
		if (esPtr->valid && (esPtr->bg_status == blocked)
		 && (esPtr->size > 0)) {
			cc = esPtr->size;
d2167 2
a2168 2
	if (esPtr->valid)
		exp_unblock_background_channelhandler(esPtr);
d2182 3
a2184 1
	ExpState *esPtr = 0;	/* ExpState associated with master */
d2188 2
a2189 2
	struct exp_state_list *state_list;	/* list of masters to watch */
	struct exp_state_list *slPtr;	/* temp for interating over state_list */
d2204 1
a2204 1
	ExpState *last_esPtr;	/* for differentiating when multiple f's */
d2233 1
a2233 1
	state_list = 0;
d2236 1
a2236 1
					(ExpState *)clientData,argc,argv))
d2241 1
a2241 1
	/* and flatten ExpStates into array */
d2243 3
a2245 3
	if ((TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_BEFORE].i_list,&state_list))
	 || (TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_AFTER].i_list, &state_list))
	 || (TCL_ERROR == update_expect_states(eg.i_list,&state_list))) {
d2253 1
a2253 1
	/* count and validate state_list */
d2255 1
a2255 1
	for (slPtr=state_list;slPtr;slPtr=slPtr->next) {
d2258 1
a2258 1
		if (!exp_fd2f(interp,slPtr->esPtr,1,1,"expect")) {
d2265 3
a2267 3
	masters = (ExpState **)ckalloc(mcount * sizeof(ExpState *));
	for (slPtr=state_list,i=0;slPtr;slPtr=slPtr->next,i++) {
		masters[i] = slPtr->esPtr;
d2284 1
a2284 1
z	last_esPtr = 0;
d2289 1
a2289 1
	eo.esPtr = 0;		/* no final ExpState selected yet */
d2310 1
a2310 1
			cc = expect_read(interp,masters,mcount,&esPtr,remtime,key);
d2326 2
d2332 1
a2332 1
			last_esPtr = 0;
d2336 1
a2336 1
			esPtr,&eo,&last_esPtr,&last_case,cc,masters,mcount,"");
d2338 1
a2338 1
			esPtr,&eo,&last_esPtr,&last_case,cc,masters,mcount,"");
d2340 1
a2340 1
			esPtr,&eo,&last_esPtr,&last_case,cc,masters,mcount,"");
d2345 3
a2347 3
			eo.esPtr = esPtr;
			eo.match = eo.esPtr->size;
			eo.buffer = eo.esPtr->buffer;
d2356 1
a2356 1
		esPtr->force_read = TRUE;
d2388 1
a2388 1
				esPtr = eo.esPtr;
d2408 1
a2408 1
			esPtr = eo.esPtr;
d2465 1
a2465 1
				str = esPtr->buffer + e->simple_start;
d2490 6
a2495 1
			out("spawn_id",esPtr->name);
d2499 3
a2501 3
			match_char = esPtr->buffer[match];
			esPtr->buffer[match] = 0;
			out("buffer",esPtr->buffer);
d2503 1
a2503 1
			esPtr->buffer[match] = match_char;
d2508 5
a2512 5
				esPtr->size -= match;
				esPtr->printed -= match;
				if (esPtr->size != 0) {
				   memmove(esPtr->buffer,esPtr->buffer+match,esPtr->size);
				   memmove(esPtr->lower,esPtr->lower+match,esPtr->size);
d2514 2
a2515 2
				esPtr->buffer[esPtr->size] = '\0';
				esPtr->lower[esPtr->size] = '\0';
d2527 1
a2527 1
				exp_close(interp,esPtr);
d2529 1
d2551 3
a2553 3
	if (state_list) {
		exp_free_state(state_list);
		state_list = 0;
a2696 1
	ExpState *esPtr = 0;
d2698 1
a2698 1
	ExpState *f;
d2718 1
a2718 1
			if (!(f = exp_update_master(interp,&esPtr,0,0)))
d2721 1
a2721 1
			if (!(f = exp_fd2f(interp,esPtr,0,0,"match_max")))
d2733 1
a2733 1
			size = esPtr->umsize;
d2752 1
a2752 1
	else esPtr->umsize = size;
d2767 1
a2767 1
	ExpState *f;
d2787 1
a2787 1
			if (!(f = exp_update_master(interp,&esPtr,0,0)))
d2790 1
a2790 1
			if (!(f = exp_fd2f(interp,esPtr,0,0,"remove_nulls")))
d2802 1
a2802 1
			value = esPtr->rm_nulls;
d2821 1
a2821 1
	else esPtr->rm_nulls = value;
d2834 30
a2863 23
    int parity;
    ExpState *esPtr = 0;
    char *chanName = 0;
    int Default = FALSE;

    argc--; argv++;

    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else break;
    }

    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expGetCurrentState(interp,0,0))) {
a2864 5
	    }
	} else {
	    if (!(esPtr = expGetState(interp,chanName,0,0,"parity"))) {
		return(TCL_ERROR);
	    }
a2865 4
    } else if (chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }
d2867 8
a2874 5
    if (argc == 0) {
	if (Default) {
	    parity = exp_default_parity;
	} else {
	    parity = esPtr->parity;
a2875 3
	sprintf(interp->result,"%d",parity);
	return(TCL_OK);
    }
d2877 4
a2880 4
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
    }
d2882 2
a2883 2
    /* all that's left is to set the parity */
    parity = atoi(argv[0]);
d2885 2
a2886 2
    if (Default) exp_default_parity = parity;
    else esPtr->parity = parity;
d2888 1
a2888 1
    return(TCL_OK);
d2895 2
a2896 2
exp_fd_print(slPtr)
struct exp_state_list *slPtr;
d2898 3
a2900 3
	if (!slPtr) return;
	printf("%d ",slPtr->esPtr);
	exp_fd_print(slPtr->next);
d2915 2
a2916 2
	printf("ExpStates: ");
	exp_fd_print(exp_i->state_list); printf("\n");
a2969 8
void
expInitExpectVars()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    tsdPtr->timeout = INIT_EXPECT_TIMEOUT;
}

d2995 1
@


5.29.2.3
log
@modified expect command to use new regexp interfaces, made various
I18N changes
@
text
@d35 1
d855 1
a855 2
	} else if ((Tcl_GetCharLength(esPtr->buffer) == esPtr->msize)
		&& (length > 0)) {
d883 3
a885 3
    int i;
    int em;	/* master of ecase */
    struct ecase *e;
d887 1
a887 1
    if (o->e || status == EXP_TCLERROR || eg->ecd.count == 0) return(status);
d889 25
a913 7
    if (status == EXP_TIMEOUT) {
	for (i=0;i<eg->ecd.count;i++) {
	    e = eg->ecd.cases[i];
	    if (e->use == PAT_TIMEOUT || e->use == PAT_DEFAULT) {
		o->e = e;
		break;
	    }
d915 6
a920 2
	return(status);
    } else if (status == EXP_EOF) {
a921 2
	    e = eg->ecd.cases[i];
	    if (e->use == PAT_EOF || e->use == PAT_DEFAULT) {
d923 1
d925 18
a942 11
		for (slPtr=e->i_list->state_list; slPtr ;slPtr=slPtr->next) {
		    em = slPtr->esPtr;
		    if (expIsStateAny(em) || em == m) {
			o->e = e;
			return(status);
		    }
		}
	    }
	}
	return(status);
    }
d944 3
a946 24
    /* the top loops are split from the bottom loop only because I can't */
    /* split'em further. */

    /* The bufferful condition does not prevent a pattern match from */
    /* occurring and vice versa, so it is scanned with patterns */
    for (i=0;i<eg->ecd.count;i++) {
	struct exp_state_list *slPtr;
	int j;

	e = eg->ecd.cases[i];
	if (e->use == PAT_TIMEOUT ||
		e->use == PAT_DEFAULT ||
		e->use == PAT_EOF) continue;

	for (slPtr = e->i_list->state_list; slPtr; slPtr = slPtr->next) {
	    em = slPtr->esPtr;
	    /* if em == EXP_SPAWN_ID_ANY, then user is explicitly asking */
	    /* every case to be checked against every master */
	    if (expIsStateAny(em)) {
		/* test against each spawn_id */
		for (j=0;j<mcount;j++) {
		    status = eval_case_string(interp,e,masters[j],o,
			    last_esPtr,last_case,suffix);
		    if (status != EXP_NOMATCH) return(status);
a947 7
	    } else {
		/* reject things immediately from wrong spawn_id */
		if (em != m) continue;

		status = eval_case_string(interp,e,m,o,last_esPtr,last_case,suffix);
		if (status != EXP_NOMATCH) return(status);
	    }
d949 1
a949 2
    }
    return(EXP_NOMATCH);
d1623 1
a1623 1
exp_buffer_shuffle(interp,esPtr,save_flags,array_name,caller_name) /* INTL */
d1630 5
a1634 3
	Tcl_UniChar *ustr;
	int first_half, second_half, length;
	char *str;
d1644 1
a1644 7
	/*
	 * The internal storage buffer object should only be referred
	 * to by the channel that uses it.  We always copy the contents
	 * out of the object before passing the data to anyone outside
	 * of these routines.  This ensures that the object always has
	 * a refcount of 1 so we can safely modify the contents in place.
	 */
d1646 3
a1648 15
	if (Tcl_IsShared(esPtr->buffer)) {
	    panic("exp_buffer_shuffle called with shared buffer object");
	}

	str = Tcl_GetString(esPtr->buffer);
	ustr = Tcl_GetUnicode(esPtr->buffer);
	length = Tcl_GetCharLength(esPtr->buffer);

	first_half = length/2;
	second_half = length - first_half;

	first_half_bytes = Tcl_UtfAtIndex(str, first_half) - str;

	memcpy(ustr, ustr+first_half, second_half);
	Tcl_SetUnicodeLength(esPtr->buffer, first_half);
d1652 1
a1652 2
	Tcl_SetVar2(interp,array_name,"buffer",Tcl_GetString(esPtr->buffer),
		save_flags);
d1654 7
a1660 1
	esPtr->printed -= first_half_bytes;
d1703 1
a1703 1
exp_i_read(interp,esPtr,timeout,save_flags) /* INTL */
a1709 1
    int size = Tcl_GetCharLength(esPtr->buffer);
d1711 1
a1711 1
    if (size == esPtr->msize) 
d1725 2
a1726 3
    
    cc = Tcl_ReadChars(esPtr->channel, esPtr->buffer, esPtr->msize - size,
	    1 /* Append */);
d1747 1
a1747 1
    return(cc);
a1920 176
int
exp_process_matches(interp, eo, bg, detail)
    Tcl_Interp interp;
    struct eval_out *eo;	/* final case of interest */
    int bg;			/* 1 if called from background handler, */
				/* else 0 */
    char *detail;
{
    ExpState *esPtr = 0;	/* ExpState associated with master */
    char *body = 0;
    Tcl_Obj *buffer;
    struct ecase *e = 0;	/* points to current ecase */
    int match = -1;		/* characters matched */
    char match_char;	/* place to hold char temporarily */
    /* uprooted by a NULL */
    char *eof_body = 0;
    int result = TCL_OK;

#define out(indexName, value) \
    debuglog("%s: set %s(%s) \"%s\"\r\n", detail, EXPECT_OUT,indexName, \
	    dprintify(value)); \
    Tcl_SetVar2(interp, EXPECT_OUT,index,value,(bg ? TCL_GLOBAL_ONLY : 0);

    if (eo->e) {
	e = eo->e;
	body = e->body;
	if (cc != EXP_TIMEOUT) {
	    esPtr = eo->esPtr;
	    match = eo->match;
	    buffer = eo->buffer;
	}
    } else if (cc == EXP_EOF) {
	/* read an eof but no user-supplied case */
	esPtr = eo->esPtr;
	match = eo->match;
	buffer = eo->buffer;
    }			

    if (match >= 0) {
	char name[20], value[20];

	if (e && e->use == PAT_RE) {
	    regexp *re;
	    int flags;
	    Tcl_RegExpInfo info;

	    if (e->Case == CASE_NORM) {
		flags = TCL_REG_ADVANCED;
	    } else {
		flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
	    }
		    
	    re = Tcl_GetRegExpFromObj(interp, e->pat, flags);
	    Tcl_RegExpGetInfo(re, &info);

	    for (i=0;i<info.nsub;i++) {
		int offset, start, end;
		Tcl_Obj *val;

		start = info.matches[i].start;
		end = info.matches[i].end-1;
		if (start == -1) continue;

		if (e->indices) {
				/* start index */
		    sprintf(name,"%d,start",i);
		    offset = 
			sprintf(value,"%d",start);
		    out(name,value);

				/* end index */
		    sprintf(name,"%d,end",i);
		    sprintf(value,"%d",end);
		    out(name,value);
		}

				/* string itself */
		sprintf(name,"%d,string",i);
		val = Tcl_GetRange(buffer, start, end);
		debuglog("expect_background: set %s(%s) \"%s\"\r\n",EXPECT_OUT,name, dprintifyobj(val));
		Tcl_SetVar2Ex(interp,EXPECT_OUT,name,
			val, TCL_GLOBAL_ONLY);
	    }
	} else if (e && (e->use == PAT_GLOB || e->use == PAT_EXACT)) {
	    char *str;

	    if (e->indices) {
		/* start index */
		sprintf(value,"%d",e->simple_start);
		out("0,start",value);

		/* end index */
		sprintf(value,"%d",e->simple_start + match - 1);
		out("0,end",value);
	    }

	    /* string itself */
	    str = Tcl_GetString(esPtr->buffer);
	    /* temporarily null-terminate in middle */
	    match_char = str[match];
	    str[match] = 0;
	    out("0,string",str + e->simple_start);
	    str[match] = match_char;

				/* redefine length of string that */
				/* matched for later extraction */
	    match += e->simple_start;
	} else if (e && e->use == PAT_NULL && e->indices) {
				/* start index */
	    sprintf(value,"%d",match-1);
	    out("0,start",value);
				/* end index */
	    sprintf(value,"%d",match-1);
	    out("0,end",value);
	} else if (e && e->use == PAT_FULLBUFFER) {
	    debuglog("expect_background: full buffer\r\n");
	}
    }

    /* this is broken out of (match > 0) (above) since it can */
    /* that an EOF occurred with match == 0 */
    if (eo->f) {
	char spawn_id[10];	/* enough for a %d */
	char *str;

	sprintf(spawn_id,"%d",f-exp_fs);
	out("spawn_id",spawn_id);

	str = Tcl_GetStringFromObj(esPtr->buffer, &length);
			
	/* save buf[0..match] */
	/* temporarily null-terminate string in middle */
	match_char = str[match];
	str[match] = 0;
	out("buffer",str);
	/* remove middle-null-terminator */
	str[match] = match_char;

	/* "!e" means no case matched - transfer by default */
	if (!e || e->transfer) {
	    /* delete matched chars from input buffer */
	    esPtr->printed -= match;
	    if (length != 0) {
		memmove(str,str+match,length-match);
	    }
	    Tcl_SetObjLength(esPtr->buffer, length-match);
	}

	if (cc == EXP_EOF) {
				/* exp_close() deletes all background bodies */
				/* so save eof body temporarily */
	    if (body) {
		eof_body = ckalloc(strlen(body)+1);
		strcpy(eof_body,body);
		body = eof_body;
	    }

	    exp_close(interp,f - exp_fs);
	}

    }

    if (body) {
	if (!bg) {
	    result = Tcl_Eval(interp,body);
	} else {
	    result = Tcl_GlobalEval(interp,body);
	    if (result != TCL_OK) Tcl_BackgroundError(interp);
	}
	if (eof_body) ckfree(eof_body);
    }
    return result;
}
#undef out


d1924 1
a1924 1
exp_background_channelhandler(clientData,mask) /* INTL */
a1939 1
    int length;
d2010 3
d2014 147
a2160 2
		exp_process_matches(interp, &eo, 1 /* bg */,
			"expect_background");
d2167 3
a2169 4
		if (esPtr->valid && (esPtr->bg_status == blocked)) {
		    Tcl_GetStringFromObj(esPtr->buffer, &length);
		    if (length > 0) {
			cc = length;
a2170 1
		    }
d2178 1
d2290 1
a2290 1
	last_esPtr = 0;
d2378 157
a2534 2
		result = exp_process_matches(interp, &eo, 0 /* not bg */,
			"expect");
@


5.29.2.4
log
@got rid of remaining references to exp_fs and friends and exp_update_masters
@
text
@d1214 1
a1214 1
	    if (!(esPtr = expGetStateFromChannelName(interp,iflag,0,0,"dummy"))) {
d2056 1
a2056 1
    if (eo->esPtr) {
d2060 2
a2061 1
	out("spawn_id",esPtr->name);
d2091 2
a2092 1
	    exp_close(interp,esPtr);
d2151 1
a2151 1
    eo.esPtr = 0;		/* no final file selected yet */
d2189 1
a2189 1
		eo.esPtr = esPtr;
d2583 5
a2587 4
    int size = -1;
    ExpState *esPtr = 0;
    char *chanName = 0;
    int Default = FALSE;
d2589 1
a2589 1
    argc--; argv++;
d2591 12
a2602 12
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else break;
    }
d2604 10
a2613 8
    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expGetCurrentMaster(interp,0,0))) {
		return(TCL_ERROR);
	    }
	} else {
	    
	    if (!(esPtr = expGetStateFromChannelName(interp,chanName,0,0,"match_max")))
a2615 4
    } else if (m != -1) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }
d2748 1
a2748 1
	    if (!(esPtr = expGetStateFromChannelName(interp,chanName,0,0,"parity"))) {
@


5.29.2.5
log
@more changes to objectify the interact command
@
text
@d338 2
a339 2
exp_one_arg_braced(objPtr)	/* INTL */
Tcl_Obj *objPtr;
a341 1
	char *p = Tcl_GetString(objPtr);
d349 1
a349 1
		if (!isspace(*p)) { /* INTL: ISO space */
d361 1
a361 1
exp_eval_with_one_arg(clientData,interp,objv) /* INTL */
d364 1
a364 1
Tcl_Obj *CONST objv[];		/* Argument objects. */
d366 8
a373 8
#define NUM_STATIC_OBJS 20
    Tcl_Obj *staticObjArray[NUM_STATIC_OBJS], **objv;
    Tcl_Token *tokenPtr;
    char *p;
    int length;
    Tcl_Obj **objs = staticObjArray;
    int maxobjs = MAXLOCAL;
    int objc, next;
d375 3
a377 12
    /*
     * Prepend the command name and the -nobrace switch so we can
     * reinvoke without recursing.
     */

    objc = 2;
    objs[0] = objv[0];
    objs[1] = Tcl_NewStringObj("-nobrace", -1);
    Tcl_IncrRefCount(objs[0]);
    Tcl_IncrRefCount(objs[1]);

    p = Tcl_GetStringFromObj(objv[1], &bytesLeft);
d379 6
a384 6
    /*
     * Treat the pattern/action block like a series of Tcl commands.
     * For each command, parse the command words, perform substititions
     * on each word, and add the words to an array of values.  We don't
     * actually evaluate the individual commands, just the substitutions.
     */
d386 2
a387 19
    do {
	if (Tcl_ParseCommand(interp, p, bytesLeft, 0, &parse)
	        != TCL_OK) {
	    rc = TCL_ERROR;
	    goto done;
	}
	numWords = parse.numWords;
 	if (numWords > 0) {
	    /*
	     * Generate an array of objects for the words of the command.
	     */
    
	    if (objc + numWords > maxobjs) {
		Tcl_Obj ** newobjs;
		maxobjs = (objc + numWords) * 2;
		newobjs = ckalloc(maxobjs * sizeof (Tcl_Obj *));
		memcpy(newobjs, objs, objc*sizeof(Tcl_Obj *));
		if (objs != staticObjArray) {
		    ckfree((char*)objs);
d389 1
a389 18
		objs = newobjs;   
	    }

	    /*
	     * For each word, perform substitutions then store the
	     * result in the objs array.
	     */
	    
	    for (tokenPtr = parse.tokenPtr; numWords > 0;
		 tokenPtr += (tokenPtr->numComponents + 1)) {
		objs[objc] = Tcl_EvalTokens(interp, tokenPtr+1,
			tokenPtr->numComponents);
		if (objv[objc] == NULL) {
		    rc = TCL_ERROR;
		    goto done;
		}
		objc++;
	    }
d392 1
a392 9
	/*
	 * Advance to the next command in the script.
	 */

	next = parse.commandStart + parse.commandSize;
	bytesLeft -= next - p;
	p = next;
	Tcl_FreeParse(&parse);
    } while (bytesLeft > 0);
d394 2
a395 15
    /*
     * Now evaluate the entire command with no further substitutions.
     */

    rc = Tcl_EvalObjv(interp, objc, objs, 0);

    done:
    for (i = 0; i < objc; i++) {
	Tcl_DecrRefCount(objs[i]);
    }
    if (objs != staticObjArray) {
	ckfree((char *) objs);
    }
    return(rc);
#undef NUM_STATIC_OBJS
d2224 1
a2224 1
Exp_ExpectCmd(clientData, interp, objc, objv)
d2227 2
a2228 2
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d2264 7
a2270 7
	if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	    return(exp_eval_with_one_arg(clientData,interp,objv));
	} else if ((objc == 3) && streq(argv[1],"-brace")) {
	    Tcl_Obj *new_objv[2];
	    new_objv[0] = objv[0];
	    new_objv[1] = objv[2];
	    return(exp_eval_with_one_arg(clientData,interp,new_objv));
d2284 1
a2284 1
					(ExpState *)clientData,objc,objv))
@


5.29.2.6
log
@fixed Log/Diag and ExpectCmd
@
text
@d153 2
d227 24
d518 1
a518 1
ExpState *default_esPtr;	/* suggested ExpState if called as expect_user or _tty */
d677 1
a677 1
			*default_esPtr = expStateCurrent(interp,0,0,1);
d717 1
a717 1
		    *default_esPtr = expStateCurrent(interp,0,0,1);
d813 17
a829 26
    Tcl_Obj *buffer;
    Tcl_RegExp re;
    Tcl_RegExpInfo info;
    char *str;
    int length, flags;

    buffer = esPtr->buffer;
    str = Tcl_GetStringFromObj(buffer, &length);

    /* if ExpState or case changed, redisplay debug-buffer */
    if ((f != *last_esPtr) || e->Case != *last_case) {
	expDiagLog("\r\nexpect%s: does \"",suffix);
	expDiagLogU(expPrintify(buffer));
	expDiagLog("\" (spawn_id %s) match %s ",esPtr->name,pattern_style[e->use]);
	*last_esPtr = esPtr;
	*last_case = e->Case;
    }

    if (e->use == PAT_RE) {
	expDiagLog("\"");
	expDiagLogU(expPrintify(e->pat));
	expDiagLog("\"? ");
	if (e->Case == CASE_NORM) {
	    flags = TCL_REG_ADVANCED;
	} else {
	    flags = TCL_REG_ADVANCED | TCL_REG_NOCASE;
d831 8
d840 8
a847 1
	re = Tcl_GetRegExpFromObj(interp, e->pat, flags);
d849 16
a864 6
	if (!buffer) {
	    expDiagLogU(no);
	} else if (Tcl_RegExpMatchObj(interp, re, buffer, 0) < 0) {
	    expDiagLogU(no);
	    return(EXP_TCLERROR);
	} else {
d866 21
a886 1
	    o->e = e;
d888 5
a892 4
	    /*
	     * Retrieve the byte offset of the end of the
	     * matched string.  
	     */
d894 3
a896 19
	    Tcl_RegExpGetInfo(re, &info);
	    o->match = Tcl_UtfAtIndex(str, info.matches[0].end) - str;
	    o->buffer = buffer;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return(EXP_MATCH);
	}
    } else if (e->use == PAT_GLOB) {
	int match; /* # of chars that matched */

	expDiagLog("\"");
	expDiagLogU(expPrintify(e->pat));
	expDiagLog("\"? ");
	if (buffer) {
	    match = Exp_StringCaseMatch(Tcl_GetString(buffer),
		    Tcl_GetString(e->pat),
		    (e->Case == CASE_NORM) ? 0 : 1,
		    &e->simple_start);
	    if (match != -1) {
d898 1
a898 1
		o->match = match;
d901 1
a901 1
		expDiagLogU(yes);
d903 14
d918 10
d929 1
a929 52
	expDiagLogU(no);
    } else if (e->use == PAT_EXACT) {
	int patLength;
	char *pat = Tcl_GetStringFromObj(e->pat, &patLength);
	int size = (patLength < length) ? patLength : length;
	char *p;

	if (e->Case == CASE_NORM) {
	    p = strstr(str, pat);
	} else {
	    p = string_case_first(str, pat);
	}	    

	expDiagLog("\"");
	expDiagLogU(expPrintify(e->pat));
	expDiagLog("\"? ");
	if (p) {
	    e->simple_start = p - str;
	    o->e = e;
	    o->match = e->simple_start + patLength;
	    o->buffer = buffer;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return(EXP_MATCH);
	} else expDiagLogU(no);
    } else if (e->use == PAT_NULL) {
	Tcl_UniChar ch;
	char *p;
	expDiagLogU("null? ");
	p = Tcl_UtfFindFirst(str, 0);

	if (p) {
	    o->e = e;
	    o->match = p-str;
	    o->buffer = buffer;
	    o->esPtr = esPtr;
	    expDiagLogU(yes);
	    return EXP_MATCH;
	}
	expDiagLogU(no);
    } else if ((Tcl_GetCharLength(esPtr->buffer) == esPtr->msize)
	    && (length > 0)) {
	expDiagLogU(e->pat);
	expDiagLogU("? ");
	o->e = e;
	o->match = length;
	o->buffer = esPtr->buffer;
	o->esPtr = esPtr;
	expDiagLogU(yes);
	return(EXP_FULLBUFFER);
    }
    return(EXP_NOMATCH);
d935 1
a935 1
eval_cases(interp,eg,esPtr,o,last_esPtr,last_case,status,esPtrs,mcount,suffix)
d944 1
a944 1
ExpState (*esPtrs)[];
d949 1
a949 1
    ExpState *em;   /* ExpState of ecase */
d971 1
a971 1
		    if (expStateAnyIs(em) || em == m) {
d998 2
a999 2
	    /* every case to be checked against every ExpState */
	    if (expStateAnyIs(em)) {
d1002 1
a1002 1
		    status = eval_case_string(interp,e,esPtrs[j],o,
d1008 1
a1008 1
		if (em != esPtr) continue;
d1010 1
a1010 1
		status = eval_case_string(interp,e,esPtr,o,last_esPtr,last_case,suffix);
d1103 1
a1103 1
		if ((ecmd->cmdtype == EXP_CMD_BG) && (expStateAnyIs(esPtr))) {
d1147 1
a1147 1
	if (expStateAnyIs(esPtr)) continue;
d1275 1
a1275 1
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
d1279 1
a1279 1
	    if (!(esPtr = expStateFromChannelName(interp,iflag,0,0,0,"dummy"))) {
d1355 2
a1356 2
	    if (!expStateAnyIs(esPtr)) {
		if (!expStateCheck(interp,esPtr,1,1,"expect")) {
d1363 1
a1363 1
	    ecmd_remove_state(interp,ecmd,esPtr,EXP_DIRECT);
d1497 1
a1497 1
expAdjust(esPtr)
a1503 10
    int excessBytes;
    char *excessGuess;

    /*
     * Resize buffer to user's request * 2 + 1.
     * x2: in case the match straddles two bufferfuls.
     * +1: for trailing null.
     */

    new_msize = esPtr->umsize*2 + 1;
d1505 9
d1515 19
a1533 7
	string = Tcl_GetStringFromObj(esPtr->buffer, &length);
	if (length > new_msize) {
	    /*
	     * too much data, forget about data at beginning of buffer
	     */

	    excessBytes = length - new_msize;	/* initial guess */
d1535 2
a1536 7
	    /*
	     * Alas, string + excessBytes may be in the middle of a UTF char.
	     * Find out for sure.
	     */
	    excessGuess = string + excessBytes;
	    for (p=string;;p=UtfNext(*p)) {
		if (p >= excessGuess) break;
d1538 1
a1538 19

	    /* now we can calculate a valid # of excess bytes */
	    excessBytes = p - string;
	    newObj = Tcl_NewStringObj(string + exessBytes,length - excessBytes);
	} else {
	    /*
	     * too little data
	     */

	    /* first copy what's there */
	    newObj = Tcl_NewStringObj(string,length);

	    /*
	     * Force object to allocate a buffer at least new_msize bytes long,
	     * then reset correct string length.
	     */

	    Tcl_SetObjLength(newObj,new_msize);
	    Tcl_SetObjLength(newObj,length);
a1539 5
	Tcl_IncrRefCount(newObj);
	Tcl_DecrRefCount(esPtr->buffer);
	esPtr->buffer = newObj;

	esPtr->key = expect_key++;
a1543 15
/* Strip parity */
static void
expParityStrip(obj,offsetBytes)
    Tcl_Obj *obj;
    int offsetBytes;
{
    char *p, ch;
    
    set changed = FALSE;
    
    for (p = Tcl_GetString(obj) + offsetBytes;*p;p++) {
	ch = *p & 0x7f;
	if (ch != *p) changed = TRUE;
	else *p &= 0x7f;
    }
d1545 1
a1545 5
    if (changed) {
/*SCOTT*/
	/* how do we invalidate the unicode rep? */
    }
}
d1547 10
a1556 101
/* Strip UTF-encoded nulls from object, beginning at offset */
static void
expNullStrip(obj,offsetBytes)
    Tcl_Obj *obj;
    int offsetBytes;
{
    char *src, *src2;
    char *dest;
    Tcl_UniChar uc;

    src2 = src = dest = Tcl_GetString(obj) + offsetBytes;

    while (*src) {
	Tcl_UtfToUniChar(src,&uc);
	if (uc == 0) {
	    src += 2;   	    /* skip over UTF-encoded null */
	} else {
	    dest += Tcl_UniCharToUtf(uc,dest);
	}
    }
    Tcl_SetObjLength(obj,dest - src2);
}

/* returns # of bytes read or (non-positive) error of form EXP_XXX */
/* returns 0 for end of file */
/* If timeout is non-zero, set an alarm before doing the read, else assume */
/* the read will complete immediately. */
/*ARGSUSED*/
static int
expIRead(interp,esPtr,timeout,save_flags) /* INTL */
Tcl_Interp *interp;
ExpState *esPtr;
int timeout;
int save_flags;
{
    int cc = EXP_TIMEOUT;
    int size = expSizeGet(esPtr);

    /* int size = Tcl_GetCharLength(esPtr->buffer);*/

    if (size + TCL_UTF_MAX >= esPtr->msize) 
	exp_buffer_shuffle(interp,esPtr,save_flags,EXPECT_OUT,"expect");
    size = expSizeGet(esPtr);

#ifdef SIMPLE_EVENT
 restart:

    alarm_fired = FALSE;

    if (timeout > -1) {
	signal(SIGALRM,sigalarm_handler);
	alarm((timeout > 0)?timeout:1);
    }
#endif

    
    cc = Tcl_ReadChars(esPtr->channel,
	    esPtr->buffer,
	    esPtr->msize - (size / TCL_UTF_MAX),
	    1 /* Append */);
    i_read_errno = errno;

#ifdef SIMPLE_EVENT
    alarm(0);

    if (cc == -1) {
	/* check if alarm went off */
	if (i_read_errno == EINTR) {
	    if (alarm_fired) {
		return EXP_TIMEOUT;
	    } else {
		if (Tcl_AsyncReady()) {
		    int rc = Tcl_AsyncInvoke(interp,TCL_OK);
		    if (rc != TCL_OK) return(exp_tcl2_returnvalue(rc));
		}
		goto restart;
	    }
	}
    }
#endif

    if (cc > 0) {
	if (esPtr->parity == 0) {
	    expParityStrip(esPtr->buffer,size /* old size which is now offset */);
	}
    }

    return expSizeGet(esPtr);
}

/*
 * expRead() does the logical equivalent of a read() for the expect command.
 * This includes figuring out which descriptor should be read from.
 *
 * The result of the read() is left in a spawn_id's buffer rather than
 * explicitly passing it back.  Note that if someone else has modified a buffer
 * either before or while this expect is running (i.e., if we or some event has
 * called Tcl_Eval which did another expect/interact), expRead will also call
 * this a successful read (for the purposes if needing to pattern match against
 * it).
 */
d1558 1
d1563 1
a1563 1
expRead(interp,esPtrs,esPtrsMax,esPtrOut,timeout,key)
d1566 3
a1568 3
int esPtrsMax;			/* If *esPtrs is not-zero, then esPtrsMax */
				/* is the number of esPtrs. */
				/* If *esPtrs is zero, then esPtrsMax */
d1571 1
a1571 1
ExpState **esPtrOut;		/* Out variable to leave new ExpState. */
a1575 1
    int size;
d1582 2
a1583 2
	/* we already know the ExpState, just find out what happened */
	cc = exp_get_next_event_info(interp,&esPtr,esPtrsMax);
d1586 1
a1586 1
	cc = exp_get_next_event(interp,esPtrs,esPtrsMax,&esPtr,timeout,key);
d1592 2
a1593 1
	cc = expIRead(interp,esPtr,timeout,tcl_set_flags);
d1601 16
a1616 6
	    /* successfully read data */
	} else {
	    /* failed to read data - some sort of error was encountered such as
	     * an interrupt with that forced an error return
	     */
	}
d1650 1
a1650 3
    /*
     * update display
     */
d1652 1
a1652 2
    size = expSizeGet(esPtr);
    if (size) write_count = size - esPtr->printed;
d1656 24
a1679 6
	/*
	 * Show chars to user if they've requested it, UNLESS they're seeing it
	 * already because they're typing it and tty driver is echoing it.
	 * Also send to Diag and Log if appropriate.
	 */
	expLogInteractionU(esPtr,size + esPtr->printed);
d1681 1
a1681 7
	/*
	 * strip nulls from input, since there is no way for Tcl to deal with
	 * such strings.  Doing it here lets them be sent to the screen, just
	 * in case they are involved in formatting operations
	 */
	if (esPtr->rm_nulls) expNullStrip(esPtr->buffer,esPtr->printed);
	esPtr->printed = size; /* count'm even if not logging */
d1696 3
a1698 3
    Tcl_UniChar *ustr;
    int first_half, second_half, length;
    char *str;
d1700 3
a1702 3
    /*
     * allow user to see data we are discarding
     */
d1704 3
a1706 3
    expDiagLog("%s: set %s(spawn_id) \"%s\"\r\n",
	    caller_name,array_name,esPtr->name);
    Tcl_SetVar2(interp,array_name,"spawn_id",esPtr->name,save_flags);
d1708 7
a1714 7
    /*
     * The internal storage buffer object should only be referred
     * to by the channel that uses it.  We always copy the contents
     * out of the object before passing the data to anyone outside
     * of these routines.  This ensures that the object always has
     * a refcount of 1 so we can safely modify the contents in place.
     */
d1716 3
a1718 3
    if (Tcl_IsShared(esPtr->buffer)) {
	panic("exp_buffer_shuffle called with shared buffer object");
    }
d1720 3
a1722 3
    str = Tcl_GetString(esPtr->buffer);
    ustr = Tcl_GetUnicode(esPtr->buffer);
    length = Tcl_GetCharLength(esPtr->buffer);
d1724 2
a1725 2
    first_half = length/2;
    second_half = length - first_half;
d1727 1
a1727 1
    first_half_bytes = Tcl_UtfAtIndex(str, first_half) - str;
d1729 2
a1730 2
    memcpy(ustr, ustr+first_half, second_half);
    Tcl_SetUnicodeLength(esPtr->buffer, first_half);
d1732 4
a1735 5
    expDiagLog("%s: set %s(buffer) \"",caller_name,array_name);
    expDiagLogU(expPrintify(esPtr->buffer));
    expDiagLogU("\"\r\n");
    Tcl_SetVar2(interp,array_name,"buffer",Tcl_GetString(esPtr->buffer),
	    save_flags);
d1737 2
a1738 2
    esPtr->printed -= first_half_bytes;
    if (esPtr->printed < 0) esPtr->printed = 0;
d1774 55
d1877 1
a1877 1
	    if (expStateAnyIs(slPtr->esPtr)) continue;
d1947 1
a1947 1
			if (expStateAnyIs(esPtr)) continue;
d1953 1
a1953 1
			if (!expStateCheck(interp,slPtr->esPtr,1,0,"")) continue;
d1981 1
a1981 1
	    if (expStateAnyIs(slPtr->esPtr)) continue;
d1983 7
a1989 7
	    if (!expStateCheck(interp,slptr->esPtr,1,1,
		    exp_cmdtype_printable(ecmd->cmdtype))) {
		static char msg[200];
		sprintf(msg,"%s from indirect variable (%s)",
			interp->result,exp_i->variable);
		return msg;
	    }
d2001 1
a2001 1
expMatchProcess(interp, eo, bg, detail)
d2008 1
a2008 1
    ExpState *esPtr = 0;
d2019 3
a2021 4
 expDiagLog("%s: set %s(%s) \"",detail,EXP_OUT,indexName); \
 expDiagLogU(expPrintify(value)); \
 expDiagLogU("\"\r\n"); \
 Tcl_SetVar2(interp, EXPECT_OUT,index,value,(bg ? TCL_GLOBAL_ONLY : 0);
d2079 1
a2079 3
		expDiagLog("expect_background: set %s(%s) \"",EXPECT_OUT,name);
		expDiagLogU(expPrintifyObj(val));
		expDiagLogU("\"\r\n");
d2115 1
a2115 1
	    expDiagLogU("expect_background: full buffer\r\n");
d2128 1
a2128 1
/*SCOTT*/			
d2148 2
a2149 2
	    /* exp_close() deletes all background bodies */
	    /* so save eof body temporarily */
d2157 1
d2171 2
d2182 1
d2184 1
a2184 1
    int cc;			/* number of bytes returned in a single read */
d2186 5
a2190 3
    int i;			/* misc temporary */
    struct eval_out eo;		/* final case of interest */
    ExpState *last_esPtr;	/* for differentiating when multiple esPtrs */
d2202 4
a2205 4
    /*
     * if mask == 0, then we've been called because the patterns changed not
     * because the waiting data has changed, so don't actually do any I/O
     */
d2209 1
a2209 1
	cc = expRead(interp,(ExpState **)0,mask,&esPtr,EXP_TIME_INFINITY,0);
d2224 6
a2229 7
	/* 
	 * if we were going to do this right, we should differentiate between
	 * things like HP ioctl-open-traps that fall out here and should
	 * rightfully be ignored and real errors that should be reported.  Come
	 * to think of it, the only errors will come from HP ioctl handshake
	 * botches anyway.
	 */
d2248 14
a2261 14
    }
    /* special eof code that cannot be done in eval_cases */
    /* or above, because it would then be executed several times */
    if (cc == EXP_EOF) {
	eo.esPtr = esPtr;
	eo.match = expSizeGet(eo.esPtr);
	eo.buffer = eo.esPtr->buffer;
	expDiagLogU("expect_background: read eof\r\n");
	goto matched;
    }
    if (!eo.e) {
	/* if we get here, there must not have been a match */
	goto finish;
    }
d2264 3
a2266 1
    expMatchProcess(interp, &eo, 1 /* bg */,"expect_background");
d2268 12
a2279 8
    /*
     * Event handler will not call us back if there is more input
     * pending but it has already arrived.  bg_status will be
     * "blocked" only if armed.
     */
    if (esPtr->valid && (esPtr->bg_status == blocked)) {
	if (0 != (cc = expSizeGet(esPtr))) {
	    goto do_more_data;
a2280 1
    }
d2282 3
a2284 3
    /* fd could have gone away, so check before using */
    if (esPtr->valid)
	exp_unblock_background_channelhandler(esPtr);
d2295 1
a2295 1
    int cc;			/* number of chars returned in a single read */
d2297 8
a2304 1
    ExpState *esPtr = 0;
d2306 1
a2306 6
    int i;			/* misc temporary */
    struct exp_cmd_descriptor eg;
    struct exp_state_list *state_list;	/* list of ExpStates to watch */
    struct exp_state_list *slPtr;	/* temp for interating over state_list */
    ExpState **esPtrs;
    int mcount;			/* number of esPtrs to watch */
d2308 1
a2308 1
    struct eval_out eo;		/* final case of interest */
d2310 6
a2315 8
    int result;			/* Tcl result */
    
    time_t start_time_total;	/* time at beginning of this procedure */
    time_t start_time = 0;	/* time when restart label hit */
    time_t current_time = 0;	/* current time (when we last looked)*/
    time_t end_time;		/* future time at which to give up */
    time_t elapsed_time_total;	/* time from now to match/fail/timeout */
    time_t elapsed_time;	/* time from restart to (ditto) */
d2317 1
a2317 1
    ExpState *last_esPtr;	/* for differentiating when multiple f's */
d2319 22
a2340 5
    int last_case;		/* as above but for case */
    int first_time = 1;		/* if not "restarted" */
    
    int key;			/* identify this expect command instance */
    int configure_count;	/* monitor exp_configure_count */
d2342 2
a2343 19
    int timeout;		/* seconds */
    int remtime;		/* remaining time in timeout */
    int reset_timer;		/* should timer be reset after continue? */

    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(argv[1],"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
    }

    time(&start_time_total);
    start_time = start_time_total;
    reset_timer = TRUE;
    
    /* make arg list for processing cases */
    /* do it dynamically, since expect can be called recursively */
d2345 6
a2350 6
    exp_cmd_init(&eg,EXP_CMD_FG,EXP_TEMPORARY);
    state_list = 0;
    esPtrs = 0;
    if (TCL_ERROR == parse_expect_args(interp,&eg,
	    (ExpState *)clientData,objc,objv))
	return TCL_ERROR;
d2353 2
a2354 1
    /* validate all descriptors and flatten ExpStates into array */
d2356 6
a2361 6
    if ((TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_BEFORE].i_list,&state_list))
	    || (TCL_ERROR == update_expect_states(exp_cmds[EXP_CMD_AFTER].i_list, &state_list))
	    || (TCL_ERROR == update_expect_states(eg.i_list,&state_list))) {
	result = TCL_ERROR;
	goto cleanup;
    }
d2363 2
a2364 2
    /* declare ourselves "in sync" with external view of close/indirect */
    configure_count = exp_configure_count;
d2366 9
a2374 8
    /* count and validate state_list */
    mcount = 0;
    for (slPtr=state_list;slPtr;slPtr=slPtr->next) {
	mcount++;
	/* validate all input descriptors */
	if (!expStateCheck(interp,slPtr->esPtr,1,1,"expect")) {
	    result = TCL_ERROR;
	    goto cleanup;
a2375 1
    }
d2377 5
a2381 5
    /* make into an array */
    esPtrs = (ExpState **)ckalloc(mcount * sizeof(ExpState *));
    for (slPtr=state_list,i=0;slPtr;slPtr=slPtr->next,i++) {
	esPtrs[i] = slPtr->esPtr;
    }
d2383 3
a2385 3
  restart:
    if (first_time) first_time = 0;
    else time(&start_time);
d2387 6
a2392 6
    if (eg.timeout_specified_by_flag) {
	timeout = eg.timeout;
    } else {
	/* get the latest timeout */
	timeout = get_timeout(interp);
    }
d2394 1
a2394 1
    key = expect_key++;
d2396 2
a2397 2
    result = TCL_OK;
    last_esPtr = 0;
d2399 1
a2399 3
    /*
     * end of restart code
     */
d2401 3
a2403 3
    eo.e = 0;		/* no final case yet */
    eo.esPtr = 0;	/* no final ExpState selected yet */
    eo.match = 0;	/* nothing matched yet */
d2405 9
a2413 8
    /* timeout code is a little tricky, be very careful changing it */
    if (timeout != EXP_TIME_INFINITY) {
	/* if exp_continue -continue_timer, do not update end_time */
	if (reset_timer) {
	    time(&current_time);
	    end_time = current_time + timeout;
	} else {
	    reset_timer = TRUE;
a2414 1
    }
d2416 2
a2417 2
    /* remtime and current_time updated at bottom of loop */
    remtime = timeout;
d2419 19
a2437 6
    for (;;) {
	if ((timeout != EXP_TIME_INFINITY) && (remtime < 0)) {
	    cc = EXP_TIMEOUT;
	} else {
	    cc = expRead(interp,esPtrs,mcount,&esPtr,remtime,key);
	}
d2439 2
a2440 15
	/*SUPPRESS 530*/
	if (cc == EXP_EOF) {
	    /* do nothing */
	} else if (cc == EXP_TIMEOUT) {
	    expDiagLogU("expect: timed out\r\n");
	} else if (cc == EXP_RECONFIGURE) {
	    reset_timer = FALSE;
	    goto restart_with_update;
	} else if (cc < 0) { /* EXP_TCLERROR or any other weird value*/
	    goto error;
	} else {
	    /* new data if cc > 0, same old data if cc == 0 */
	    
	    /* below here, cc as general status */
	    cc = EXP_NOMATCH;
d2442 3
a2444 3
	    /* force redisplay of buffer when debugging */
	    last_esPtr = 0;
	}
d2446 17
a2462 17
	cc = eval_cases(interp,&exp_cmds[EXP_CMD_BEFORE],
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
	cc = eval_cases(interp,&eg,
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
	cc = eval_cases(interp,&exp_cmds[EXP_CMD_AFTER],
		esPtr,&eo,&last_esPtr,&last_case,cc,esPtrs,mcount,"");
	if (cc == EXP_TCLERROR) goto error;
	/* special eof code that cannot be done in eval_cases */
	/* or above, because it would then be executed several times */
	if (cc == EXP_EOF) {
	    eo.esPtr = esPtr;
	    eo.match = expGetSize(eo.esPtr);
	    eo.buffer = eo.esPtr->buffer;
	    expDiagLogU("expect: read eof\r\n");
	    break;
	} else if (cc == EXP_TIMEOUT) break;
	/* break if timeout or eof and failed to find a case for it */
d2464 1
a2464 1
	if (eo.e) break;
d2466 2
a2467 2
	/* no match was made with current data, force a read */
	esPtr->force_read = TRUE;
d2469 4
a2472 3
	if (timeout != EXP_TIME_INFINITY) {
	    time(&current_time);
	    remtime = end_time - current_time;
a2473 1
    }
d2475 1
a2475 1
    goto done;
d2478 1
a2478 1
    result = exp_2tcl_returnvalue(cc);
d2480 8
a2487 3
    if (result != TCL_ERROR) {
	result = expMatchProcess(interp, &eo, 0 /* not bg */,"expect");
    }
d2490 24
a2513 4
    if (result == EXP_CONTINUE_TIMER) {
	reset_timer = FALSE;
	result = EXP_CONTINUE;
    }
d2515 2
a2516 4
    if ((result == EXP_CONTINUE) && (configure_count == exp_configure_count)) {
	expDiagLogU("expect: continuing expect\r\n");
	goto restart;
    }
d2518 3
a2520 8
    if (state_list) {
	exp_free_state(state_list);
	state_list = 0;
    }
    if (esPtrs) {
	ckfree((char *)esPtrs);
	esPtrs = 0;
    }
d2522 1
a2522 4
    if (result == EXP_CONTINUE) {
	expDiagLogU("expect: continuing expect after update\r\n");
	goto restart_with_update;
    }
d2524 9
a2532 2
    free_ecases(interp,&eg,0);	/* requires i_lists to be avail */
    exp_free_i(interp,eg.i_list,exp_indirect_update2);
d2534 27
a2560 1
    return(result);
d2562 1
d2668 1
a2668 1
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
d2673 1
a2673 1
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"match_max")))
d2717 4
a2720 4
    int value = -1;
    ExpState *esPtr = 0;
    chanName = 0;
    int Default = FALSE;
d2722 1
a2722 1
    argc--; argv++;
d2724 12
a2735 12
    for (;argc>0;argc--,argv++) {
	if (streq(*argv,"-d")) {
	    Default = TRUE;
	} else if (streq(*argv,"-i")) {
	    argc--;argv++;
	    if (argc < 1) {
		exp_error(interp,"-i needs argument");
		return(TCL_ERROR);
	    }
	    chanName = *argv;
	} else break;
    }
d2737 10
a2746 6
    if (!Default) {
	if (!chanName) {
	    if (!(esPtr = expStateCurrent(interp,0,0,0)))
		return(TCL_ERROR);
	} else {
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"remove_nulls")))
a2748 4
    } else if (m != -1) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }
d2750 8
a2757 5
    if (argc == 0) {
	if (Default) {
	    value = exp_default_match_max;
	} else {
	    value = esPtr->rm_nulls;
a2758 3
	sprintf(interp->result,"%d",value);
	return(TCL_OK);
    }
d2760 4
a2763 4
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
    }
d2765 6
a2770 6
    /* all that's left is to set the value */
    value = atoi(argv[0]);
    if (value != 0 && value != 1) {
	exp_error(interp,"must be 0 or 1");
	return(TCL_ERROR);
    }
d2772 2
a2773 2
    if (Default) exp_default_rm_nulls = value;
    else esPtr->rm_nulls = value;
d2775 1
a2775 1
    return(TCL_OK);
d2808 1
a2808 1
	    if (!(esPtr = expStateCurrent(interp,0,0,0))) {
d2812 1
a2812 1
	    if (!(esPtr = expStateFromChannelName(interp,chanName,0,0,0,"parity"))) {
d2925 1
a2925 1
expExpectVarsInit()
@


5.29.2.7
log
@made stuff compile
@
text
@d1558 2
a1559 4
	/* invalidate the unicode rep */
	if (obj->typePtr->freeIntRepProc) {
	    obj->typePtr->freeIntRepProc(obj);
	}
d1601 2
d1622 1
a1622 1
	    1 /* append */);
a1644 1
	/* strip parity if requested */
a1647 1
	cc = expSizeGet(esPtr); /* generate true byte count */
d1649 2
a1650 1
    return cc;	
a2602 1
#if OBSOLETEWITH81
a2614 1
#endif
@


5.29.2.8
log
@making expect.c compile
@
text
@d342 1
a342 2
    Tcl_Obj *staticObjArray[NUM_STATIC_OBJS];
    int maxobjs = NUM_STATIC_OBJS;
d344 2
a345 2
    char *p, *next;
    int length, rc;
d347 2
a348 2
    int objc, bytesLeft, numWords, i;
    Tcl_Parse parse;
d651 1
a651 1
			default_esPtr = expStateCurrent(interp,0,0,1);
d691 1
a691 1
		    default_esPtr = expStateCurrent(interp,0,0,1);
d797 1
a797 1
    if ((esPtr != *last_esPtr) || e->Case != *last_case) {
d799 1
a799 1
	expDiagLogU(expPrintify(str));
d807 1
a807 1
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
d817 3
a819 2
	if (Tcl_RegExpMatchObj(interp, re, buffer, 0 /* offset */,
		-1 /* nmatches */, 0 /* eflags */) < 0) {
d842 1
a842 1
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
d872 1
a872 1
	expDiagLogU(expPrintify(Tcl_GetString(e->pat)));
d900 1
a900 1
	expDiagLogU(Tcl_GetString(e->pat));
d924 1
a924 1
ExpState *(esPtrs[]);
d951 1
a951 1
		    if (expStateAnyIs(em) || em == esPtr) {
d1139 1
a1139 1
exp_i_uses_fd(exp_i,esPtr)
d1141 1
a1141 1
ExpState *esPtr;
d1146 1
a1146 1
		if (fdp->esPtr == esPtr) return 1;
d1217 22
a1238 6
    struct exp_i *exp_i;
    int i;
    int direct = EXP_DIRECT|EXP_INDIRECT;
    char *iflag = 0;
    int all = FALSE;	/* report on all fds */
    ExpState *esPtr = 0;
d1240 12
a1251 13
    while (*argv) {
	if (streq(argv[0],"-i") && argv[1]) {
	    iflag = argv[1];
	    argc-=2; argv+=2;
	} else if (streq(argv[0],"-all")) {
	    all = TRUE;
	    argc--; argv++;
	} else if (streq(argv[0],"-noindirect")) {
	    direct &= ~EXP_INDIRECT;
	    argc--; argv++;
	} else {
	    exp_error(interp,"usage: -info [-all | -i spawn_id]\n");
	    return TCL_ERROR;
a1252 1
    }
d1254 3
a1256 8
    if (all) {
	/* avoid printing out -i when redundant */
	struct exp_i *previous = 0;

	for (i=0;i<ecmd->ecd.count;i++) {
	    if (previous != ecmd->ecd.cases[i]->i_list) {
		exp_i_append(interp,ecmd->ecd.cases[i]->i_list);
		previous = ecmd->ecd.cases[i]->i_list;
d1258 12
a1269 1
	    ecase_append(interp,ecmd->ecd.cases[i]);
a1270 2
	return TCL_OK;
    }
d1272 5
a1276 12
    if (!iflag) {
	if (!(esPtr = expStateCurrent(interp,0,0,0))) {
	    return TCL_ERROR;
	}
    } else if (!(esPtr = expStateFromChannelName(interp,iflag,0,0,0,"dummy"))) {
	/* not a valid ExpState so assume it is an indirect variable */
	Tcl_ResetResult(interp);
	for (i=0;i<ecmd->ecd.count;i++) {
	    if (ecmd->ecd.cases[i]->i_list->direct == EXP_INDIRECT &&
		    streq(ecmd->ecd.cases[i]->i_list->variable,iflag)) {
		ecase_append(interp,ecmd->ecd.cases[i]);
	    }
d1278 1
a1279 10
    }
    
    /* print ecases of this direct_fd */
    for (exp_i=ecmd->i_list;exp_i;exp_i=exp_i->next) {
	if (!(direct & exp_i->direct)) continue;
	if (!exp_i_uses_state(exp_i,esPtr)) continue;
	ecase_by_exp_i_append(interp,ecmd,exp_i);
    }

    return TCL_OK;
d1282 1
a1282 1
/* Exp_ExpectGlobalCmd is invoked to process expect_before/after/background */
d1285 1
a1285 1
Exp_ExpectGlobalCmd(clientData, interp, objc, objv)
d1288 2
a1289 2
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d1299 7
a1305 7
    if ((objc == 2) && exp_one_arg_braced(objv[1])) {
	return(exp_eval_with_one_arg(clientData,interp,objv));
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
	Tcl_Obj *new_objv[2];
	new_objv[0] = objv[0];
	new_objv[1] = objv[2];
	return(exp_eval_with_one_arg(clientData,interp,new_objv));
d1308 3
a1310 3
    if (objc > 1 && (Tcl_GetString(objv[1])[0] == '-')) {
	if (exp_flageq("info",Tcl_GetString(objv[1])+1,4)) {
	    return(expect_info(interp,ecmd,objc-2,objv+2));
d1317 1
a1317 1
	    objc,objv)) {
d1332 1
a1332 1
	    ExpState *esPtr = slPtr->esPtr;
a1485 1
    char *p;
d1509 1
a1509 1
	    for (p=string;;p=Tcl_UtfNext(p)) {
d1515 1
a1515 1
	    newObj = Tcl_NewStringObj(string + excessBytes,length - excessBytes);
d1549 1
a1549 1
    int changed = FALSE;
d1672 1
a1672 1
ExpState *(esPtrs[]);		/* If 0, then m is already known and set. */
d1691 1
a1691 1
	cc = exp_get_next_event_info(interp,esPtr,esPtrsMax);
d1761 1
a1761 1
	expLogInteractionU(esPtr,Tcl_GetString(esPtr->buffer) + esPtr->printed);
a1786 1
    char *first_half_bytes;
d1821 1
a1821 1
    expDiagLogU(expPrintify(Tcl_GetString(esPtr->buffer)));
d1979 1
a1979 1
			ExpState *esPtr = slPtr->esPtr;
d2017 1
a2017 1
	    if (!expStateCheck(interp,slPtr->esPtr,1,1,
d2035 1
a2035 1
expMatchProcess(interp, eo, cc, bg, detail)
a2037 1
    int cc;			/* EOF, TIMEOUT, etc... */
d2043 1
a2043 1
    Tcl_Obj *body = 0;
d2049 1
a2049 1
    Tcl_Obj *eof_body = 0;
d2053 1
a2053 1
 expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,indexName); \
a2074 1
	int i;
d2077 1
a2077 1
	    Tcl_RegExp re;
d2099 1
a2099 1
		    /* start index */
d2101 2
a2102 1
		    offset = sprintf(value,"%d",start);
d2105 1
a2105 1
		    /* end index */
d2117 2
a2118 1
		Tcl_SetVar2Ex(interp,EXPECT_OUT,name,val,TCL_GLOBAL_ONLY);
d2165 2
a2166 1
	/* Save buf[0..match] */
d2187 5
a2191 1
	    if (body) Tcl_IncrRefCount(body);
d2198 1
a2198 1
	    result = Tcl_EvalObj(interp,body);
d2200 1
a2200 1
	    result = Tcl_GlobalEvalObj(interp,body);
d2203 1
a2203 1
	if (cc == EXP_EOF) Tcl_DecrRefCount(body);
d2296 1
a2296 1
    expMatchProcess(interp, &eo, cc, 1 /* bg */,"expect_background");
d2509 1
a2509 1
	result = expMatchProcess(interp, &eo, cc, 0 /* not bg */,"expect");
@


5.29.2.9
log
@Checkpoint
@
text
@a67 8
/*
 * addr of these placeholders appear as clientData in ExpectCmd * when called
 * as expect_user and expect_tty.  It would be nicer * to invoked
 * expDevttyGet() but C doesn't allow this in an array initialization, sigh.
 */
static ExpState StdinoutPlaceholder;
static ExpState DevttyPlaceholder;

d1783 2
d1786 1
a1786 6
    char *middleGuess;
    char *p;
    char *end;
    int length, newlen;
    int skiplen;
    char lostByte;
d1808 3
a1810 4
    str = Tcl_GetStringFromObj(esPtr->buffer,&length);

    /* guess at the middle */
    middleGuess = str + length/2;
d1812 2
a1813 10
    /* crawl our way into the middle of the string
     * to make sure we are at a UTF char boundary
     */
    for (p=str;*p;p = Tcl_UtfNext(p)) {
	if (p > middleGuess) break;   /* ok, that's enough */
    }

    /*
     * p is now at the beginning of a UTF char
     */
d1815 1
d1817 2
a1818 10
    /*
     * before doing move, show user data we are discarding
     */
    end = strchr(p,'\0');
    length = end - p;
    
    skiplen = p-str;
    lostByte = *p;
    /* temporarily stick null in middle of string */
    Tcl_SetObjLength(esPtr->buffer,skiplen);
d1826 1
a1826 15
    /*
     * restore damage
     */
    *p = lostByte;

    /*
     * move 2nd half of string down to 1st half
     */

    newlen = length - skiplen;
    memmove(str,p, newlen);

    Tcl_SetObjLength(esPtr->buffer,newlen);

    esPtr->printed -= skiplen;
d2036 1
a2036 1
    Tcl_Interp *interp;
d2057 1
a2057 1
 Tcl_SetVar2(interp, EXPECT_OUT,indexName,value,(bg ? TCL_GLOBAL_ONLY : 0));
a2160 1
	int length;
d2193 1
a2193 2
/*SCOTT - is DIRECT correct? */
	    result = Tcl_EvalObjEx(interp,body,TCL_EVAL_DIRECT);
d2195 1
a2195 1
	    result = Tcl_EvalObjEx(interp,body,TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL);
d2222 1
a2222 1
    esPtr = (ExpState *)clientData;
d2298 1
a2298 8

    /*
     * Connection could have been closed on us.  In this case,
     * exitWhenBgStatusUnblocked will be 1 and we should disable the channel
     * handler and release the esPtr.
     */

    if ((!esPtr->freeWhenBgHandlerUnblocked) && (esPtr->bg_status == blocked)) {
d2304 3
a2306 3
    exp_unblock_background_channelhandler(esPtr);
    if (esPtr->freeWhenBgHandlerUnblocked)
	expStateFree(esPtr);
d2353 1
a2353 1
    } else if ((objc == 3) && streq(Tcl_GetString(objv[1]),"-brace")) {
a2363 6
    if (&StdinoutPlaceholder == (ExpState *)clientData) {
	clientData = (ClientData) expStdinoutGet();
    } else if (&DevttyPlaceholder == (ExpState *)clientData) {
	clientData = (ClientData) expDevttyGet();
    }
	
a2641 5
    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

d2652 3
d2657 8
a2664 5
    if (argc == 0) {
	if (Default) {
	    size = exp_default_match_max;
	} else {
	    size = esPtr->umsize;
a2665 3
	sprintf(interp->result,"%d",size);
	return(TCL_OK);
    }
d2667 4
a2670 8
    if (argc > 1) {
	exp_error(interp,"too many arguments");
	return(TCL_OK);
    }
    
    /*
     * All that's left is to set the size
     */
d2672 6
a2677 5
    size = atoi(argv[0]);
    if (size <= 0) {
	exp_error(interp,"must be positive");
	return(TCL_ERROR);
    }
d2679 2
a2680 2
    if (Default) exp_default_match_max = size;
    else esPtr->umsize = size;
d2682 1
a2682 1
    return(TCL_OK);
d2695 1
a2695 1
    char *chanName = 0;
a2712 5
    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

d2721 3
a2781 5
    if (Default && chanName) {
	exp_error(interp,"cannot do -d and -i at the same time");
	return(TCL_ERROR);
    }

d2792 3
d2908 4
d2914 1
a2914 1
{"expect",	exp_proc(Exp_ExpectCmd),	(ClientData)0,	0},
d2917 2
a2918 2
{"expect_user",	exp_proc(Exp_ExpectCmd),	(ClientData)&StdinoutPlaceholder,0},
{"expect_tty",	exp_proc(Exp_ExpectCmd),	(ClientData)&DevttyPlaceholder,0},
d2922 1
a2922 1
{"parity",	exp_proc(Exp_ParityCmd),	0,	0},
a2930 2


@


5.29.2.10
log
@Fixed interact of all but regexp probs.
@
text
@d59 4
@


5.29.2.11
log
@updated interact code to use new regexp interfaces
fixed bug in eval_case_string where non-matches were reported as matches
@
text
@a796 1
    int result;
d822 2
a823 3
	result = Tcl_RegExpMatchObj(interp, re, buffer, 0 /* offset */,
		-1 /* nmatches */, 0 /* eflags */);
	if (result < 0) {
d826 1
a826 1
	} else if (result > 0) {
@


5.29.2.12
log
@expect.c and exp_inter.c now compile cleanly
@
text
@d2131 1
a2131 1
	    for (i=0;i<info.nsubs;i++) {
@


5.29.2.13
log
@Everything but Dbg.c
@
text
@d573 1
a573 1
				TCL_REG_ADVANCED))) {
@


5.29.2.14
log
@compiled!
@
text
@d1145 1
a1145 1
exp_i_uses_state(exp_i,esPtr)
a1545 1
#if OBSOLETE
a1568 1
#endif /*OBSOLETE*/
d1650 4
a1687 1

d1696 1
a1696 1
	cc = exp_get_next_event_info(interp,*esPtrOut,esPtrsMax);
d1699 1
a1699 1
	cc = exp_get_next_event(interp,esPtrs,esPtrsMax,esPtrOut,timeout,key);
a1701 1
    esPtr = *esPtrOut;
d2233 2
a2234 1
	    result = Tcl_EvalObjEx(interp,body,0);
d2236 1
a2236 1
	    result = Tcl_EvalObjEx(interp,body,TCL_EVAL_GLOBAL);
d2359 1
a2359 1
Exp_ExpectObjCmd(clientData, interp, objc, objv)
d2534 1
a2534 1
	    eo.match = expSizeGet(eo.esPtr);
d2973 1
a2973 1
{"expect",	Exp_ExpectObjCmd,	0,	(ClientData)0,	0},
d2976 2
a2977 2
{"expect_user",	Exp_ExpectObjCmd,	0,	(ClientData)&StdinoutPlaceholder,0},
{"expect_tty",	Exp_ExpectObjCmd,	0,	(ClientData)&DevttyPlaceholder,0},
@


5.29.2.15
log
@-gl now appears to work
@
text
@a553 1
			i++;
d559 1
a559 2
			i++;
			if (i >= objc) {
d572 1
a572 1
			if (!(Tcl_GetRegExpFromObj(interp, objv[i],
a577 1
			i++;
d668 1
d1585 4
a1588 2
	src += Tcl_UtfToUniChar(src,&uc);
	if (uc != 0) {
d2131 1
a2131 1
	    for (i=0;i<=info.nsubs;i++) {
d2173 1
a2173 1
	    str = Tcl_GetString(esPtr->buffer) + e->simple_start;
d2177 1
a2177 1
	    out("0,string",str);
@


5.29.2.16
log
@Updated to reflect change of Tcl_RegExpMatchObj to Tcl_RegExpExecObj
moved compiler configure tests earlier in file so it works with gcc
@
text
@d825 1
a825 1
	result = Tcl_RegExpExecObj(interp, re, buffer, 0 /* offset */,
@


5.29.2.17
log
@Fixed:
 expect command's arg handling to work (like interact)
 spawn -open
 expect eof
and various other bugs.
Expect now runs its minimal test suite (but not the examples).
@
text
@d93 1
d390 1
a390 1
		newobjs = (Tcl_Obj **)ckalloc(maxobjs * sizeof (Tcl_Obj *));
d451 1
d501 26
a526 4
    int index;
    int i;
    char *string;
    struct ecase ec;	/* temporary to collect args */
d528 2
a529 1
    eg->timeout_specified_by_flag = FALSE;
d531 36
a566 1
    ecase_clear(&ec);
d568 15
a582 22
    /* Allocate an array to store the ecases.  Force array even if 0 */
    /* cases.  This will often be too large (i.e., if there are flags) */
    /* but won't affect anything. */

    eg->ecd.cases = (struct ecase **)ckalloc(sizeof(struct ecase *) * (1+(objc/2)));

    eg->ecd.count = 0;

    for (i = 1;i<objc;i++) {
	string = Tcl_GetString(objv[i]);
	if (string[0] == '-') {
	    static char *flags[] = {
		"-glob", "-regexp", "-exact", "-notransfer", "-nocase",
		"-i", "-indices", "-iread", "-timestamp", "-timeout",
		"-nobrace", (char *) NULL
	    };
	    enum flags {
		EXP_ARG_GLOB, EXP_ARG_REGEXP, EXP_ARG_EXACT,
		EXP_ARG_NOTRANSFER, EXP_ARG_NOCASE, EXP_ARG_SPAWN_ID,
		EXP_ARG_INDICES, EXP_ARG_IREAD, EXP_ARG_TIMESTAMP,
		EXP_ARG_DASH_TIMEOUT, EXP_ARG_NOBRACE
	    };
d584 12
a595 4
	    /*
	     * Allow abbreviations of switches and report an error if we
	     * get an invalid switch.
	     */
d597 41
a637 14
	    if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
		    &index) != TCL_OK) {
		return TCL_ERROR;
	    }
	    switch ((enum flags) index) {
	    case EXP_ARG_GLOB:
		i++;
		/* assignment here is not actually necessary */
		/* since cases are initialized this way above */
		/* ec.use = PAT_GLOB; */
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,
				     "-glob pattern");
		    return TCL_ERROR;
a638 10
		goto pattern;
	    case EXP_ARG_REGEXP:
		i++;
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,
				     "-regexp regexp");
		    return TCL_ERROR;
		}
		ec.use = PAT_RE;

d640 2
a641 3
		 * Try compiling the expression so we can report
		 * any errors now rather then when we first try to
		 * use it.
d643 1
a643 63

		if (!(Tcl_GetRegExpFromObj(interp, objv[i],
					   TCL_REG_ADVANCED))) {
		    goto error;
		}
		goto pattern;
	    case EXP_ARG_EXACT:
		i++;
		if (i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-exact string");
		    return TCL_ERROR;
		}
		ec.use = PAT_EXACT;
		goto pattern;
	    case EXP_ARG_NOTRANSFER:
		ec.transfer = 0;
		break;
	    case EXP_ARG_NOCASE:
		ec.Case = CASE_LOWER;
		break;
	    case EXP_ARG_SPAWN_ID:
		i++;
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-i spawn_id");
		    goto error;
		}
		ec.i_list = exp_new_i_complex(interp,
				      Tcl_GetString(objv[i]),
				      eg->duration, exp_indirect_update2);
		ec.i_list->cmdtype = eg->cmdtype;

		/* link new i_list to head of list */
		ec.i_list->next = eg->i_list;
		eg->i_list = ec.i_list;
		break;
	    case EXP_ARG_INDICES:
		ec.indices = TRUE;
		break;
	    case EXP_ARG_IREAD:
		ec.iread = TRUE;
		break;
	    case EXP_ARG_TIMESTAMP:
		ec.timestamp = TRUE;
		break;
	    case EXP_ARG_DASH_TIMEOUT:
		i++;
		if (i>=objc) {
		    Tcl_WrongNumArgs(interp, 1, objv, "-timeout seconds");
		    goto error;
		}
		if (Tcl_GetIntFromObj(interp, objv[i],
				      &eg->timeout) != TCL_OK) {
		    goto error;
		}
		eg->timeout_specified_by_flag = TRUE;
		break;
	    case EXP_ARG_NOBRACE:
		/* nobrace does nothing but take up space */
		/* on the command line which prevents */
		/* us from re-expanding any command lines */
		/* of one argument that looks like it should */
		/* be expanded to multiple arguments. */
		break;
a644 18
	    /*
	     * Keep processing arguments, we aren't ready for the
	     * pattern yet.
	     */
	    continue;
	} else {
	    /*
	     * We have a pattern or keyword.
	     */

	    static char *keywords[] = {
		"timeout", "eof", "full_buffer", "default", "null",
		(char *)NULL
	    };
	    enum keywords {
		EXP_ARG_TIMEOUT, EXP_ARG_EOF, EXP_ARG_FULL_BUFFER,
		EXP_ARG_DEFAULT, EXP_ARG_NULL
	    };
d647 1
a647 1
	     * Match keywords exactly, otherwise they are patterns.
d650 1
a650 23
	    if (Tcl_GetIndexFromObj(interp, objv[i], keywords, "keyword",
		    1 /* exact */, &index) != TCL_OK) {
		Tcl_ResetResult(interp);
		goto pattern;
	    }
	    switch ((enum keywords) index) {
	    case EXP_ARG_TIMEOUT:
		ec.use = PAT_TIMEOUT;
		break;
	    case EXP_ARG_EOF:
		ec.use = PAT_EOF;
		break;
	    case EXP_ARG_FULL_BUFFER:
		ec.use = PAT_FULLBUFFER;
		break;
	    case EXP_ARG_DEFAULT:
		ec.use = PAT_DEFAULT;
		break;
	    case EXP_ARG_NULL:
		ec.use = PAT_NULL;
		break;
	    }
pattern:
a688 1
    }
d690 2
a691 2
    /* if no patterns at all have appeared force the current */
    /* spawn id to be added to list anyway */
d693 8
a700 7
    if (eg->i_list == 0) {
	if (default_esPtr != EXP_SPAWN_ID_BAD) {
	    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
	} else {
	    /* it'll be checked later, if used */
	    default_esPtr = expStateCurrent(interp,0,0,1);
	    eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
a701 1
    }
d703 1
a703 1
    return(TCL_OK);
d706 2
a707 2
    /* very hard to free case_master_list here if it hasn't already */
    /* been attached to a case, ugh */
d709 2
a710 2
    /* note that i_list must be avail to free ecases! */
    free_ecases(interp,eg,0);
d712 3
a714 3
    if (eg->i_list)
	exp_free_i(interp,eg->i_list,exp_indirect_update2);
    return(TCL_ERROR);
d827 4
a830 1
	if (result > 0) {
a844 4
	} else if (result == 0) {
	    expDiagLogU(no);
	} else { /* result < 0 */
	    return(EXP_TCLERROR);
d1166 1
d2651 15
@


5.29.2.18
log
@fixed examples
@
text
@d753 2
a754 2
    int match;			/* # of bytes in buffer that matched */
			        /* or # of bytes in buffer at EOF */
d874 1
a874 1
	int match; /* # of bytes that matched */
d1618 1
a1618 1
    Tcl_SetObjLength(obj,offsetBytes + (dest - src2));
d1676 4
@


5.29.2.19
log
@* expect.c: Fixed bug in token parsing where index was not being
incremented properly.

* configure.in: Changed version number to 5.31.

* aclocal.m4: Fixed CY_AC_LOAD_TKCONFIG so it tests for Tk_Init
instead of Tk_Main (which is only a macro in 8.1 and later).  Also
added TCL_BUILD_LIB_SPEC to the set of flags used in this test to
avoid linker errors.

* Dbgconfig.in: move CY_*_TCLCONFIG tests below AC_PROG_CC so it
will work with gcc
@
text
@d403 1
a403 1
		 numWords--, tokenPtr += (tokenPtr->numComponents + 1)) {
@


5.29.2.20
log
@Fixed interact's -input/-output.
More fixes to exp_eval_with_one_arg.
Now runs dislocate.
@
text
@d358 1
d406 1
a406 1
		if (objs[objc] == NULL) {
d417 1
d429 2
a430 1
 done:
d547 2
a548 1
		    Tcl_WrongNumArgs(interp, 1, objv,"-glob pattern");
d555 2
a556 1
		    Tcl_WrongNumArgs(interp, 1, objv,"-regexp regexp");
@


5.29.2.21
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d163 5
d171 57
d235 4
a238 4
    if (ec->i_list->duration == EXP_PERMANENT) {
	if (ec->pat) Tcl_DecrRefCount(ec->pat);
	if (ec->body) Tcl_DecrRefCount(ec->body);
    }
d240 5
a244 5
    if (free_ilist) {
	ec->i_list->ecount--;
	if (ec->i_list->ecount == 0)
	    exp_free_i(interp,ec->i_list,exp_indirect_update2);
    }
d246 1
a246 1
    ckfree((char *)ec);	/* NEW */
d349 1
a349 1
    int rc;
d496 1
a513 1
	int index;
d519 1
a519 1
		"-nobrace", (char *)0
d892 1
d914 1
d1240 1
a1240 1
expect_info(interp,ecmd,objc,objv)
d1243 2
a1244 2
int objc;
Tcl_Obj *CONST objv[];		/* Argument objects. */
d1253 5
a1257 24
    static char *flags[] = {"-i", "-all", "-noindirect", (char *)0};
    enum flags {EXP_ARG_I, EXP_ARG_ALL, EXP_ARG_NOINDIRECT};

    /* start with 2 to skip over "cmdname -info" */
    for (i = 2;i<objc;i++) {
	/*
	 * Allow abbreviations of switches and report an error if we
	 * get an invalid switch.
	 */

	int index;
	if (Tcl_GetIndexFromObj(interp, objv[i], flags, "flag", 0,
				&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum flags) index) {
	case EXP_ARG_I:
	    i++;
	    if (i >= objc) {
		Tcl_WrongNumArgs(interp, 1, objv,"-i spawn_id");
		return TCL_ERROR;
	    }
	    break;
	case EXP_ARG_ALL:
d1259 2
a1260 2
	    break;
	case EXP_ARG_NOINDIRECT:
d1262 4
a1265 1
	    break;
d1309 1
a1309 1
/* Exp_ExpectGlobalObjCmd is invoked to process expect_before/after/background */
d1312 1
a1312 1
Exp_ExpectGlobalObjCmd(clientData, interp, objc, objv)
d1320 1
a1320 1
    struct exp_state_list *slPtr;   /* temp for interating over state_list */
d1337 1
a1337 1
	    return(expect_info(interp,ecmd,objc,objv));
d1692 6
a1697 2
ExpState *(esPtrs[]);		/* If 0, then esPtrOut already known and set */
int esPtrsMax;			/* number of esPtrs */
d1712 1
a1712 1
	cc = exp_get_next_event_info(interp,*esPtrOut);
d2106 1
d2149 1
a2149 1
		int start, end;
d2159 1
a2159 1
		    sprintf(value,"%d",start);
d2215 1
d2271 1
d2276 1
d2292 1
a2292 3
	esPtr->notifiedMask = mask;
	esPtr->notified = FALSE;
	cc = expRead(interp,(ExpState **)0,0,&esPtr,EXP_TIME_INFINITY,0);
d2400 2
d2975 2
a2976 2
{"expect_after",Exp_ExpectGlobalObjCmd, 0,	(ClientData)&exp_cmds[EXP_CMD_AFTER],0},
{"expect_before",Exp_ExpectGlobalObjCmd,0,	(ClientData)&exp_cmds[EXP_CMD_BEFORE],0},
d2979 1
a2979 1
{"expect_background",Exp_ExpectGlobalObjCmd,0,	(ClientData)&exp_cmds[EXP_CMD_BG],0},
@


5.29.2.22
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d457 1
a457 1
		"-nobrace", "--", (char *)0
d463 1
a463 1
		EXP_ARG_DASH_TIMEOUT, EXP_ARG_NOBRACE, EXP_ARG_DASH
a476 1
	    case EXP_ARG_DASH:
d2118 1
a2118 1
		expDiagLog("%s: set %s(%s) \"",detail,EXPECT_OUT,name);
d2121 1
a2121 1
		Tcl_SetVar2Ex(interp,EXPECT_OUT,name,val,(bg ? TCL_GLOBAL_ONLY : 0));
@


5.29.2.23
log
@Wasn't catching bogus spawn ids properly in expect cmd.
@
text
@d617 3
a619 3
		        default_esPtr = expStateCurrent(interp,0,0,1);
		        if (!default_esPtr) goto error;
		        eg->i_list = exp_new_i_simple(default_esPtr,eg->duration);
a658 1
	    if (!default_esPtr) goto error;
@


5.29.2.24
log
@removed comment that no longer applies
@
text
@d657 1
@


5.29.2.25
log
@Fixed exp_internal command mishandling of args.

Fixed "expect -exact" which was looking at the wrong spot in the buffer.
@
text
@d845 1
a845 1
	    o->match = patLength;
d1758 1
d1796 1
a1796 1
     * p is now at the beginning of a UTF char in the middle of the string
d1799 1
d1803 3
@


5.29.2.26
log
@Fixes to library.
Testing new fix to system command.
@
text
@d17 3
d139 6
@


5.29.2.27
log
@Scriptics reported memory leak.  Was bug in parse_expect_args.
@
text
@d622 1
a622 1
	    if (eg->duration == EXP_PERMANENT) Tcl_IncrRefCount(ec.pat);
d627 1
a627 1
		if (eg->duration == EXP_PERMANENT) Tcl_IncrRefCount(ec.body);
@


5.28
log
@Initial revision
@
text
@d1834 6
a1839 1
			exp_fs[m].bg_ecount--;
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@
