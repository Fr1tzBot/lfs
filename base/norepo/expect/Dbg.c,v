head	5.46;
access;
symbols
	expect_5_45:5.46
	expect_6_branch:5.44.0.2
	expect_5_44_1_15:5.44
	activestate_win32_port_start:5.33
	win32-jump-point-1:5.31
	telco-tec-win32-take2-branch:5.31.0.4
	telco-tec-win32-branch:5.31.0.2
	expect-sf418892-sf439042-branch:5.30.0.2
	tclpro-1-5-0:5.30
	tclpro-1-4-1:5.30
	tclpro-1-4-0:5.30
	expect-5-32-2:5.30
	expect-5-32-0:5.30
	ajuba-ajuba2-2-0:5.28.1.1.2.8
	scriptics-sc-2-0-b5:5.28.1.1.2.8
	scriptics-sc-2-0-fixed:5.28.1.1.2.8
	scriptics-sc-2-0-b2:5.28.1.1.2.8
	scriptics-sc-2-0-b1:5.28.1.1.2.8
	scriptics-sc-1-1:5.28.1.1.2.8
	scriptics-sc-1-1-b1:5.28.1.1.2.8
	scriptics-sc-1-1-branch:5.28.1.1.2.8.0.4
	scriptics-sc-1-1-base:5.28.1.1.2.8
	scriptics-sc-1-0:5.28.1.1.2.8
	scriptics-sc-1-0-branch:5.28.1.1.2.8.0.2
	scriptics-sc-1-0-base:5.28.1.1.2.8
	expect-5-31-3:5.28.1.1.2.8
	scriptics-bc-1-0-b1:5.28.1.1.2.7
	scriptics-tclpro-1-3-0:5.28.1.1.2.7
	scriptics-tclpro-1-3-b4:5.28.1.1.2.7
	scriptics-tclpro-1-3-b3:5.28.1.1.2.7
	expect-5-31:5.28.1.1.2.7
	expect-5-31-branch:5.28.1.1.0.2
	expect-5-31-base:5.28.1.1
	scriptics-tclpro-1-2:5.28.1.1
	scriptics-tclpro-1-2-b2:5.28.1.1
	scriptics-tclpro-1-2-b1:5.28.1.1
	scriptics-tclpro-1-2-a1:5.28.1.1
	expect-5-28-1:5.28.1.1
	expect:5.28.1;
locks; strict;
comment	@ * @;


5.46
date	2010.08.31.18.30.29;	author andreas_kupries;	state Exp;
branches;
next	5.45;

5.45
date	2010.08.27.21.51.53;	author hobbs;	state Exp;
branches;
next	5.44;

5.44
date	2010.07.01.00.53.49;	author eee;	state Exp;
branches;
next	5.43;

5.43
date	2010.03.25.16.47.59;	author eee;	state Exp;
branches;
next	5.42;

5.42
date	2010.03.17.23.47.49;	author eee;	state Exp;
branches;
next	5.41;

5.41
date	2010.03.11.21.55.19;	author eee;	state Exp;
branches;
next	5.40;

5.40
date	2010.03.11.21.47.17;	author eee;	state Exp;
branches;
next	5.39;

5.39
date	2008.04.03.19.07.14;	author andreas_kupries;	state Exp;
branches;
next	5.38;

5.38
date	2008.02.29.17.47.33;	author andreas_kupries;	state Exp;
branches;
next	5.37;

5.37
date	2007.07.11.20.51.44;	author andreas_kupries;	state Exp;
branches;
next	5.36;

5.36
date	2007.07.11.20.22.10;	author andreas_kupries;	state Exp;
branches;
next	5.35;

5.35
date	2007.07.11.20.00.35;	author andreas_kupries;	state Exp;
branches;
next	5.34;

5.34
date	2005.03.29.23.08.17;	author andreas_kupries;	state Exp;
branches;
next	5.33;

5.33
date	2002.03.23.04.55.04;	author libes;	state Exp;
branches;
next	5.32;

5.32
date	2001.11.09.19.36.18;	author andreas_kupries;	state Exp;
branches;
next	5.31;

5.31
date	2001.08.02.00.30.14;	author hobbs;	state Exp;
branches
	5.31.2.1;
next	5.30;

5.30
date	2000.06.09.19.09.38;	author libes;	state Exp;
branches
	5.30.2.1;
next	5.29;

5.29
date	2000.01.06.23.22.00;	author wart;	state Exp;
branches;
next	5.28;

5.28
date	98.10.14.22.53.20;	author cvsadmin;	state Exp;
branches
	5.28.1.1;
next	;

5.28.1.1
date	98.10.14.22.53.20;	author cvsadmin;	state Exp;
branches
	5.28.1.1.2.1;
next	;

5.28.1.1.2.1
date	99.06.15.22.52.53;	author don;	state Exp;
branches;
next	5.28.1.1.2.2;

5.28.1.1.2.2
date	99.06.15.23.41.21;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.3;

5.28.1.1.2.3
date	99.06.16.08.15.57;	author don;	state Exp;
branches;
next	5.28.1.1.2.4;

5.28.1.1.2.4
date	99.06.18.01.41.49;	author stanton;	state Exp;
branches;
next	5.28.1.1.2.5;

5.28.1.1.2.5
date	99.06.28.06.29.21;	author libes;	state Exp;
branches;
next	5.28.1.1.2.6;

5.28.1.1.2.6
date	99.06.29.02.27.45;	author libes;	state Exp;
branches;
next	5.28.1.1.2.7;

5.28.1.1.2.7
date	99.07.03.03.44.12;	author libes;	state Exp;
branches;
next	5.28.1.1.2.8;

5.28.1.1.2.8
date	99.10.06.05.54.16;	author libes;	state Exp;
branches;
next	;

5.30.2.1
date	2001.08.02.00.31.40;	author hobbs;	state Exp;
branches;
next	;

5.31.2.1
date	2001.10.02.23.04.51;	author davygrvy;	state dead;
branches;
next	;


desc
@@


5.46
log
@
	* Dbg.c: [Bug 2972727]: Applied the parts of Larry Virden's patch
	  which were still current. Most of it applied to the partially
	  ansified sources we had in trunk for a time and where errors in
	  that set of changes, thus out of date now.
@
text
@/* Dbg.c - Tcl Debugger - See cmdHelp() for commands

Written by: Don Libes, NIST, 3/23/93

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.

*/

#include <stdio.h>

#ifndef HAVE_STRCHR
#define strchr(s,c) index(s,c)
#endif /* HAVE_STRCHR */

#if 0
/* tclInt.h drags in stdlib.  By claiming no-stdlib, force it to drag in */
/* Tcl's compat version.  This avoids having to test for its presence */
/* which is too tricky - configure can't generate two cf files, so when */
/* Expect (or any app) uses the debugger, there's no way to get the info */
/* about whether stdlib exists or not, except pointing the debugger at */
/* an app-dependent .h file and I don't want to do that. */
#define NO_STDLIB_H
#endif


#include "tclInt.h"
/*#include <varargs.h>		tclInt.h drags in varargs.h.  Since Pyramid */
/*				objects to including varargs.h twice, just */
/*				omit this one. */
/*#include "string.h"		tclInt.h drags this in, too! */
#include "tcldbg.h"

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

static int simple_interactor (Tcl_Interp *interp, ClientData data);
static int zero (Tcl_Interp *interp, char *string);

/* most of the static variables in this file may be */
/* moved into Tcl_Interp */

static Dbg_InterProc *interactor = &simple_interactor;
static ClientData interdata = 0;
static Dbg_IgnoreFuncsProc *ignoreproc = &zero;
static Dbg_OutputProc *printproc = 0;
static ClientData printdata = 0;
static int stdinmode;

static void print _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp));

static int debugger_active = FALSE;

/* this is not externally documented anywhere as of yet */
char *Dbg_VarName = "dbg";

#define DEFAULT_COMPRESS	0
static int compress = DEFAULT_COMPRESS;
#define DEFAULT_WIDTH		75	/* leave a little space for printing */
					/*  stack level */
static int buf_width = DEFAULT_WIDTH;

static int main_argc = 1;
static char *default_argv = "application";
static char **main_argv = &default_argv;

static Tcl_Trace debug_handle;
static int step_count = 1;	/* count next/step */

#define FRAMENAMELEN 10		/* enough to hold strings like "#4" */
static char viewFrameName[FRAMENAMELEN];/* destination frame name for up/down */

static CallFrame *goalFramePtr;	/* destination for next/return */
static int goalNumLevel;	/* destination for Next */

static enum debug_cmd {
	none, step, next, ret, cont, up, down, where, Next
} debug_cmd = step;

/* info about last action to use as a default */
static enum debug_cmd last_action_cmd = next;
static int last_step_count = 1;

/* this acts as a strobe (while testing breakpoints).  It is set to true */
/* every time a new debugger command is issued that is an action */
static int debug_new_action;

#define NO_LINE -1	/* if break point is not set by line number */

struct breakpoint {
	int id;
	Tcl_Obj *file;	/* file where breakpoint is */
	int line;	/* line where breakpoint is */
	int re;		/* 1 if this is regexp pattern */
	Tcl_Obj *pat;	/* pattern defining where breakpoint can be */
	Tcl_Obj *expr;	/* expr to trigger breakpoint */
	Tcl_Obj *cmd;	/* cmd to eval at breakpoint */
	struct breakpoint *next, *previous;
};

static struct breakpoint *break_base = 0;
static int breakpoint_max_id = 0;

static struct breakpoint *
breakpoint_new()
{
	struct breakpoint *b = (struct breakpoint *)ckalloc(sizeof(struct breakpoint));
	if (break_base) break_base->previous = b;
	b->next = break_base;
	b->previous = 0;
	b->id = breakpoint_max_id++;
	b->file = 0;
	b->line = NO_LINE;
	b->pat = 0;
	b->re = 0;
	b->expr = 0;
	b->cmd = 0;
	break_base = b;
	return(b);
}

static
void
breakpoint_print(interp,b)
Tcl_Interp *interp;
struct breakpoint *b;
{
    print(interp,"breakpoint %d: ",b->id);

    if (b->re) {
	print(interp,"-re \"%s\" ",Tcl_GetString(b->pat));
    } else if (b->pat) {
	print(interp,"-glob \"%s\" ",Tcl_GetString(b->pat));
    } else if (b->line != NO_LINE) {
	if (b->file) {
	    print(interp,"%s:",Tcl_GetString(b->file));
	}
	print(interp,"%d ",b->line);
    }

    if (b->expr)
	print(interp,"if {%s} ",Tcl_GetString(b->expr));

    if (b->cmd)
	print(interp,"then {%s}",Tcl_GetString(b->cmd));

    print(interp,"\n");
}

static void
save_re_matches(interp, re, objPtr)
Tcl_Interp *interp;
Tcl_RegExp re;
Tcl_Obj *objPtr;
{
    Tcl_RegExpInfo info;
    int i, start;
    char name[20];

    Tcl_RegExpGetInfo(re, &info); 
    for (i=0;i<=info.nsubs;i++) {
	start = info.matches[i].start;
	/* end = info.matches[i].end-1;*/

	if (start == -1) continue;

	sprintf(name,"%d",i);
	Tcl_SetVar2Ex(interp, Dbg_VarName, name, Tcl_GetRange(objPtr,
		info.matches[i].start, info.matches[i].end-1), 0);
    }
}

/* return 1 to break, 0 to continue */
static int
breakpoint_test(interp,cmd,bp)
Tcl_Interp *interp;
char *cmd;		/* command about to be executed */
struct breakpoint *bp;	/* breakpoint to test */
{
    if (bp->re) {
        int found = 0;
	Tcl_Obj *cmdObj;
	Tcl_RegExp re = Tcl_GetRegExpFromObj(NULL, bp->pat,
		TCL_REG_ADVANCED);
	cmdObj = Tcl_NewStringObj(cmd,-1);
	Tcl_IncrRefCount(cmdObj);
	if (Tcl_RegExpExecObj(NULL, re, cmdObj, 0 /* offset */,
		-1 /* nmatches */, 0 /* eflags */) > 0) {
	    save_re_matches(interp, re, cmdObj);
	    found = 1;
	}
	Tcl_DecrRefCount(cmdObj);
	if (!found) return 0;
    } else if (bp->pat) {
	if (0 == Tcl_StringMatch(cmd,
		Tcl_GetString(bp->pat))) return 0;
    } else if (bp->line != NO_LINE) {
	/* not yet implemented - awaiting support from Tcl */
	return 0;
    }

    if (bp->expr) {
	int value;

	/* ignore errors, since they are likely due to */
	/* simply being out of scope a lot */
	if (TCL_OK != Tcl_ExprBooleanObj(interp,bp->expr,&value)
		|| (value == 0)) return 0;
    }

    if (bp->cmd) {
	Tcl_EvalObjEx(interp, bp->cmd, 0);
    } else {
	breakpoint_print(interp,bp);
    }

    return 1;
}

static char *already_at_top_level = "already at top level";

/* similar to TclGetFrame but takes two frame ptrs and a direction.
If direction is up,   search up stack from curFrame
If direction is down, simulate searching down stack by
		      seaching up stack from origFrame
*/
static
int
TclGetFrame2(interp, origFramePtr, string, framePtrPtr, dir)
    Tcl_Interp *interp;
    CallFrame *origFramePtr;	/* frame that is true top-of-stack */
    char *string;		/* String describing frame. */
    CallFrame **framePtrPtr;	/* Store pointer to frame here (or NULL
				 * if global frame indicated). */
    enum debug_cmd dir;	/* look up or down the stack */
{
    Interp *iPtr = (Interp *) interp;
    int level, result;
    CallFrame *framePtr;	/* frame currently being searched */

    CallFrame *curFramePtr = iPtr->varFramePtr;

    /*
     * Parse string to figure out which level number to go to.
     */

    result = 1;
    if (*string == '#') {
	if (Tcl_GetInt(interp, string+1, &level) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (level < 0) {
	    levelError:
	    Tcl_AppendResult(interp, "bad level \"", string, "\"",
		    (char *) NULL);
	    return TCL_ERROR;
	}
	framePtr = origFramePtr; /* start search here */
	
    } else if (isdigit(*string)) {
	if (Tcl_GetInt(interp, string, &level) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (dir == up) {
		if (curFramePtr == 0) {
			Tcl_SetResult(interp,already_at_top_level,TCL_STATIC);
			return TCL_ERROR;
		}
		level = curFramePtr->level - level;
		framePtr = curFramePtr; /* start search here */
	} else {
		if (curFramePtr != 0) {
			level = curFramePtr->level + level;
		}
		framePtr = origFramePtr; /* start search here */
	}
    } else {
	level = curFramePtr->level - 1;
	result = 0;
    }

    /*
     * Figure out which frame to use.
     */

    if (level == 0) {
	framePtr = NULL;
    } else {
	for (;framePtr != NULL;	framePtr = framePtr->callerVarPtr) {
	    if (framePtr->level == level) {
		break;
	    }
	}
	if (framePtr == NULL) {
	    goto levelError;
	}
    }
    *framePtrPtr = framePtr;
    return result;
}


static char *printify(s)
char *s;
{
    static int destlen = 0;
    char *d;		/* ptr into dest */
    unsigned int need;
    static char buf_basic[DEFAULT_WIDTH+1];
    static char *dest = buf_basic;
    Tcl_UniChar ch;

    if (s == 0) return("<null>");

    /* worst case is every character takes 4 to printify */
    need = strlen(s)*6;
    if (need > destlen) {
	if (dest && (dest != buf_basic)) ckfree(dest);
	dest = (char *)ckalloc(need+1);
	destlen = need;
    }

    for (d = dest;*s;) {
	s += Tcl_UtfToUniChar(s, &ch);
	if (ch == '\b') {
	    strcpy(d,"\\b");		d += 2;
	} else if (ch == '\f') {
	    strcpy(d,"\\f");		d += 2;
	} else if (ch == '\v') {
	    strcpy(d,"\\v");		d += 2;
	} else if (ch == '\r') {
	    strcpy(d,"\\r");		d += 2;
	} else if (ch == '\n') {
	    strcpy(d,"\\n");		d += 2;
	} else if (ch == '\t') {
	    strcpy(d,"\\t");		d += 2;
	} else if ((unsigned)ch < 0x20) { /* unsigned strips parity */
	    sprintf(d,"\\%03o",ch);		d += 4;
	} else if (ch == 0177) {
	    strcpy(d,"\\177");		d += 4;
	} else if ((ch < 0x80) && isprint(UCHAR(ch))) {
	    *d = (char)ch;		d += 1;
	} else {
	    sprintf(d,"\\u%04x",ch);	d += 6;
	}
    }
    *d = '\0';
    return(dest);
}

static
char *
print_argv(interp,argc,argv)
Tcl_Interp *interp;
int argc;
char *argv[];
{
	static int buf_width_max = DEFAULT_WIDTH;
	static char buf_basic[DEFAULT_WIDTH+1];	/* basic buffer */
	static char *buf = buf_basic;
	int space;		/* space remaining in buf */
	int len;
	char *bufp;
	int proc;		/* if current command is "proc" */
	int arg_index;

	if (buf_width > buf_width_max) {
		if (buf && (buf != buf_basic)) ckfree(buf);
		buf = (char *)ckalloc(buf_width + 1);
		buf_width_max = buf_width;
	}

	proc = (0 == strcmp("proc",argv[0]));
	sprintf(buf,"%.*s",buf_width,argv[0]);
	len = strlen(buf);
	space = buf_width - len;
	bufp = buf + len;
	argc--; argv++;
	arg_index = 1;
	
	while (argc && (space > 0)) {
		CONST char *elementPtr;
		CONST char *nextPtr;
		int wrap;

		/* braces/quotes have been stripped off arguments */
		/* so put them back.  We wrap everything except lists */
		/* with one argument.  One exception is to always wrap */
		/* proc's 2nd arg (the arg list), since people are */
		/* used to always seeing it this way. */

		if (proc && (arg_index > 1)) wrap = TRUE;
		else {
			(void) TclFindElement(interp,*argv,
#if TCL_MAJOR_VERSION >= 8
					      -1,
#endif
				&elementPtr,&nextPtr,(int *)0,(int *)0);
			if (*elementPtr == '\0') wrap = TRUE;
			else if (*nextPtr == '\0') wrap = FALSE;
			else wrap = TRUE;
		}

		/* wrap lists (or null) in braces */
		if (wrap) {
			sprintf(bufp," {%.*s}",space-3,*argv);
		} else {
			sprintf(bufp," %.*s",space-1,*argv);
		}
		len = strlen(buf);
		space = buf_width - len;
		bufp = buf + len;
		argc--; argv++;
		arg_index++;
	}

	if (compress) {
		/* this copies from our static buf to printify's static buf */
		/* and back to our static buf */
		strncpy(buf,printify(buf),buf_width);
	}

	/* usually but not always right, but assume truncation if buffer is */
	/* full.  this avoids tiny but odd-looking problem of appending "}" */
	/* to truncated lists during {}-wrapping earlier */
	if (strlen(buf) == buf_width) {
		buf[buf_width-1] = buf[buf_width-2] = buf[buf_width-3] = '.';
	}

	return(buf);
}

#if TCL_MAJOR_VERSION >= 8
static
char *
print_objv(interp,objc,objv)
Tcl_Interp *interp;
int objc;
Tcl_Obj *objv[];
{
    char **argv;
    int argc;
    int len;
    argv = (char **)ckalloc(objc+1 * sizeof(char *));
    for (argc=0 ; argc<objc ; argc++) {
	argv[argc] = Tcl_GetStringFromObj(objv[argc],&len);
    }
    argv[argc] = NULL;
    return(print_argv(interp,argc,argv));
}
#endif

static
void
PrintStackBelow(interp,curf,viewf)
Tcl_Interp *interp;
CallFrame *curf;	/* current FramePtr */
CallFrame *viewf;	/* view FramePtr */
{
	char ptr;	/* graphically indicate where we are in the stack */

	/* indicate where we are in the stack */
	ptr = ((curf == viewf)?'*':' ');

	if (curf == 0) {
		print(interp,"%c0: %s\n",
				ptr,print_argv(interp,main_argc,main_argv));
	} else {
		PrintStackBelow(interp,curf->callerVarPtr,viewf);
		print(interp,"%c%d: %s\n",ptr,curf->level,
#if TCL_MAJOR_VERSION >= 8
	      print_objv(interp,curf->objc,curf->objv)
#else
	      print_argv(interp,curf->argc,curf->argv)
#endif
	      );
	}
}

static
void
PrintStack(interp,curf,viewf,objc,objv,level)
Tcl_Interp *interp;
CallFrame *curf;	/* current FramePtr */
CallFrame *viewf;	/* view FramePtr */
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
char *level;
{
	PrintStackBelow(interp,curf,viewf);
    print(interp," %s: %s\n",level,print_objv(interp,objc,objv));
}

/* return 0 if goal matches current frame or goal can't be found */
/*	anywere in frame stack */
/* else return 1 */
/* This catches things like a proc called from a Tcl_Eval which in */
/* turn was not called from a proc but some builtin such as source */
/* or Tcl_Eval.  These builtin calls to Tcl_Eval lose any knowledge */
/* the FramePtr from the proc, so we have to search the entire */
/* stack frame to see if it's still there. */
static int
GoalFrame(goal,iptr)
CallFrame *goal;
Interp *iptr;
{
	CallFrame *cf = iptr->varFramePtr;

	/* if at current level, return success immediately */
	if (goal == cf) return 0;

	while (cf) {
		cf = cf->callerVarPtr;
		if (goal == cf) {
			/* found, but since it's above us, fail */
			return 1;
		}
	}
	return 0;
}

#if 0
static char *cmd_print(cmdtype)
enum debug_cmd cmdtype;
{
	switch (cmdtype) {
	case none:  return "cmd: none";
	case step:  return "cmd: step";
	case next:  return "cmd: next";
	case ret:   return "cmd: ret";
	case cont:  return "cmd: cont";
	case up:    return "cmd: up";
	case down:  return "cmd: down";
	case where: return "cmd: where";
	case Next:  return "cmd: Next";
	}
	return "cmd: Unknown";
}
#endif

/* debugger's trace handler */

static int
debugger_trap _ANSI_ARGS_ ((
     ClientData clientData,
     Tcl_Interp *interp,
     int level,
     CONST char *command,
     Tcl_Command commandInfo,
     int objc,
     struct Tcl_Obj * CONST * objv));


/*ARGSUSED*/
static int
debugger_trap(clientData,interp,level,command,commandInfo,objc,objv)
     ClientData clientData;		/* not used */
     Tcl_Interp *interp;
     int level;			/* positive number if called by Tcl, -1 if */
				/* called by Dbg_On in which case we don't */
				/* know the level */
     CONST char *command;
     Tcl_Command commandInfo; /* Unused */
     int objc;
     struct Tcl_Obj * CONST * objv;
{
	char level_text[6];	/* textual representation of level */

	int break_status;
	Interp *iPtr = (Interp *)interp;

	CallFrame *trueFramePtr;	/* where the pc is */
	CallFrame *viewFramePtr;	/* where up/down are */

	int print_command_first_time = TRUE;
	static int debug_suspended = FALSE;

	struct breakpoint *b;

    char* thecmd;

	/* skip commands that are invoked interactively */
    if (debug_suspended) return TCL_OK;

    thecmd = Tcl_GetString (objv[0]);
	/* skip debugger commands */
    if (thecmd[1] == '\0') {
	switch (thecmd[0]) {
		case 'n':
		case 's':
		case 'c':
		case 'r':
		case 'w':
		case 'b':
		case 'u':
	case 'd': return TCL_OK;
		}
	}

    if ((*ignoreproc)(interp,thecmd)) return TCL_OK;

	/* if level is unknown, use "?" */
	sprintf(level_text,(level == -1)?"?":"%d",level);

	/* save so we can restore later */
	trueFramePtr = iPtr->varFramePtr;

	/* do not allow breaking while testing breakpoints */
	debug_suspended = TRUE;

	/* test all breakpoints to see if we should break */
	/* if any successful breakpoints, start interactor */
	debug_new_action = FALSE;	/* reset strobe */
	break_status = FALSE;		/* no successful breakpoints yet */
	for (b = break_base;b;b=b->next) {
		break_status |= breakpoint_test(interp,command,b);
	}
	if (break_status) {
		if (!debug_new_action) {
			goto start_interact;
		}

		/* if s or n triggered by breakpoint, make "s 1" */
		/* (and so on) refer to next command, not this one */
		/* step_count++;*/
		goto end_interact;
	}

	switch (debug_cmd) {
	case cont:
		goto finish;
	case step:
		step_count--;
		if (step_count > 0) goto finish;
		goto start_interact;
	case next:
		/* check if we are back at the same level where the next */
		/* command was issued.  Also test */
		/* against all FramePtrs and if no match, assume that */
		/* we've missed a return, and so we should break  */
/*		if (goalFramePtr != iPtr->varFramePtr) goto finish;*/
		if (GoalFrame(goalFramePtr,iPtr)) goto finish;
		step_count--;
		if (step_count > 0) goto finish;
		goto start_interact;
	case Next:
		/* check if we are back at the same level where the next */
		/* command was issued.  */
		if (goalNumLevel < iPtr->numLevels) goto finish;
		step_count--;
		if (step_count > 0) goto finish;
		goto start_interact;
	case ret:
		/* same comment as in "case next" */
		if (goalFramePtr != iPtr->varFramePtr) goto finish;
		goto start_interact;
    /* DANGER: unhandled cases! none, up, down, where */
	}

start_interact:
	if (print_command_first_time) {
		print(interp,"%s: %s\n",
				level_text,print_argv(interp,1,&command));
		print_command_first_time = FALSE;
	}
	/* since user is typing a command, don't interrupt it immediately */
	debug_cmd = cont;
	debug_suspended = TRUE;

	/* interactor won't return until user gives a debugger cmd */
	(*interactor)(interp,interdata);
end_interact:

	/* save this so it can be restored after "w" command */
	viewFramePtr = iPtr->varFramePtr;

	if (debug_cmd == up || debug_cmd == down) {
		/* calculate new frame */
		if (-1 == TclGetFrame2(interp,trueFramePtr,viewFrameName,
					&iPtr->varFramePtr,debug_cmd)) {
	    print(interp,"%s\n",Tcl_GetStringResult (interp));
			Tcl_ResetResult(interp);
		}
		goto start_interact;
	}

	/* reset view back to normal */
	iPtr->varFramePtr = trueFramePtr;

#if 0
	/* allow trapping */
	debug_suspended = FALSE;
#endif

	switch (debug_cmd) {
	case cont:
	case step:
		goto finish;
	case next:
		goalFramePtr = iPtr->varFramePtr;
		goto finish;
	case Next:
		goalNumLevel = iPtr->numLevels;
		goto finish;
	case ret:
		goalFramePtr = iPtr->varFramePtr;
		if (goalFramePtr == 0) {
			print(interp,"nowhere to return to\n");
			break;
		}
		goalFramePtr = goalFramePtr->callerVarPtr;
		goto finish;
	case where:
	PrintStack(interp,iPtr->varFramePtr,viewFramePtr,objc,objv,level_text);
		break;
	}

	/* restore view and restart interactor */
	iPtr->varFramePtr = viewFramePtr;
	goto start_interact;

 finish:
	debug_suspended = FALSE;
	return TCL_OK;
}

/*ARGSUSED*/
static
int
cmdNext(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
	debug_new_action = TRUE;
	debug_cmd = *(enum debug_cmd *)clientData;

	last_action_cmd = debug_cmd;

    if (objc == 1) {
	step_count = 1;
    } else if (TCL_OK != Tcl_GetIntFromObj (interp, objv[1], &step_count)) {
	return TCL_ERROR;
    }

	last_step_count = step_count;
	return(TCL_RETURN);
}

/*ARGSUSED*/
static
int
cmdDir(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    char* frame;
    debug_cmd = *(enum debug_cmd *)clientData;

    if (objc == 1) {
	frame = "1";
    } else {
	frame = Tcl_GetString (objv[1]);
    }

    strncpy(viewFrameName,frame,FRAMENAMELEN);
	return TCL_RETURN;
}

/*ARGSUSED*/
static
int
cmdSimple(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
	debug_new_action = TRUE;
	debug_cmd = *(enum debug_cmd *)clientData;
	last_action_cmd = debug_cmd;

	return TCL_RETURN;
}

static
void
breakpoint_destroy(b)
struct breakpoint *b;
{
	if (b->file) Tcl_DecrRefCount(b->file);
	if (b->pat) Tcl_DecrRefCount(b->pat);
	if (b->cmd) Tcl_DecrRefCount(b->cmd);
	if (b->expr) Tcl_DecrRefCount(b->expr);

	/* unlink from chain */
	if ((b->previous == 0) && (b->next == 0)) {
		break_base = 0;
	} else if (b->previous == 0) {
		break_base = b->next;
		b->next->previous = 0;
	} else if (b->next == 0) {
		b->previous->next = 0;
	} else {
		b->previous->next = b->next;
		b->next->previous = b->previous;
	}

	ckfree((char *)b);
}

static void
savestr(objPtr,str)
Tcl_Obj **objPtr;
char *str;
{
    *objPtr = Tcl_NewStringObj(str, -1);
    Tcl_IncrRefCount(*objPtr);
}

/*ARGSUSED*/
static
int
cmdWhere(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    static char* options [] = {
	"-compress",
	"-width",
	NULL
    };
    enum options {
	WHERE_COMPRESS,
	WHERE_WIDTH
    };
    int i;

    if (objc == 1) {
		debug_cmd = where;
		return TCL_RETURN;
	}

    /* Check and process switches */

    for (i=1; i<objc; i++) {
	char *name;
	int index;

	name = Tcl_GetString(objv[i]);
	if (name[0] != '-') {
	    break;
		}
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) != TCL_OK) {
	    goto usage;
	}
	switch ((enum options) index) {
	case WHERE_COMPRESS:
	    i++;
	    if (i >= objc) {
		print(interp,"%d\n",compress);
		break;
	    }
	    if (TCL_OK != Tcl_GetBooleanFromObj (interp, objv[i], &buf_width))
		goto usage;
	    break;
	case WHERE_WIDTH:
	    i++;
	    if (i >= objc) {
		print(interp,"%d\n",buf_width);
		break;
	}
	    if (TCL_OK != Tcl_GetIntFromObj (interp, objv[i], &buf_width))
		goto usage;
	    break;
	}
    }

    if (i < objc) goto usage;

	return TCL_OK;

 usage:
    print(interp,"usage: w [-width #] [-compress 0|1]\n");
    return TCL_ERROR;
}

#define breakpoint_fail(msg) {error_msg = msg; goto break_fail;}

/*ARGSUSED*/
static
int
cmdBreak(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
	struct breakpoint *b;
	char *error_msg;

    static char* options [] = {
	"-glob",
	"-regexp",
	"if",
	"then",
	NULL
    };
    enum options {
	BREAK_GLOB,
	BREAK_RE,
	BREAK_IF,
	BREAK_THEN
    };
    int i;
    int index;


    /* No arguments, list breakpoints */
    if (objc == 1) {
		for (b = break_base;b;b=b->next) breakpoint_print(interp,b);
		return(TCL_OK);
	}

    /* Process breakpoint deletion (-, -x) */

    /* Copied from exp_prog.h */
#define streq(x,y)	(0 == strcmp((x),(y)))

    if (objc == 2) {
	int id;

	if (streq (Tcl_GetString (objv[1]),"-")) {
			while (break_base) {
				breakpoint_destroy(break_base);
			}
			breakpoint_max_id = 0;
			return(TCL_OK);
	}

	if ((Tcl_GetString (objv[1])[0] == '-') &&
	    (TCL_OK == Tcl_GetIntFromObj (interp, objv[1], &id))) {
	    id = -id;

			for (b = break_base;b;b=b->next) {
				if (b->id == id) {
					breakpoint_destroy(b);
					if (!break_base) breakpoint_max_id = 0;
					return(TCL_OK);
				}
			}
			Tcl_SetResult(interp,"no such breakpoint",TCL_STATIC);
			return(TCL_ERROR);
		}
	}

	b = breakpoint_new();

    /* Process switches */

    i = 1;
    if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
			    &index) == TCL_OK) {
	switch ((enum options) index) {
	case BREAK_GLOB:
	    i++;
	    if (i == objc) breakpoint_fail("no pattern?");
	    savestr(&b->pat,Tcl_GetString (objv[i]));
	    i++;
	    break;
	case BREAK_RE:
	    i++;
	    if (i == objc) breakpoint_fail("bad regular expression");
		    b->re = 1;
	    savestr(&b->pat,Tcl_GetString (objv[i]));
	    if (Tcl_GetRegExpFromObj(interp, b->pat, TCL_REG_ADVANCED) == NULL) {
			breakpoint_destroy(b);
			return TCL_ERROR;
		    }
	    i++;
	    break;
	case BREAK_IF:   break;
	case BREAK_THEN: break;
		}
		} else {
		/* look for [file:]line */
		char *colon;
		char *linep;	/* pointer to beginning of line number */
	char* ref = Tcl_GetString (objv[i]);
	colon = strchr(ref,':');
		if (colon) {
			*colon = '\0';
	    savestr(&b->file,ref);
			*colon = ':';
			linep = colon + 1;
		} else {
	    linep = ref;
			/* get file from current scope */
			/* savestr(&b->file, ?); */
		}

		if (TCL_OK == Tcl_GetInt(interp,linep,&b->line)) {
	    i++;
			print(interp,"setting breakpoints by line number is currently unimplemented - use patterns or expressions\n");
		} else {
			/* not an int? - unwind & assume it is an expression */

			if (b->file) Tcl_DecrRefCount(b->file);
		}

	}

    if (i < objc) {
		int do_if = FALSE;

	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) == TCL_OK) {
	    switch ((enum options) index) {
	    case BREAK_IF:
		i++;
		do_if = TRUE;
		/* Consider next word as expression */
		break;
	    case BREAK_THEN:
		/* No 'if expression' guard here, do nothing */
		break;
	    case BREAK_GLOB:
	    case BREAK_RE:
			do_if = TRUE;
		/* Consider current word as expression, without a preceding 'if' */
		break;
	    }
	} else {
	    /* Consider current word as expression, without a preceding 'if' */
			do_if = TRUE;
		}

		if (do_if) {
	    if (i == objc) breakpoint_fail("if what");
	    savestr(&b->expr,Tcl_GetString (objv[i]));
	    i++;
		}
	}

    if (i < objc) {
	/* Remainder is a command */
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "flag", 0,
				&index) == TCL_OK) {
	    switch ((enum options) index) {
	    case BREAK_THEN:
		i++;
		break;
	    case BREAK_IF:
	    case BREAK_GLOB:
	    case BREAK_RE:
		break;
		}
		}

	if (i == objc) breakpoint_fail("then what?");

	savestr(&b->cmd,Tcl_GetString (objv[i]));
	}

    Tcl_SetObjResult (interp, Tcl_NewIntObj (b->id));
	return(TCL_OK);

 break_fail:
	breakpoint_destroy(b);
	Tcl_SetResult(interp,error_msg,TCL_STATIC);
	return(TCL_ERROR);
}

static char *help[] = {
"s [#]		step into procedure",
"n [#]		step over procedure",
"N [#]		step over procedures, commands, and arguments",
"c		continue",
"r		continue until return to caller",
"u [#]		move scope up level",
"d [#]		move scope down level",
"		go to absolute frame if # is prefaced by \"#\"",
"w		show stack (\"where\")",
"w -w [#]	show/set width",
"w -c [0|1]	show/set compress",
"b		show breakpoints",
"b [-r regexp-pattern] [if expr] [then command]",
"b [-g glob-pattern]   [if expr] [then command]",
"b [[file:]#]          [if expr] [then command]",
"		if pattern given, break if command resembles pattern",
"		if # given, break on line #",
"		if expr given, break if expr true",
"		if command given, execute command at breakpoint",
"b -#		delete breakpoint",
"b -		delete all breakpoints",
0};

/*ARGSUSED*/
static
int
cmdHelp(clientData, interp, objc, objv)
ClientData clientData;
Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];		/* Argument objects. */
{
	char **hp;

	for (hp=help;*hp;hp++) {
		print(interp,"%s\n",*hp);
	}

	return(TCL_OK);
}

/* occasionally, we print things larger buf_max but not by much */
/* see print statements in PrintStack routines for examples */
#define PAD 80

/*VARARGS*/
static void
print TCL_VARARGS_DEF(Tcl_Interp *,arg1)
{
	Tcl_Interp *interp;
	char *fmt;
	va_list args;

	interp = TCL_VARARGS_START(Tcl_Interp *,arg1,args);
	fmt = va_arg(args,char *);
	if (!printproc) vprintf(fmt,args);
	else {
		static int buf_width_max = DEFAULT_WIDTH+PAD;
		static char buf_basic[DEFAULT_WIDTH+PAD+1];
		static char *buf = buf_basic;

		if (buf_width+PAD > buf_width_max) {
			if (buf && (buf != buf_basic)) ckfree(buf);
			buf = (char *)ckalloc(buf_width+PAD+1);
			buf_width_max = buf_width+PAD;
		}

		vsprintf(buf,fmt,args);
		(*printproc)(interp,buf,printdata);
	}
	va_end(args);
}

/*ARGSUSED*/
Dbg_InterStruct
Dbg_Interactor(interp,inter_proc,data)
Tcl_Interp *interp;
Dbg_InterProc *inter_proc;
ClientData data;
{
	Dbg_InterStruct tmp;

	tmp.func = interactor;
	tmp.data = interdata;
	interactor = (inter_proc?inter_proc:simple_interactor);
	interdata = data;
	return tmp;
}

/*ARGSUSED*/
Dbg_IgnoreFuncsProc *
Dbg_IgnoreFuncs(interp,proc)
Tcl_Interp *interp;
Dbg_IgnoreFuncsProc *proc;
{
	Dbg_IgnoreFuncsProc *tmp = ignoreproc;
	ignoreproc = (proc?proc:zero);
	return tmp;
}

/*ARGSUSED*/
Dbg_OutputStruct
Dbg_Output(interp,proc,data)
Tcl_Interp *interp;
Dbg_OutputProc *proc;
ClientData data;
{
	Dbg_OutputStruct tmp;

	tmp.func = printproc;
	tmp.data = printdata;
	printproc = proc;
	printdata = data;
	return tmp;
}

/*ARGSUSED*/
int
Dbg_Active(interp)
Tcl_Interp *interp;
{
	return debugger_active;
}

char **
Dbg_ArgcArgv(argc,argv,copy)
int argc;
char *argv[];
int copy;
{
	char **alloc;

	main_argc = argc;

	if (!copy) {
		main_argv = argv;
		alloc = 0;
	} else {
		main_argv = alloc = (char **)ckalloc((argc+1)*sizeof(char *));
		while (argc-- >= 0) {
			*main_argv++ = *argv++;
		}
		main_argv = alloc;
	}
	return alloc;
}

static struct cmd_list {
	char *cmdname;
    Tcl_ObjCmdProc *cmdproc;
	enum debug_cmd cmdtype;
} cmd_list[]  = {
		{"n", cmdNext,   next},
		{"s", cmdNext,   step},
		{"N", cmdNext,   Next},
		{"c", cmdSimple, cont},
		{"r", cmdSimple, ret},
		{"w", cmdWhere,  none},
		{"b", cmdBreak,  none},
		{"u", cmdDir,    up},
		{"d", cmdDir,    down},
		{"h", cmdHelp,   none},
		{0}
};

/* this may seem excessive, but this avoids the explicit test for non-zero */
/* in the caller, and chances are that that test will always be pointless */
/*ARGSUSED*/
static int
zero (Tcl_Interp *interp, char *string)
{
	return 0;
}

extern int expSetBlockModeProc _ANSI_ARGS_((int fd, int mode));

static int
simple_interactor(Tcl_Interp *interp, ClientData data)
{
	int rc;
	char *ccmd;		/* pointer to complete command */
	char line[BUFSIZ+1];	/* space for partial command */
	int newcmd = TRUE;
	Interp *iPtr = (Interp *)interp;

	Tcl_DString dstring;
	Tcl_DStringInit(&dstring);

	/* Force blocking if necessary */

	if (stdinmode == TCL_MODE_NONBLOCKING) {
	  expSetBlockModeProc(0, TCL_MODE_BLOCKING);
	}

	newcmd = TRUE;
	while (TRUE) {
		struct cmd_list *c;

		if (newcmd) {
#if TCL_MAJOR_VERSION < 8
			print(interp,"dbg%d.%d> ",iPtr->numLevels,iPtr->curEventNum+1);
#else
			/* unncessarily tricky coding - if nextid
			   isn't defined, maintain our own static
			   version */

			static int nextid = 0;
			CONST char *nextidstr = Tcl_GetVar2(interp,"tcl::history","nextid",0);
			if (nextidstr) {
				sscanf(nextidstr,"%d",&nextid);
			}
			print(interp,"dbg%d.%d> ",iPtr->numLevels,nextid++);
#endif
		} else {
			print(interp,"dbg+> ");
		}
		fflush(stdout);

		rc = read(0,line,BUFSIZ);
		if (0 >= rc) {
			if (!newcmd) line[0] = 0;
			else exit(0);
		} else line[rc] = '\0';

		ccmd = Tcl_DStringAppend(&dstring,line,rc);
		if (!Tcl_CommandComplete(ccmd)) {
			newcmd = FALSE;
			continue;	/* continue collecting command */
		}
		newcmd = TRUE;

		/* if user pressed return with no cmd, use previous one */
		if ((ccmd[0] == '\n' || ccmd[0] == '\r') && ccmd[1] == '\0') {

			/* this loop is guaranteed to exit through break */
			for (c = cmd_list;c->cmdname;c++) {
				if (c->cmdtype == last_action_cmd) break;
			}

			/* recreate textual version of command */
			Tcl_DStringAppend(&dstring,c->cmdname,-1);

			if (c->cmdtype == step ||
			    c->cmdtype == next ||
			    c->cmdtype == Next) {
				char num[10];

				sprintf(num," %d",last_step_count);
				Tcl_DStringAppend(&dstring,num,-1);
			}
		}

#if TCL_MAJOR_VERSION == 7 && TCL_MINOR_VERSION < 4
		rc = Tcl_RecordAndEval(interp,ccmd,0);
#else
		rc = Tcl_RecordAndEval(interp,ccmd,TCL_NO_EVAL);
		rc = Tcl_Eval(interp,ccmd);
#endif
		Tcl_DStringFree(&dstring);

		switch (rc) {
		case TCL_OK:
	    {
		char* res = Tcl_GetStringResult (interp);
		if (*res != 0)
		    print(interp,"%s\n",res);
	    }
			continue;
		case TCL_ERROR:
			print(interp,"%s\n",Tcl_GetVar(interp,"errorInfo",TCL_GLOBAL_ONLY));
			/* since user is typing by hand, we expect lots
			   of errors, and want to give another chance */
			continue;
		case TCL_BREAK:
		case TCL_CONTINUE:
#define finish(x)	{rc = x; goto done;}
			finish(rc);
		case TCL_RETURN:
			finish(TCL_OK);
		default:
			/* note that ccmd has trailing newline */
			print(interp,"error %d: %s\n",rc,ccmd);
			continue;
		}
	}
	/* cannot fall thru here, must jump to label */
 done:
	Tcl_DStringFree(&dstring);

	/* Restore old blocking mode */
	if (stdinmode == TCL_MODE_NONBLOCKING) {
	  expSetBlockModeProc(0, TCL_MODE_NONBLOCKING);
	}
	return(rc);
}

static char init_auto_path[] = "lappend auto_path $dbg_library";

static void
init_debugger(interp)
Tcl_Interp *interp;
{
	struct cmd_list *c;

	for (c = cmd_list;c->cmdname;c++) {
	Tcl_CreateObjCommand(interp,c->cmdname,c->cmdproc,
			(ClientData)&c->cmdtype,(Tcl_CmdDeleteProc *)0);
	}

    debug_handle = Tcl_CreateObjTrace(interp,10000,0,
				      debugger_trap,(ClientData)0, NULL);

	debugger_active = TRUE;
	Tcl_SetVar2(interp,Dbg_VarName,"active","1",0);
#ifdef DBG_SCRIPTDIR
	Tcl_SetVar(interp,"dbg_library",DBG_SCRIPTDIR,0);
#endif
	Tcl_Eval(interp,init_auto_path);

}

/* allows any other part of the application to jump to the debugger */
/*ARGSUSED*/
void
Dbg_On(interp,immediate)
Tcl_Interp *interp;
int immediate;		/* if true, stop immediately */
			/* should only be used in safe places */
			/* i.e., when Tcl_Eval can be called */
{
	if (!debugger_active) init_debugger(interp);

	/* Initialize debugger in single-step mode.  Note: if the
	  command reader is already active, it's too late which is why
	  we also statically initialize debug_cmd to step. */
	debug_cmd = step;
	step_count = 1;

#define LITERAL(s) Tcl_NewStringObj ((s), sizeof(s)-1)

	if (immediate) {
	Tcl_Obj* fake_cmd = LITERAL ( "--interrupted-- (command_unknown)");

	Tcl_IncrRefCount (fake_cmd);
	debugger_trap((ClientData)0,interp,-1,Tcl_GetString (fake_cmd),0,1,&fake_cmd);
/*		(*interactor)(interp);*/
	Tcl_DecrRefCount (fake_cmd);
	}
}

void
Dbg_Off(interp)
Tcl_Interp *interp;
{
	struct cmd_list *c;

	if (!debugger_active) return;

	for (c = cmd_list;c->cmdname;c++) {
		Tcl_DeleteCommand(interp,c->cmdname);
	}

	Tcl_DeleteTrace(interp,debug_handle);
	debugger_active = FALSE;
	Tcl_UnsetVar(interp,Dbg_VarName,TCL_GLOBAL_ONLY);

	/* initialize for next use */
	debug_cmd = step;
	step_count = 1;
}

/* allows any other part of the application to tell the debugger where the Tcl channel for stdin is. */
/*ARGSUSED*/
void
Dbg_StdinMode(mode)
     int mode;
{
  stdinmode = mode;
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
@


5.45
log
@	* config.guess, config.sub, expect.m4 (removed):
	* configure, configure.in, tclconfig/tcl.m4: Update to TEA 3.9
	* Makefile.in, aclocal.m4: Partial cleanup of the build system.
	* testsuite/Makefile.in:   Remove unused EXP_ from configure.in
	* testsuite/aclocal.m4:    and no longer use Tk.
	* testsuite/configure:     Update testsuite bits to use TEA info.
	* testsuite/configure.in:
	Update expect to version 5.45

	* Dbg.c: account for removal of tcldbgcf.h
	* DbgMkfl.in, Dbgconfig.in, Dbgconfigure, DbgpkgInd.in (removed):
	* tcldbgcf.h.in (removed): removed Dbg debugger subcomponent as it
	no longer built and debugger functionality is included in expect
	library and binary

	* pty_termios.c: add HAVE_STRING_H include string.h
	* exp_trap.c: add HAVE_STRING_H include string.h

	* expectk.man, exp_main_tk.c (removed): expectk no longer
	built. Use tclsh with package require Tk and Expect instead.

	* tests/all.tcl: add package require Expect

	* example/archie, example/autoexpect: minor code cleanup
	* example/tkpasswd, example/tknewsbiff, example/tkterm: use
	package require statements in lieu of expectk
@
text
@d40 2
a41 2
static int simple_interactor();
static int zero();
d46 1
a46 1
static Dbg_InterProc *interactor = simple_interactor;
d48 1
a48 1
static Dbg_IgnoreFuncsProc *ignoreproc = zero;
d89 1
a89 1
static debug_new_action;
d1252 2
a1253 3
static int zero(interp,string)
Tcl_Interp *interp;
char *string;
d1261 1
a1261 2
simple_interactor(interp)
Tcl_Interp *interp;
@


5.44
log
@Undoing all changes made by me during ANSIfication attempt, and
reverting to tag 'expect_5_44_1_15'.  Further ANSIfication will
be pursued on a branch.
@
text
@d13 4
a16 1
#include "tcldbgcf.h"
@


5.43
log
@ANSIfication
@
text
@d14 10
d26 4
a29 2
#include <varargs.h>
#include <string.h>
d37 2
a38 2
static int simple_interactor(Tcl_Interp *);
static int zero(Tcl_Interp *, char *);
d50 1
a50 1
static void print TCL_VARARGS(Tcl_Interp *,interp);
d101 1
a101 1
static struct breakpoint *break_base =  NULL;
d105 1
a105 1
breakpoint_new(void)
d122 5
a126 2
static void
breakpoint_print(Tcl_Interp *interp, struct breakpoint *b)
d151 4
a154 1
save_re_matches(Tcl_Interp *interp, Tcl_RegExp re, Tcl_Obj *objPtr)
d260 1
a260 1
    } else if (isdigit((unsigned char)*string)) {
d1156 4
a1159 1
Dbg_Interactor(Tcl_Interp *interp, Dbg_InterProc *inter_proc, ClientData data)
d1172 3
a1174 1
Dbg_IgnoreFuncs(Tcl_Interp *interp, Dbg_IgnoreFuncsProc *proc)
d1183 4
a1186 1
Dbg_Output(Tcl_Interp *interp, Dbg_OutputProc *proc, ClientData data)
d1199 2
a1200 1
Dbg_Active(Tcl_Interp *interp)
d1206 4
a1209 1
Dbg_ArgcArgv(int argc, char *argv[], int copy)
d1249 1
a1249 1
static int zero(Tcl_Interp *interp, char *string)
d1256 1
a1256 1
extern int expSetBlockModeProc (int fd, int mode);
d1259 2
a1260 1
simple_interactor(Tcl_Interp *interp)
d1382 2
a1383 1
init_debugger(Tcl_Interp *interp)
d1407 5
a1411 4
Dbg_On(Tcl_Interp *interp, int immediate)
/* if immediate is true, stop immediately */
/* should only be used in safe places */
/* i.e., when Tcl_Eval can be called */
d1434 2
a1435 1
Dbg_Off(Tcl_Interp *interp)
d1457 2
a1458 1
Dbg_StdinMode(int mode)
d1462 1
a1462 1

@


5.42
log
@ANSIfication changes
@
text
@d242 1
a242 1
    } else if (isdigit(*string)) {
@


5.41
log
@WHITESPACE CHANGES ONLY. I removed a number of form-feed characters
that had been littered about the source code.
@
text
@a13 10
#if 0
/* tclInt.h drags in stdlib.  By claiming no-stdlib, force it to drag in */
/* Tcl's compat version.  This avoids having to test for its presence */
/* which is too tricky - configure can't generate two cf files, so when */
/* Expect (or any app) uses the debugger, there's no way to get the info */
/* about whether stdlib exists or not, except pointing the debugger at */
/* an app-dependent .h file and I don't want to do that. */
#define NO_STDLIB_H
#endif

d16 2
a17 4
/*#include <varargs.h>		tclInt.h drags in varargs.h.  Since Pyramid */
/*				objects to including varargs.h twice, just */
/*				omit this one. */
/*#include "string.h"		tclInt.h drags this in, too! */
@


5.40
log
@Converting function declarations and definitions from K&R style
to ISO C style, along with occasional related comment changes.
@
text
@d1439 1
a1439 1

@


5.39
log
@
	* configure.in: Bumped version to 5.44.1.6.
	* configure: Regen'd, autoconf 2.59.

	* The following set of changes was sent our way by Reinhard Max
	  <max@@tclers.tk>.

	* configure.in: Fixed checking of stty on linux, do not restrict
	  to specific cpu's. Further try with stdin, and stdin redirected
	  to /dev/tty when determining if stdout is read.

	* testsuite/configure.in: Brought up to TEA 3.5.
	* testsuite/aclocal.m4: New file, to import the TEA definitions.

	* Dbg.c: Added missed CONST in declaration and definition of
	  'debugger_trap'.

	* exp_command.c: Fixed pointer aliasing trouble with
	  'Tcl_DetachPids', and added the missing initialization of the
	  command string in the 'overlay' command.

	* expect.c: Fixed missing initialization of 'simple_start' element
	  of 'ecase'.

	* exp_inter.c: Fixed bogus use of 'slen' in 'intMatch'. The
	  relevant string is Tcl_Unichar, not Utf.

	* Makefile.in: Replaced bogus INSTALL_ROOT with DESTDIR, and added
	  missing DESTDIR references to the target for the installation of
	  the manpages.
@
text
@d37 2
a38 2
static int simple_interactor();
static int zero();
d50 1
a50 1
static void print _ANSI_ARGS_(TCL_VARARGS(Tcl_Interp *,interp));
d101 1
a101 1
static struct breakpoint *break_base = 0;
d105 1
a105 1
breakpoint_new()
d122 2
a123 5
static
void
breakpoint_print(interp,b)
Tcl_Interp *interp;
struct breakpoint *b;
d148 1
a148 4
save_re_matches(interp, re, objPtr)
Tcl_Interp *interp;
Tcl_RegExp re;
Tcl_Obj *objPtr;
d1150 1
a1150 4
Dbg_Interactor(interp,inter_proc,data)
Tcl_Interp *interp;
Dbg_InterProc *inter_proc;
ClientData data;
d1163 1
a1163 3
Dbg_IgnoreFuncs(interp,proc)
Tcl_Interp *interp;
Dbg_IgnoreFuncsProc *proc;
d1172 1
a1172 4
Dbg_Output(interp,proc,data)
Tcl_Interp *interp;
Dbg_OutputProc *proc;
ClientData data;
d1185 1
a1185 2
Dbg_Active(interp)
Tcl_Interp *interp;
d1191 1
a1191 4
Dbg_ArgcArgv(argc,argv,copy)
int argc;
char *argv[];
int copy;
d1231 1
a1231 1
static int zero(interp,string)
d1238 1
a1238 1
extern int expSetBlockModeProc _ANSI_ARGS_((int fd, int mode));
d1241 1
a1241 2
simple_interactor(interp)
Tcl_Interp *interp;
d1363 1
a1363 2
init_debugger(interp)
Tcl_Interp *interp;
d1387 4
a1390 5
Dbg_On(interp,immediate)
Tcl_Interp *interp;
int immediate;		/* if true, stop immediately */
			/* should only be used in safe places */
			/* i.e., when Tcl_Eval can be called */
d1413 1
a1413 2
Dbg_Off(interp)
Tcl_Interp *interp;
d1435 1
a1435 2
Dbg_StdinMode(mode)
     int mode;
@


5.38
log
@
	* expect.c: Fixed refcounting error when parsing a single expect
	* configure.in: argument into a list of patterns and
	* configure: actions. Updated the version number to 5.44.1.5.
	* Dbg.c: Added missing 'return TCL_OK' to debugger_trap.
@
text
@d548 1
a548 1
     char *command,
d557 3
a559 3
ClientData clientData;		/* not used */
Tcl_Interp *interp;
int level;			/* positive number if called by Tcl, -1 if */
d562 1
a562 1
char *command;
@


5.37
log
@
	* Dbg.c: Converted the lot of argc,argv based command
	* exp_command.c: implementations over to objc,objv.
	* expect.c:
	* exp_main_sub.c:
@
text
@d724 1
@


5.36
log
@
	* Dbg.c: Cleaned up the direct access to interp->result,
	* exp_command.c: replaced with the proper functions and
	* expect.c: Tcl_Obj's.
	* exp_main_exp.c:
	* exp_main_sub.c:
	* exp_main_tk.c:
	* exp_prog.h:
	* exp_trap.c:
	* exp_tty.c:
	* exp_win.c:
	* exp_win.h:
@
text
@d472 1
a472 1
			print_objv(interp,curf->objc,curf->objv));
d474 1
a474 1
			print_argv(interp,curf->argc,curf->argv));
d476 1
d482 1
a482 1
PrintStack(interp,curf,viewf,argc,argv,level)
d486 2
a487 2
int argc;
char *argv[];
d491 1
a491 2
	
	print(interp," %s: %s\n",level,print_argv(interp,argc,argv));
d522 1
d539 1
d542 12
d555 2
a556 2
static void
debugger_trap(clientData,interp,level,command,cmdProc,cmdClientData,argc,argv)
d563 3
a565 4
int (*cmdProc)();		/* not used */
ClientData cmdClientData;
int argc;
char *argv[];
d580 2
d583 1
a583 1
	if (debug_suspended) return;
d585 1
d587 2
a588 2
	if (argv[0][1] == '\0') {
		switch (argv[0][0]) {
d596 1
a596 1
		case 'd': return;
d600 1
a600 1
	if ((*ignoreproc)(interp,argv[0])) return;
d714 1
a714 1
		PrintStack(interp,iPtr->varFramePtr,viewFramePtr,argc,argv,level_text);
d729 1
a729 1
cmdNext(clientData, interp, argc, argv)
d732 2
a733 2
int argc;
char **argv;
d740 6
a745 1
	step_count = (argc == 1)?1:atoi(argv[1]);
d753 1
a753 1
cmdDir(clientData, interp, argc, argv)
d756 2
a757 2
int argc;
char **argv;
d759 2
a760 1
	debug_cmd = *(enum debug_cmd *)clientData;
d762 5
a766 2
	if (argc == 1) argv[1] = "1";
	strncpy(viewFrameName,argv[1],FRAMENAMELEN);
d768 1
d775 1
a775 1
cmdSimple(clientData, interp, argc, argv)
d778 2
a779 2
int argc;
char **argv;
a822 15
/* return 1 if a string is substring of a flag */
static int
flageq(flag,string,minlen)
char *flag;
char *string;
int minlen;		/* at least this many chars must match */
{
	for (;*flag;flag++,string++,minlen--) {
		if (*string == '\0') break;
		if (*string != *flag) return 0;
	}
	if (*string == '\0' && minlen <= 0) return 1;
	return 0;
}

d826 1
a826 1
cmdWhere(clientData, interp, argc, argv)
d829 2
a830 2
int argc;
char **argv;
d832 12
a843 1
	if (argc == 1) {
d848 1
a848 1
	argc--; argv++;
d850 31
a880 17
	while (argc) {
		if (flageq("-width",*argv,2)) {
			argc--; argv++;
			if (*argv) {
				buf_width = atoi(*argv);
				argc--; argv++;
			} else print(interp,"%d\n",buf_width);
		} else if (flageq("-compress",*argv,2)) {
			argc--; argv++;
			if (*argv) {
				compress = atoi(*argv);
				argc--; argv++;
			} else print(interp,"%d\n",compress);
		} else {
			print(interp,"usage: w [-width #] [-compress 0|1]\n");
			return TCL_ERROR;
		}
d882 4
d887 4
d898 1
a898 1
cmdBreak(clientData, interp, argc, argv)
d901 2
a902 2
int argc;
char **argv;
d907 16
a922 1
	argc--; argv++;
d924 2
a925 1
	if (argc < 1) {
d930 9
a938 2
	if (argv[0][0] == '-') {
		if (argv[0][1] == '\0') {
d944 5
a948 2
		} else if (isdigit(argv[0][1])) {
			int id = atoi(argv[0]+1);
d964 15
a978 3
	if (flageq("-regexp",argv[0],2)) {
		argc--; argv++;
		if (argc > 0) {
d980 2
a981 3
		    savestr(&b->pat,argv[0]);
		    if (Tcl_GetRegExpFromObj(interp, b->pat, TCL_REG_ADVANCED)
			    == NULL) {
d985 4
a988 3
		    argc--; argv++;
		} else {
			breakpoint_fail("bad regular expression")
a989 5
	} else if (flageq("-glob",argv[0],2)) {
		argc--; argv++;
		if (argc > 0) {
			savestr(&b->pat,argv[0]);
			argc--; argv++;
a990 3
			breakpoint_fail("no pattern?");
		}
	} else if ((!(flageq("if",*argv,1)) && (!(flageq("then",*argv,1))))) {
d994 2
a995 2

		colon = strchr(argv[0],':');
d998 1
a998 1
			savestr(&b->file,argv[0]);
d1002 1
a1002 1
			linep = argv[0];
d1008 1
a1008 1
			argc--; argv++;
d1015 1
d1018 1
a1018 1
	if (argc > 0) {
d1021 13
a1033 2
		if (flageq("if",argv[0],1)) {
			argc--; argv++;
d1035 5
a1039 1
		} else if (!flageq("then",argv[0],1)) {
d1044 3
a1046 6
			if (argc < 1) {
				breakpoint_fail("if what");
			}

			savestr(&b->expr,argv[0]);
			argc--; argv++;
d1050 13
a1062 3
	if (argc > 0) {
		if (flageq("then",argv[0],1)) {
			argc--; argv++;
d1065 1
a1065 3
		if (argc < 1) {
			breakpoint_fail("then what?");
		}
d1067 1
a1067 1
		savestr(&b->cmd,argv[0]);
d1070 1
a1070 1
	sprintf(interp->result,"%d",b->id);
d1106 1
a1106 1
cmdHelp(clientData, interp, argc, argv)
d1109 2
a1110 2
int argc;
char **argv;
d1229 1
a1229 1
	Tcl_CmdProc *cmdproc;
d1387 1
a1387 1
		Tcl_CreateCommand(interp,c->cmdname,c->cmdproc,
d1391 2
a1392 2
	debug_handle = Tcl_CreateTrace(interp,
				10000,debugger_trap,(ClientData)0);
d1420 2
d1423 1
a1423 1
		static char *fake_cmd = "--interrupted-- (command_unknown)";
d1425 2
a1426 2
		debugger_trap((ClientData)0,interp,-1,fake_cmd,(int (*)())0,
					(ClientData)0,1,&fake_cmd);
d1428 1
d1461 8
@


5.35
log
@
	* Dbg.c: Added note about unhandled cases in a switch.
	* exp_chan.c: Added code to suppress unhandled warning for
	  unreachable code.
	* exp_command.c: Removed unused variable.
	* expect.c: Removed unused static function, added code to suppress
	  unhandled warning for unreachable code.
@
text
@d665 1
a665 1
			print(interp,"%s\n",interp->result);
d1249 5
a1253 2
			if (*interp->result != 0)
				print(interp,"%s\n",interp->result);
@


5.34
log
@
	* exp_chan.c: Fixed problem with debugger introduced at '2004-06-14'.
	* tcldbg.h:   For a nonblocking stdin the debugger blowed up on the
	* Dbg.c:      empty reads it could get, exiting the application. I
	              guess that this was an implicit 'panic'. Fix:

		      - Split ExpBlockmodeProc into high- and lowlevel
		        code, the latter for use by the debugger. The
		        high-level code tells the debugger which state
		        stdin is in (doing this explicitly because if
		        FIONBIO is used it is not possible to query the fd
		        directly, and I saw no reason to #ifdef for fcntl
		        which can).

		      - Debugger now exports a function for use by the
		        blockmode proc, and in each interaction it checks
		        for nonblocking input, forces blocking if
		        necessary. At the end of each interaction the true
		        mode is restored. Both operations use the
		        low-level blockmode code.
@
text
@d641 1
@


5.33
log
@Andreas Kupries mods to provide CONST support per TIP 27.
@
text
@d48 1
d1159 2
d1174 6
d1204 2
a1205 1
		if (0 >= (rc = read(0,line,BUFSIZ))) {
d1272 4
d1350 9
@


5.32
log
@
Upgrading to 5.33.
@
text
@d1184 1
a1184 1
			char *nextidstr = Tcl_GetVar2(interp,"tcl::history","nextid",0);
@


5.31
log
@Dbg.c (Dbg_On): fixed handling of stepping. [Bug: #446412]
@
text
@a8 2
 RCS: @@(#) $Id:  Exp $

d1301 4
a1304 6
	/* Initialize debugger in single-step mode.
	 *
	 * Note: if the command reader is already active, it's too late
	 * which is why we also statically initialize debug_cmd to step.
	 */
	debug_cmd = step; 
@


5.31.2.1
log
@Top-level source files removed.
@
text
@d9 1
a9 1
 RCS: @@(#) $Id: Dbg.c,v 5.31 2001/08/02 00:30:14 hobbs Exp $
@


5.30
log
@debugger's bp cmd broke on every command.  Was a bug in
breakpoint_trace from when we installed the new regexp engine.
@
text
@d9 2
d1303 6
a1308 5
	/* intuitively, it would seem natural to initialize the
	debugger with the step command.  However, it's too late at
	this point.  It must be done before the command reader
	(whatever it is) has gotten control. */
	/* debug_cmd = step;*/
@


5.30.2.1
log
@Dbg.c (Dbg_On): fixed handling of stepping. [Bug: #446412]
@
text
@a8 2
 RCS: @@(#) $Id: Dbg.c,v 5.31 2001/08/02 00:30:14 hobbs Exp $

d1301 5
a1305 6
	/* Initialize debugger in single-step mode.
	 *
	 * Note: if the command reader is already active, it's too late
	 * which is why we also statically initialize debug_cmd to step.
	 */
	debug_cmd = step; 
@


5.29
log
@Merge of expect5-31-branch to mainline
@
text
@d180 1
d189 1
d192 1
@


5.28
log
@Initial revision
@
text
@d91 1
a91 1
	char *file;	/* file where breakpoint is */
d93 4
a96 4
	char *pat;	/* pattern defining where breakpoint can be */
	regexp *re;	/* regular expression to trigger breakpoint */
	char *expr;	/* expr to trigger breakpoint */
	char *cmd;	/* cmd to eval at breakpoint */
d127 1
a127 1
	print(interp,"breakpoint %d: ",b->id);
d129 7
a135 9
	if (b->re) {
		print(interp,"-re \"%s\" ",b->pat);
	} else if (b->pat) {
		print(interp,"-glob \"%s\" ",b->pat);
	} else if (b->line != NO_LINE) {
		if (b->file) {
			print(interp,"%s:",b->file);
		}
		print(interp,"%d ",b->line);
d137 2
d140 2
a141 2
	if (b->expr)
		print(interp,"if {%s} ",b->expr);
d143 2
a144 2
	if (b->cmd)
		print(interp,"then {%s}",b->cmd);
d146 1
a146 1
	print(interp,"\n");
d150 1
a150 1
save_re_matches(interp,re)
d152 2
a153 1
regexp *re;
d155 10
a164 13
	int i;
	char name[20];
	char match_char;/* place to hold char temporarily */
			/* uprooted by a NULL */

	for (i=0;i<NSUBEXP;i++) {
		if (re->startp[i] == 0) break;

		sprintf(name,"%d",i);
		/* temporarily null-terminate in middle */
		match_char = *re->endp[i];
		*re->endp[i] = 0;
		Tcl_SetVar2(interp,Dbg_VarName,name,re->startp[i],0);
d166 4
a169 3
		/* undo temporary null-terminator */
		*re->endp[i] = match_char;
	}
d179 27
a205 18
	if (bp->re) {
		if (0 == TclRegExec(bp->re,cmd,cmd)) return 0;
		save_re_matches(interp,bp->re);
	} else if (bp->pat) {
		if (0 == Tcl_StringMatch(cmd,bp->pat)) return 0;
	} else if (bp->line != NO_LINE) {
		/* not yet implemented - awaiting support from Tcl */
		return 0;
	}

	if (bp->expr) {
		int value;

		/* ignore errors, since they are likely due to */
		/* simply being out of scope a lot */
		if (TCL_OK != Tcl_ExprBoolean(interp,bp->expr,&value)
		    || (value == 0)) return 0;
	}
d207 5
a211 5
	if (bp->cmd) {
		Tcl_Eval(interp,bp->cmd);
	} else {
		breakpoint_print(interp,bp);
	}
d213 1
a213 1
	return 1;
d302 39
a340 40
	static int destlen = 0;
	char *d;		/* ptr into dest */
	unsigned int need;
	static char buf_basic[DEFAULT_WIDTH+1];
	static char *dest = buf_basic;

	if (s == 0) return("<null>");

	/* worst case is every character takes 4 to printify */
	need = strlen(s)*4;
	if (need > destlen) {
		if (dest && (dest != buf_basic)) ckfree(dest);
		dest = (char *)ckalloc(need+1);
		destlen = need;
	}

	for (d = dest;*s;s++) {
		/* since we check at worst by every 4 bytes, play */
		/* conservative and subtract 4 from the limit */
		if (d-dest > destlen-4) break;

		if (*s == '\b') {
			strcpy(d,"\\b");		d += 2;
		} else if (*s == '\f') {
			strcpy(d,"\\f");		d += 2;
		} else if (*s == '\v') {
			strcpy(d,"\\v");		d += 2;
		} else if (*s == '\r') {
			strcpy(d,"\\r");		d += 2;
		} else if (*s == '\n') {
			strcpy(d,"\\n");		d += 2;
		} else if (*s == '\t') {
			strcpy(d,"\\t");		d += 2;
		} else if ((unsigned)*s < 0x20) { /* unsigned strips parity */
			sprintf(d,"\\%03o",*s);		d += 4;
		} else if (*s == 0177) {
			strcpy(d,"\\177");		d += 4;
		} else {
			*d = *s;			d += 1;
		}
d342 3
a344 2
	*d = '\0';
	return(dest);
d378 2
a379 2
		char *elementPtr;
		char *nextPtr;
d440 1
a440 1
    argv = ckalloc(objc+1 * sizeof(char *));
d762 4
a765 4
	if (b->file) ckfree(b->file);
	if (b->pat) ckfree(b->pat);
	if (b->re) ckfree((char *)b->re);			
	if (b->cmd) ckfree(b->cmd);
d784 2
a785 2
savestr(straddr,str)
char **straddr;
d788 2
a789 2
	*straddr = ckalloc(strlen(str)+1);
	strcpy(*straddr,str);
d891 9
a899 3
		if ((argc > 0) && (b->re = TclRegComp(argv[0]))) {
			savestr(&b->pat,argv[0]);
			argc--; argv++;
d934 1
a934 1
			if (b->file) ckfree(b->file);
@


5.28.1.1
log
@Import of Expect v. 5.28.1
@
text
@@


5.28.1.1.2.1
log
@Everything but Dbg.c
@
text
@d94 1
a94 1
	Tcl_RegExp *re;	/* regular expression to trigger breakpoint */
@


5.28.1.1.2.2
log
@regenerated configure script
removed exp_printify files
changed Dbg.c to use new regexp interfaces
@
text
@d91 1
a91 1
	Tcl_Obj *file;	/* file where breakpoint is */
d93 4
a96 4
	int re;		/* 1 if this is regexp pattern */
	Tcl_Obj *pat;	/* pattern defining where breakpoint can be */
	Tcl_Obj *expr;	/* expr to trigger breakpoint */
	Tcl_Obj *cmd;	/* cmd to eval at breakpoint */
d127 1
a127 1
    print(interp,"breakpoint %d: ",b->id);
d129 9
a137 7
    if (b->re) {
	print(interp,"-re \"%s\" ",Tcl_GetString(b->pat));
    } else if (b->pat) {
	print(interp,"-glob \"%s\" ",Tcl_GetString(b->pat));
    } else if (b->line != NO_LINE) {
	if (b->file) {
	    print(interp,"%s:",Tcl_GetString(b->file));
a138 2
	print(interp,"%d ",b->line);
    }
d140 2
a141 2
    if (b->expr)
	print(interp,"if {%s} ",Tcl_GetString(b->expr));
d143 2
a144 2
    if (b->cmd)
	print(interp,"then {%s}",Tcl_GetString(b->cmd));
d146 1
a146 1
    print(interp,"\n");
d150 1
a150 1
save_re_matches(interp, re, objPtr)
d152 1
a152 2
Tcl_RegExp re;
Tcl_Obj *objPtr;
d154 17
a170 17
    Tcl_RegExpInfo info;
    int i, start, end;
    char name[20];
    char match_char;/* place to hold char temporarily */
    /* uprooted by a NULL */

    Tcl_GetRegExpInfo(re, &info); 
    for (i=0;i<info.nsubs;i++) {
	start = info.matches[i].start;
	end = info.matches[i].end-1;

	if (start == -1) continue;

	sprintf(name,"%d",i);
	Tcl_SetVar2Ex(interp, Dbg_VarName, name, Tcl_GetRange(objPtr,
		info.matches[i].start, info.matches[i].end), 0);
    }
d177 1
a177 1
Tcl_Obj *cmd;		/* command about to be executed */
d180 18
a197 14
    if (bp->re) {
	Tcl_RegExp re = Tcl_GetRegExpFromObj(NULL, bp->pat,
		TCL_REG_ADVANCED);
	if (Tcl_RegExpMatchObj(NULL, re, cmd, 0 /* offset */,
		-1 /* nmatches */, 0 /* eflags */) > 0) {
	    save_re_matches(interp, re, cmd);
	}
    } else if (bp->pat) {
	if (0 == Tcl_StringMatch(Tcl_GetString(cmd),
		Tcl_GetString(bp->pat))) return 0;
    } else if (bp->line != NO_LINE) {
	/* not yet implemented - awaiting support from Tcl */
	return 0;
    }
d199 5
a203 2
    if (bp->expr) {
	int value;
d205 1
a205 13
	/* ignore errors, since they are likely due to */
	/* simply being out of scope a lot */
	if (TCL_OK != Tcl_ExprBooleanObj(interp,bp->expr,&value)
		|| (value == 0)) return 0;
    }

    if (bp->cmd) {
	Tcl_EvalObjEx(interp, bp->cmd, 0);
    } else {
	breakpoint_print(interp,bp);
    }

    return 1;
d294 40
a333 39
    static int destlen = 0;
    char *d;		/* ptr into dest */
    unsigned int need;
    static char buf_basic[DEFAULT_WIDTH+1];
    static char *dest = buf_basic;
    Tcl_UniChar ch;

    if (s == 0) return("<null>");

    /* worst case is every character takes 4 to printify */
    need = strlen(s)*6;
    if (need > destlen) {
	if (dest && (dest != buf_basic)) ckfree(dest);
	dest = (char *)ckalloc(need+1);
	destlen = need;
    }

    for (d = dest;*s;) {
	s += Tcl_UtfToUniChar(s, &ch);
	if (ch == '\b') {
	    strcpy(d,"\\b");		d += 2;
	} else if (ch == '\f') {
	    strcpy(d,"\\f");		d += 2;
	} else if (ch == '\v') {
	    strcpy(d,"\\v");		d += 2;
	} else if (ch == '\r') {
	    strcpy(d,"\\r");		d += 2;
	} else if (ch == '\n') {
	    strcpy(d,"\\n");		d += 2;
	} else if (ch == '\t') {
	    strcpy(d,"\\t");		d += 2;
	} else if ((unsigned)ch < 0x20) { /* unsigned strips parity */
	    sprintf(d,"\\%03o",ch);		d += 4;
	} else if (ch == 0177) {
	    strcpy(d,"\\177");		d += 4;
	} else if ((ch < 0x80) && isprint(UCHAR(ch))) {
	    *d = (char)ch;		d += 1;
	} else {
	    sprintf(d,"\\u%04x",ch);	d += 6;
d335 2
a336 3
    }
    *d = '\0';
    return(dest);
d370 2
a371 2
		CONST char *elementPtr;
		CONST char *nextPtr;
d754 4
a757 4
	if (b->file) Tcl_DecrRefCount(b->file);
	if (b->pat) Tcl_DecrRefCount(b->pat);
	if (b->cmd) Tcl_DecrRefCount(b->cmd);
	if (b->expr) Tcl_DecrRefCount(b->expr);
d776 2
a777 2
savestr(objPtr,str)
Tcl_Obj **objPtr;
d780 2
a781 2
    *objPtr = Tcl_NewStringObj(str, -1);
    Tcl_IncrRefCount(*objPtr);
d883 3
a885 9
		if (argc > 0) {
		    b->re = 1;
		    savestr(&b->pat,argv[0]);
		    if (Tcl_GetRegExpFromObj(interp, b->pat, TCL_REG_ADVANCED)
			    == NULL) {
			breakpoint_destroy(b);
			return TCL_ERROR;
		    }
		    argc--; argv++;
d920 1
a920 1
			if (b->file) Tcl_DecrRefCount(b->file);
@


5.28.1.1.2.3
log
@-gl now appears to work
@
text
@d162 1
a162 1
    for (i=0;i<=info.nsubs;i++) {
@


5.28.1.1.2.4
log
@Updated to reflect change of Tcl_RegExpMatchObj to Tcl_RegExpExecObj
moved compiler configure tests earlier in file so it works with gcc
@
text
@d184 1
a184 1
	if (Tcl_RegExpExecObj(NULL, re, cmd, 0 /* offset */,
@


5.28.1.1.2.5
log
@fixes throughout code but all tests and examples finally run
see NEWS file for summary
@
text
@d156 1
a156 1
    int i, start /*, end*/;
d158 1
a158 1
    /* char match_char;/* place to hold char temporarily */
d164 1
a164 1
	/* end = info.matches[i].end-1;*/
d178 1
a178 1
char *cmd;		/* command about to be executed */
a181 1
	Tcl_Obj *cmdObj;
d184 1
a184 3
	cmdObj = Tcl_NewStringObj(cmd,-1);
	Tcl_IncrRefCount(cmdObj);
	if (Tcl_RegExpExecObj(NULL, re, cmdObj, 0 /* offset */,
a187 1
	Tcl_DecrRefCount(cmdObj);
d189 1
a189 1
	if (0 == Tcl_StringMatch(cmd,
d438 1
a438 1
    argv = (char **)ckalloc(objc+1 * sizeof(char *));
@


5.28.1.1.2.6
log
@Fixed spawn -pty.
Fixed off by one error while stuffing regexp matches into variables.
Some of the regexp matches were being stuck into the global frame.
Protected all exprs in examples with {}.
Returned support for "expect --"
@
text
@d156 1
a156 1
    int i, start;
d158 2
d170 1
a170 1
		info.matches[i].start, info.matches[i].end-1), 0);
@


5.28.1.1.2.7
log
@Fixed Expect's standalone C library and examples.  This required some
changes to Expect since it and the library share some things.
@
text
@d159 1
a159 1
    Tcl_RegExpGetInfo(re, &info); 
@


5.28.1.1.2.8
log
@In interact, fixed encoding bug and -echo bug.
Made Makefile.in support CodeCenter better.
Fixed regexp bug in debugger.
@
text
@d187 1
a187 1
	    save_re_matches(interp, re, cmdObj);
@


