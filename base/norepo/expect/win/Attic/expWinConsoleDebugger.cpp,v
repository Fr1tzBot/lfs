head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.14
	telco-tec-win32-take2-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2002.03.07.03.25.43;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.07.03.25.43;	author davygrvy;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.08.23.20.49;	author davygrvy;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.09.01.17.29;	author davygrvy;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.09.01.51.29;	author davygrvy;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.03.09.03.10.31;	author davygrvy;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.03.09.05.48.50;	author davygrvy;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2002.03.09.22.56.23;	author davygrvy;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2002.03.11.05.36.37;	author davygrvy;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2002.03.12.07.09.36;	author davygrvy;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.03.12.18.14.59;	author davygrvy;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2002.03.13.03.52.57;	author davygrvy;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2002.03.15.07.41.45;	author davygrvy;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2002.03.15.07.51.56;	author davygrvy;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2002.03.16.00.37.01;	author davygrvy;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2002.06.18.22.51.31;	author davygrvy;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2002.06.18.23.14.18;	author davygrvy;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2002.06.20.06.43.55;	author davygrvy;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2002.06.20.21.52.53;	author davygrvy;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2002.06.21.03.01.50;	author davygrvy;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2002.06.21.22.04.24;	author davygrvy;	state Exp;
branches;
next	1.1.2.21;

1.1.2.21
date	2002.06.22.02.50.09;	author davygrvy;	state Exp;
branches;
next	1.1.2.22;

1.1.2.22
date	2002.06.22.05.54.32;	author davygrvy;	state Exp;
branches;
next	1.1.2.23;

1.1.2.23
date	2002.06.22.14.02.03;	author davygrvy;	state Exp;
branches;
next	1.1.2.24;

1.1.2.24
date	2002.06.23.09.27.22;	author davygrvy;	state Exp;
branches;
next	1.1.2.25;

1.1.2.25
date	2002.06.25.08.40.50;	author davygrvy;	state Exp;
branches;
next	1.1.2.26;

1.1.2.26
date	2002.06.25.22.50.07;	author davygrvy;	state Exp;
branches;
next	1.1.2.27;

1.1.2.27
date	2002.06.26.03.58.13;	author davygrvy;	state Exp;
branches;
next	1.1.2.28;

1.1.2.28
date	2002.06.27.03.43.34;	author davygrvy;	state Exp;
branches;
next	1.1.2.29;

1.1.2.29
date	2002.06.27.22.51.04;	author davygrvy;	state Exp;
branches;
next	1.1.2.30;

1.1.2.30
date	2002.06.28.01.26.56;	author davygrvy;	state Exp;
branches;
next	1.1.2.31;

1.1.2.31
date	2002.06.29.00.44.35;	author davygrvy;	state Exp;
branches;
next	1.1.2.32;

1.1.2.32
date	2003.08.25.23.17.49;	author davygrvy;	state Exp;
branches;
next	1.1.2.33;

1.1.2.33
date	2003.08.26.00.14.38;	author davygrvy;	state Exp;
branches;
next	1.1.2.34;

1.1.2.34
date	2003.08.26.20.46.52;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expWinConsoleDebugger.cpp was initially added on branch telco-tec-win32-take2-branch.
@
text
@@


1.1.2.1
log
@C++ rewrite of the debugger code is coming along well.
@
text
@a0 1154
/* ----------------------------------------------------------------------------
 * expWinConsoleDebugger.cpp --
 *
 *	Console debugger core implimentation.
 *
 * ----------------------------------------------------------------------------
 *
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 * 
 * Copyright (c) 1997 Mitel Corporation
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
 *
 * Copyright (c) 2001-2002 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
 *
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: expWinConsoleDebugger.hpp,v 1.1.2.2 2002/03/07 02:41:46 davygrvy Exp $
 * ----------------------------------------------------------------------------
 */

#include <stddef.h>
#include <assert.h>
#include "expWinConsoleDebugger.hpp"
#ifdef _MSC_VER
#   pragma comment (lib, "imagehlp.lib")
#endif

// constructor.
ConsoleDebugger::ConsoleDebugger (int argc, char * const *argv)
    : _argc(argc), _argv(argv), ProcessList(0L), CursorKnown(FALSE)
{
    ConsoleSize.X = 80;
    ConsoleSize.Y = 25;
    CursorPosition.X = 0;
    CursorPosition.Y = 0;

    BreakArrayKernel32[0].funcName = "Beep";
    BreakArrayKernel32[0].nargs = 2;
    BreakArrayKernel32[0].breakProc = OnBeep;
    BreakArrayKernel32[0].dwFlags = BREAK_OUT|BREAK_IN;

    BreakArrayKernel32[1].funcName = "FillConsoleOutputCharacterA";
    BreakArrayKernel32[1].nargs = 5;
    BreakArrayKernel32[1].breakProc = OnFillConsoleOutputCharacter;
    BreakArrayKernel32[1].dwFlags = BREAK_OUT;

    BreakArrayKernel32[2].funcName = "FillConsoleOutputCharacterW";
    BreakArrayKernel32[2].nargs = 5;
    BreakArrayKernel32[2].breakProc = OnFillConsoleOutputCharacter;
    BreakArrayKernel32[2].dwFlags = BREAK_OUT;

    BreakArrayKernel32[3].funcName = "GetStdHandle";
    BreakArrayKernel32[3].nargs = 1;
    BreakArrayKernel32[3].breakProc = OnGetStdHandle;
    BreakArrayKernel32[3].dwFlags = BREAK_OUT;

    BreakArrayKernel32[4].funcName = "OpenConsoleW";
    BreakArrayKernel32[4].nargs = 4;
    BreakArrayKernel32[4].breakProc = OnOpenConsoleW;
    BreakArrayKernel32[4].dwFlags = BREAK_OUT;

    BreakArrayKernel32[5].funcName = "ReadConsoleInputA";
    BreakArrayKernel32[5].nargs = 4;
    BreakArrayKernel32[5].breakProc = OnReadConsoleInput;
    BreakArrayKernel32[5].dwFlags = BREAK_OUT;

    BreakArrayKernel32[6].funcName = "ReadConsoleInputW";
    BreakArrayKernel32[6].nargs = 4;
    BreakArrayKernel32[6].breakProc = OnReadConsoleInput;
    BreakArrayKernel32[6].dwFlags = BREAK_OUT;

    BreakArrayKernel32[7].funcName = "ScrollConsoleScreenBufferA";
    BreakArrayKernel32[7].nargs = 5;
    BreakArrayKernel32[7].breakProc = OnScrollConsoleScreenBuffer;
    BreakArrayKernel32[7].dwFlags = BREAK_OUT;

    BreakArrayKernel32[8].funcName = "ScrollConsoleScreenBufferW";
    BreakArrayKernel32[8].nargs = 5;
    BreakArrayKernel32[8].breakProc = OnScrollConsoleScreenBuffer;
    BreakArrayKernel32[8].dwFlags = BREAK_OUT;

    BreakArrayKernel32[9].funcName = "SetConsoleMode";
    BreakArrayKernel32[9].nargs = 2;
    BreakArrayKernel32[9].breakProc = OnSetConsoleMode;
    BreakArrayKernel32[9].dwFlags = BREAK_OUT;

    BreakArrayKernel32[10].funcName = "SetConsoleActiveScreenBuffer";
    BreakArrayKernel32[10].nargs = 1;
    BreakArrayKernel32[10].breakProc = OnSetConsoleActiveScreenBuffer;
    BreakArrayKernel32[10].dwFlags = BREAK_OUT;

    BreakArrayKernel32[11].funcName = "SetConsoleCursorPosition";
    BreakArrayKernel32[11].nargs = 2;
    BreakArrayKernel32[11].breakProc = OnSetConsoleCursorPosition;
    BreakArrayKernel32[11].dwFlags = BREAK_OUT;

    BreakArrayKernel32[12].funcName = "SetConsoleWindowInfo";
    BreakArrayKernel32[12].nargs = 2;
    BreakArrayKernel32[12].breakProc = OnSetConsoleWindowInfo;
    BreakArrayKernel32[12].dwFlags = BREAK_OUT;

    BreakArrayKernel32[13].funcName = "WriteConsoleA";
    BreakArrayKernel32[13].nargs = 5;
    BreakArrayKernel32[13].breakProc = OnWriteConsoleA;
    BreakArrayKernel32[13].dwFlags = BREAK_OUT;

    BreakArrayKernel32[14].funcName = "WriteConsoleW";
    BreakArrayKernel32[14].nargs = 5;
    BreakArrayKernel32[14].breakProc = OnWriteConsoleW;
    BreakArrayKernel32[14].dwFlags = BREAK_OUT;

    BreakArrayKernel32[15].funcName = "WriteConsoleOutputA";
    BreakArrayKernel32[15].nargs = 5;
    BreakArrayKernel32[15].breakProc = OnWriteConsoleOutputA;
    BreakArrayKernel32[15].dwFlags = BREAK_OUT;

    BreakArrayKernel32[16].funcName = "WriteConsoleOutputW";
    BreakArrayKernel32[16].nargs = 5;
    BreakArrayKernel32[16].breakProc = OnWriteConsoleOutputW;
    BreakArrayKernel32[16].dwFlags = BREAK_OUT;

    BreakArrayKernel32[17].funcName = "WriteConsoleOutputCharacterA";
    BreakArrayKernel32[17].nargs = 5;
    BreakArrayKernel32[17].breakProc = OnWriteConsoleOutputCharacterA;
    BreakArrayKernel32[17].dwFlags = BREAK_OUT;

    BreakArrayKernel32[18].funcName = "WriteConsoleOutputCharacterW";
    BreakArrayKernel32[18].nargs = 5;
    BreakArrayKernel32[18].breakProc = OnWriteConsoleOutputCharacterW;
    BreakArrayKernel32[18].dwFlags = BREAK_OUT;

    BreakArrayKernel32[19].funcName = 0L;
    BreakArrayKernel32[19].nargs = 0;
    BreakArrayKernel32[19].breakProc = 0L;
    BreakArrayKernel32[19].dwFlags = 0;

/*    BreakArrayKernel32[0] = {
	{"Beep", 2, OnBeep, BREAK_OUT|BREAK_IN},
	{"FillConsoleOutputCharacterA", 5, OnFillConsoleOutputCharacter, BREAK_OUT},
	{"FillConsoleOutputCharacterW", 5, OnFillConsoleOutputCharacter, BREAK_OUT},
	{"GetStdHandle", 1, OnGetStdHandle, BREAK_OUT},
	{"OpenConsoleW", 4, OnOpenConsoleW, BREAK_OUT},
	{"ReadConsoleInputA", 4, OnReadConsoleInput, BREAK_OUT},
	{"ReadConsoleInputW", 4, OnReadConsoleInput, BREAK_OUT},
	{"ScrollConsoleScreenBufferA", 5, OnScrollConsoleScreenBuffer, BREAK_OUT},
	{"ScrollConsoleScreenBufferW", 5, OnScrollConsoleScreenBuffer, BREAK_OUT},
	{"SetConsoleMode", 2, OnSetConsoleMode, BREAK_OUT},
	{"SetConsoleActiveScreenBuffer", 1, OnSetConsoleActiveScreenBuffer, BREAK_OUT},
	{"SetConsoleCursorPosition", 2, OnSetConsoleCursorPosition, BREAK_OUT},
	{"SetConsoleWindowInfo", 2, OnSetConsoleWindowInfo, BREAK_OUT},
	{"WriteConsoleA", 5, OnWriteConsoleA, BREAK_OUT},
	{"WriteConsoleW", 5, OnWriteConsoleW, BREAK_OUT},
	{"WriteConsoleOutputA", 5, OnWriteConsoleOutputA, BREAK_OUT},
	{"WriteConsoleOutputW", 5, OnWriteConsoleOutputW, BREAK_OUT},
	{"WriteConsoleOutputCharacterA", 5, OnWriteConsoleOutputCharacterA, BREAK_OUT},
	{"WriteConsoleOutputCharacterW", 5, OnWriteConsoleOutputCharacterW, BREAK_OUT|BREAK_IN},
	{0L, 0, 0L}
    };*/

    BreakArrayUser32[0].funcName = "IsWindowVisible";
    BreakArrayUser32[0].nargs = 1;
    BreakArrayUser32[0].breakProc = OnIsWindowVisible;
    BreakArrayUser32[0].dwFlags = BREAK_OUT;
    BreakArrayUser32[1].funcName = 0L;
    BreakArrayUser32[1].nargs = 0;
    BreakArrayUser32[1].breakProc = 0L;
    BreakArrayUser32[1].dwFlags = 0;

    BreakPoints[0].dllName = "kernel32.dll";
    BreakPoints[0].breakInfo = BreakArrayKernel32;
    BreakPoints[1].dllName = "user32.dll";
    BreakPoints[1].breakInfo = BreakArrayUser32;
    BreakPoints[2].dllName = 0L;
    BreakPoints[2].breakInfo = 0L;
}

unsigned ConsoleDebugger::ThreadHandlerProc(void)
{
    //ExpSlaveDebugArg *arg = (ExpSlaveDebugArg *) lparg;
    Process *proc;
    DWORD result;
    HANDLE process;
    DWORD pid;

    //HConsole = arg->hConsole;
    //HMaster = arg->hMaster;		/* Set the master program */
    //UseSocket = arg->useSocket;

    /* Make sure the master does not ignore Ctrl-C */
    SetConsoleCtrlHandler(0L, FALSE);
    result = ExpWinCreateProcess(
	    _argc,
	    _argv,
	    NULL,
	    NULL,
	    NULL,
	    FALSE,
	    FALSE,
	    TRUE, /* debug */
	    TRUE, /* newProcessGroup */
	    &process,
	    &pid);

    if (result) {
	//arg->lastError = GetLastError();
    }

    /* Make sure we now ignore Ctrl-C */
    SetConsoleCtrlHandler(0L, TRUE);
    //SetEvent(arg->event);

    if (result) {
	return 0;
    }

    proc = ProcessNew();
    //proc->hPid = arg->globalPid;
//    if (arg->passThrough) {
//	ExpProcess *proc;
//
//	proc = ExpProcessNew();
//	proc->overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
//	proc->hProcess = arg->process;
//	ExpAddToWaitQueue(proc->hProcess);
//    } else {
	//CloseHandle(arg->process);
	proc->hProcess = process;
//	arg->process = proc->hProcess;
	if (proc->hProcess == 0L) {
	    //arg->lastError = GetLastError();
	    return 0;
	}
	//ExpAddToWaitQueue(proc->hProcess);
	//proc->overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	CommonDebugger();
//    }

    return 0;			/* Never executes */
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::ProcessNew --
 *
 *	Allocates a new structure for debugging a process and
 *	initializes it.
 *
 * Results:
 *	A new structure
 *
 * Side Effects:
 *	Memory is allocated, an event is created.
 *
 *----------------------------------------------------------------------
 */

ConsoleDebugger::Process *
ConsoleDebugger::ProcessNew(void)
{
    Process *proc;
    proc = new Process;
    proc->threadList = NULL;
    proc->threadCount = 0;
    proc->brkptList = NULL;
    proc->lastBrkpt = NULL;
    proc->offset = 0;
    proc->nBreakCount = 0;
    proc->consoleHandlesMax = 0;
    proc->isConsoleApp = FALSE;
    proc->isShell = FALSE;
    proc->hProcess = NULL;
    proc->pSubprocessMemory = 0;
    proc->pSubprocessBuffer = 0;
    proc->pMemoryCacheBase = 0;
    proc->funcTable = new Tcl_HashTable;
    Tcl_InitHashTable(proc->funcTable, TCL_STRING_KEYS);
    proc->moduleTable = new Tcl_HashTable;
    Tcl_InitHashTable(proc->moduleTable, TCL_ONE_WORD_KEYS);
    proc->exeModule = NULL;
    proc->nextPtr = ProcessList;
    ProcessList = proc;
    return proc;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::ProcessFree --
 *
 *	Frees all allocated memory for a process and closes any
 *	open handles
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::ProcessFree(Process *proc)
{
    ThreadInfo *tcurr, *tnext;
    Breakpoint *bcurr, *bnext;
    Process *pcurr, *pprev;
    
    for (tcurr = proc->threadList; tcurr != NULL; tcurr = tnext) {
	tnext = tcurr->nextPtr;
	proc->threadCount--;
	CloseHandle(tcurr->hThread);
	delete tcurr;
    }
    for (bcurr = proc->brkptList; bcurr != NULL; bcurr = bnext) {
	bnext = bcurr->nextPtr;
	delete bcurr;
    }
    Tcl_DeleteHashTable(proc->funcTable);
    delete proc->funcTable;
    Tcl_DeleteHashTable(proc->moduleTable);
    delete proc->moduleTable;

    for (pprev = NULL, pcurr = ProcessList; pcurr != NULL;
	 pcurr = pcurr->nextPtr)
    {
	if (pcurr == proc) {
	    if (pprev == NULL) {
		ProcessList = pcurr->nextPtr;
	    } else {
		pprev->nextPtr = pcurr->nextPtr;
	    }
	    break;
	}
    }

    delete proc;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::CommonDebugger --
 *
 *	This is the function that is the debugger for all slave processes
 *
 * Results:
 *	None.  This thread exits with ExitThread() when the subprocess dies.
 *
 * Side Effects:
 *	Adds the process to the things being waited for by
 *	WaitForMultipleObjects
 *
 *----------------------------------------------------------------------
 */
void
ConsoleDebugger::CommonDebugger()
{
    DEBUG_EVENT debEvent;	// debugging event info.
    DWORD dwContinueStatus;	// exception continuation.
    DWORD err;
    Process *proc;
    DWORD n, i;

    n = GetEnvironmentVariable("Path", NULL, 0);
    n += GetEnvironmentVariable("_NT_SYMBOL_PATH", NULL, 0) + 1;
    n += GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", NULL, 0) + 1;
    n += GetEnvironmentVariable("SystemRoot", NULL, 0) + 1;

    SymbolPath = new char [n];

    i = GetEnvironmentVariable("Path", SymbolPath, n);
    SymbolPath[i++] = ';';
    i += GetEnvironmentVariable("_NT_SYMBOL_PATH", &SymbolPath[i], n-i);
    SymbolPath[i++] = ';';
    i += GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", &SymbolPath[i], n-i);
    SymbolPath[i++] = ';';
    i += GetEnvironmentVariable("SystemRoot", &SymbolPath[i], n-i);

    for(;;) {
	dwContinueStatus = DBG_CONTINUE;

	/*
	 * Wait for a debugging event to occur. The second parameter
	 * indicates that the function does not return until
	 * a debugging event occurs.
	 */

	if (WaitForDebugEvent(&debEvent, INFINITE) == FALSE) {
	    err = GetLastError();
	    *((char *) 0L) = 0;   // cause an exception.
	}

	/*
	 * Find the process that is responsible for this event.
	 */
	for (proc = ProcessList; proc; proc = proc->nextPtr) {
	    if (proc->hPid == debEvent.dwProcessId) {
		break;
	    }
	}

	if (!proc && debEvent.dwDebugEventCode != CREATE_PROCESS_DEBUG_EVENT) {
	    char buf[50];
	    wsprintfA(buf, "%d/%d (%d)", 
		    debEvent.dwProcessId, debEvent.dwThreadId,
		    debEvent.dwDebugEventCode);
//	    EXP_LOG1(MSG_DT_UNEXPECTEDDBGEVENT, buf);
	    EXP_LOG("Unexpected debug event for %s", buf);
	    if (debEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
//		char buf[50];
//		wsprintfA(buf, "0x%08x", debEvent.u.Exception.ExceptionRecord.ExceptionCode);
//		EXP_LOG1(MSG_DT_EXCEPTIONDBGEVENT, buf);
		EXP_LOG("ExceptionCode: 0x%08x",
			debEvent.u.Exception.ExceptionRecord.ExceptionCode);
		dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
	    }
	    goto skip;
	}

	/* Process the debugging event code. */

	switch (debEvent.dwDebugEventCode) {
	case EXCEPTION_DEBUG_EVENT:
	    /*
	     * Process the exception code. When handling
	     * exceptions, remember to set the continuation
	     * status parameter (dwContinueStatus). This value
	     * is used by the ContinueDebugEvent function.
	     */

	    switch (debEvent.u.Exception.ExceptionRecord.ExceptionCode) {
	    case EXCEPTION_BREAKPOINT:
	    {
		if (proc->nBreakCount < 1000) {
		    proc->nBreakCount++;
		}
		if (proc->nBreakCount == 1) {
		    OnXFirstBreakpoint(proc, &debEvent);
		} else if (proc->nBreakCount == 2) {
		    OnXSecondBreakpoint(proc, &debEvent);
		} else {
		    OnXBreakpoint(proc, &debEvent);
		}
		break;
	    }

	    case EXCEPTION_SINGLE_STEP:
		OnXSingleStep(proc, &debEvent);
		break;

	    case DBG_CONTROL_C:
		/* fprintf(stderr, "Saw DBG_CONTROL_C event\n"); */
		dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
		break;

	    case DBG_CONTROL_BREAK:
		/* fprintf(stderr, "Saw DBG_CONTROL_BREAK event\n"); */
		dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
		break;

	    case EXCEPTION_DATATYPE_MISALIGNMENT:
	    case EXCEPTION_ACCESS_VIOLATION:
	    default:
		/*
		 * An exception was hit and it was not handled by the program.
		 * Now it is time to get a backtrace.
		 */
		if (! debEvent.u.Exception.dwFirstChance) {
		    OnXSecondChanceException(proc, &debEvent);
		}
		dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
	    }
	    break;

	case CREATE_THREAD_DEBUG_EVENT:
#if 0
	    fprintf(stderr, "Process %d creating thread %d\n", proc->hPid, 
		    debEvent.dwThreadId);
#endif
	    OnXCreateThread(proc, &debEvent);
	    break;

	case CREATE_PROCESS_DEBUG_EVENT:
#if 0
	    fprintf(stderr, "Process %d starting...\n", debEvent.dwProcessId);
#endif
	    OnXCreateProcess(proc, &debEvent);
	    break;

	case EXIT_THREAD_DEBUG_EVENT:
#if 0
	    fprintf(stderr, "Process %d thread %d exiting\n", proc->hPid,
		    debEvent.dwThreadId);
#endif
	    OnXDeleteThread(proc, &debEvent);
	    break;

	case EXIT_PROCESS_DEBUG_EVENT:
	    /*
	     * XXX: This is really screwed up, but we get breakpoints
	     * for processes that are already dead.  So we cannot remove
	     * and cleanup a process until some later (How much later?)
	     * point.  This really, really sucks....
	     */
//	    CloseHandle(proc->overlapped.hEvent);
#if 0 /* This gets closed in WaitQueueThread */
	    CloseHandle(proc->hProcess);
#endif
	    err = debEvent.u.ExitProcess.dwExitCode;
	    ProcessFree(proc);
	    if (ProcessList == NULL) {
		// When the last process exits, we exit.
		return;
	    }
	    break;

	case LOAD_DLL_DEBUG_EVENT:
	    OnXLoadDll(proc, &debEvent);
	    break;

	case UNLOAD_DLL_DEBUG_EVENT:
	    OnXUnloadDll(proc, &debEvent);
	    break;

	case OUTPUT_DEBUG_STRING_EVENT:
	    /* Display the output debugging string. */
	    break;
	}

    skip:
	/* Resume executing the thread that reported the debugging event. */
	ContinueDebugEvent(debEvent.dwProcessId,
			   debEvent.dwThreadId, dwContinueStatus);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::SetBreakpoint --
 *
 *	Inserts a single breakpoint
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful.
 *
 *----------------------------------------------------------------------
 */

BOOL
ConsoleDebugger::SetBreakpoint(Process *proc, BreakInfo *info)
{
    Tcl_HashEntry *tclEntry;
    PVOID funcPtr;

    tclEntry = Tcl_FindHashEntry(proc->funcTable, info->funcName);
    if (tclEntry == NULL) {
//	EXP_LOG("Unable to set breakpoint at %s", info->funcName);
	return FALSE;
    }

#if 0
    fprintf(stderr, "%s: ", info->funcName);
#endif
    /*
     * Set a breakpoint at the function start in the subprocess and
     * save the original code at the function start.
     */
    funcPtr = Tcl_GetHashValue(tclEntry);
    SetBreakpointAtAddr(proc, info, funcPtr);
    return TRUE;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::SetBreakpointAtAddr --
 *
 *	Inserts a single breakpoint at the given address
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful.
 *
 *----------------------------------------------------------------------
 */

ConsoleDebugger::Breakpoint *
ConsoleDebugger::SetBreakpointAtAddr(Process *proc, BreakInfo *info, PVOID funcPtr)
{
    Breakpoint *bpt;
    UCHAR code;

#if 0
    fprintf(stderr, "SetBreakpointAtAddr: addr=0x%08x\n", funcPtr);
#endif
    bpt = new Breakpoint;
    bpt->returning = FALSE;
    bpt->codePtr = funcPtr;
    bpt->codeReturnPtr = (PVOID) (proc->offset + (DWORD) proc->pSubprocessMemory);
    bpt->origRetAddr = 0;
    bpt->breakInfo = info;
    bpt->threadInfo = NULL;
    proc->offset += 2;
    bpt->nextPtr = proc->brkptList;
    proc->brkptList = bpt;

    ReadSubprocessMemory(proc, funcPtr, &bpt->code, sizeof(UCHAR));
#ifdef _M_IX86
    // Breakpoint opcode on i386
    code = 0xcc;
#else
#   error "need breakpoint opcode for this hardware"
#endif
    WriteSubprocessMemory(proc, funcPtr, &code, sizeof(UCHAR));
    return bpt;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXFirstBreakpoint --
 *
 *	This routine is called when a EXCEPTION_DEBUG_EVENT with
 *	an exception code of EXCEPTION_BREAKPOINT, and it is the
 *	first one to occur in the program.  This happens when the
 *	process finally gets loaded into memory and is about to
 *	start.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

static CONTEXT FirstContext;
static UCHAR   FirstPage[PAGESIZE];
static HANDLE  FirstThread;
#include <pshpack1.h>
typedef struct _InjectCode {
    UCHAR instPush1;
    DWORD argMemProtect;
    UCHAR instPush2;
    DWORD argMemType;
    UCHAR instPush3;
    DWORD argMemSize;
    UCHAR instPush4;
    DWORD argMemAddr;
    UCHAR instCall;
    DWORD argCallAddr;
    DWORD instIntr;
} InjectCode;
#include <poppack.h>

void
ConsoleDebugger::OnXFirstBreakpoint(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    DWORD base;
    ThreadInfo *tinfo;

#if 0
    fprintf(stderr, "OnXFirstBreakpoint: proc=0x%08x\n", proc);
#endif
    for (tinfo = proc->threadList; tinfo != NULL; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
    }

    /*
     * Set up the memory that will serve as the place for our
     * intercepted function return points.
     */

    {
	InjectCode code;
	Tcl_HashEntry *tclEntry;
	DWORD addr;

	FirstThread = tinfo->hThread;
	FirstContext.ContextFlags = CONTEXT_FULL;
	GetThreadContext(FirstThread, &FirstContext);

	tclEntry = Tcl_FindHashEntry(proc->funcTable, "VirtualAlloc");
	if (tclEntry == 0L) {
	    proc->nBreakCount++;	/* Don't stop at second breakpoint */
//	    EXP_LOG0(MSG_DT_NOVIRT);
	    EXP_LOG("Unable to find entry for VirtualAlloc", NULL);
	    return;
	}
	addr = (DWORD) Tcl_GetHashValue(tclEntry);

	code.instPush1     = 0x68;
	code.argMemProtect = PAGE_EXECUTE_READWRITE;
	code.instPush2     = 0x68;
	code.argMemType    = MEM_COMMIT;
	code.instPush3     = 0x68;
	code.argMemSize    = 2048;
	code.instPush4     = 0x68;
	code.argMemAddr    = 0;
	code.instCall      = 0xe8;
	code.argCallAddr   = addr - FirstContext.Eip - offsetof(InjectCode, instCall) - 5;
	code.instIntr      = 0xCC;

	base = FirstContext.Eip;
	if (!ReadSubprocessMemory(proc, (PVOID) base, FirstPage, sizeof(InjectCode))) {
//	    EXP_LOG0(MSG_DT_CANTREADSPMEM);
	    EXP_LOG("Error reading subprocess memory", NULL);
	}
	if (!WriteSubprocessMemory(proc, (PVOID) base, &code, sizeof(InjectCode))) {
//	    EXP_LOG0(MSG_DT_CANTWRITESPMEM);
    	    EXP_LOG("Error writing subprocess memory", NULL);
	}
    }
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXSecondBreakpoint --
 *
 *	This routine is called when the second breakpoint is hit.
 *	The second breakpoint is at the end of our call to GlobalAlloc().
 *	Save the returned pointer from GlobalAlloc, then restore the
 *	first page of memory and put everything back the way it was.
 *	Finally, we can start.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXSecondBreakpoint(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    CONTEXT context;
    UCHAR retbuf[2048];
    DWORD base;
    LPEXCEPTION_DEBUG_INFO exceptInfo;
    BreakInfo *info;
    int i;

    exceptInfo = &pDebEvent->u.Exception;

    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(FirstThread, &context);
    proc->pSubprocessMemory = context.Eax;

    memset(retbuf, 0xcc, sizeof(retbuf));	/* All breakpoints */
    WriteSubprocessMemory(proc, (PVOID) proc->pSubprocessMemory,
			  retbuf, sizeof(retbuf));

    base = FirstContext.Eip;
    if (!WriteSubprocessMemory(proc, (PVOID) base, FirstPage, sizeof(InjectCode))) {
//	EXP_LOG0(MSG_DT_CANTWRITESPMEM);
	EXP_LOG("Error writing subprocess memory", NULL);
    }
    SetThreadContext(FirstThread, &FirstContext);

    /*
     * Set all breakpoints
     */
    for (i = 0; BreakPoints[i].dllName; i++) {
	for (info = BreakPoints[i].breakInfo; info->funcName; info++) {
	    SetBreakpoint(proc, info);
	}
    }
}


/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::ReadSubprocessMemory --
 *
 *	Reads memory from the subprocess.  Takes care of all the
 *	issues with page protection.
 *
 * Results:
 *	FALSE if unsuccessful, TRUE if successful.
 *
 * Notes:
 *	The efficient memory reading routine is disabled here
 *	because it doesn't quite work right.  I don't see the
 *	problem in the code, but there must be something there
 *	since the test suite fails when run with this code
 *	enabled.  When it works, it should be much faster than
 *	the current safe but slow implementation.
 *
 *----------------------------------------------------------------------
 */

#if 0
BOOL
ConsoleDebugger::ReadSubprocessMemory(ExpProcess *proc, LPVOID addr, LPVOID buf, DWORD len)
{
    DWORD oldProtection = 0;
    MEMORY_BASIC_INFORMATION mbi;
    BOOL ret = TRUE;
    DWORD offset;
    DWORD base, curr, end, n;
    HANDLE hProcess;
    PBYTE bufpos = buf;

    hProcess = proc->hProcess;

    end = len + (DWORD) addr;
    for (curr = (DWORD) addr; curr < end; ) {
	base = curr & (~PAGEMASK);
	offset = curr & PAGEMASK;
	if (offset + len > PAGESIZE) {
	    n = PAGESIZE - offset;
	} else {
	    n = len;
	}
	if (proc->pMemoryCacheBase != (curr & PAGEMASK)) {
	    /* if not committed memory abort */
	    if (!VirtualQueryEx(hProcess, (LPVOID) base, &mbi, sizeof(mbi)) ||
		(mbi.State != MEM_COMMIT))
	    {
		return FALSE;
	    }

	    /* if guarded memory, change protection temporarily */
	    if (!(mbi.Protect & PAGE_READONLY) &&
		!(mbi.Protect & PAGE_READWRITE))
	    {
		VirtualProtectEx(hProcess, (LPVOID) base, PAGESIZE,
		    PAGE_READONLY, &oldProtection);
	    }

	    if (!ReadProcessMemory(hProcess, (LPVOID) base, proc->pMemoryCache,
		PAGESIZE, NULL)) {
		ret = FALSE;
	    }
    
	    /* reset protection if changed */
	    if (oldProtection) {
		VirtualProtectEx(hProcess, (LPVOID) base, PAGESIZE,
		    oldProtection, &oldProtection);
	    }
	    if (ret == FALSE) {
		return FALSE;
	    }
	    proc->pMemoryCacheBase = base;
	}

	memcpy(bufpos, &proc->pMemoryCache[offset], n);
	bufpos += n;
	curr += n;
    }

    return ret;
}

#else
BOOL
ConsoleDebugger::ReadSubprocessMemory(Process *proc, LPVOID addr, LPVOID buf, DWORD len)
{
    DWORD oldProtection = 0;
    MEMORY_BASIC_INFORMATION mbi;
    BOOL ret;
    LONG error;

    /* if not committed memory abort */
    if (!VirtualQueryEx(proc->hProcess, addr, &mbi, sizeof(mbi)) ||
	mbi.State != MEM_COMMIT)
    {
	return FALSE;
    }
    
    /* if guarded memory, change protection temporarily */
    if (!(mbi.Protect & PAGE_READONLY) && !(mbi.Protect & PAGE_READWRITE)) {
	VirtualProtectEx(proc->hProcess, addr, len, PAGE_READONLY, &oldProtection);
    }
    
    ret = ReadProcessMemory(proc->hProcess, addr, buf, len, NULL);
    if (ret == FALSE) {
	error = GetLastError();
    }
    
    /* reset protection if changed */
    if (oldProtection) {
	VirtualProtectEx(proc->hProcess, addr, len, oldProtection, &oldProtection);
	SetLastError(error);
    }
    return ret;
}
#endif /* XXX */

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::WriteSubprocessMemory --
 *
 *	Writes memory from the subprocess.  Takes care of all the
 *	issues with page protection.
 *
 * Results:
 *	0 if unsuccessful, 1 if successful.
 *
 *----------------------------------------------------------------------
 */

BOOL
ConsoleDebugger::WriteSubprocessMemory(Process *proc, LPVOID addr, LPVOID buf, DWORD len)
{
    DWORD oldProtection = 0;
    MEMORY_BASIC_INFORMATION mbi;
    BOOL ret = TRUE;
    DWORD err;
    HANDLE hProcess;

    hProcess = proc->hProcess;

    /* Flush the read cache */
    proc->pMemoryCacheBase = 0;

    /* if not committed memory abort */
    if (!VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi)) ||
	mbi.State != MEM_COMMIT)
    {
	ret = FALSE;
	/* assert(ret != FALSE); */
	return ret;
    }
    
    /* if guarded memory, change protection temporarily */
    if (!(mbi.Protect & PAGE_READWRITE)) {
	if (!VirtualProtectEx(hProcess, addr, len, PAGE_READWRITE,
			      &oldProtection)) {
	    err = GetLastError();
	}
    }
    
    if (!WriteProcessMemory(hProcess, addr, buf, len, NULL)) {
	ret = FALSE;
	err = GetLastError();
    }
    
    /* reset protection if changed */
    if (oldProtection) {
	VirtualProtectEx(hProcess, addr, len, oldProtection, &oldProtection);
    }
#if 0 /* Debugging purposes only */
    if (ret == FALSE) {
	assert(ret != FALSE); 
    }
#endif
    return ret;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXBreakpoint --
 *
 *	This routine is called when a EXCEPTION_DEBUG_EVENT with
 *	an exception code of EXCEPTION_BREAKPOINT.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXBreakpoint(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    LPEXCEPTION_DEBUG_INFO exceptInfo;
    CONTEXT context;
    ThreadInfo *tinfo;
    Breakpoint *pbrkpt, *brkpt;
    PDWORD pdw;
    DWORD i;
    DWORD dw;

    for (tinfo = proc->threadList; tinfo != 0L; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
    }
    assert(tinfo != 0L);

    exceptInfo = &pDebEvent->u.Exception;
#if 0
    fprintf(stderr, "OnXBreakpoint: proc=0x%x, count=%d, addr=0x%08x\n", proc, proc->nBreakCount, exceptInfo->ExceptionRecord.ExceptionAddress);
#endif

    pbrkpt = 0L;
    for (brkpt = proc->brkptList; brkpt != 0L;
	 pbrkpt = brkpt, brkpt = brkpt->nextPtr) {
	if (brkpt->codePtr == exceptInfo->ExceptionRecord.ExceptionAddress) {
	    if (brkpt->threadInfo == 0L) {
		break;
	    }
	    if (brkpt->threadInfo == tinfo) {
		break;
	    }
	}
    }
#if 0 /* Allow user breakpoints to be hit when we are not debugging */
    if (brkpt == 0L) {
	fprintf(stderr, "OnXBreakpoint: proc=0x%x, count=%d, addr=0x%08x\n", proc, proc->nBreakCount, exceptInfo->ExceptionRecord.ExceptionAddress);
    }
    assert(brkpt != 0L);
#endif

    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(tinfo->hThread, &context);

    if (! brkpt->returning) {
	Breakpoint *bpt;
	/*
	 * Get the arguments to the function and store them in the thread
	 * specific data structure.
	 */
	for (pdw = tinfo->args, i=0; i < brkpt->breakInfo->nargs; i++, pdw++) {
	    ReadSubprocessMemory(proc, (PVOID) (context.Esp+(4*(i+1))),
				 pdw, sizeof(DWORD));
	}
	tinfo->nargs = brkpt->breakInfo->nargs;
	tinfo->context = &context;

	if (brkpt->breakInfo->dwFlags & BREAK_IN) {
	    ((this)->*(brkpt->breakInfo->breakProc))(proc, tinfo, brkpt, &context.Eax, BREAK_IN);
	}

	/*
	 * Only set a return breakpoint if something is interested
	 * in the return value
	 */
	if (brkpt->breakInfo->dwFlags & BREAK_OUT) {
	    bpt = new Breakpoint;
	    ReadSubprocessMemory(proc, (PVOID) context.Esp,
		&bpt->origRetAddr, sizeof(DWORD));
	    dw = (DWORD) brkpt->codeReturnPtr;
	    WriteSubprocessMemory(proc, (PVOID) context.Esp,
		&dw, sizeof(DWORD));
	    bpt->codePtr = brkpt->codeReturnPtr;
	    bpt->returning = TRUE;
	    bpt->codeReturnPtr = NULL;	/* Doesn't matter */
	    bpt->breakInfo = brkpt->breakInfo;
	    bpt->threadInfo = tinfo;
	    bpt->nextPtr = proc->brkptList;
	    proc->brkptList = bpt;

	}

	/*
	 * Now, we need to restore the original code for this breakpoint.
	 * Put the program counter back, then do a single-step and put
	 * the breakpoint back again.
	 */
	WriteSubprocessMemory(proc, brkpt->codePtr, &brkpt->code, sizeof(UCHAR));

	context.EFlags |= SINGLE_STEP_BIT;
	context.Eip--;

	proc->lastBrkpt = brkpt;
    } else {
	/*
	 * Make the callback with the params and the return value
	 */
	if (brkpt->breakInfo->dwFlags & BREAK_OUT) {
	    ((this)->*(brkpt->breakInfo->breakProc))(proc, tinfo, brkpt, &context.Eax, BREAK_OUT);
	}
	context.Eip = brkpt->origRetAddr;

	if (pbrkpt == 0L) {
	    proc->brkptList = brkpt->nextPtr;
	} else {
	    pbrkpt->nextPtr = brkpt->nextPtr;
	}
	delete brkpt;
    }
    SetThreadContext(tinfo->hThread, &context);
}

/*
 *----------------------------------------------------------------------
 *
 * ReadSubprocessStringA --
 *
 *	Read a character string from the subprocess
 *
 * Results:
 *	The length of the string
 *
 *----------------------------------------------------------------------
 */

int
ConsoleDebugger::ReadSubprocessStringA(Process *proc, PVOID base,
    PCHAR buf, int buflen)
{
    CHAR *ip, *op;
    int i;
    
    ip = static_cast<CHAR *>(base);
    op = buf;
    i = 0;
    while (i < buflen-1) {
	if (! ReadSubprocessMemory(proc, ip, op, sizeof(CHAR))) {
	    break;
	}
	if (*op == 0) break;
	op++; ip++; i++;
    }
    *op = 0;
    return i;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::ReadSubprocessStringW --
 *
 *	Read a character string from the subprocess
 *
 * Results:
 *	The length of the string
 *
 *----------------------------------------------------------------------
 */

int
ConsoleDebugger::ReadSubprocessStringW(Process *proc, PVOID base,
    PWCHAR buf, int buflen)
{
    WCHAR *ip, *op;
    int i;
    
    ip = static_cast<WCHAR *>(base);
    op = buf;
    i = 0;
    while (i < buflen-1) {
	if (! ReadSubprocessMemory(proc, ip, op, sizeof(WCHAR))) {
	    break;
	}
	if (*op == 0) break;
	op++; ip++; i++;
    }
    *op = 0;
    return i;
}
@


1.1.2.2
log
@more cleanup.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.1 2002/03/07 03:25:43 davygrvy Exp $
d36 1
a36 1
//  Constructor.
a39 2
    //  Until further notice, assume this.
    //
a41 3

    //  Until further notice, assume this, too.
    //
a44 5
    //  Set all our breakpoint info.  We have to do this the long way, here in
    //  the constructor, because we need to have the this pointer already
    //  set because we refer to ourselves by needing the address to member
    //  functions.
    //
d145 23
a171 1

a178 1

a180 1

d185 1
a185 2
unsigned
ConsoleDebugger::ThreadHandlerProc(void)
a198 1

d225 1
a225 1
//    proc->hPid = arg->globalPid;
d234 1
a234 1
	CloseHandle(process);
d241 2
a242 2
//	ExpAddToWaitQueue(proc->hProcess);
//	proc->overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
d459 1
d464 1
d483 4
d491 3
d498 4
d533 1
a533 1
	    // Display the output debugging string.
d538 3
a540 3
	// Resume executing the thread that reported the debugging event.
	ContinueDebugEvent(debEvent.dwProcessId, debEvent.dwThreadId,
		dwContinueStatus);
@


1.1.2.3
log
@Almost linkable again.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.2 2002/03/08 23:20:49 davygrvy Exp $
d461 4
a464 2
		// An exception was hit and it was not handled by the program.
		// Now it is time to get a backtrace.
d526 81
d743 1
a743 1
//	EXP_LOG("Error writing subprocess memory", NULL);
a756 617
/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXSingleStep --
 *
 *	This routine is called when a EXCEPTION_DEBUG_EVENT with
 *	an exception code of EXCEPTION_SINGLE_STEP.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXSingleStep(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    BYTE code;
    /*
     * Now, we need to restore the breakpoint that we had removed.
     */
    code = 0xcc;
    WriteSubprocessMemory(proc, proc->lastBrkpt->codePtr, &code, sizeof(BYTE));
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXSecondChanceException --
 *
 *	Handle a second chance exception
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXSecondChanceException(Process *proc,
    LPDEBUG_EVENT pDebEvent)
{
    BOOL b;
    STACKFRAME frame;
    CONTEXT context;
    ThreadInfo *tinfo;
    Tcl_HashEntry *tclEntry;
    Tcl_HashSearch tclSearch;
    Module *modPtr;
    DWORD displacement;
    BYTE symbolBuffer[sizeof(IMAGEHLP_SYMBOL) + 512];
    PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
    char *s;

    if (!ExpDebug) {
	return;
    }

    for (tinfo = proc->threadList; tinfo != NULL; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
    }
    assert(tinfo != NULL);

    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(tinfo->hThread, &context);

    /*
     * XXX: From what I can tell, SymInitialize is broken on Windows NT 4.0
     * if you try to have it iterate the modules in a process.  It always
     * returns an object mismatch error.  Instead, initialize without iterating
     * the modules.  Contrary to what MSDN documentation says,
     * Microsoft debuggers do not exclusively use the imagehlp API.  In
     * fact, the only thing VC 5.0 uses is the StackWalk function.
     * Windbg uses a few more functions, but it doesn't use SymInitialize.
     * We will then do the hard work of finding all the
     * modules and doing the right thing.
     */

    if (! SymInitialize(proc->hProcess, SymbolPath, FALSE)){
	fprintf(stderr, "Unable to get backtrace (Debug 1): 0x%08x\n",
	    GetLastError());
	goto error;
    }

#ifdef _M_IX86
    memset(&frame, 0, sizeof(frame));
    frame.AddrPC.Mode = AddrModeFlat;
    frame.AddrPC.Segment = 0;
    frame.AddrPC.Offset = context.Eip;

    frame.AddrReturn.Mode = AddrModeFlat;
    frame.AddrReturn.Segment = 0;
    frame.AddrReturn.Offset = context.Ebp; /* I think this is correct */

    frame.AddrFrame.Mode = AddrModeFlat;
    frame.AddrFrame.Segment = 0;
    frame.AddrFrame.Offset = context.Ebp;

    frame.AddrStack.Mode = AddrModeFlat;
    frame.AddrStack.Segment = 0;
    frame.AddrStack.Offset = context.Esp;

    frame.FuncTableEntry = NULL;
    frame.Params[0] = context.Eax;
    frame.Params[1] = context.Ecx;
    frame.Params[2] = context.Edx;
    frame.Params[3] = context.Ebx;
    frame.Far = FALSE;
    frame.Virtual = FALSE;
    frame.Reserved[0] = 0;
    frame.Reserved[1] = 0;
    frame.Reserved[2] = 0;
    /* frame.KdHelp.* is not set */

    /*
     * Iterate through the loaded modules and load symbols for each one.
     */
    tclEntry = Tcl_FirstHashEntry(proc->moduleTable, &tclSearch);
    while (tclEntry) {
	modPtr = (Module *) Tcl_GetHashValue(tclEntry);
	if (! modPtr->loaded) {
	    modPtr->dbgInfo = MapDebugInformation(modPtr->hFile, NULL,
		SymbolPath, (DWORD)modPtr->baseAddr);

	    SymLoadModule(proc->hProcess, modPtr->hFile,
		NULL, NULL, (DWORD) modPtr->baseAddr, 0);
	    modPtr->loaded = TRUE;
	}

	tclEntry = Tcl_NextHashEntry(&tclSearch);
    }


    if (proc->exeModule && proc->exeModule->dbgInfo && 
	proc->exeModule->dbgInfo->ImageFileName) {
	s = proc->exeModule->dbgInfo->ImageFileName;
    } else {
	s = "";
    }
    fprintf(stderr, "Backtrace for %s\n", s);
    fprintf(stderr, "-------------------------------------\n");
    //EXP_LOG("Backtrace for %s", s);
    while (1) {
        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLength = 512;

	b = StackWalk(IMAGE_FILE_MACHINE_I386, proc->hProcess,
	    tinfo->hThread, &frame, &context, NULL,
	    SymFunctionTableAccess, SymGetModuleBase,
	    NULL);

	if (b == FALSE || frame.AddrPC.Offset == 0) {
	    break;
	}
	    
        if (SymGetSymFromAddr(proc->hProcess, frame.AddrPC.Offset,
	    &displacement, pSymbol) )
        {
	    DWORD base;
	    char buf[1024];

	    base = SymGetModuleBase(proc->hProcess, frame.AddrPC.Offset);
	    tclEntry = Tcl_FindHashEntry(proc->moduleTable, (const char *) base);
	    modPtr = (Module *) Tcl_GetHashValue(tclEntry);
	    if (modPtr->dbgInfo && modPtr->dbgInfo->ImageFileName) {
		s = modPtr->dbgInfo->ImageFileName;
	    } else {
		s = "";
	    }
            fprintf(stderr, "%.20s %08x\t%s+%X\n", s, frame.AddrPC.Offset,
		pSymbol->Name, displacement);
	    sprintf(buf, "%.20s %08x\t%s+%X", s, frame.AddrPC.Offset,
		pSymbol->Name, displacement);
	    //EXP_LOG("%s", buf);
	} else {
	    fprintf(stderr, "%08x\n", frame.AddrPC.Offset);
	    //EXP_LOG("%08x\t", frame.AddrPC.Offset);
	}
    }

error:
    if (ExpDebug) {
	Sleep(10000);
    }
#else
#  error "Unsupported architecture"	    
#endif
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXCreateThread --
 *
 *	This routine is called when a CREATE_THREAD_DEBUG_EVENT
 *	occurs.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXCreateThread(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    /*
     * As needed, examine or change the thread's registers
     * with the GetThreadContext and SetThreadContext functions;
     * and suspend and resume thread execution with the
     * SuspendThread and ResumeThread functions.
     */
    ThreadInfo *threadInfo;

    threadInfo = new ThreadInfo;
    threadInfo->dwThreadId = pDebEvent->dwThreadId;
    threadInfo->hThread = pDebEvent->u.CreateThread.hThread;
    proc->threadCount++;
    threadInfo->nextPtr = proc->threadList;
    proc->threadList = threadInfo;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXDeleteThread --
 *
 *	This routine is called when a CREATE_THREAD_DEBUG_EVENT
 *	occurs.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXDeleteThread(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    /*
     * As needed, examine or change the thread's registers
     * with the GetThreadContext and SetThreadContext functions;
     * and suspend and resume thread execution with the
     * SuspendThread and ResumeThread functions.
     */
    ThreadInfo *threadInfo;
    ThreadInfo *prev;

    prev = NULL;
    for (threadInfo = proc->threadList; threadInfo;
	 prev = threadInfo, threadInfo = threadInfo->nextPtr)
    {
	if (threadInfo->dwThreadId == pDebEvent->dwThreadId) {
	    if (prev == NULL) {
		proc->threadList = threadInfo->nextPtr;
	    } else {
		prev->nextPtr = threadInfo->nextPtr;
	    }
	    proc->threadCount--;
	    CloseHandle(threadInfo->hThread);
	    delete threadInfo;
	    break;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXCreateProcess --
 *
 *	This routine is called when a CREATE_PROCESS_DEBUG_EVENT
 *	occurs.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXCreateProcess(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    ThreadInfo *threadInfo;
    CREATE_PROCESS_DEBUG_INFO *info = &pDebEvent->u.CreateProcessInfo;
    int known;

    if (proc == 0L) {
	proc = ProcessNew();
//	proc->overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	
	if (!DuplicateHandle(GetCurrentProcess(),
			     info->hProcess,
			     GetCurrentProcess(),
			     &proc->hProcess, PROCESS_ALL_ACCESS,
			     FALSE, 0)) {
	    fprintf(stderr, "Unable to duplicate handle\n");
	}
	proc->hPid = pDebEvent->dwProcessId;

//	ExpAddToWaitQueue(proc->hProcess);
    }

    known = LoadedModule(proc, info->hFile, info->lpImageName,
		info->fUnicode, info->lpBaseOfImage,
		info->dwDebugInfoFileOffset);

    /*
     * As needed, examine or change the registers of the
     * process's initial thread with the GetThreadContext and
     * SetThreadContext functions; read from and write to the
     * process's virtual memory with the ReadProcessMemory and
     * WriteProcessMemory functions; and suspend and resume
     * thread execution with the SuspendThread and ResumeThread
     * functions.
     */

    threadInfo = new ThreadInfo;
    threadInfo->dwThreadId = pDebEvent->dwThreadId;
    threadInfo->hThread = info->hThread;
    threadInfo->nextPtr = proc->threadList;
    proc->threadCount++;
    proc->threadList = threadInfo;
}

/*
 *----------------------------------------------------------------------
 *
 * OnXLoadDll --
 *
 *	This routine is called when a LOAD_DLL_DEBUG_EVENT is seen
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Some information is printed
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXLoadDll(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    WORD w;
    DWORD dw;
    DWORD ImageHdrOffset;
    PIMAGE_FILE_HEADER pfh;	/* File header image in subprocess memory */
    PIMAGE_SECTION_HEADER psh;
    PIMAGE_OPTIONAL_HEADER poh;
    IMAGE_DATA_DIRECTORY dataDir;
    PIMAGE_EXPORT_DIRECTORY ped;
    IMAGE_EXPORT_DIRECTORY exportDir;
    DWORD n;
    DWORD base;
    CHAR funcName[256];
    CHAR dllname[256];
    PVOID ptr, namePtr, funcPtr;
    DWORD p;
    LPLOAD_DLL_DEBUG_INFO info = &pDebEvent->u.LoadDll;
    Tcl_HashEntry *tclEntry;
    int isNew;
    BOOL bFound;

    int unknown = !LoadedModule(proc, info->hFile,
	info->lpImageName, info->fUnicode,
	info->lpBaseOfDll, info->dwDebugInfoFileOffset);

    base = (DWORD) info->lpBaseOfDll;

    /*
     * Check for the DOS signature
     */
    ReadSubprocessMemory(proc, info->lpBaseOfDll, &w, sizeof(WORD));
    if (w != IMAGE_DOS_SIGNATURE) return;
    
    /*
     * Skip over the DOS signature and check the NT signature
     */
    p = base;
    p += 15 * sizeof(DWORD);
    ptr = (PVOID) p;
    ReadSubprocessMemory(proc, (PVOID) p, &ImageHdrOffset, sizeof(DWORD));

    p = base;
    p += ImageHdrOffset;
    ReadSubprocessMemory(proc, (PVOID) p, &dw, sizeof(DWORD));
    if (dw != IMAGE_NT_SIGNATURE) {
	return;
    }
    ImageHdrOffset += sizeof(DWORD);
    p += sizeof(DWORD);

    pfh = (PIMAGE_FILE_HEADER) p;
    ptr = &pfh->SizeOfOptionalHeader;
    ReadSubprocessMemory(proc, ptr, &w, sizeof(WORD));

    /*
     * We want to find the exports section.  It can be found in the
     * data directory that is part of the IMAGE_OPTIONAL_HEADER
     */
    if (!w) return;
    p += sizeof(IMAGE_FILE_HEADER);
    poh = (PIMAGE_OPTIONAL_HEADER) p;

    /*
     * Find the number of entries in the data directory
     */
    ptr = &poh->NumberOfRvaAndSizes;
    ReadSubprocessMemory(proc, ptr, &dw, sizeof(DWORD));
    if (dw == 0) return;

    /*
     * Read the export data directory
     */
    ptr = &poh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    ReadSubprocessMemory(proc, ptr, &dataDir, sizeof(IMAGE_DATA_DIRECTORY));

    /*
     * This points us to the exports section
     */
    ptr = (PVOID) (base + dataDir.VirtualAddress);
    ped = (PIMAGE_EXPORT_DIRECTORY) ptr;
    ReadSubprocessMemory(proc, ptr, &exportDir, sizeof(IMAGE_EXPORT_DIRECTORY));

    /*
     * See if this is a DLL we are interested in
     */
    ptr = &ped->Name;
    ReadSubprocessMemory(proc, ptr, &dw, sizeof(DWORD));
    ptr = (PVOID) (base + dw);
    ReadSubprocessStringA(proc, ptr, dllname, sizeof(dllname));

#if 0 /* Debugging purposes */
    /*
     * We now have the DLL name, even if it was unknown.
     */
    if (unknown) {
	printf("0x%08x: Loaded %s\n", info->lpBaseOfDll, dllname);
    }
#endif


    bFound = FALSE;
    for (n = 0; BreakPoints[n].dllName; n++) {
	if (stricmp(dllname, BreakPoints[n].dllName) == 0) {
	    bFound = TRUE;
	    break;
	}
    }
    if (!bFound) {
	return;
    }

    ptr = (PVOID) (base + (DWORD) exportDir.AddressOfNames);
    for (n = 0; n < exportDir.NumberOfNames; n++) {
	ReadSubprocessMemory(proc, ptr, &dw, sizeof(DWORD));
	namePtr = (PVOID) (base + dw);
	/*
	 * Now, we should hopefully have a pointer to the name of the
	 * function, so lets get it.
	 */
	ReadSubprocessStringA(proc, namePtr, funcName, sizeof(funcName));
	/* printf("%s\n", funcName); */

	/*
	 * Keep a list of all function names in a hash table
	 */

	funcPtr = (PVOID) (base + n*sizeof(DWORD) +
	    (DWORD) exportDir.AddressOfFunctions);
	ReadSubprocessMemory(proc, funcPtr, &dw, sizeof(DWORD));
	funcPtr = (PVOID) (base + dw);

	tclEntry = Tcl_CreateHashEntry(proc->funcTable, funcName, &isNew);
	Tcl_SetHashValue(tclEntry, funcPtr);

	ptr = (PVOID) (sizeof(DWORD) + (ULONG) ptr);
    }

    /*
     * The IMAGE_SECTION_HEADER comes after the IMAGE_OPTIONAL_HEADER
     * (if the IMAGE_OPTIONAL_HEADER exists)
     */
    p += w;

    psh = (PIMAGE_SECTION_HEADER) p;
}

/*
 *----------------------------------------------------------------------
 *
 * OnXUnloadDll --
 *
 *	This routine is called when a UNLOAD_DLL_DEBUG_EVENT is seen
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Some information is printed
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXUnloadDll(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    Tcl_HashEntry *tclEntry;
    Module *modPtr;

    /*
     * Display a message that the DLL has
     * been unloaded.
     */
#if 0
    fprintf(stderr, "0x%08x: Unloading\n", pDebEvent->u.UnloadDll.lpBaseOfDll);
#endif
    
    tclEntry = Tcl_FindHashEntry(proc->moduleTable,
	(const char *) pDebEvent->u.UnloadDll.lpBaseOfDll);

    if (tclEntry != NULL) {
	modPtr = (Module *) Tcl_GetHashValue(tclEntry);
	if (modPtr->hFile) {
	    CloseHandle(modPtr->hFile);
	}
	if (modPtr->modName) {
	    free(modPtr->modName);
	}
	if (modPtr->dbgInfo) {
	    UnmapDebugInformation(modPtr->dbgInfo);
	}
	delete modPtr;
	Tcl_DeleteHashEntry(tclEntry);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::SetBreakpoint --
 *
 *	Inserts a single breakpoint
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful.
 *
 *----------------------------------------------------------------------
 */

BOOL
ConsoleDebugger::SetBreakpoint(Process *proc, BreakInfo *info)
{
    Tcl_HashEntry *tclEntry;
    PVOID funcPtr;

    tclEntry = Tcl_FindHashEntry(proc->funcTable, info->funcName);
    if (tclEntry == NULL) {
//	EXP_LOG("Unable to set breakpoint at %s", info->funcName);
	return FALSE;
    }

#if 0
    fprintf(stderr, "%s: ", info->funcName);
#endif
    /*
     * Set a breakpoint at the function start in the subprocess and
     * save the original code at the function start.
     */
    funcPtr = Tcl_GetHashValue(tclEntry);
    SetBreakpointAtAddr(proc, info, funcPtr);
    return TRUE;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::SetBreakpointAtAddr --
 *
 *	Inserts a single breakpoint at the given address
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful.
 *
 *----------------------------------------------------------------------
 */

ConsoleDebugger::Breakpoint *
ConsoleDebugger::SetBreakpointAtAddr(Process *proc, BreakInfo *info, PVOID funcPtr)
{
    Breakpoint *bpt;
    UCHAR code;

#if 0
    fprintf(stderr, "SetBreakpointAtAddr: addr=0x%08x\n", funcPtr);
#endif
    bpt = new Breakpoint;
    bpt->returning = FALSE;
    bpt->codePtr = funcPtr;
    bpt->codeReturnPtr = (PVOID) (proc->offset + (DWORD) proc->pSubprocessMemory);
    bpt->origRetAddr = 0;
    bpt->breakInfo = info;
    bpt->threadInfo = NULL;
    proc->offset += 2;
    bpt->nextPtr = proc->brkptList;
    proc->brkptList = bpt;

    ReadSubprocessMemory(proc, funcPtr, &bpt->code, sizeof(UCHAR));
#ifdef _M_IX86
    // Breakpoint opcode on i386
    code = 0xcc;
#else
#   error "need breakpoint opcode for this hardware"
#endif
    WriteSubprocessMemory(proc, funcPtr, &code, sizeof(UCHAR));
    return bpt;
}
a1132 80
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::LoadedModule --
 *
 *	A module with the specifed name was loaded.  Add it to our
 *	list of loaded modules and print any debugging information
 *	if debugging is enabled.
 *
 * Results:
 *	If the module is known, return TRUE.  Otherwise, return FALSE
 *
 *----------------------------------------------------------------------
 */

int
ConsoleDebugger::LoadedModule(Process *proc, HANDLE hFile, LPVOID modname,
    int isUnicode, LPVOID baseAddr, DWORD debugOffset)
{
#undef PRINTF
#if 0
#define PRINTF(x) printf x
#else
#define PRINTF(x)
#endif
    int known = 1;
    PVOID ptr;
    Tcl_HashEntry *tclEntry;
    int isNew;
    char mbstr[512];
    char *s = NULL;
    Module *modPtr;

    if (modname) {

	/*
	 * This modname is a pointer to the name of the
	 * DLL in the process space of the subprocess
	 */
	if (ReadSubprocessMemory(proc, modname, &ptr, sizeof(PVOID)) && ptr) {
	    if (isUnicode) {
		WCHAR name[512];
		ReadSubprocessStringW(proc, ptr, name, 512);
		PRINTF(("0x%08x: Loaded %S\n", baseAddr, name));
		wcstombs(mbstr, name, sizeof(mbstr));
	    } else {
		ReadSubprocessStringA(proc, ptr, mbstr, sizeof(mbstr));
		PRINTF(("0x%08x: Loaded %s\n", baseAddr, mbstr));
	    }
	    s = strdup(mbstr);

	} else {
	    PRINTF(("0x%08x: Loaded module, but couldn't read subprocess' memory, error=0x%08x\n", baseAddr, GetLastError()));
	    known = 0;
	}
	if (debugOffset) {
	    PRINTF((" with debugging info at offset 0x%08x\n",
		   debugOffset));
	}
    } else {
	PRINTF(("0x%08x: Loaded module with no known name\n", baseAddr));
    }
    tclEntry = Tcl_CreateHashEntry(proc->moduleTable, (const char *)baseAddr, &isNew);

    modPtr = new Module;
    modPtr->loaded = FALSE;
    modPtr->hFile = hFile;
    modPtr->baseAddr = baseAddr;
    modPtr->modName = s;
    modPtr->dbgInfo = NULL;
    if (proc->exeModule == NULL) {
	proc->exeModule = modPtr;
    }

    Tcl_SetHashValue(tclEntry, modPtr);

    return known;
#undef PRINTF
@


1.1.2.4
log
@Changed all uses of NULL to the C++ 0L understanding.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.3 2002/03/09 01:17:29 davygrvy Exp $
d194 3
a196 3
	    0L,
	    0L,
	    0L,
d263 1
a263 1
    proc->threadList = 0L;
d265 2
a266 2
    proc->brkptList = 0L;
    proc->lastBrkpt = 0L;
d272 1
a272 1
    proc->hProcess = 0L;
d280 1
a280 1
    proc->exeModule = 0L;
d307 1
a307 1
    for (tcurr = proc->threadList; tcurr != 0L; tcurr = tnext) {
d313 1
a313 1
    for (bcurr = proc->brkptList; bcurr != 0L; bcurr = bnext) {
d322 1
a322 1
    for (pprev = 0L, pcurr = ProcessList; pcurr != 0L;
d326 1
a326 1
	    if (pprev == 0L) {
d363 4
a366 4
    n = GetEnvironmentVariable("Path", 0L, 0);
    n += GetEnvironmentVariable("_NT_SYMBOL_PATH", 0L, 0) + 1;
    n += GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", 0L, 0) + 1;
    n += GetEnvironmentVariable("SystemRoot", 0L, 0) + 1;
d495 1
a495 1
	    if (ProcessList == 0L) {
d566 1
a566 1
    for (tinfo = proc->threadList; tinfo != 0L; tinfo = tinfo->nextPtr) {
d590 1
a590 1
	    EXP_LOG("Unable to find entry for VirtualAlloc", 0L);
d610 1
a610 1
	    EXP_LOG("Error reading subprocess memory", 0L);
d614 1
a614 1
    	    EXP_LOG("Error writing subprocess memory", 0L);
d660 1
a660 1
//	EXP_LOG("Error writing subprocess memory", 0L);
d729 1
a729 1
    for (tinfo = proc->threadList; tinfo != 0L; tinfo = tinfo->nextPtr) {
d734 1
a734 1
    assert(tinfo != 0L);
d775 1
a775 1
    frame.FuncTableEntry = 0L;
d794 1
a794 1
	    modPtr->dbgInfo = MapDebugInformation(modPtr->hFile, 0L,
d798 1
a798 1
		0L, 0L, (DWORD) modPtr->baseAddr, 0);
d820 1
a820 1
	    tinfo->hThread, &frame, &context, 0L,
d822 1
a822 1
	    0L);
d921 1
a921 1
    prev = 0L;
d926 1
a926 1
	    if (prev == 0L) {
d1195 1
a1195 1
    if (tclEntry != 0L) {
d1231 1
a1231 1
    if (tclEntry == 0L) {
d1276 1
a1276 1
    bpt->threadInfo = 0L;
d1354 1
a1354 1
		PAGESIZE, 0L)) {
d1398 1
a1398 1
    ret = ReadProcessMemory(proc->hProcess, addr, buf, len, 0L);
d1457 1
a1457 1
    if (!WriteProcessMemory(hProcess, addr, buf, len, 0L)) {
d1563 1
a1563 1
	    bpt->codeReturnPtr = 0L;	/* Doesn't matter */
d1699 1
a1699 1
    char *s = 0L;
d1738 2
a1739 2
    modPtr->dbgInfo = 0L;
    if (proc->exeModule == 0L) {
@


1.1.2.5
log
@links once more, but isn't yet working again.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.4 2002/03/09 01:51:29 davygrvy Exp $
d38 1
a38 2
    : _argc(argc), _argv(argv), ProcessList(0L), CursorKnown(FALSE),
    ShowExceptionBacktraces(FALSE)
d725 1
a725 1
    if (!ShowExceptionBacktraces) {
d754 1
a754 1
	return;
d851 5
@


1.1.2.6
log
@Got error codes working.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.5 2002/03/09 03:10:31 davygrvy Exp $
d407 2
a408 2
	    EXP_LOG1(MSG_DT_UNEXPECTEDDBGEVENT, buf);
//	    EXP_LOG("Unexpected debug event for %s", buf);
d410 5
a414 5
		char buf[50];
		wsprintfA(buf, "0x%08x", debEvent.u.Exception.ExceptionRecord.ExceptionCode);
		EXP_LOG1(MSG_DT_EXCEPTIONDBGEVENT, buf);
//		EXP_LOG("ExceptionCode: 0x%08x",
//			debEvent.u.Exception.ExceptionRecord.ExceptionCode);
d590 2
a591 1
	    EXP_LOG0(MSG_DT_NOVIRT);
d610 2
a611 1
	    EXP_LOG0(MSG_DT_CANTREADSPMEM);
d614 2
a615 1
	    EXP_LOG0(MSG_DT_CANTWRITESPMEM);
d642 1
a642 1
    BYTE retbuf[2048];
d654 1
a654 1
    memset(retbuf, 0xcc, sizeof(retbuf));	// All breakpoints
d660 2
a661 1
	EXP_LOG0(MSG_DT_CANTWRITESPMEM);
d665 3
a667 2
    // Set all breakpoints
    //
d788 3
a790 2
    //  Iterate through the loaded modules and load symbols for each one.
    //
d813 3
a815 3
//    fprintf(stderr, "Backtrace for %s\n", s);
//    fprintf(stderr, "-------------------------------------\n");
//    EXP_LOG("Backtrace for %s", s);
d843 2
a844 2
//            fprintf(stderr, "%.20s %08x\t%s+%X\n", s, frame.AddrPC.Offset,
//		pSymbol->Name, displacement);
d847 1
a847 1
//	    EXP_LOG("%s", buf);
d849 2
a850 2
//	    fprintf(stderr, "%08x\n", frame.AddrPC.Offset);
//	    EXP_LOG("%08x\t", frame.AddrPC.Offset);
@


1.1.2.7
log
@Started on the app-level message queue.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.6 2002/03/09 05:48:50 davygrvy Exp $
d37 1
a37 1
ConsoleDebugger::ConsoleDebugger (int argc, char * const *argv, CMclQueue<Message> &_mQ)
d39 1
a39 1
    ShowExceptionBacktraces(FALSE), mQ(_mQ)
a175 5
ConsoleDebugger::~ConsoleDebugger()
{
    delete [] SymbolPath;
}

d382 6
a387 4
	// Wait for a debugging event to occur. The second parameter
	// indicates that the function does not return until
	// a debugging event occurs.
	//
d393 3
a395 2
	// Find the process that is responsible for this event.
	//
d404 1
a404 1
	    wsprintf(buf, "%d/%d (%d)", 
d408 1
d411 1
a411 1
		wsprintf(buf, "0x%08x", debEvent.u.Exception.ExceptionRecord.ExceptionCode);
d413 2
d420 2
a421 2
	// Process the debugging event code.
	//
d424 7
a430 5
	    // Process the exception code. When handling
	    // exceptions, remember to set the continuation
	    // status parameter (dwContinueStatus). This value
	    // is used by the ContinueDebugEvent function.
	    //
d484 7
a490 5
	    // XXX: This is really screwed up, but we get breakpoints
	    // for processes that are already dead.  So we cannot remove
	    // and cleanup a process until some later (How much later?)
	    // point.  This really, really sucks....
	    //
d573 4
a576 2
    // Set up the memory that will serve as the place for our
    // intercepted function return points.
d589 1
a589 1
	    proc->nBreakCount++;	// Don't stop at second breakpoint
d688 3
a690 3

    // Now, we need to restore the breakpoint that we had removed.
    //
d735 12
a746 10
    // XXX: From what I can tell, SymInitialize is broken on Windows NT 4.0
    // if you try to have it iterate the modules in a process.  It always
    // returns an object mismatch error.  Instead, initialize without iterating
    // the modules.  Contrary to what MSDN documentation says,
    // Microsoft debuggers do not exclusively use the imagehlp API.  In
    // fact, the only thing VC 5.0 uses is the StackWalk function.
    // Windbg uses a few more functions, but it doesn't use SymInitialize.
    // We will then do the hard work of finding all the
    // modules and doing the right thing.
    //
d761 1
a761 1
    frame.AddrReturn.Offset = context.Ebp; // I think this is correct
d869 6
a874 5
    // As needed, examine or change the thread's registers
    // with the GetThreadContext and SetThreadContext functions;
    // and suspend and resume thread execution with the
    // SuspendThread and ResumeThread functions.
    //
d902 6
a907 5
    // As needed, examine or change the thread's registers
    // with the GetThreadContext and SetThreadContext functions;
    // and suspend and resume thread execution with the
    // SuspendThread and ResumeThread functions.
    //
d970 10
a979 8
    // As needed, examine or change the registers of the
    // process's initial thread with the GetThreadContext and
    // SetThreadContext functions; read from and write to the
    // process's virtual memory with the ReadProcessMemory and
    // WriteProcessMemory functions; and suspend and resume
    // thread execution with the SuspendThread and ResumeThread
    // functions.
    //
d1033 3
a1035 2
    // Check for the DOS signature
    //
d1039 3
a1041 2
    // Skip over the DOS signature and check the PE signature
    //
d1060 4
a1063 3
    // We want to find the exports section.  It can be found in the
    // data directory that is part of the IMAGE_OPTIONAL_HEADER
    //
d1068 3
a1070 2
    // Find the number of entries in the data directory
    //
d1075 3
a1077 2
    // Read the export data directory
    //
d1081 3
a1083 2
    // This points us to the exports section
    //
d1088 3
a1090 2
    // See if this is a DLL we are interested in
    //
d1096 10
d1121 6
d1128 3
a1130 4
	// Now, we should hopefully have a pointer to the name of the
	// function, so lets get it.
	//
	ReadSubprocessStringA(proc, namePtr, funcName, sizeof(funcName));
a1131 2
	// Keep a list of all function names in a hash table
	//
d1143 4
a1146 3
    // The IMAGE_SECTION_HEADER comes after the IMAGE_OPTIONAL_HEADER
    // (if the IMAGE_OPTIONAL_HEADER exists)
    //
d1174 8
d1226 7
a1232 3
    // Set a breakpoint at the function start in the subprocess and
    // save the original code at the function start.
    //
d1255 1
a1255 1
    BYTE code;
d1257 3
d1271 1
a1271 1
    ReadSubprocessMemory(proc, funcPtr, &bpt->code, sizeof(BYTE));
d1278 1
a1278 1
    WriteSubprocessMemory(proc, funcPtr, &code, sizeof(BYTE));
d1376 1
a1376 1
    // if not committed memory abort
d1383 1
a1383 1
    // if guarded memory, change protection temporarily
d1393 1
a1393 1
    // reset protection if changed
d1427 1
a1427 1
    // Flush the read cache.
d1430 1
a1430 1
    // if not committed memory abort
d1435 1
a1435 1
	// assert(ret != FALSE);
d1439 1
a1439 1
    // if guarded memory, change protection temporarily.
d1452 1
a1452 1
    // reset protection if changed
d1456 5
d1497 3
d1513 6
d1525 4
a1528 2
	// Get the arguments to the function and store them in the thread
	// specific data structure.
d1540 4
a1543 2
	// Only set a return breakpoint if something is interested
	// in the return value
d1553 1
a1553 1
	    bpt->codeReturnPtr = 0L;	// Doesn't matter
d1561 6
a1566 5
	// Now, we need to restore the original code for this breakpoint.
	// Put the program counter back, then do a single-step and put
	// the breakpoint back again.
	//
	WriteSubprocessMemory(proc, brkpt->codePtr, &brkpt->code, sizeof(BYTE));
d1573 3
a1575 1
	// Make the callback with the params and the return value
d1678 6
d1693 5
a1697 3
	// This modname is a pointer to the name of the
	// DLL in the process space of the subprocess
	//
d1702 1
d1706 1
d1711 1
d1714 6
d1736 1
@


1.1.2.8
log
@replacing mailboxing with simple pipes as our transport.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.7 2002/03/09 22:56:23 davygrvy Exp $
d37 3
a39 3
ConsoleDebugger::ConsoleDebugger (int _argc, char * const *_argv, CMclQueue<Message> &_mQ)
    : argc(_argc), argv(_argv), ProcessList(0L), CursorKnown(FALSE),
    ShowExceptionBacktraces(FALSE), SymbolPath(0L), mQ(_mQ)
d178 1
a178 1
    if (SymbolPath) delete [] SymbolPath;
d184 1
d186 7
a192 9
    DWORD ok;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char *cmdline;

    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    si.wShowWindow = SW_SHOWDEFAULT;
d194 1
a194 3
    cmdline = ArgMaker::BuildCommandLine(argc, argv);

    // Make sure the master does not ignore Ctrl-C
d197 12
a208 14
    ok = CreateProcess (
	    0L,		// Module name (not needed).
	    cmdline,	// Command line.
	    0L,		// Process handle will not be inheritable.
	    0L,		// Thread handle will not be inheritable.
	    FALSE,	// No handle inheritance.
	    DEBUG_PROCESS|CREATE_NEW_CONSOLE|CREATE_DEFAULT_ERROR_MODE,
			// Creation flags.
	    0L,		// Use parent's environment block.
	    0L,		// Use parent's starting directory.
	    &si,	// Pointer to STARTUPINFO structure.
	    &pi);	// Pointer to PROCESS_INFORMATION structure.

    delete [] cmdline;
d210 1
a210 1
    if (!ok) {
d214 3
a216 2
    WaitForInputIdle(pi.hProcess, 5000);
    CloseHandle(pi.hThread);
d218 3
a220 2
    // Make sure we now ignore Ctrl-C
    SetConsoleCtrlHandler(0L, TRUE);
d223 20
a242 3
    //CloseHandle(pi.hProcess);
    proc->hProcess = pi.hProcess;
    proc->pid = pi.dwProcessId;
d244 1
a244 2
    CommonDebugger();
    return 0;
d399 1
a399 1
	    if (proc->pid == debEvent.dwProcessId) {
d950 1
a950 1
	proc->pid = pDebEvent->dwProcessId;
@


1.1.2.9
log
@removed all use of Tcl from the slavedrv.  It was only being used for hash tables.  replaced them with std::map.  It's a bit fatter now, but i'll live.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.8 2002/03/11 05:36:37 davygrvy Exp $
d37 1
a37 1
ConsoleDebugger::ConsoleDebugger (int _argc, char * const *_argv, CMclQueue<Message *> &_mQ)
d269 4
a272 4
//    proc->funcTable = new Tcl_HashTable;
//    Tcl_InitHashTable(proc->funcTable, TCL_STRING_KEYS);
//    proc->moduleTable = new Tcl_HashTable;
//    Tcl_InitHashTable(proc->moduleTable, TCL_ONE_WORD_KEYS);
d310 4
a313 4
//    Tcl_DeleteHashTable(proc->funcTable);
//    delete proc->funcTable;
//    Tcl_DeleteHashTable(proc->moduleTable);
//    delete proc->moduleTable;
d546 3
d560 1
a560 1
	STRING2PTR::iterator iTor;
d567 2
a568 2
	iTor = proc->funcTable.find("VirtualAlloc");
	if (iTor == proc->funcTable.end()) {
d573 1
a573 1
	addr = reinterpret_cast<DWORD>((*iTor).second);
d693 2
a694 1
    PTR2MODULE::iterator iTor;
d763 3
a765 3
    iTor = proc->moduleTable.begin();
    while (iTor != proc->moduleTable.end()) {
	modPtr = (*iTor).second;
d774 2
a775 1
	iTor++;
d808 2
a809 2
	    iTor = proc->moduleTable.find(reinterpret_cast<PVOID>(base));
	    modPtr = (*iTor).second;
d997 2
d1091 2
a1092 1
	proc->funcTable.insert(STRING2PTR::value_type(funcName, funcPtr));
d1124 1
a1124 1
    PTR2MODULE::iterator iTor;
d1127 2
a1128 1
    iTor = proc->moduleTable.find(pDebEvent->u.UnloadDll.lpBaseOfDll);
d1130 2
a1131 3

    if (iTor != proc->moduleTable.end()) {
	modPtr = (*iTor).second;
d1142 1
a1142 1
	proc->moduleTable.erase(iTor);
d1162 1
a1162 1
    STRING2PTR::iterator iTor;
d1165 2
a1166 3
    iTor = proc->funcTable.find(info->funcName);

    if (iTor == proc->funcTable.end()) {
d1174 1
a1174 1
    funcPtr = (*iTor).second;
d1597 2
d1621 1
d1633 1
a1633 1
    proc->moduleTable.insert(PTR2MODULE::value_type(baseAddr, modPtr));
@


1.1.2.10
log
@re-added use of tcl's hash tables, but this time using the template.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.9 2002/03/12 07:09:36 davygrvy Exp $
d557 1
d564 2
a565 3
	if (proc->funcTable.Find("VirtualAlloc",
		reinterpret_cast<PVOID *>(&addr)) != TCL_OK)
	{
d570 1
d690 1
d759 3
a761 2
    proc->moduleTable.Top(&modPtr);
    do {
d770 2
a771 1
    } while (proc->moduleTable.Next(&modPtr) != TCL_ERROR);
d803 2
a804 1
	    proc->moduleTable.Find(reinterpret_cast<PVOID>(base), &modPtr);
d1084 1
a1084 1
	proc->funcTable.Add(funcName, funcPtr);
d1116 1
d1119 5
a1123 3
    if (proc->moduleTable.Find(pDebEvent->u.UnloadDll.lpBaseOfDll, &modPtr)
	    != TCL_ERROR)
    {
d1134 1
a1134 1
	proc->moduleTable.Delete(pDebEvent->u.UnloadDll.lpBaseOfDll);
d1154 1
d1157 3
a1159 2
    if (proc->funcTable.Find((void *)info->funcName, &funcPtr) == TCL_ERROR)
    {
d1167 1
d1623 1
a1623 1
    proc->moduleTable.Add(baseAddr, modPtr);
@


1.1.2.11
log
@milestone!  It works.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.10 2002/03/12 18:14:59 davygrvy Exp $
a1614 11
}

void
ConsoleDebugger::WriteMaster(CHAR *buf, DWORD len)
{
    Message *msg;
    msg = new Message;
    msg->bytes = (BYTE *) _strdup(buf);
    msg->length = len;
    msg->type = Message::TYPE_NORMAL;
    mQ.Put(msg);
@


1.1.2.12
log
@final instalment.  tried to work on cleanup issues, but more testing needed.  Fixed a big bug in ConsoleDebugger::OnFillConsoleOutputCharacter() where the master console handle was null.  I successfully logged into panix.com with Win2k's telnet.exe and trapped it all!
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.11 2002/03/13 03:52:57 davygrvy Exp $
a173 3

    MasterHConsole = CreateFile("CONOUT$", GENERIC_READ|GENERIC_WRITE,
	    FILE_SHARE_READ|FILE_SHARE_WRITE, 0L, OPEN_EXISTING, 0, 0L);
d269 4
d299 1
a299 1

d310 5
a326 1
    CloseHandle(proc->hProcess);
@


1.1.2.13
log
@final instalment.  tried to work on cleanup issues, but more testing needed.  Fixed a big bug in ConsoleDebugger::OnFillConsoleOutputCharacter() where the master console handle was null.  I successfully logged into panix.com with Win2k's telnet.exe and trapped it all!
@
text
@d175 1
a175 1
    hMasterConsole = CreateFile("CONOUT$", GENERIC_READ|GENERIC_WRITE,
@


1.1.2.14
log
@fixed a nasty bug in the SetArgv() function that was all my fault.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.13 2002/03/15 07:51:56 davygrvy Exp $
a474 1
		NotifyDone();
a1619 9
    mQ.Put(msg);
}

void
ConsoleDebugger::NotifyDone()
{
    Message *msg;
    msg = new Message;
    msg->type = Message::TYPE_SLAVEDONE;
@


1.1.2.15
log
@these changes perfect the debugger code under Win98 and have been sitting in my workspace for quite some time now.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.14 2002/03/16 00:37:01 davygrvy Exp $
d38 2
a39 2
    : argc(_argc), argv(_argv), ProcessList(0L), CursorKnown(FALSE), ConsoleOutputCP(0),
    ConsoleCP(0), mQ(_mQ)
a40 6
    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);
    dwPlatformId = osvi.dwPlatformId;

d52 1
a52 1
    //  the constructor, because we need to have the 'this' pointer already
d56 9
d66 1
a66 11
    BreakArrayKernel32[0].funcName = "AllocConsole";
    BreakArrayKernel32[0].nargs = 0;
    BreakArrayKernel32[0].breakProc = OnAllocConsole;
    BreakArrayKernel32[0].dwFlags = BREAK_OUT;

    BreakArrayKernel32[1].funcName = "Beep";
    BreakArrayKernel32[1].nargs = 2;
    BreakArrayKernel32[1].breakProc = OnBeep;
    BreakArrayKernel32[1].dwFlags = BREAK_OUT|BREAK_IN;

    BreakArrayKernel32[2].funcName = "FillConsoleOutputCharacterA";
d71 3
a73 3
    BreakArrayKernel32[3].funcName = "FillConsoleOutputCharacterW";
    BreakArrayKernel32[3].nargs = 5;
    BreakArrayKernel32[3].breakProc = OnFillConsoleOutputCharacter;
d76 3
a78 3
    BreakArrayKernel32[4].funcName = "FreeConsole";
    BreakArrayKernel32[4].nargs = 0;
    BreakArrayKernel32[4].breakProc = OnFreeConsole;
d81 3
a83 3
    BreakArrayKernel32[5].funcName = "GetStdHandle";
    BreakArrayKernel32[5].nargs = 1;
    BreakArrayKernel32[5].breakProc = OnGetStdHandle;
d86 1
a86 1
    BreakArrayKernel32[6].funcName = "OpenConsoleW";
d88 1
a88 1
    BreakArrayKernel32[6].breakProc = OnOpenConsoleW;
d101 3
a103 3
    BreakArrayKernel32[9].funcName = "SetConsoleActiveScreenBuffer";
    BreakArrayKernel32[9].nargs = 1;
    BreakArrayKernel32[9].breakProc = OnSetConsoleActiveScreenBuffer;
d106 1
a106 1
    BreakArrayKernel32[10].funcName = "SetConsoleCP";
d108 1
a108 1
    BreakArrayKernel32[10].breakProc = OnSetConsoleCP;
d111 1
a111 1
    BreakArrayKernel32[11].funcName = "SetConsoleCursorInfo";
d113 1
a113 1
    BreakArrayKernel32[11].breakProc = OnSetConsoleCursorInfo;
d116 1
a116 1
    BreakArrayKernel32[12].funcName = "SetConsoleCursorPosition";
d118 1
a118 1
    BreakArrayKernel32[12].breakProc = OnSetConsoleCursorPosition;
d121 3
a123 3
    BreakArrayKernel32[13].funcName = "SetConsoleMode";
    BreakArrayKernel32[13].nargs = 2;
    BreakArrayKernel32[13].breakProc = OnSetConsoleMode;
d126 3
a128 3
    BreakArrayKernel32[14].funcName = "SetConsoleOutputCP";
    BreakArrayKernel32[14].nargs = 1;
    BreakArrayKernel32[14].breakProc = OnSetConsoleOutputCP;
d131 3
a133 3
    BreakArrayKernel32[15].funcName = "SetConsoleWindowInfo";
    BreakArrayKernel32[15].nargs = 2;
    BreakArrayKernel32[15].breakProc = OnSetConsoleWindowInfo;
d136 1
a136 1
    BreakArrayKernel32[16].funcName = "WriteConsoleA";
d138 1
a138 1
    BreakArrayKernel32[16].breakProc = OnWriteConsoleA;
d141 1
a141 1
    BreakArrayKernel32[17].funcName = "WriteConsoleW";
d143 1
a143 1
    BreakArrayKernel32[17].breakProc = OnWriteConsoleW;
d146 1
a146 1
    BreakArrayKernel32[18].funcName = "WriteConsoleOutputA";
d148 1
a148 1
    BreakArrayKernel32[18].breakProc = OnWriteConsoleOutputA;
d151 4
a154 19
    BreakArrayKernel32[19].funcName = "WriteConsoleOutputW";
    BreakArrayKernel32[19].nargs = 5;
    BreakArrayKernel32[19].breakProc = OnWriteConsoleOutputW;
    BreakArrayKernel32[19].dwFlags = BREAK_OUT;

    BreakArrayKernel32[20].funcName = "WriteConsoleOutputCharacterA";
    BreakArrayKernel32[20].nargs = 5;
    BreakArrayKernel32[20].breakProc = OnWriteConsoleOutputCharacterA;
    BreakArrayKernel32[20].dwFlags = BREAK_OUT;

    BreakArrayKernel32[21].funcName = "WriteConsoleOutputCharacterW";
    BreakArrayKernel32[21].nargs = 5;
    BreakArrayKernel32[21].breakProc = OnWriteConsoleOutputCharacterW;
    BreakArrayKernel32[21].dwFlags = BREAK_OUT;

    BreakArrayKernel32[22].funcName = 0L;
    BreakArrayKernel32[22].nargs = 0;
    BreakArrayKernel32[22].breakProc = 0L;
    BreakArrayKernel32[22].dwFlags = 0;
d181 1
d187 2
a188 1
    DWORD ok, exitcode;
d201 1
a201 1
    //SetConsoleCtrlHandler(0L, FALSE);
d203 1
a203 1
    ok = CreateProcess(
d216 2
d219 1
a219 1
	EXP_LOG2(MSG_DT_BADDEBUGGEE, cmdline, GetSysMsg(GetLastError()));
a220 1
    delete [] cmdline;
a223 1
    CloseHandle(pi.hProcess);
d226 27
a252 1
    //SetConsoleCtrlHandler(0L, TRUE);
d254 70
a323 3
    exitcode = CommonDebugger();
    NotifyDone();
    return exitcode;
d342 1
a342 1
DWORD
d347 1
d349 1
d351 26
a376 2
again:
    dwContinueStatus = DBG_CONTINUE;
d378 7
a384 5
    // Wait (forever) for a debugging event to occur.
    //
    if (WaitForDebugEvent(&debEvent, INFINITE) == FALSE) {
	return GetLastError();
    }
d386 13
a398 5
    // Find the process that is responsible for this event.
    //
    for (proc = ProcessList; proc; proc = proc->nextPtr) {
	if (proc->pid == debEvent.dwProcessId) {
	    break;
a399 1
    }
d401 32
a432 14
    if (!proc && debEvent.dwDebugEventCode != CREATE_PROCESS_DEBUG_EVENT) {
/*	char buf[50];
	wsprintf(buf, "%d/%d (%d)", 
		debEvent.dwProcessId, debEvent.dwThreadId,
		debEvent.dwDebugEventCode);
	EXP_LOG1(MSG_DT_UNEXPECTEDDBGEVENT, buf);*/
	if (debEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
	    /*char buf[50];
	    wsprintf(buf, "0x%08x", debEvent.u.Exception.ExceptionRecord.ExceptionCode);
	    EXP_LOG1(MSG_DT_EXCEPTIONDBGEVENT, buf);*/
	    dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
	}
	goto skip;
    }
d434 3
a436 1
    bpCritSec.Enter();
d438 9
a446 14
    // Process the debugging event code.
    //
    switch (debEvent.dwDebugEventCode) {
    case EXCEPTION_DEBUG_EVENT:
	switch (debEvent.u.Exception.ExceptionRecord.ExceptionCode) {
	case EXCEPTION_BREAKPOINT:
	{
	    switch (proc->nBreakCount < 3 ? ++(proc->nBreakCount) : 3) {
	    case 1:
		OnXFirstBreakpoint(proc, &debEvent); break;
	    case 2:
//		OnXSecondBreakpoint(proc, &debEvent); break;
	    case 3:
		OnXBreakpoint(proc, &debEvent);
a448 1
	}
d450 2
a451 2
	case EXCEPTION_SINGLE_STEP:
	    OnXSingleStep(proc, &debEvent);
d454 2
a455 3
	case DBG_CONTROL_C:
	case DBG_CONTROL_BREAK:
	    dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
d458 3
a460 10
	default:
	    if (! debEvent.u.Exception.dwFirstChance) {
		// An exception was hit and it was not handled by the program.
		// Now it is time to get a backtrace.
		//
		OnXSecondChanceException(proc, &debEvent);
	    }
	    dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
	}
	break;
d462 5
a466 16
    case CREATE_THREAD_DEBUG_EVENT:
	OnXCreateThread(proc, &debEvent);
	break;

    case CREATE_PROCESS_DEBUG_EVENT:
	OnXCreateProcess(proc, &debEvent);
	break;

    case EXIT_THREAD_DEBUG_EVENT:
	OnXDeleteThread(proc, &debEvent);
	break;

    case EXIT_PROCESS_DEBUG_EVENT:
	ProcessFree(proc);
	if (ProcessList == 0L) {
	    // When the last process exits, we exit.
d468 11
a478 3
	    return debEvent.u.ExitProcess.dwExitCode;
	}
	break;
d480 3
a482 3
    case LOAD_DLL_DEBUG_EVENT:
	OnXLoadDll(proc, &debEvent);
	break;
d484 3
a486 3
    case UNLOAD_DLL_DEBUG_EVENT:
	OnXUnloadDll(proc, &debEvent);
	break;
d488 9
a496 3
    case OUTPUT_DEBUG_STRING_EVENT:
	// Display the output debugging string.
	break;
a497 9

    bpCritSec.Leave();

skip:
    // Resume executing the thread that reported the debugging event.
    //
    ContinueDebugEvent(debEvent.dwProcessId, debEvent.dwThreadId,
	    dwContinueStatus);
    goto again;
d517 18
d539 1
a539 2
#   define RETBUF_SIZE 2048
    BYTE retbuf[RETBUF_SIZE];
a540 2
    BreakInfo *binfo;
    int i;
a549 2
    //
    MakeSubprocessMemory(proc, RETBUF_SIZE, &(proc->pSubprocessMemory));
d551 7
a557 4
    // Fill the buffer with all breakpoints
    //
    memset(retbuf, 0xCC, RETBUF_SIZE);
    WriteSubprocessMemory(proc, proc->pSubprocessMemory, retbuf, RETBUF_SIZE);
d559 26
a584 5
    // Set all breakpoints
    //
    for (i = 0; BreakPoints[i].dllName; i++) {
	for (binfo = BreakPoints[i].breakInfo; binfo->funcName; binfo++) {
	    SetBreakpoint(proc, binfo);
a586 27
/*
    //  Make some memory for our stub that we place into the slave's address
    //  space and cause it to run it as if was part of the slave's application.
    //  This stub (or set of opcodes) calls LoadLibrary() to bring in our
    //  injector dll that acts as the receiver for "injecting" console events.
    //
    MakeSubprocessMemory(proc, sizeof(LOADLIBRARY_STUB), &pInjectorStub,
	    PAGE_EXECUTE_READWRITE);
    injectStub.operand_PUSH_value = (DWORD) pInjectorStub +
	    offsetof(LOADLIBRARY_STUB, data_DllName);
    injectStub.operand_MOV_EAX = (DWORD) GetProcAddress(GetModuleHandle(
	    "KERNEL32.DLL"),"LoadLibraryA");
    WriteSubprocessMemory(proc, pInjectorStub, &injectorStub,
	    sizeof(LOADLIBRARY_STUB));

    //  Save the instruction pointer so we can restore it later.
    //
    preStubContext.ContextFlags = CONTEXT_FULL;
    GetThreadContext(tinfo->hThread, &preStubContext);

    //  Set instruction pointer to run the Stub instead of continuing
    //  from where we are.
    //
    CONTEXT stubContext = preStubContext;
    stubContext.Eip = (DWORD) pInjectorStub;
    SetThreadContext(tinfo->hThread, &stubContext);
*/
a587 1
#   undef RETBUF_SIZE
d595 5
a599 2
 *	This routine is called when the second breakpoint is hit and
 *	our stub has run and our injector is loaded.
d610 12
a621 1
/*    ThreadInfo *tinfo;
d623 7
a629 4
    for (tinfo = proc->threadList; tinfo != 0L; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
d631 1
d633 1
a633 4
    SetThreadContext(tinfo->hThread, &preStubContext);

    // We should now remove the memory allocated in the sub process and
    // remove our stub.
d635 5
a639 3
    RemoveSubprocessMemory(proc, pStubInjector);
*/
    return;
d663 1
a663 1
    code = 0xCC;
d681 133
a813 2
    // Do nothing.
    return;
d833 5
d865 5
d914 9
a922 1
	proc->hProcess = info->hProcess;
d924 2
d928 12
a939 3
    known = LoadedModule(proc, info->hFile, info->lpImageName, info->fUnicode,
	    info->lpBaseOfImage, info->dwDebugInfoFileOffset);

d1109 1
a1109 1
    if (proc->moduleTable.Extract(pDebEvent->u.UnloadDll.lpBaseOfDll, &modPtr)
d1116 1
a1116 1
	    delete [] modPtr->modName;
d1122 1
d1177 1
d1180 1
d1182 1
d1190 1
a1190 1
    code = 0xCC;
d1210 6
a1215 1
 *	Currently safe, but slow.
d1220 64
d1289 2
a1290 2
    BOOL ret = TRUE;
    DWORD err = ERROR_SUCCESS;
d1292 1
a1292 2
    // if not committed memory abort.
    //
d1294 2
a1295 1
	    mbi.State != MEM_COMMIT) {
a1297 13

    // On Win9x, special ranges can't have their protection changed.
    //
    if (dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
	    && addr >= (LPVOID) 0x80000000 && addr <= (LPVOID) 0xBFFFFFFF) {
	ret = ReadProcessMemory(proc->hProcess, addr, buf, len, 0L);
    } else {
	// if guarded memory, change protection temporarily.
	//
	if (!(mbi.Protect & PAGE_READONLY) && !(mbi.Protect & PAGE_READWRITE)) {
	    VirtualProtectEx(proc->hProcess, addr, len, PAGE_READONLY,
		    &oldProtection);
	}
d1299 9
a1307 4
	if (!ReadProcessMemory(proc->hProcess, addr, buf, len, 0L)) {
	    err = GetLastError();
	    ret = FALSE;
	}
d1309 4
a1312 7
	// reset protection if changed.
	//
	if (oldProtection) {
	    VirtualProtectEx(proc->hProcess, addr, len, oldProtection,
		    &oldProtection);
	    SetLastError(err);
	}
d1316 1
d1327 1
a1327 1
 *	zero if unsuccessful, non-zero if successful.
d1338 7
a1344 1
    DWORD err = ERROR_SUCCESS;
d1347 1
a1347 1
    if (!VirtualQueryEx(proc->hProcess, addr, &mbi, sizeof(mbi)) ||
d1350 3
a1352 1
	return FALSE;
d1355 5
a1359 13
    // On Win9x, special ranges can't have their protection changed.
    //
    if (dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
	    && addr >= (LPVOID) 0x80000000 && addr <= (LPVOID) 0xBFFFFFFF) {
	ret = WriteProcessMemory(proc->hProcess, addr, buf, len, 0L);
    } else {
	// if guarded memory, change protection temporarily.
	//
	if (!(mbi.Protect & PAGE_READWRITE)) {
	    if (!VirtualProtectEx(proc->hProcess, addr, len, PAGE_READWRITE,
		    &oldProtection)) {
		return FALSE;
	    }
d1361 1
d1363 4
a1366 4
	if (!WriteProcessMemory(proc->hProcess, addr, buf, len, 0L)) {
	    ret = FALSE;
	    err = GetLastError();
	}
d1368 3
a1370 7
	// reset protection if changed.
	//
	if (oldProtection) {
	    VirtualProtectEx(proc->hProcess, addr, len, oldProtection,
		    &oldProtection);
	    SetLastError(err);
	}
d1489 1
a1489 1
 * ConsoleDebugger::ReadSubprocessStringA --
d1585 1
a1585 2
		WCHAR name[MAX_PATH];
		int len;
d1587 1
a1587 3
		len = WideCharToMultiByte(CP_ACP, 0, name, -1, 0L, 0, 0L, 0L);
		s = new char [len];
		WideCharToMultiByte(CP_ACP, 0, name, -1, s, len, 0L, 0L);
a1589 2
		s = new char [strlen(mbstr)];
		strcpy(s, mbstr);
d1591 2
a1630 217
}

void
ConsoleDebugger::MakeSubprocessMemory(Process *proc, SIZE_T amount,
    LPVOID *pBuff, DWORD access)
{
    typedef LPVOID (__stdcall *PFNVIRTALLEX)(HANDLE,LPVOID,SIZE_T,DWORD,DWORD);

    if (dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // We're on NT, so use VirtualAllocEx to allocate memory in the other
        // process' address space.  Alas, we can't just call VirtualAllocEx
        // since it's not defined in the Windows 95 KERNEL32.DLL.
	//
        static PFNVIRTALLEX pfnVirtualAllocEx = (PFNVIRTALLEX)
            GetProcAddress(GetModuleHandle("KERNEL32.DLL"),"VirtualAllocEx");

        if (!(*pBuff = pfnVirtualAllocEx(proc->hProcess, 0, amount, MEM_COMMIT,
		access))) {
	    EXP_LOG1(MSG_DT_CANTMAKENTSPMEM, GetSysMsg(GetLastError()));
	}
    } else {
        // In Windows 9X, create a small memory mapped file.  On this
        // platform, memory mapped files are above 2GB, and thus are
        // accessible to all processes.
	//
        HANDLE hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE, 0,
		access | SEC_COMMIT, 0, amount, 0);

	if (!hFileMapping) {
	    EXP_LOG1(MSG_DT_CANTMAKE95SPMEM, GetSysMsg(GetLastError()));
	}

	LPVOID buffer = MapViewOfFile(hFileMapping, FILE_MAP_WRITE, 0, 0,
		amount);

	if (!buffer) {
	    EXP_LOG1(MSG_DT_CANTMAKE95SPMEM, GetSysMsg(GetLastError()));
	}

	// Save the association
	//
	spMemMapping.Add(buffer, hFileMapping);
	*pBuff = buffer;
    }
}

void
ConsoleDebugger::RemoveSubprocessMemory(Process *proc, LPVOID buff)
{
    if (dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // We're on NT, so use VirtualAllocEx to control memory in the other
        // process' address space.  Alas, we can't just call VirtualAllocEx
        // since it's not defined in the Windows 95 KERNEL32.DLL.
	//
        static PFNVIRTALLEX pfnVirtualAllocEx = (PFNVIRTALLEX)
            GetProcAddress(GetModuleHandle("KERNEL32.DLL"),"VirtualAllocEx");

	pfnVirtualAllocEx(proc->hProcess, buff, 0, MEM_RELEASE);
    } else {
	HANDLE hFileMapping;
	if (spMemMapping.Extract(buff, &hFileMapping) != TCL_OK) {
	}
	UnmapViewOfFile(buff);
	CloseHandle(hFileMapping);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RefreshScreen --
 *
 *	Redraw the entire screen
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */
/*
void
ConsoleDebugger::RefreshScreen(void)
{
    CONSOLE_SCREEN_BUFFER_INFO info;
    CHAR buf[4096];
    DWORD bufpos = 0;
    CHAR_INFO consoleBuf[4096];
    COORD size = {ConsoleSize.X, ConsoleSize.Y};
    COORD begin = {0, 0};
    SMALL_RECT rect = {0, 0, ConsoleSize.X-1, ConsoleSize.Y-1};
    int x, y, prespaces, postspaces, offset;

    // Clear the screen
    bufpos += wsprintf(&buf[bufpos], "\033[2J");
    bufpos += wsprintf(&buf[bufpos], "\033[%d;%dH", CursorPosition.Y+1,
	    CursorPosition.X+1);
    CursorKnown = TRUE;

    WriteMaster(buf, bufpos);
    bufpos = 0;

//    if (GetConsoleScreenBufferInfo(HConsole, &info) != FALSE) {
//	return;
//    }

    CursorPosition = info.dwCursorPosition;

//    if (! ReadConsoleOutput(HConsole, consoleBuf, size, begin, &rect)) {
//	return;
//    }

    offset = 0;
    for (y = 0; y < ConsoleSize.Y; y++) {
	offset += ConsoleSize.X;
	for (x = 0; x < ConsoleSize.X; x++) {
	    if (consoleBuf[offset+x].Char.AsciiChar != ' ') {
		break;
	    }
	}
	prespaces = x;
	if (prespaces == ConsoleSize.X) {
	    continue;
	}

	for (x = ConsoleSize.X-1; x >= 0; x--) {
	    if (consoleBuf[offset+x].Char.AsciiChar != ' ') {
		break;
	    }
	}
	postspaces = x;
	bufpos += wsprintf(&buf[bufpos], "\033[%d;%dH", y+1, prespaces+1);

	for (x = prespaces; x < postspaces; x++) {
	    buf[bufpos++] = consoleBuf[offset+x].Char.AsciiChar;
	}
    }

    bufpos += wsprintf(&buf[bufpos], "\033[%d;%dH", CursorPosition.Y+1,
	    CursorPosition.X+1);
    CursorKnown = TRUE;
    WriteMaster(buf, bufpos);
}
*/

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::ProcessNew --
 *
 *	Allocates a new structure for debugging a process and
 *	initializes it.
 *
 * Results:
 *	A new structure
 *
 * Side Effects:
 *	Memory is allocated, an event is created.
 *
 *----------------------------------------------------------------------
 */

ConsoleDebugger::Process *
ConsoleDebugger::ProcessNew(void)
{
    Process *proc;
    proc = new Process;
    proc->nextPtr = ProcessList;
    ProcessList = proc;
    return proc;
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::ProcessFree --
 *
 *	Frees all allocated memory for a process and closes any
 *	open handles
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::ProcessFree(Process *proc)
{
    ThreadInfo *tcurr, *tnext;
    Breakpoint *bcurr, *bnext;
    Process *pcurr, *pprev;

    for (tcurr = proc->threadList; tcurr != 0L; tcurr = tnext) {
	tnext = tcurr->nextPtr;
	proc->threadCount--;
	CloseHandle(tcurr->hThread);
	delete tcurr;
    }
    for (bcurr = proc->brkptList; bcurr != 0L; bcurr = bnext) {
	bnext = bcurr->nextPtr;
	delete bcurr;
    }
    for (pprev = 0L, pcurr = ProcessList; pcurr != 0L;
	 pcurr = pcurr->nextPtr)
    {
	if (pcurr == proc) {
	    if (pprev == 0L) {
		ProcessList = pcurr->nextPtr;
	    } else {
		pprev->nextPtr = pcurr->nextPtr;
	    }
	    break;
	}
    }
    CloseHandle(proc->hProcess);

    delete proc;
@


1.1.2.16
log
@oops. fixed a compiling bug.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.15 2002/06/18 22:51:31 davygrvy Exp $
a35 2
typedef LPVOID (__stdcall *PFNVIRTALLEX)(HANDLE,LPVOID,SIZE_T,DWORD,DWORD);

d1286 2
d1337 1
a1337 1
	pfnVirtualAllocEx(proc->hProcess, buff, 0, MEM_RELEASE, 0);
@


1.1.2.17
log
@small refactoring.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.16 2002/06/18 23:14:18 davygrvy Exp $
a35 10
#ifdef _M_IX86
    // Breakpoint opcode on i386
#   define BRK_OPCODE	    0xCC
    // Single step flag
#   define SINGLE_STEP_BIT  0x100
#else
#   error need opcodes for this hardware.
#endif


d432 1
a432 1
    // Fill the buffer with all breakpoint opcodes.
d434 1
a434 1
    memset(retbuf, BRK_OPCODE, RETBUF_SIZE);
d531 1
a531 1
    code = BRK_OPCODE;
d892 6
a897 1
    code = BRK_OPCODE;
@


1.1.2.18
log
@Added OnXDebugString() to the ConsoleDebugger class to handle the
OUTPUT_DEBUG_STRING_EVENT debugger event.  This sends a new
message type called TYPE_WARNING to the output client.  Changed the
stdio client to just send this out on stderr.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.17 2002/06/20 06:43:55 davygrvy Exp $
d390 1
a390 1
	OnXDebugString(proc, &debEvent);
d669 1
a669 1
 * ConsoleDebugger::OnXLoadDll --
d809 1
a809 1
 * ConsoleDebugger::OnXUnloadDll --
a845 41
 * ConsoleDebugger::OnXDebugString --
 *
 *	This routine is called when a OUTPUT_DEBUG_STRING_EVENT is seen.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	Allocates a buffer for the string that is not cleared *here*.
 *
 *----------------------------------------------------------------------
 */
void
ConsoleDebugger::OnXDebugString(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    CHAR *buffer;
    DWORD len;

    if (pDebEvent->u.DebugString.fUnicode) {
	int wlen = pDebEvent->u.DebugString.nDebugStringLength;
	WCHAR *wbuffer = new WCHAR [wlen];
	ReadSubprocessStringW(proc,
		pDebEvent->u.DebugString.lpDebugStringData,
		wbuffer, wlen);
	len = WideCharToMultiByte(CP_ACP, 0, wbuffer, wlen, 0L, 0, 0L, 0L);
	buffer = new CHAR [len];
	WideCharToMultiByte(CP_ACP, 0, wbuffer, wlen, buffer, len, 0L, 0L);
    } else {
	len = pDebEvent->u.DebugString.nDebugStringLength;
	buffer = new CHAR [len];
	ReadSubprocessStringA(proc,
		pDebEvent->u.DebugString.lpDebugStringData,
		buffer, len);
    }

    WriteMasterWarning(buffer, len);
}

/*
 *----------------------------------------------------------------------
 *
a1276 12
    mQ.Put(msg);
}

/* doesn't copy */
void
ConsoleDebugger::WriteMasterWarning(CHAR *buf, DWORD len)
{
    Message *msg;
    msg = new Message;
    msg->bytes = (BYTE *) buf;
    msg->length = len;
    msg->type = Message::TYPE_WARNING;
@


1.1.2.19
log
@Injector code hook-in, but doesn't yet work.  I don't know why.
The opcodes for loading the DLL are correct.  The opcodes are
written to the sub process memory and run.  I just don't know.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.18 2002/06/20 21:52:53 davygrvy Exp $
d333 1
a333 1
		OnXSecondBreakpoint(proc, &debEvent); break;
d454 1
a454 1

d462 1
a462 1
    injectorStub.operand_PUSH_value = (DWORD) pInjectorStub +
d464 2
a465 2
    injectorStub.operand_MOV_EAX = (DWORD) GetProcAddress(GetModuleHandle(
	    "KERNEL32.DLL"), "LoadLibraryA");
d480 1
a480 1

d502 1
a502 2
    ThreadInfo *tinfo;
    CONTEXT now;
a509 6
    now.ContextFlags = CONTEXT_FULL;
    GetThreadContext(tinfo->hThread, &now);
    
    // Eax should not be zero, if the injector loaded.
    // It should be the handle of the injector dll.

d515 2
a516 2
    RemoveSubprocessMemory(proc, pInjectorStub);

d848 1
a848 2
 *	This routine is called when a OUTPUT_DEBUG_STRING_EVENT
 *	happens.
d1046 1
a1046 1
	if (!(mbi.Protect & PAGE_READWRITE || mbi.Protect & PAGE_EXECUTE_READWRITE)) {
d1311 1
a1311 1
ConsoleDebugger::WriteMasterCopy(CHAR *buf, DWORD len)
a1313 2
    DWORD i;

d1315 1
a1315 2
    msg->bytes = new CHAR [len];
    for (i = 0; i < len; i++) msg->bytes[i] = buf[i];
d1327 1
a1327 1
    msg->bytes = buf;
d1436 1
a1436 1
    WriteMasterCopy(buf, bufpos);
d1478 1
a1478 1
    WriteMasterCopy(buf, bufpos);
@


1.1.2.20
log
@The injector DLL is now loading into the process.  That's the good news.
The bad news is that it's crashing the process.  I decided to commit the
changes anyways with the hope someone can assist.  Even with the
injector doing nothing, we still crash for some unknown reason.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.19 2002/06/21 03:01:50 davygrvy Exp $
d46 1
d51 1
a51 1
    ConsoleCP(0), mQ(_mQ), pStartAddress(0L), originalExeEntryPointOpcode(0), pInjectorStub(0)
a53 1
    DWORD n, i;
a58 22
    if (dwPlatformId == VER_PLATFORM_WIN32_NT) {
	pfnVirtualAllocEx = (PFNVIRTUALALLOCEX) GetProcAddress(
		GetModuleHandle("KERNEL32.DLL"),"VirtualAllocEx");
	pfnVirtualFreeEx = (PFNVIRTUALFREEEX) GetProcAddress(
		GetModuleHandle("KERNEL32.DLL"),"VirtualFreeEx");
    }

    n = GetEnvironmentVariable("Path", NULL, 0);
    n += GetEnvironmentVariable("_NT_SYMBOL_PATH", NULL, 0) + 1;
    n += GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", NULL, 0) + 1;
    n += GetEnvironmentVariable("SystemRoot", NULL, 0) + 1;

    SymbolPath = new char [n];

    i = GetEnvironmentVariable("Path", SymbolPath, n);
    SymbolPath[i++] = ';';
    i += GetEnvironmentVariable("_NT_SYMBOL_PATH", &SymbolPath[i], n-i);
    SymbolPath[i++] = ';';
    i += GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", &SymbolPath[i], n-i);
    SymbolPath[i++] = ';';
    i += GetEnvironmentVariable("SystemRoot", &SymbolPath[i], n-i);

a214 1
    delete [] SymbolPath;
d329 1
a329 1
	    switch (proc->nBreakCount < 4 ? ++(proc->nBreakCount) : 4) {
a334 9
		if ((DWORD)debEvent.u.Exception.ExceptionRecord.ExceptionAddress
			!= (injectorStub.operand_PUSH_value - sizeof(BYTE)))
		{
		    --(proc->nBreakCount);
		    OnXBreakpoint(proc, &debEvent);
		    break;
		}
		OnXThirdBreakpoint(proc, &debEvent); break;
	    case 4:
a348 4
	case EXCEPTION_NONCONTINUABLE_EXCEPTION:
	    // we die here.
	    return EXCEPTION_NONCONTINUABLE_EXCEPTION;

d350 1
a350 1
	    if (!debEvent.u.Exception.dwFirstChance) {
d447 1
a447 1
    // Set all Console API breakpoints.
d455 3
a457 46
    // Install our entry breakpoint.  We can't run the injector Stub now
    // as the process heap hasn't been created.  (it was some memory related
    // error and I don't know exactly why, but moving the stub run later
    // solved it).  It seems that the first breakpoint naturally fired is
    // much too early in the creation of the initial process for much of
    // anything to be ready.
    //
    ReadSubprocessMemory(proc, pStartAddress,
	    &originalExeEntryPointOpcode, sizeof(BYTE));

    BYTE bpOpcode = BRK_OPCODE;
    WriteSubprocessMemory(proc, pStartAddress, &bpOpcode, sizeof(BYTE));

    return;
#   undef RETBUF_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXSecondBreakpoint --
 *
 *	This routine is called when the second breakpoint is hit.
 *	The processes' entry-point is getting called.  We intercept this
 *	and make our injector.dll load first before the entry-point is
 *	called.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXSecondBreakpoint(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    ThreadInfo *tinfo;

    for (tinfo = proc->threadList; tinfo != 0L; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
    }

    //  Make some memory for our stub that we place into the processes' address
    //  space.  This stub (or set of opcodes) calls LoadLibrary() to bring in our
a467 2
    FlushInstructionCache(proc->hProcess, pInjectorStub, sizeof(LOADLIBRARY_STUB));

d475 1
a475 1
    //  from where we are (which is the app's entry point).
d480 3
d488 1
a488 1
 * ConsoleDebugger::OnXThirdBreakpoint --
d490 1
a490 1
 *	This routine is called when the third breakpoint is hit and
d500 1
a500 1
ConsoleDebugger::OnXThirdBreakpoint(Process *proc, LPDEBUG_EVENT pDebEvent)
d502 1
a503 1
    ThreadInfo *tinfo;
a516 3
    WriteSubprocessMemory(proc, pStartAddress,
	    &originalExeEntryPointOpcode, sizeof(BYTE));

d519 2
a520 2
    // We should now remove the memory allocated in the sub process for
    // our injector stub.
d526 1
d566 2
a567 157
    BOOL b;
    STACKFRAME frame;
    CONTEXT context;
    ThreadInfo *tinfo;
    Module *modPtr;
    DWORD displacement;
    BYTE symbolBuffer[sizeof(IMAGEHLP_SYMBOL) + 512];
    PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
    char *s;
    int result;

    for (tinfo = proc->threadList; tinfo != NULL; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
    }

    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(tinfo->hThread, &context);

    /*
     * XXX: From what I can tell, SymInitialize is broken on Windows NT 4.0
     * if you try to have it iterate the modules in a process.  It always
     * returns an object mismatch error.  Instead, initialize without iterating
     * the modules.  Contrary to what MSDN documentation says,
     * Microsoft debuggers do not exclusively use the imagehlp API.  In
     * fact, the only thing VC 5.0 uses is the StackWalk function.
     * Windbg uses a few more functions, but it doesn't use SymInitialize.
     * We will then do the hard work of finding all the
     * modules and doing the right thing.
     */

    if (!SymInitialize(proc->hProcess, SymbolPath, FALSE))
    {
	CHAR *buffer = new CHAR [512];
	DWORD len;
	len = wsprintf(buffer, "Unable to get backtrace: %s\n",
		GetSysMsg(GetLastError()));
	WriteMasterError(buffer, len);
	return;
    }

#ifdef _X86_
    memset(&frame, 0, sizeof(frame));
    frame.AddrPC.Mode = AddrModeFlat;
    frame.AddrPC.Segment = 0;
    frame.AddrPC.Offset = context.Eip;

    frame.AddrReturn.Mode = AddrModeFlat;
    frame.AddrReturn.Segment = 0;
    frame.AddrReturn.Offset = context.Ebp; /* I think this is correct */

    frame.AddrFrame.Mode = AddrModeFlat;
    frame.AddrFrame.Segment = 0;
    frame.AddrFrame.Offset = context.Ebp;

    frame.AddrStack.Mode = AddrModeFlat;
    frame.AddrStack.Segment = 0;
    frame.AddrStack.Offset = context.Esp;

    frame.FuncTableEntry = NULL;
    frame.Params[0] = context.Eax;
    frame.Params[1] = context.Ecx;
    frame.Params[2] = context.Edx;
    frame.Params[3] = context.Ebx;
    frame.Far = FALSE;
    frame.Virtual = FALSE;
    frame.Reserved[0] = 0;
    frame.Reserved[1] = 0;
    frame.Reserved[2] = 0;
    /* frame.KdHelp.* is not set */

    /*
     * Iterate through the loaded modules and load symbols for each one.
     */
    for (
	result = proc->moduleTable.Top(&modPtr);
	result == TCL_OK;
	result = proc->moduleTable.Next(&modPtr)
    ) {
	if (!modPtr->loaded) {
	    modPtr->dbgInfo = MapDebugInformation(modPtr->hFile, 0L,
		SymbolPath, (DWORD)modPtr->baseAddr);

	    SymLoadModule(proc->hProcess, modPtr->hFile,
		0L, 0L, (DWORD) modPtr->baseAddr, 0);
	    modPtr->loaded = TRUE;
	}
    }


    if (proc->exeModule && proc->exeModule->dbgInfo && 
	proc->exeModule->dbgInfo->ImageFileName) {
	s = proc->exeModule->dbgInfo->ImageFileName;
    } else {
	s = "";
    }

    {
	DWORD len;
	CHAR *buffer = new CHAR [MAX_PATH+54];
	len = wsprintf(buffer, "A fatal exception has occured in \"%s\"\n"
		"This is the backtrace\n"
		"-------------------------------------\n", s);
	WriteMasterError(buffer, len);
    }

    while (1) {
        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLength = 512;

	b = StackWalk(
#ifdef _WIN64
	    IMAGE_FILE_MACHINE_IA64,
#else
	    IMAGE_FILE_MACHINE_I386,
#endif
	    proc->hProcess,
	    tinfo->hThread, &frame, &context, 0L,
	    SymFunctionTableAccess, SymGetModuleBase,
	    0L);

	if (b == FALSE || frame.AddrPC.Offset == 0) {
	    break;
	}
	    
        if (SymGetSymFromAddr(proc->hProcess, frame.AddrPC.Offset,
	    &displacement, pSymbol) )
        {
	    DWORD base, len;
	    CHAR *buffer = new CHAR [128];

	    base = SymGetModuleBase(proc->hProcess, frame.AddrPC.Offset);
	    if (proc->moduleTable.Find((void *)base, &modPtr) != TCL_ERROR) {
		if (modPtr->dbgInfo && modPtr->dbgInfo->ImageFileName) {
		    s = modPtr->dbgInfo->ImageFileName;
		} else {
		    s = "";
		}
	    } else {
		s = "";
	    }
	    len = wsprintf(buffer, "%.20s %08.8x\t%s+%X\n", s, frame.AddrPC.Offset,
		    pSymbol->Name, displacement);
	    WriteMasterError(buffer, len);
	} else {
	    DWORD len;
	    CHAR *buffer = new CHAR [33];
	    len = wsprintf(buffer, "%08.8x\n", frame.AddrPC.Offset);
	    WriteMasterError(buffer, len);
	}
    }

    SymCleanup(proc->hProcess);
#else
#  error Unsupported architecture	    
#endif
a655 4
    // Save the first processes' start address.
    if (!pStartAddress)
	    pStartAddress = info->lpStartAddress;

d879 1
a879 1
	buffer = new CHAR [len+1];
d883 1
a883 1
	buffer = new CHAR [len+1];
a888 1
    buffer[len] = '\0';  // Oops, Win9x forgets this.
a958 111
 * ConsoleDebugger::OnXBreakpoint --
 *
 *	This routine is called when a EXCEPTION_DEBUG_EVENT with
 *	an exception code of EXCEPTION_BREAKPOINT.
 *
 * Results:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
ConsoleDebugger::OnXBreakpoint(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    LPEXCEPTION_DEBUG_INFO exceptInfo;
    CONTEXT context;
    ThreadInfo *tinfo;
    Breakpoint *pbrkpt, *brkpt;
    PDWORD pdw;
    DWORD i;
    DWORD dw;

    for (tinfo = proc->threadList; tinfo != 0L; tinfo = tinfo->nextPtr) {
	if (pDebEvent->dwThreadId == tinfo->dwThreadId) {
	    break;
	}
    }
    assert(tinfo != 0L);

    exceptInfo = &pDebEvent->u.Exception;

    pbrkpt = 0L;
    for (brkpt = proc->brkptList; brkpt != 0L;
	 pbrkpt = brkpt, brkpt = brkpt->nextPtr) {
	if (brkpt->codePtr == exceptInfo->ExceptionRecord.ExceptionAddress) {
	    if (brkpt->threadInfo == 0L) {
		break;
	    }
	    if (brkpt->threadInfo == tinfo) {
		break;
	    }
	}
    }

    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(tinfo->hThread, &context);

    if (! brkpt->returning) {
	Breakpoint *bpt;
	// Get the arguments to the function and store them in the thread
	// specific data structure.
	for (pdw = tinfo->args, i=0; i < brkpt->breakInfo->nargs; i++, pdw++) {
	    ReadSubprocessMemory(proc, (PVOID) (context.Esp+(4*(i+1))),
				 pdw, sizeof(DWORD));
	}
	tinfo->nargs = brkpt->breakInfo->nargs;
	tinfo->context = &context;

	if (brkpt->breakInfo->dwFlags & BREAK_IN) {
	    ((this)->*(brkpt->breakInfo->breakProc))(proc, tinfo, brkpt, &context.Eax, BREAK_IN);
	}

	// Only set a return breakpoint if something is interested
	// in the return value
	if (brkpt->breakInfo->dwFlags & BREAK_OUT) {
	    bpt = new Breakpoint;
	    ReadSubprocessMemory(proc, (PVOID) context.Esp,
		&bpt->origRetAddr, sizeof(DWORD));
	    dw = (DWORD) brkpt->codeReturnPtr;
	    WriteSubprocessMemory(proc, (PVOID) context.Esp,
		&dw, sizeof(DWORD));
	    bpt->codePtr = brkpt->codeReturnPtr;
	    bpt->returning = TRUE;
	    bpt->codeReturnPtr = 0L;	// Doesn't matter
	    bpt->breakInfo = brkpt->breakInfo;
	    bpt->threadInfo = tinfo;
	    bpt->nextPtr = proc->brkptList;
	    proc->brkptList = bpt;

	}

	// Now, we need to restore the original code for this breakpoint.
	// Put the program counter back, then do a single-step and put
	// the breakpoint back again.
	//
	WriteSubprocessMemory(proc, brkpt->codePtr, &brkpt->code, sizeof(BYTE));

	context.EFlags |= SINGLE_STEP_BIT;
	context.Eip--;

	proc->lastBrkpt = brkpt;
    } else {
	// Make the callback with the params and the return value
	if (brkpt->breakInfo->dwFlags & BREAK_OUT) {
	    ((this)->*(brkpt->breakInfo->breakProc))(proc, tinfo, brkpt, &context.Eax, BREAK_OUT);
	}
	context.Eip = brkpt->origRetAddr;

	if (pbrkpt == 0L) {
	    proc->brkptList = brkpt->nextPtr;
	} else {
	    pbrkpt->nextPtr = brkpt->nextPtr;
	}
	delete brkpt;
    }
    SetThreadContext(tinfo->hThread, &context);
}

/*
 *----------------------------------------------------------------------
 *
d1080 111
d1319 35
d1358 7
d1395 1
a1395 1
BOOL
d1398 7
a1404 1
    BOOL ret;
d1406 1
a1406 2
    if (dwPlatformId == VER_PLATFORM_WIN32_NT) {
	ret = pfnVirtualFreeEx(proc->hProcess, buff, 0, MEM_RELEASE);
a1409 2
	    SetLastError(ERROR_FILE_NOT_FOUND);
	    return FALSE;
d1411 1
a1411 1
	ret = UnmapViewOfFile(buff);
a1413 1
    return ret;
a1566 47

void
ConsoleDebugger::WriteMasterCopy(CHAR *buf, DWORD len)
{
    Message *msg;
    DWORD i;

    msg = new Message;
    msg->bytes = new CHAR [len];
    for (i = 0; i < len; i++) msg->bytes[i] = buf[i];
    msg->length = len;
    msg->type = Message::TYPE_NORMAL;
    mQ.Put(msg);
}

/* doesn't copy! */
void
ConsoleDebugger::WriteMasterWarning(CHAR *buf, DWORD len)
{
    Message *msg;
    msg = new Message;
    msg->bytes = buf;
    msg->length = len;
    msg->type = Message::TYPE_WARNING;
    mQ.Put(msg);
}

void
ConsoleDebugger::WriteMasterError(CHAR *buf, DWORD len)
{
    Message *msg;
    msg = new Message;
    msg->bytes = buf;
    msg->length = len;
    msg->type = Message::TYPE_ERROR;
    mQ.Put(msg);
}

void
ConsoleDebugger::NotifyDone()
{
    Message *msg;
    msg = new Message;
    msg->type = Message::TYPE_SLAVEDONE;
    mQ.Put(msg);
}

@


1.1.2.21
log
@Big crash big fixed.  I was restarting the thread AFTER the breakpoint rather
than on top of it.  OutputDebugString() is now passing through, too.  No
connection has been made yet to the IPC server the injector dll is providing.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.20 2002/06/21 22:04:24 davygrvy Exp $
d362 1
a362 1
		    dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
d461 2
d464 2
d473 18
d505 1
a534 4
    // Put the first opcode at the entry point back in place.
    WriteSubprocessMemory(proc, pStartAddress,
	    &originalExeEntryPointOpcode, sizeof(BYTE));

a581 4
#   define RETBUF_SIZE 2048
    BYTE retbuf[RETBUF_SIZE];
    BreakInfo *binfo;
    int i;
d595 3
a597 1
    preStubContext.Eip -= sizeof(BYTE);
a604 21


    // Set up the memory that will serve as the place for our
    // intercepted function return points.
    //
    MakeSubprocessMemory(proc, RETBUF_SIZE, &(proc->pSubprocessMemory));

    // Fill the buffer with all breakpoint opcodes.
    //
    memset(retbuf, BRK_OPCODE, RETBUF_SIZE);
    WriteSubprocessMemory(proc, proc->pSubprocessMemory, retbuf, RETBUF_SIZE);

    // Set all Console API breakpoints.
    //
    for (i = 0; BreakPoints[i].dllName; i++) {
	for (binfo = BreakPoints[i].breakInfo; binfo->funcName; binfo++) {
	    SetBreakpoint(proc, binfo);
	}
    }

#   undef RETBUF_SIZE
@


1.1.2.22
log
@IPC connection to the injector dll, done.  Write() added, but does nothing yet.
I have to think this through...
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.21 2002/06/22 02:50:09 davygrvy Exp $
d48 3
a50 5
ConsoleDebugger::ConsoleDebugger
(int _argc, char * const *_argv, CMclQueue<Message *> &_mQ)
    : argc(_argc), argv(_argv), ProcessList(0L), CursorKnown(FALSE),
    ConsoleOutputCP(0), ConsoleCP(0), mQ(_mQ), pStartAddress(0L),
    originalExeEntryPointOpcode(0), pInjectorStub(0), injectorIPC(0L)
d561 1
a562 2
    CHAR boxName[50];
    DWORD err;
d574 5
a578 14
    // Create the IPC connection to our loaded injector.dll
    //
    wsprintf(boxName, "ExpectInjector_pid%d", proc->pid);
    injectorIPC = new CMclMailbox(boxName);
    // Check status.
    if ((err = injectorIPC->Status()) != NO_ERROR) {
	char *error = new char [512];
	strcpy(error, "IPC connection to injector.dll could not be made: ");
	strcat(error, GetSysMsg(err));
	strcat(error, "\n");
	WriteMasterError(error, strlen(error));
	delete injectorIPC;
	injectorIPC = 0L;
    }
a579 2
    // Set our thread to run the entry point, now, starting the
    // application once we return from this breakpoint.
a582 1

d584 1
a584 2
    // our injector stub.  The dll is already loaded and there's no sense
    // hogging a virtual memory page.
a588 4
    /////////////////////////////////////////////////////////////////////
    // Now create our breakpoints on all calls to the OS console API.
    /////////////////////////////////////////////////////////////////////

a1813 5
void
ConsoleDebugger::Write (Message *msg)
{
    delete msg;
}
@


1.1.2.23
log
@More new good stuff.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.22 2002/06/22 05:54:32 davygrvy Exp $
d31 1
a31 1
#include "expWinSlave.hpp"
a239 1
    if (injectorIPC) delete injectorIPC;
d360 7
d1796 1
a1796 2
    for (i = 0; i < len; i++)
	    ((PCHAR)msg->bytes)[i] = buf[i];
d1835 1
a1835 1
ConsoleDebugger::WriteRecord (INPUT_RECORD *ir)
d1837 1
a1837 3
    if (injectorIPC != 0L) {
	injectorIPC->Post(ir);
    }
a1838 2


@


1.1.2.24
log
@hMasterConsole now properly closed in destructor.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.23 2002/06/22 14:02:03 davygrvy Exp $
a240 1
    CloseHandle(hMasterConsole);
d258 3
d282 3
@


1.1.2.25
log
@We can now write to the slave console.  Debugged and working.
slavedrv1.1 was released today from the code of this commit.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.24 2002/06/23 09:27:22 davygrvy Exp $
d255 1
a255 4
    si.dwXCountChars = 80;
    si.dwYCountChars = 25;
    si.wShowWindow = SW_SHOWNOACTIVATE;
    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USECOUNTCHARS;
d569 1
a569 2
    injectorIPC = new CMclMailbox(80, sizeof(INPUT_RECORD), boxName);

a1826 1
    DWORD why;
d1828 1
a1828 1
	why = injectorIPC->Post(ir);
@


1.1.2.26
log
@Added RIP events to the debugger and better error reporting for bad trap
and transport methods on the commandline.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.25 2002/06/25 08:40:50 davygrvy Exp $
d258 1
a258 2
    si.dwFlags = STARTF_FORCEONFEEDBACK | STARTF_USESHOWWINDOW |
	STARTF_USECOUNTCHARS;
a421 4

    case RIP_EVENT:
	OnXRip(proc, &debEvent);
	break;
a1146 33
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::OnXRip --
 *
 *	Catches and reports RIP events (system error messages).
 *	Is RIP short for Rest-In-Peace??
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	allocates memory that is freed by the Message destructor.
 *
 *----------------------------------------------------------------------
 */
void
ConsoleDebugger::OnXRip(Process *proc, LPDEBUG_EVENT pDebEvent)
{
    char *errorMsg = new CHAR [512];
    DWORD len;

    if (pDebEvent->u.RipInfo.dwType == SLE_ERROR) {
	len = wsprintf(errorMsg, "A fatal RIP error was caught: %s",
		GetSysMsg(pDebEvent->u.RipInfo.dwError));
	WriteMasterError(errorMsg, len);
    } else {
	len = wsprintf(errorMsg, "A non-fatal RIP error was caught: %s",
		GetSysMsg(pDebEvent->u.RipInfo.dwError));
	WriteMasterWarning(errorMsg, len);
    }
@


1.1.2.27
log
@small stuff
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.26 2002/06/25 22:50:07 davygrvy Exp $
d1387 1
a1387 1
    // if inaccessible or not committed memory, abort
d1389 2
a1390 3
    if (!VirtualQueryEx(proc->hProcess, addr, &mbi,
	    sizeof(MEMORY_BASIC_INFORMATION)) || mbi.State != MEM_COMMIT)
    {
d1445 3
a1447 3
    // if inaccessible or not committed memory, abort
    if (!VirtualQueryEx(proc->hProcess, addr, &mbi,
	    sizeof(MEMORY_BASIC_INFORMATION)) || mbi.State != MEM_COMMIT)
a1845 1
/* doesn't copy! */
d1869 1
d1871 1
a1871 1
	injectorIPC->Post(ir);
@


1.1.2.28
log
@closing of the test application is more thorough and controlled.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.27 2002/06/26 03:58:13 davygrvy Exp $
a311 1
    int breakCount = 0;
d354 1
a354 2
	    // only the first three get special attention.
	    switch (breakCount < 4 ? ++breakCount : 4) {
d769 1
a769 2
	len = wsprintf(buffer,
		"\nA fatal exception has occured in \"%s\"\n"
@


1.1.2.29
log
@slot and slot sizes are shared on both sides.  This ensures there won't be
any errors from different info.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.28 2002/06/27 03:43:34 davygrvy Exp $
a31 2
#include "expWinInjectorIPC.hpp"

d579 1
a579 1
    injectorIPC = new CMclMailbox(IPC_NUMSLOTS, IPC_SLOTSIZE, boxName);
d582 1
a582 2
    err = injectorIPC->Status();
    if (err != NO_ERROR && err != ERROR_ALREADY_EXISTS) {
@


1.1.2.30
log
@The ClientInteract class has been created.  It's empty, though.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.29 2002/06/27 22:51:04 davygrvy Exp $
d54 1
a54 2
    originalExeEntryPointOpcode(0), pInjectorStub(0), injectorIPC(0L),
    interacting(false), interactingConsole(0L)
d348 1
a348 1
//    bpCritSec.Enter();
d433 1
a433 1
//    bpCritSec.Leave();
a1881 4
void
ConsoleDebugger::EnterInteract (HANDLE OutConsole)
{
    interactingConsole = OutConsole;
a1882 14
    // More stuff to do here... What?
    // Copy entire screen contents, how?
    // Set interactingConsole to the proper size?
    // more ???  help!

    interacting = true;
}

void
ConsoleDebugger::ExitInteract ()
{
    interactingConsole = 0L;
    interacting = false;
}@


1.1.2.31
log
@Started on adding the interact logic to the breakpoints.  This is sticky...
I don't know what to expect (pun intended).
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.30 2002/06/28 01:26:56 davygrvy Exp $
d50 2
a51 5
ConsoleDebugger::ConsoleDebugger (
	int _argc,
	char * const *_argv,
	CMclQueue<Message *> &_mQ
    )
d114 1
a114 1
    BreakArrayKernel32[2].breakProc = OnFillConsoleOutputCharacterA;
d119 1
a119 1
    BreakArrayKernel32[3].breakProc = OnFillConsoleOutputCharacterW;
d177 1
a177 1
    BreakArrayKernel32[15].funcName = "SetConsoleTextAttribute";
d179 1
a179 1
    BreakArrayKernel32[15].breakProc = OnSetConsoleTextAttribute;
d182 3
a184 3
    BreakArrayKernel32[16].funcName = "SetConsoleWindowInfo";
    BreakArrayKernel32[16].nargs = 3;
    BreakArrayKernel32[16].breakProc = OnSetConsoleWindowInfo;
d187 1
a187 1
    BreakArrayKernel32[17].funcName = "WriteConsoleA";
d189 1
a189 1
    BreakArrayKernel32[17].breakProc = OnWriteConsoleA;
d192 1
a192 1
    BreakArrayKernel32[18].funcName = "WriteConsoleW";
d194 1
a194 1
    BreakArrayKernel32[18].breakProc = OnWriteConsoleW;
d197 1
a197 1
    BreakArrayKernel32[19].funcName = "WriteConsoleOutputA";
d199 1
a199 1
    BreakArrayKernel32[19].breakProc = OnWriteConsoleOutputA;
d202 1
a202 1
    BreakArrayKernel32[20].funcName = "WriteConsoleOutputW";
d204 1
a204 1
    BreakArrayKernel32[20].breakProc = OnWriteConsoleOutputW;
d207 1
a207 1
    BreakArrayKernel32[21].funcName = "WriteConsoleOutputCharacterA";
d209 1
a209 1
    BreakArrayKernel32[21].breakProc = OnWriteConsoleOutputCharacterA;
d212 4
a215 14
    BreakArrayKernel32[22].funcName = "WriteConsoleOutputCharacterW";
    BreakArrayKernel32[22].nargs = 5;
    BreakArrayKernel32[22].breakProc = OnWriteConsoleOutputCharacterW;
    BreakArrayKernel32[22].dwFlags = BREAK_OUT;

    BreakArrayKernel32[23].funcName = "WriteFile";
    BreakArrayKernel32[23].nargs = 5;
    BreakArrayKernel32[23].breakProc = OnWriteFile;
    BreakArrayKernel32[23].dwFlags = BREAK_OUT;

    BreakArrayKernel32[24].funcName = 0L;
    BreakArrayKernel32[24].nargs = 0;
    BreakArrayKernel32[24].breakProc = 0L;
    BreakArrayKernel32[24].dwFlags = 0;
d349 1
a349 1
    bpCritSec.Enter();
d434 1
a434 1
    bpCritSec.Leave();
a1885 2
    bpCritSec.Enter();

a1893 1
    bpCritSec.Leave();
@


1.1.2.32
log
@these uncommitted edits have been sitting on my desktop for an eternity.

Adds some MS-DOS support but fails to deliver the required hooks to
succeed.
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.31 2002/06/29 00:44:35 davygrvy Exp $
d31 1
a31 1
#include "expWinConsoleDebugger.hpp"
a32 2
#include <vdmdbg.h>
#pragma comment (lib, "vdmdbg.lib")
a104 3
    // interesting ones I might want to add:
    // DuplicateConsoleHandle

d115 1
a115 1
    BreakArrayKernel32[2].funcName = "CreateConsoleScreenBuffer";
d117 1
a117 1
    BreakArrayKernel32[2].breakProc = OnCreateConsoleScreenBuffer;
d120 1
a120 1
    BreakArrayKernel32[3].funcName = "FillConsoleOutputAttribute";
d122 1
a122 1
    BreakArrayKernel32[3].breakProc = OnFillConsoleOutputAttribute;
d125 3
a127 3
    BreakArrayKernel32[4].funcName = "FillConsoleOutputCharacterA";
    BreakArrayKernel32[4].nargs = 5;
    BreakArrayKernel32[4].breakProc = OnFillConsoleOutputCharacterA;
d130 3
a132 3
    BreakArrayKernel32[5].funcName = "FillConsoleOutputCharacterW";
    BreakArrayKernel32[5].nargs = 5;
    BreakArrayKernel32[5].breakProc = OnFillConsoleOutputCharacterW;
d135 3
a137 3
    BreakArrayKernel32[6].funcName = "FreeConsole";
    BreakArrayKernel32[6].nargs = 0;
    BreakArrayKernel32[6].breakProc = OnFreeConsole;
d140 3
a142 3
    BreakArrayKernel32[7].funcName = "GetStdHandle";
    BreakArrayKernel32[7].nargs = 1;
    BreakArrayKernel32[7].breakProc = OnGetStdHandle;
d145 3
a147 3
    BreakArrayKernel32[8].funcName = "OpenConsoleW";
    BreakArrayKernel32[8].nargs = 4;
    BreakArrayKernel32[8].breakProc = OnOpenConsoleW;
d150 3
a152 3
    BreakArrayKernel32[9].funcName = "ScrollConsoleScreenBufferA";
    BreakArrayKernel32[9].nargs = 5;
    BreakArrayKernel32[9].breakProc = OnScrollConsoleScreenBuffer;
d155 3
a157 3
    BreakArrayKernel32[10].funcName = "ScrollConsoleScreenBufferW";
    BreakArrayKernel32[10].nargs = 5;
    BreakArrayKernel32[10].breakProc = OnScrollConsoleScreenBuffer;
d160 3
a162 3
    BreakArrayKernel32[11].funcName = "SetConsoleActiveScreenBuffer";
    BreakArrayKernel32[11].nargs = 1;
    BreakArrayKernel32[11].breakProc = OnSetConsoleActiveScreenBuffer;
d165 3
a167 3
    BreakArrayKernel32[12].funcName = "SetConsoleCP";
    BreakArrayKernel32[12].nargs = 1;
    BreakArrayKernel32[12].breakProc = OnSetConsoleCP;
d170 1
a170 1
    BreakArrayKernel32[13].funcName = "SetConsoleCursorInfo";
d172 1
a172 1
    BreakArrayKernel32[13].breakProc = OnSetConsoleCursorInfo;
d175 3
a177 3
    BreakArrayKernel32[14].funcName = "SetConsoleCursorPosition";
    BreakArrayKernel32[14].nargs = 2;
    BreakArrayKernel32[14].breakProc = OnSetConsoleCursorPosition;
d180 1
a180 1
    BreakArrayKernel32[15].funcName = "SetConsoleMode";
d182 1
a182 1
    BreakArrayKernel32[15].breakProc = OnSetConsoleMode;
d185 3
a187 3
    BreakArrayKernel32[16].funcName = "SetConsoleOutputCP";
    BreakArrayKernel32[16].nargs = 1;
    BreakArrayKernel32[16].breakProc = OnSetConsoleOutputCP;
d190 3
a192 3
    BreakArrayKernel32[17].funcName = "SetConsoleTextAttribute";
    BreakArrayKernel32[17].nargs = 2;
    BreakArrayKernel32[17].breakProc = OnSetConsoleTextAttribute;
d195 3
a197 3
    BreakArrayKernel32[18].funcName = "SetConsoleWindowInfo";
    BreakArrayKernel32[18].nargs = 3;
    BreakArrayKernel32[18].breakProc = OnSetConsoleWindowInfo;
d200 1
a200 1
    BreakArrayKernel32[19].funcName = "WriteConsoleA";
d202 1
a202 1
    BreakArrayKernel32[19].breakProc = OnWriteConsoleA;
d205 1
a205 1
    BreakArrayKernel32[20].funcName = "WriteConsoleW";
d207 1
a207 1
    BreakArrayKernel32[20].breakProc = OnWriteConsoleW;
d210 1
a210 1
    BreakArrayKernel32[21].funcName = "WriteConsoleOutputA";
d212 1
a212 1
    BreakArrayKernel32[21].breakProc = OnWriteConsoleOutputA;
d215 1
a215 1
    BreakArrayKernel32[22].funcName = "WriteConsoleOutputW";
d217 1
a217 1
    BreakArrayKernel32[22].breakProc = OnWriteConsoleOutputW;
d220 1
a220 1
    BreakArrayKernel32[23].funcName = "WriteConsoleOutputCharacterA";
d222 1
a222 1
    BreakArrayKernel32[23].breakProc = OnWriteConsoleOutputCharacterA;
d225 4
a228 14
    BreakArrayKernel32[24].funcName = "WriteConsoleOutputCharacterW";
    BreakArrayKernel32[24].nargs = 5;
    BreakArrayKernel32[24].breakProc = OnWriteConsoleOutputCharacterW;
    BreakArrayKernel32[24].dwFlags = BREAK_OUT;

    BreakArrayKernel32[25].funcName = "WriteFile";
    BreakArrayKernel32[25].nargs = 5;
    BreakArrayKernel32[25].breakProc = OnWriteFile;
    BreakArrayKernel32[25].dwFlags = BREAK_OUT;

    BreakArrayKernel32[26].funcName = 0L;
    BreakArrayKernel32[26].nargs = 0;
    BreakArrayKernel32[26].breakProc = 0L;
    BreakArrayKernel32[26].dwFlags = 0;
d285 1
a285 5
	    DEBUG_PROCESS |
	    CREATE_NEW_CONSOLE |
	    CREATE_DEFAULT_ERROR_MODE |
	    CREATE_SEPARATE_WOW_VDM |
	    0,
a397 4
	case STATUS_VDM_EVENT:
	    OnXVDMException(proc, &debEvent);
	    break;

d401 1
a401 1
		// Now it is time to get a backtrace before it's death.
a634 3

    // Write it out to our buffer space in the other process.
    //
a647 80

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::SetBreakpoint --
 *
 *	Inserts a single breakpoint
 *
 * Results:
 *	TRUE if successful, FALSE if unsuccessful.
 *
 *----------------------------------------------------------------------
 */

BOOL
ConsoleDebugger::SetBreakpoint(Process *process, BreakInfo *info)
{
    PVOID funcPtr;

    if (process->funcTable.Find(info->funcName, &funcPtr) == TCL_ERROR)
    {
//	PCHAR buffer;
//	DWORD len;
//
//	buffer = new CHAR [128];
//	len = wsprintf(buffer, "Unable to set breakpoint at %s", info->funcName);
//	WriteMasterError(buffer, len);
	return FALSE;
    }

    // Set a breakpoint at the function start in the subprocess and
    // save the original code at the function start.
    //
    return SetBreakpointAtAddr(process, info, funcPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ConsoleDebugger::SetBreakpointAtAddr --
 *
 *	Inserts a single breakpoint at the given address
 *
 * Results:
 *	The new BreakPoint instance.
 *
 *----------------------------------------------------------------------
 */

BOOL
ConsoleDebugger::SetBreakpointAtAddr(Process *proc, BreakInfo *info, PVOID funcPtr)
{
    Breakpoint *bpt, *lastBpt;
    BYTE code;
    BOOL ok;

    bpt = new Breakpoint;
    bpt->codePtr = funcPtr;
    bpt->codeReturnPtr = (PVOID) (proc->offset + (DWORD) proc->pSubprocessMemory);
    bpt->breakInfo = info;
    proc->offset += 2;
    bpt->nextPtr = lastBpt = proc->brkptList;
    proc->brkptList = bpt;

    if ((ok = ReadSubprocessMemory(proc, funcPtr, &bpt->code, sizeof(BYTE)))
	    == TRUE) {
	code = BRK_OPCODE;
	ok = WriteSubprocessMemory(proc, funcPtr, &code, sizeof(BYTE));
    }

    if (!ok) {
	// unsplice it.
	proc->brkptList = lastBpt;
	delete bpt;
	bpt = 0L;
    }

    return ok;
}

a696 1
    unsigned int level = 0;
d787 1
a787 2
	CHAR *buffer = new CHAR [MAX_PATH+600];
	DWORD exCode = pDebEvent->u.Exception.ExceptionRecord.ExceptionCode;
d789 3
a791 5
		"\nA fatal, second-chance exception has occured in \"%s\".\n"
		"(0x%X) -- %s\n"
		"This is the backtrace:\n"
		"-------------------------------------\n", s, exCode,
		GetExceptionCodeString(exCode));
a812 2

	level++;
d830 1
a830 1
	    len = wsprintf(buffer, "%u) %.20s 0x%08.8x\t%s+%X\n", level, s, frame.AddrPC.Offset,
a849 33
 * ConsoleDebugger::GetExceptionCodeString --
 *
 *	Returns a string about the exception code.  Much more can
 *	be added.
 *
 *----------------------------------------------------------------------
 */

PCSTR
ConsoleDebugger::GetExceptionCodeString (DWORD exCode)
{
    switch (exCode)
    {
	case EXCEPTION_ACCESS_VIOLATION:
	    return "Access Violation.";
	case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
	    return "Array access was out-of-bounds.";
	case EXCEPTION_INT_DIVIDE_BY_ZERO:
	case EXCEPTION_FLT_DIVIDE_BY_ZERO:
	    return "Divide by zero.";
	case EXCEPTION_ILLEGAL_INSTRUCTION:
	case EXCEPTION_PRIV_INSTRUCTION:
	    return "Illegal opcode.";
	case EXCEPTION_STACK_OVERFLOW:
	    return "Stack overflow.";
	default:
	    return "exception unknown.";
    }
}

/*
 *----------------------------------------------------------------------
 *
a1052 16
    {
	int len;
	CHAR msg[256];

	if (dllname[0] == '\0') {
	    // image has no export section, so get the name another way.
	    // TODO: How??

	} else {
	    strcpy(msg, dllname);
	    strcat(msg, " has loaded.\n");
	    len = strlen(msg);
	}
	WriteMasterWarning(strdup(msg), len);
    }

d1170 2
a1171 2
//    buffer[len] = '\0';  // Oops, Win9x forgets this.
    WriteMasterWarning(buffer, len-1);
d1177 1
a1177 1
 * ConsoleDebugger::OnXVDMException --
d1179 2
a1180 3
 *	Exceptions raised by the NTVDM (Virtual Dos Machine).  We only
 *	get here when a DOS or Win16 (not likely for us, though)
 *	application is the slave or a child of the slave.
d1186 1
a1186 1
 *	.
a1189 1

d1191 1
a1191 1
ConsoleDebugger::OnXVDMException(Process *proc, LPDEBUG_EVENT pDebEvent)
d1193 2
a1194 8
    EXCEPTION_RECORD &exrec = pDebEvent->u.Exception.ExceptionRecord;
    USHORT exCode = W1(exrec);
    VDMProcessException(pDebEvent);

    switch (exCode) {
        case DBG_SEGLOAD:
	    __asm nop;
	    break;
d1196 10
a1205 3
        case DBG_SEGMOVE:
	    __asm nop;
	    break;
d1207 12
a1218 3
        case DBG_SEGFREE:
	    __asm nop;
	    break;
d1220 4
a1223 15
        case DBG_MODFREE:
        case DBG_MODLOAD:
	    {
		SEGMENT_NOTE segNote;
		char *buffer;
		DWORD len;
		const char *verb;

                switch (exCode)
                {
                    case DBG_MODLOAD:
                        verb = "loaded into"; break;
                    case DBG_MODFREE:
                        verb = "unloaded from"; break;
		}
d1225 5
d1231 5
a1235 101
		ReadSubprocessMemory(proc, (PVOID)DW3(exrec), &segNote, sizeof(segNote));
		len = strlen(segNote.FileName) + 25;
		buffer = new char [len];
		len = wsprintf(buffer, "%s %s the VDM.\n", segNote.FileName, verb);
		WriteMasterWarning(buffer, len);
	    }
	    break;

        case DBG_SINGLESTEP:
	    __asm nop;
	    break;

        case DBG_BREAK:
	    __asm nop;
	    break;

        case DBG_GPFAULT:
	    __asm nop;
	    break;

        case DBG_DIVOVERFLOW:
	    __asm nop;
	    break;

        case DBG_INSTRFAULT:
	    __asm nop;
	    break;

        case DBG_TASKSTART:
        case DBG_TASKSTOP:
        case DBG_DLLSTART:
        case DBG_DLLSTOP:
	    {
		IMAGE_NOTE imgNote;
		char *buffer;
		DWORD len;
		const char *verb;

                switch (exCode)
                {
                    case DBG_TASKSTART:
                        verb = "started in"; break;
                    case DBG_DLLSTART:
                        verb = "started in"; break;
                    case DBG_DLLSTOP:
                        verb = "stopped in"; break;
                    case DBG_TASKSTOP:
                        verb = "stopped in"; break;
                }

		ReadSubprocessMemory(proc, (PVOID)DW3(exrec), &imgNote, sizeof(IMAGE_NOTE));
		len = strlen(imgNote.FileName) + 25;
		buffer = new char [len];
		len = wsprintf(buffer, "%s %s the VDM.\n", imgNote.FileName, verb);
		WriteMasterWarning(buffer, len);
	    }
	    break;

        case DBG_ATTACH:
	    __asm nop;
	    break;

	case DBG_TOOLHELP:
	    __asm nop;
	    break;

	case DBG_STACKFAULT:
	    __asm nop;
	    break;

	case DBG_WOWINIT:
	    __asm nop;
	    break;

	case DBG_TEMPBP:
	    __asm nop;
	    break;

	case DBG_MODMOVE:
	    __asm nop;
	    break;

	case DBG_INIT:
	    VDMSetDbgFlags(proc->hProcess,
//		    VDMDBG_BREAK_DOSTASK |  // <- seems to cause a non-continueable exception on it's own.
//		    VDMDBG_BREAK_WOWTASK |
		    VDMDBG_BREAK_LOADDLL |
		    VDMDBG_BREAK_EXCEPTIONS |
		    VDMDBG_BREAK_DEBUGGER |
//		    VDMDBG_TRACE_HISTORY |
		    0);
	    break;

	case DBG_GPFAULT2:
	    __asm nop;
	    break;

	default:
	    __asm nop;
	    break;
    }
d1241 1
a1241 1
 * ConsoleDebugger::OnXRip --
d1243 1
a1243 2
 *	Catches and reports RIP events (system error messages).
 *	Is RIP short for Rest-In-Peace??
d1246 1
a1246 4
 *	None
 *
 * Side Effects:
 *	allocates memory that is freed by the Message destructor.
d1250 3
a1252 2
void
ConsoleDebugger::OnXRip(Process *proc, LPDEBUG_EVENT pDebEvent)
d1254 10
a1263 2
    char *errorMsg = new CHAR [512];
    DWORD len;
d1265 4
a1268 9
    if (pDebEvent->u.RipInfo.dwType == SLE_ERROR) {
	len = wsprintf(errorMsg, "A fatal RIP error was caught: %s",
		GetSysMsg(pDebEvent->u.RipInfo.dwError));
	WriteMasterError(errorMsg, len);
    } else {
	len = wsprintf(errorMsg, "A non-fatal RIP error was caught: %s",
		GetSysMsg(pDebEvent->u.RipInfo.dwError));
	WriteMasterWarning(errorMsg, len);
    }
@


1.1.2.33
log
@ConsoleDebugger::OnXBreakpoint(): sometimes a breakpoint is not set.
Don't crash, just punt..

Unknown for why...  td32.exe can cause this by launching a new command
shell that will launch a seperate console (ie. File->OS Shell)
@
text
@d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.32 2003/08/25 23:17:49 davygrvy Exp $
a1572 5
    if (brkpt == 0L) {
	// shouldn't happen, but does..
	return;
    }

d1576 1
a1576 1
    if (!brkpt->returning) {
@


1.1.2.34
log
@titleblock comment changes and removal of the Detours library usage.
@
text
@a17 1
 * Copyright (c) 2003 ActiveState Corporation
d25 1
a25 1
 * RCS: @@(#) $Id: expWinConsoleDebugger.cpp,v 1.1.2.33 2003/08/26 00:14:38 davygrvy Exp $
a1574 1
	// ask td32 for a new OS shell in a seperate console and this happens.
@


