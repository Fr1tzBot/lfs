head	1.1;
access;
symbols
	win32-jump-point-1:1.1.4.1
	telco-tec-win32-take2-branch:1.1.0.4
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2001.11.07.10.00.24;	author davygrvy;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2001.11.07.10.00.24;	author davygrvy;	state Exp;
branches;
next	;

1.1.4.1
date	2001.11.22.22.44.38;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file CMclAutoPtr.cpp was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.4.1
log
@Merged Mcl into the take2 branch
@
text
@a0 66
//
// FILE: CMclAutoPtr.cpp
//
// Copyright (c) 1997 by Aaron Michael Cohen
//
/////////////////////////////////////////////////////////////////////////

#include "CMclAutoPtr.h"

/////////////////////////////////////////////////////////////////////////
// CMclKernelAutoPtr
/////////////////////////////////////////////////////////////////////////

// can construct a kernel auto pointer with a valid internal object
// or a NULL...
CMclKernelAutoPtr::CMclKernelAutoPtr(CMclKernel *pObjectPtr) { 
    m_pObjectPtr = pObjectPtr; 
}

// deleting the auto pointer deletes what the internal pointer points to...
CMclKernelAutoPtr::~CMclKernelAutoPtr() {
    // no check needed since deleting a NULL
    // pointer is okay in C++...
    delete m_pObjectPtr; 
}

void CMclKernelAutoPtr::Reset(CMclKernel *pObjectPtr) {
    // we don't need to check for NULL in C++...
    if (m_pObjectPtr != pObjectPtr)
        delete m_pObjectPtr;

    m_pObjectPtr = pObjectPtr; 
}

// dereferencing operator...
CMclKernel * CMclKernelAutoPtr::operator->() const { 
    return m_pObjectPtr; 
}

// indirection operator...
CMclKernel & CMclKernelAutoPtr::operator*() const { 
    return *m_pObjectPtr; 
}

// get the handle of the internal object...
HANDLE CMclKernelAutoPtr::GetHandle(void) const {
    return m_pObjectPtr->GetHandle();
}

// read the current status of the internal object...
DWORD CMclKernelAutoPtr::Status(void) const {
    return m_pObjectPtr->Status();
}

BOOL CMclKernelAutoPtr::IsNull(void) const {
    return (m_pObjectPtr == NULL);
}









@


1.1.2.1
log
@"Mcl" multithreading C++ class library added
@
text
@a0 66
//
// FILE: CMclAutoPtr.cpp
//
// Copyright (c) 1997 by Aaron Michael Cohen
//
/////////////////////////////////////////////////////////////////////////

#include "CMclAutoPtr.h"

/////////////////////////////////////////////////////////////////////////
// CMclKernelAutoPtr
/////////////////////////////////////////////////////////////////////////

// can construct a kernel auto pointer with a valid internal object
// or a NULL...
CMclKernelAutoPtr::CMclKernelAutoPtr(CMclKernel *pObjectPtr) { 
    m_pObjectPtr = pObjectPtr; 
}

// deleting the auto pointer deletes what the internal pointer points to...
CMclKernelAutoPtr::~CMclKernelAutoPtr() {
    // no check needed since deleting a NULL
    // pointer is okay in C++...
    delete m_pObjectPtr; 
}

void CMclKernelAutoPtr::Reset(CMclKernel *pObjectPtr) {
    // we don't need to check for NULL in C++...
    if (m_pObjectPtr != pObjectPtr)
        delete m_pObjectPtr;

    m_pObjectPtr = pObjectPtr; 
}

// dereferencing operator...
CMclKernel * CMclKernelAutoPtr::operator->() const { 
    return m_pObjectPtr; 
}

// indirection operator...
CMclKernel & CMclKernelAutoPtr::operator*() const { 
    return *m_pObjectPtr; 
}

// get the handle of the internal object...
HANDLE CMclKernelAutoPtr::GetHandle(void) const {
    return m_pObjectPtr->GetHandle();
}

// read the current status of the internal object...
DWORD CMclKernelAutoPtr::Status(void) const {
    return m_pObjectPtr->Status();
}

BOOL CMclKernelAutoPtr::IsNull(void) const {
    return (m_pObjectPtr == NULL);
}









@

