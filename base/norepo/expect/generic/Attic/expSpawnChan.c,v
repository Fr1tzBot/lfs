head	1.1;
access;
symbols
	win32-jump-point-1:1.1.2.1.2.4
	telco-tec-win32-take2-branch:1.1.2.1.0.2
	telco-tec-win32-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.1
date	2001.09.13.01.08.46;	author davygrvy;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.09.13.01.08.46;	author davygrvy;	state Exp;
branches
	1.1.2.1.2.1;
next	1.1.2.2;

1.1.2.2
date	2001.10.05.00.44.53;	author davygrvy;	state Exp;
branches;
next	;

1.1.2.1.2.1
date	2001.11.22.08.50.38;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.2;

1.1.2.1.2.2
date	2001.11.22.22.36.53;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.3;

1.1.2.1.2.3
date	2002.02.10.02.58.53;	author davygrvy;	state Exp;
branches;
next	1.1.2.1.2.4;

1.1.2.1.2.4
date	2002.02.10.12.04.22;	author davygrvy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file expSpawnChan.c was initially added on branch telco-tec-win32-branch.
@
text
@@


1.1.2.1
log
@snap29 "import"
@
text
@a0 331
/*
 * expWinChan.c --
 *
 *	Implements the exp_spawn channel id.  This wraps a normal
 *	file channel in another channel so we can close the file
 *	channel normally but still have another id to wait on.
 *	The file channel is not exposed in any interps.
 *
 * Copyright (c) 1997 by Mitel Corporation
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 */

#include "exp_port.h"
#include "tclInt.h"
#include "tclPort.h"
#include "exp_command.h"
#include "expWin.h"

static int	ExpSpawnBlock _ANSI_ARGS_((ClientData instanceData,
		    int mode));
static int	ExpSpawnInput _ANSI_ARGS_((ClientData instanceData,
		    char *bufPtr, int bufSize, int *errorPtr));
static int	ExpSpawnOutput _ANSI_ARGS_((ClientData instanceData,
		    char *bufPtr, int toWrite, int *errorPtr));
static int	ExpSpawnClose _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp));
static int	ExpSpawnSetOption _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp, char *nameStr, char *val));
static int	ExpSpawnGetOption _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp, char *nameStr, Tcl_DString *dsPtr));
static int	ExpSpawnGetHandle _ANSI_ARGS_((ClientData instanceData,
		    int direction, ClientData *handlePtr));
static void	ExpSpawnWatch _ANSI_ARGS_((ClientData instanceData,
		    int mask));

static Tcl_ChannelType ExpSpawnChannelType = {
    "exp_spawn",
    ExpSpawnBlock,
    ExpSpawnClose,
    ExpSpawnInput,
    ExpSpawnOutput,
    NULL,         		/* Can't seek! */
    ExpSpawnSetOption,
    ExpSpawnGetOption,
    ExpSpawnWatch,
    ExpSpawnGetHandle
};

static int expSpawnCount = 0;


/*
 *----------------------------------------------------------------------
 *
 * ExpCreateSpawnChannel --
 *
 *	Create an expect spawn identifier
 *
 * Results:
 *	A Tcl channel
 *
 * Side Effects:
 *	Allocates and registers a channel
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
ExpCreateSpawnChannel(interp, chan)
    Tcl_Interp *interp;
    Tcl_Channel chan;
{
    ExpSpawnState *ssPtr;
    char channelNameStr[20];

    ssPtr = (ExpSpawnState *) ckalloc(sizeof(ExpSpawnState));
    ssPtr->channelPtr = chan;
    ssPtr->toWrite = 0;

    /*
     * Setup the expect channel to always flush immediately
     */

    sprintf(channelNameStr, "exp_spawn%d", expSpawnCount++);

    chan = Tcl_CreateChannel(&ExpSpawnChannelType, channelNameStr,
			     (ClientData) ssPtr, TCL_READABLE|TCL_WRITABLE);
    Tcl_SetChannelOption(interp, chan, "-blocking", "0");
    Tcl_SetChannelOption(interp, chan, "-buffering", "none");
    Tcl_SetChannelOption(interp, chan, "-translation","binary");
    return chan;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnBlock --
 *
 *	Generic routine to set I/O to blocking or non-blocking.
 *
 * Results:
 *	TCL_OK or TCL_ERROR.
 *    
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ExpSpawnBlock(instanceData, mode)
    ClientData instanceData;
    int mode;			/* (in) Block or not */
{
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;

    return (Tcl_GetChannelType(channelPtr)->blockModeProc)
	(Tcl_GetChannelInstanceData(channelPtr), mode);
}


/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnInput --
 *
 *	Generic read routine for expect console
 *
 * Returns:
 *	Amount read or -1 with errorcode in errorPtr.
 *    
 * Side Effects:
 *	Buffer is updated. 
 *
 *----------------------------------------------------------------------
 */

static int
ExpSpawnInput(instanceData, bufPtr, bufSize, errorPtr)
    ClientData instanceData;
    char *bufPtr;		/* (in) Ptr to buffer */
    int bufSize;		/* (in) sizeof buffer */
    int *errorPtr;		/* (out) error code */
{
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;

    return (Tcl_GetChannelType(channelPtr)->inputProc)
	(Tcl_GetChannelInstanceData(channelPtr), bufPtr, bufSize, errorPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnOutput --
 *
 *	Write routine for expect console
 *
 * Results:
 *	Amount written or -1 with errorcode in errorPtr
 *    
 * Side Effects:
 *	None. 
 *
 *----------------------------------------------------------------------
 */

static int
ExpSpawnOutput(instanceData, bufPtr, toWrite, errorPtr)
    ClientData instanceData;
    char *bufPtr;		/* (in) Ptr to buffer */
    int toWrite;		/* (in) amount to write */
    int *errorPtr;		/* (out) error code */
{
    return ExpPlatformSpawnOutput(instanceData, bufPtr, toWrite, errorPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnClose --
 *
 *	Generic routine to close the expect console
 *
 * Results:
 *      0 if successful or a POSIX errorcode with
 *      interp updated.
 *    
 * Side Effects:
 *	Channel is deleted.
 *
 *----------------------------------------------------------------------
 */

static int
ExpSpawnClose(instanceData, interp)
    ClientData instanceData;
    Tcl_Interp *interp;
{
    ExpSpawnState *ssPtr = (ExpSpawnState *) instanceData;
    Tcl_Channel channelPtr = ssPtr->channelPtr;
    int ret;

    ret = Tcl_Close(interp, channelPtr);

    ckfree((char *)ssPtr);

    return ret;
}


/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnSetOption --
 *
 *	Set the value of an ExpSpawn channel option
 *
 * Results:
 *	TCL_OK and dsPtr updated with the value or TCL_ERROR.
 *
 * Side Effects
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ExpSpawnSetOption(instanceData, interp, nameStr, valStr)
    ClientData instanceData;
    Tcl_Interp *interp;
    char *nameStr;		/* (in) Name of option */
    char *valStr;		/* (in) New value of option */
{
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;

    return (Tcl_GetChannelType(channelPtr)->setOptionProc)
	(Tcl_GetChannelInstanceData(channelPtr), interp, nameStr, valStr);
}

/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnGetOption --
 *
 *	Queries ExpSpawn channel for the current value of
 *      the given option.
 *
 * Results:
 *	TCL_OK and dsPtr updated with the value or TCL_ERROR.
 *
 * Side Effects
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ExpSpawnGetOption(instanceData, interp, nameStr, dsPtr)
    ClientData instanceData;
    Tcl_Interp *interp;
    char *nameStr;		/* (in) Name of option to retrieve */		
    Tcl_DString *dsPtr;		/* (in) String to place value */
{
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;

    return (Tcl_GetChannelType(channelPtr)->getOptionProc)
	(Tcl_GetChannelInstanceData(channelPtr), interp, nameStr, dsPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnGetHandle --
 *
 *	Get the Tcl_File for the appropriate direction in from the
 *	Tcl_Channel.
 *
 * Results:
 *	NULL because ExpSpawn ids are handled through other channel
 *	types.
 *
 * Side Effects
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
ExpSpawnGetHandle(instanceData, direction, handlePtr)
    ClientData instanceData;
    int direction;
    ClientData *handlePtr;
{
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;

    return (Tcl_GetChannelType(channelPtr)->getHandleProc)
	(Tcl_GetChannelInstanceData(channelPtr), direction, handlePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ExpSpawnWatch --
 *
 *	Sets up event handling on a expect console Tcl_Channel using
 *	the underlying channel type.
 *
 * Results:
 *	Nothing
 *
 * Side Effects
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
ExpSpawnWatch(instanceData, mask)
    ClientData instanceData;
    int mask;
{
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;

    (Tcl_GetChannelType(channelPtr)->watchProc)
	(Tcl_GetChannelInstanceData(channelPtr), mask);
    return;
}
@


1.1.2.1.2.1
log
@A working set of code against Tcl8.4!
@
text
@a18 3

#define BUILD_expect

a19 2

#ifdef __WIN32__
a20 1
#endif
d22 16
a37 11
static Tcl_DriverCloseProc ExpSpawnClose;
static Tcl_DriverInputProc ExpSpawnInput;
static Tcl_DriverOutputProc ExpSpawnOutput;
/*static Tcl_DriverSeekProc ExpSpawnSeek;*/
static Tcl_DriverSetOptionProc ExpSpawnSetOption;
static Tcl_DriverGetOptionProc ExpSpawnGetOption;
static Tcl_DriverWatchProc ExpSpawnWatch;
static Tcl_DriverGetHandleProc ExpSpawnGetHandle;
static Tcl_DriverBlockModeProc ExpSpawnBlock;
/*static Tcl_DriverFlushProc ExpSpawnFlush;*/
/*static Tcl_DriverHandlerProc ExpSpawnHandler;*/
d41 1
a41 1
    TCL_CHANNEL_VERSION_2,
d45 1
a45 1
    NULL,         		/* no seek! */
d49 1
a49 5
    ExpSpawnGetHandle,
    NULL,			/* no close2 */
    ExpSpawnBlock,
    NULL,			/* no flush */
    NULL			/* no handler */
d52 1
a52 5
typedef struct ThreadSpecificData {
    int expSpawnCount;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
d54 1
a75 3
//    char channelNameStr[20];
//    Tcl_Channel chan2;
    Tcl_Channel chan3;
d77 1
a77 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
a82 8
//    sprintf(channelNameStr, "exp_spawn%d", tsdPtr->expSpawnCount++);

//    chan2 = Tcl_CreateChannel(&ExpSpawnChannelType, channelNameStr,
//			     (ClientData) NULL, TCL_READABLE|TCL_WRITABLE);

    chan3 = Tcl_StackChannel(interp, &ExpSpawnChannelType,
	    (ClientData) ssPtr, TCL_READABLE|TCL_WRITABLE, chan);

d87 1
a87 3
    Tcl_SetChannelOption(interp, chan3, "-buffering",  "none");
    Tcl_SetChannelOption(interp, chan3, "-blocking",   "0");
    Tcl_SetChannelOption(interp, chan3, "-translation","binary");
d89 6
a94 1
    return chan3;
d96 1
a96 1

d100 1
a100 1
 * ExpSpawnClose --
d102 1
a102 1
 *	Generic routine to close the expect spawn channel and child.
d105 1
a105 2
 *      0 if successful or a POSIX errorcode with
 *      interp updated.
d108 1
a108 1
 *	Channel is deleted.
d114 1
a114 1
ExpSpawnClose(instanceData, interp)
d116 1
a116 1
    Tcl_Interp *interp;
d118 1
a118 3
    ExpSpawnState *ssPtr = (ExpSpawnState *) instanceData;
    //Tcl_Channel channelPtr = ssPtr->channelPtr;
    //int ret;
d120 2
a121 4
    //ret = Tcl_UnStackChannel(interp, channelPtr);
    ckfree((char *)ssPtr);

    return TCL_OK;
d124 1
d154 1
d180 1
a180 1

d184 1
a184 1
 * ExpSpawnSetOption --
d186 1
a186 1
 *	Set the value of an ExpSpawn channel option
d189 5
a193 4
 *	TCL_OK and dsPtr updated with the value or TCL_ERROR.
 *
 * Side Effects
 *	None.
d199 1
a199 1
ExpSpawnSetOption(instanceData, interp, nameStr, valStr)
a201 2
    char *nameStr;		/* (in) Name of option */
    char *valStr;		/* (in) New value of option */
d203 5
a207 2
    Tcl_Channel channelPtr = ((ExpSpawnState *)instanceData)->channelPtr;
    Tcl_DriverSetOptionProc *setOpt;
d209 1
a209 1
    setOpt = Tcl_GetChannelType(channelPtr)->setOptionProc;
d211 1
a211 6
    if (setOpt) {
	return (setOpt)(Tcl_GetChannelInstanceData(channelPtr), interp,
		nameStr, valStr);
    } else {
	return Tcl_BadChannelOption(interp, nameStr, "");
    }
d214 1
d218 1
a218 1
 * ExpSpawnGetOption --
d220 1
a220 2
 *	Queries ExpSpawn channel for the current value of
 *      the given option.
d232 1
a232 1
ExpSpawnGetOption(instanceData, interp, nameStr, dsPtr)
d235 2
a236 2
    char *nameStr;		/* (in) Name of option to retrieve */		
    Tcl_DString *dsPtr;		/* (in) String to place value */
a238 1
    Tcl_DriverGetOptionProc *getOpt;
d240 2
a241 9
    getOpt = Tcl_GetChannelType(channelPtr)->getOptionProc;
    if (getOpt) {
	return (getOpt)(Tcl_GetChannelInstanceData(channelPtr), interp,
		nameStr, dsPtr);
    } else if (nameStr != NULL) {
	return Tcl_BadChannelOption(interp, nameStr, "");
    } else {
	return TCL_OK;
    }
d243 1
d247 1
a247 1
 * ExpSpawnWatch --
d249 2
a250 2
 *	Sets up event handling on a expect console Tcl_Channel using
 *	the underlying channel type.
d253 1
a253 1
 *	Nothing
d261 2
a262 2
void
ExpSpawnWatch(instanceData, mask)
d264 3
a266 1
    int mask;
d270 2
a271 3
    (Tcl_GetChannelType(channelPtr)->watchProc)
	(Tcl_GetChannelInstanceData(channelPtr), mask);
    return;
d273 1
a273 1

d300 2
a301 1
    return Tcl_GetChannelHandle(channelPtr, direction, handlePtr);
d303 1
a303 1

d307 1
a307 1
 * ExpSpawnBlock --
d309 2
a310 1
 *	Generic routine to set I/O to blocking or non-blocking.
d313 3
a315 3
 *	TCL_OK or TCL_ERROR.
 *    
 * Side Effects:
d321 2
a322 2
static int
ExpSpawnBlock(instanceData, mode)
d324 1
a324 1
    int mode;			/* (in) Block or not */
d328 3
a330 2
    return (Tcl_GetChannelType(channelPtr)->blockModeProc)
	(Tcl_GetChannelInstanceData(channelPtr), mode);
@


1.1.2.1.2.2
log
@removed some left-over C++ style comments.
@
text
@d57 6
d84 3
a86 1
    Tcl_Channel chan2;
d88 1
d94 6
a99 1
    chan2 = Tcl_StackChannel(interp, &ExpSpawnChannelType,
d106 3
a108 3
    Tcl_SetChannelOption(interp, chan2, "-buffering",  "none");
    Tcl_SetChannelOption(interp, chan2, "-blocking",   "0");
    Tcl_SetChannelOption(interp, chan2, "-translation","binary");
d110 1
a110 1
    return chan2;
d135 7
a141 1
    ckfree((char *)(ExpSpawnState *)instanceData);
@


1.1.2.1.2.3
log
@moved all header files over to a more core style with the beginnings of a
Stubs table.  This work is far from complete.
@
text
@d16 11
a26 1
#include "expInt.h"
d173 1
a173 1
    CONST char *bufPtr;		/* (in) Ptr to buffer */
d200 2
a201 2
    CONST char *nameStr;		/* (in) Name of option */
    CONST char *valStr;		/* (in) New value of option */
d237 1
a237 1
    CONST char *nameStr;		/* (in) Name of option to retrieve */		
@


1.1.2.1.2.4
log
@All file comments have the same form.
@
text
@d1 1
a1 1
/* ----------------------------------------------------------------------------
d9 1
a9 1
 * ----------------------------------------------------------------------------
d11 2
a12 8
 * Written by: Don Libes, libes@@cme.nist.gov, NIST, 12/3/90
 * 
 * Design and implementation of this program was paid for by U.S. tax
 * dollars.  Therefore it is public domain.  However, the author and NIST
 * would appreciate credit if this program or parts of it are used.
 * 
 * Copyright (c) 1997 Mitel Corporation
 *	work by Gordon Chaffee <chaffee@@bmrc.berkeley.edu> for the WinNT port.
a13 10
 * Copyright (c) 2001-2002 Telindustrie, LLC
 *	work by David Gravereaux <davygrvy@@pobox.com> for any Win32 OS.
 *
 * ----------------------------------------------------------------------------
 * URLs:    http://expect.nist.gov/
 *	    http://expect.sf.net/
 *	    http://bmrc.berkeley.edu/people/chaffee/expectnt.html
 * ----------------------------------------------------------------------------
 * RCS: @@(#) $Id: exp.h,v 1.1.4.4 2002/02/10 10:17:04 davygrvy Exp $
 * ----------------------------------------------------------------------------
@


1.1.2.2
log
@Mostly adapted to the ExpState structure...
@
text
@d2 1
a2 1
 * expSpawnChan.c --
d16 1
a18 1
#include "expect_tcl.h"
d22 1
a22 1
static int	ExpSpawnBlockProc _ANSI_ARGS_((ClientData instanceData,
d24 1
a24 3
static int	ExpSpawnCloseProc _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp));
static int	ExpSpawnInputProc _ANSI_ARGS_((ClientData instanceData,
d26 1
a26 1
static int	ExpSpawnOutputProc _ANSI_ARGS_((ClientData instanceData,
d28 5
a32 1
static int	ExpSpawnGetOptionProc _ANSI_ARGS_((ClientData instanceData,
d34 3
a36 3
static int	ExpSpawnSetOptionProc _ANSI_ARGS_((ClientData instanceData,
		    Tcl_Interp *interp, char *nameStr, char *val));
static void	ExpSpawnWatchProc _ANSI_ARGS_((ClientData instanceData,
a37 2
static int	ExpSpawnGetHandleProc _ANSI_ARGS_((ClientData instanceData,
		    int direction, ClientData *handlePtr));
d39 11
a49 18
/*
 * This structure describes the channel type structure for Expect-based IO:
 */

Tcl_ChannelType expSpawnChanType = {
    "exp_spawn",			/* Type name. */
    TCL_CHANNEL_VERSION_1,		/* Version of the channel type. */
    ExpSpawnCloseProc,			/* Close proc. */
    ExpSpawnInputProc,			/* Input proc. */
    ExpSpawnOutputProc,			/* Output proc. */
    NULL,				/* Seek proc. */
    ExpSpawnSetOptionProc,		/* Set option proc. */
    ExpSpawnGetOptionProc,		/* Get option proc. */
    ExpSpawnWatchProc,			/* Initialize notifier. */
    ExpSpawnGetHandleProc,		/* Get OS handles out of channel. */
    NULL,				/* Close2 proc */
    ExpSpawnBlockProc			/* Set blocking/nonblocking mode.
					 * Expect channels are always blocking */
d52 1
a52 273
typedef struct ThreadSpecificData {
    /*
     * List of all exp channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    ExpState *firstExpPtr;
    int channelCount;	 /* this is process-wide as it is used to
			     give user some hint as to why a spawn has failed
			     by looking at process-wide resource usage */
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;


/*
 *----------------------------------------------------------------------
 *
 * expChannelInit --
 *
 *	Inits the TSD structure for the calling thread context.
 *
 * Results:
 *	nothing
 *
 * Side Effects:
 *	A datakey and associated TSD structure now exists for the
 *	calling thread context.
 *
 *----------------------------------------------------------------------
 */
void
expChannelInit() {
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    tsdPtr->channelCount = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * expChannelCountGet --
 *
 *	.
 *
 * Results:
 *	Count of how many spawn channels are open.
 *
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
expChannelCountGet()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    return tsdPtr->channelCount;
}

/*
 *----------------------------------------------------------------------
 *
 * expSizeGet --
 *
 *	Get how much data is currently in the channel's buffer.
 *
 * Results:
 *	bytes in use.
 *
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
expSizeGet(esPtr)
    ExpState *esPtr;
{
    int len;
    Tcl_GetStringFromObj(esPtr->buffer,&len);
    return len;
}

/*
 *----------------------------------------------------------------------
 *
 * expSizeZero --
 *
 *	Asks if the buffer is empty.
 *
 * Results:
 *	Boolean.
 *
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
int
expSizeZero(esPtr)
    ExpState *esPtr;
{
    int len;
    Tcl_GetStringFromObj(esPtr->buffer,&len);
    return (len == 0);
}

/*
 *----------------------------------------------------------------------
 *
 * expStateFree --
 *
 *	Asks if the buffer is empty.
 *
 * Results:
 *	Boolean.
 *
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
expStateFree(esPtr)
    ExpState *esPtr;
{
    if (esPtr->fdBusy) {
//    close(esPtr->fdin);    /* BUG: not OS neutral */
//      expPlatformStateFree(esPtr);
    }

    esPtr->valid = FALSE;
    
    if (!esPtr->keepForever) {
	ckfree((char *)esPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * exp_close_all --
 *
 *	close all connections
 * 
 *	The kernel would actually do this by default, however Tcl is going to
 *	come along later and try to reap its exec'd processes.  If we have
 *	inherited any via spawn -open, Tcl can hang if we don't close the
 *	connections first.
 *
 * Results:
 *	A Tcl channel
 *
 * Side Effects:
 *	Allocates and registers a channel
 *
 *----------------------------------------------------------------------
 */

void
exp_close_all(interp)
    Tcl_Interp *interp;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;

    /* no need to keep things in sync (i.e., tsdPtr, count) since we could only
       be doing this if we're exiting.  Just close everything down. */

    for (esPtr = tsdPtr->firstExpPtr; esPtr; esPtr = esPtr->nextPtr) {
	exp_close(interp, esPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * expWaitOnAny --
 *
 *	Wait for any of our own spawned processes we call waitpid rather than
 *	wait to avoid running into someone else's processes.  Yes, according
 *	to Ousterhout this is the best way to do it.
 *
 * Results:
 *	returns the ExpState or 0 if nothing to wait on
 *
 * Side Effects:
 *	
 *
 *----------------------------------------------------------------------
 */

ExpState *
expWaitOnAny()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int result;
    ExpState *esPtr;

    for (esPtr = tsdPtr->firstExpPtr; esPtr; esPtr = esPtr->nextPtr) {
	if (esPtr->pid == exp_getpid) continue; /* skip ourself */
	if (esPtr->user_waited) continue;	/* one wait only! */
	if (esPtr->sys_waited) break;
      restart:
	result = waitpid(esPtr->pid, &esPtr->wait, WNOHANG);  /* BUG: not OS neutral */
	if (result == esPtr->pid) break;
	if (result == 0) continue;	/* busy, try next */
	if (result == -1) {
	    if (errno == EINTR) goto restart;
	    else break;
	}
    }
    return esPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * expWaitOnOne --
 *
 *	Add comment here.
 *
 * Results:
 *	
 *
 * Side Effects:
 *	
 *
 *----------------------------------------------------------------------
 */

ExpState *
expWaitOnOne()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;
    int pid;
    /* should really be recoded using the common wait code in command.c */
    WAIT_STATUS_TYPE status;

    pid = wait(&status);   /* BUG: not OS neutral */
    for (esPtr = tsdPtr->firstExpPtr; esPtr; esPtr = esPtr->nextPtr) {
	if (esPtr->pid == pid) {
	    esPtr->sys_waited = TRUE;
	    esPtr->wait = status;
	    return esPtr;
	}
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * ExpCreateSpawnChannel --
 *
 *	Create an expect spawn identifier
 *
 * Results:
 *	A Tcl channel
 *
 * Side Effects:
 *	Allocates and registers a channel
 *
 *----------------------------------------------------------------------
 */

void
exp_background_channelhandlers_run_all()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ExpState *esPtr;
a53 8
    /* kick off any that already have input waiting */
    for (esPtr = tsdPtr->firstExpPtr; esPtr; esPtr = esPtr->nextPtr) {
	/* is bg_interp the best way to check if armed? */
	if (esPtr->bg_interp && !expSizeZero(esPtr)) {
	    exp_background_channelhandler((ClientData)esPtr,0);
	}
    }
}
d77 1
a77 11
    ExpState *esPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    esPtr = (ExpState *) ckalloc((unsigned) sizeof(ExpState));
    esPtr->nextPtr = tsdPtr->firstExpPtr;
    tsdPtr->firstExpPtr = esPtr;

    //ssPtr->channelPtr = chan;
    //ssPtr->toWrite = 0;

    esPtr->fdBusy = FALSE;
d79 3
d87 1
a87 1
    sprintf(esPtr->name, "exp_spawn%d", tsdPtr->channelCount++);
d89 2
a90 3
    chan = Tcl_CreateChannel(&expSpawnChanType, esPtr->name,
			     (ClientData) esPtr, TCL_READABLE|TCL_WRITABLE);
    Tcl_RegisterChannel(interp, chan);
a93 34

    esPtr->msize = 0;

    /* initialize a dummy buffer */
    esPtr->buffer = Tcl_NewStringObj("",0);
    Tcl_IncrRefCount(esPtr->buffer);
    esPtr->umsize = exp_default_match_max;

    /* this will reallocate object with an appropriate sized buffer */
    expAdjust(esPtr);

    esPtr->printed = 0;
    esPtr->echoed = 0;
    esPtr->rm_nulls = exp_default_rm_nulls;
    esPtr->parity = exp_default_parity;
    esPtr->key = expect_key++;
    esPtr->force_read = FALSE;
    esPtr->fg_armed = FALSE;
    esPtr->channel_orig = 0;
    esPtr->fd_slave = EXP_NOFD;
#ifdef HAVE_PTYTRAP
    esPtr->slave_name = 0;
#endif /* HAVE_PTYTRAP */
    esPtr->open = TRUE;
    esPtr->notified = FALSE;
    esPtr->user_waited = FALSE;
    esPtr->sys_waited = FALSE;
    esPtr->bg_interp = 0;
    esPtr->bg_status = unarmed;
    esPtr->bg_ecount = 0;
    esPtr->freeWhenBgHandlerUnblocked = FALSE;
    esPtr->keepForever = FALSE;
    esPtr->valid = TRUE;

d100 1
a100 1
 * ExpSpawnBlockProc --
d113 2
a114 2
int
ExpSpawnBlockProc(instanceData, mode)
d118 4
a121 1
    return 0;   /* BUG: fix me! */
d123 1
d128 1
a128 1
 * ExpSpawnInputProc --
d141 2
a142 2
int
ExpSpawnInputProc(instanceData, buf, toRead, errorCodePtr)
d144 3
a146 3
    char *buf;		/* (in) Ptr to buffer */
    int toRead;		/* (in) sizeof buffer */
    int *errorCodePtr;		/* (out) error code */
d148 4
a151 2
    ExpState *esPtr = (ExpState *) instanceData;
    return ExpPlatformSpawnInput(esPtr, buf, toRead, errorCodePtr);
d158 1
a158 1
 * ExpSpawnOutputProc --
d171 2
a172 2
int
ExpSpawnOutputProc(instanceData, bufPtr, toWrite, errorPtr)
d184 1
a184 1
 * ExpSpawnCloseProc --
d186 1
a186 2
 *	This procedure is called from the generic IO level to perform
 *	channel-type-specific cleanup when an exp-based channel is closed.
d189 5
a193 4
 *	0 if successful, errno if failed.
 *
 * Side effects:
 *	Closes the device of the channel.
d198 2
a199 2
int
ExpSpawnCloseProc(instanceData, interp)
d203 3
a205 13
    ExpState *esPtr = (ExpState *) instanceData;
    ExpState **nextPtrPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    esPtr->registered = FALSE;

#if 0
    /*
      Really should check that we created one first.  Since we're sharing fds
      with Tcl, perhaps a filehandler was created with a plain tcl file - we
      wouldn't want to delete that.  Although if user really close Expect's
      user_spawn_id, it probably doesn't matter anyway.
    */
d207 1
a207 2
    Tcl_DeleteFileHandler(esPtr->fdin);
#endif /*0*/
d209 1
a209 1
    Tcl_DecrRefCount(esPtr->buffer);
d211 1
a211 30
    /* Actually file descriptor should have been closed earlier. */
    /* So do nothing here */

    /*
     * Conceivably, the process may not yet have been waited for.  If this
     * becomes a requirement, we'll have to revisit this code.  But for now, if
     * it's just Tcl exiting, the processes will exit on their own soon
     * anyway.
     */

    for (nextPtrPtr = &(tsdPtr->firstExpPtr); (*nextPtrPtr) != NULL;
	 nextPtrPtr = &((*nextPtrPtr)->nextPtr)) {
	if ((*nextPtrPtr) == esPtr) {
	    (*nextPtrPtr) = esPtr->nextPtr;
	    break;
	}
    }
    tsdPtr->channelCount--;

    if (esPtr->bg_status == blocked ||
	    esPtr->bg_status == disarm_req_while_blocked) {
	esPtr->freeWhenBgHandlerUnblocked = 1;
	/*
	 * If we're in the middle of a bg event handler, then the event
	 * handler will have to take care of freeing esPtr.
	 */
    } else {
	expStateFree(esPtr);
    }
    return 0;
d218 1
a218 1
 * ExpSpawnSetOptionProc --
d231 2
a232 2
int
ExpSpawnSetOptionProc(instanceData, interp, nameStr, valStr)
d247 1
a247 1
 * ExpSpawnGetOptionProc --
d261 2
a262 2
int
ExpSpawnGetOptionProc(instanceData, interp, nameStr, dsPtr)
d277 1
a277 1
 * ExpSpawnGetHandleProc --
d293 1
a293 1
ExpSpawnGetHandleProc(instanceData, direction, handlePtr)
d307 1
a307 1
 * ExpSpawnWatchProc --
d322 1
a322 1
ExpSpawnWatchProc(instanceData, mask)
@


